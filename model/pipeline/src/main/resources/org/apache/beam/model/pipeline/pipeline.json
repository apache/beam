{
  "$schema": "http://json-schema.org/draft-04/schema#",

  "type": "object",

  "$ref": "#/definitions/Pipeline",

  "definitions": {
    // A Pipeline contains the entire hierarchical graph including
    // nodes for all values.
    //
    // Nodes (transform or value or other) are identified by some unique id. This need
    // not be readable. It is simplest to think of it as a reified pointer or UUID.
    // Cyclic pointer structures are forbidden throughout.
    "Pipeline": {
      "type": "object",
      "additionalProperties": false,
      "required": [ "userFns", "transforms", "values", "windowingStrategies", "coders" ],
      "properties": {

        // A mapping containing all user-definable functions in the pipeline.
        // The keys must be unique to this pipeline definition, but otherwise are
        // arbitrary.
        "userFns": {
          "type": "object",
          "additionalProperties": { "$ref": "#/definitions/UserFn" }
        },

        // A mapping containing all transforms in the pipeline.
        "transforms": {
          "type": "object",
          "additionalProperties": { "$ref": "#/definitions/TransformNode" }
        },

        // A mapping containing all the primitive values in the pipeline.
        "values": {
          "type": "object",
          "additionalProperties": { "$ref": "#/definitions/Value" }
        },

        // A flat list of windowing strategies. These may be referenced repeatedly.
        "windowingStrategies": {
          "type": "object",
          "additionalProperties": { "$ref": "#/definitions/WindowingStrategy" }
        },

        "coders": {
          "type": "object",
          "additionalProperties": { "$ref": "#/definitions/Coder" }
        }

        // TODO: aggregators
        // TODO: pipeline options
        // TODO: pipeline-level display metadata
        // TODO: SDK capabilities
      }
    },

    // A user-defined function.
    //
    // TODO: the exact details of this will be fleshed out as the Fn API matures.
    "UserFn": {
      "type": "object",
      "additionalProperties": false,
      "properties": {

        // A cross-language, stable, unique identifier for the function. It should indicate
        // enough information that naive optimization (or language-to-language replacement)
        // may be possible, since the runner will have no insight into the SDK-specific data.
        "urn": { "type": "string" },

        // A URL for the container image containing the SDK that understands how to run
        // this user-definable function.
        "sdkContainer": { "type": "string" },

        // A free-form object containing SDK-specific data.
        "data":  { "type": "object" }
      },

      "required": ["urn", "data"]
    },

    // A windowing strategy describes the window function, triggering, allowed lateness
    // for a PCollection
    "WindowingStrategy": {
      "type": "object",
      "additionalProperties": false,
      "properties": {

        // The id of a user-definable function that assigns windows, merges windows, and shifts
        // timestamps.
        "windowFn": { "type": "string" },

        // Whether or not the window fn is merging; this affects how a runner may implement things
        //
        // TBD whether this metadata will live in the UserFn record or here or both
        "isMergingWindowFn": { "type": "boolean" },

        // The encoding node of the windows for the window_fn.
        "windowCoder": { "type": "string" },

        // The trigger, as a simple syntax tree
        // TODO: the referenced definition
        "trigger": { "$ref": "#/definitions/Trigger" },

        // The accumulation mode indicates whether new panes are a full replacement for
        // prior panes or whether they are deltas to be combined with other panes (the combine
        // should correspond to whatever the upstream grouping transform is).
        "accumulationMode": { "$ref": "#/definitions/AccumulationMode" },

        // The OutputTime specifies, for a grouping transform, how to compute the
        // aggregate timestamp. The window_fn will first possibly shift it later, then the
        // OutputTime takes the max, min, or ignores it and takes the end of window.
        "outputTime": { "$ref": "#/definitions/OutputTime" },

        // After the watermark gets this far past the end of the window, new elements are dropped.
        // in milliseconds
        "allowedLateness": { "type": "number" }
      }
    },

    "SideInput": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        // Only "multimap" is supported for initial Beam model
        "accessPattern": { "type": "string" },

        // The SDK converts the access pattern to an SDK-specific type, and this function
        // converts it to the users desired side input type
        "viewFn": { "type": "string" },

        // A function that maps from the main input window to the desired side input window
        "windowMappingFn": { "type": "string" }
      }
    },

     // The parameters to a ParDo transform and further metatdata
    "ParDoPayload": {
      "type": "object",
      "additionalProperties": false,

      "properties": {
        // The DoFn for this ParDo
        "doFn": { "type": "string" },

        // Whether the ParDo requires access to the current window (this may force runners to perform
        // additional work prior to executing this ParDo)
        "requiresWindowAccess": { "type": "boolean" },

        // A map from PCollection id to the specification for how to materialize and read it
        // as a side input
        "sideInputs": {
          "type": "object",
          "additionalProperties": { "$ref" : "#/definitions/SideInput" }
        }
      }
    },

    // The parameters to a Read transform and further metadata.
    //
    // TODO: decide what metadata should be here in runner-readable form vs what is part of the
    // UDF.
    "ReadPayload": {
      "type": "object",
      "additionalProperties": false,
      "properties": {

        // The ID of the user-definable source fn
        "source": { "type": "string" },

        "isBounded": { "type": "boolean" },
        "doesNotRequireSplitting": { "type": "boolean" },
        "producesSortedKeys": { "type": "boolean" }
      }
    },

    // The parameters to a Combine transform and further metadata.
    "CombinePayload": {
      "type": "object",
      "additionalProperties": false,

      "properties": {
        // The ID of the user-defined CombineFn
        "combineFn": { "type": "string" }
      }
    },

    "WindowIntoPayload": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "windowingStrategy": { "type": "string" }
      }
    },

    // A transform node contains pointers to its inputs and outputs, whether
    // or not it is composite. If it is part of a composite, it contains a pointer
    // to its parent.
    "TransformNode": {
      "type": "object",
      "additionalProperties": false,
      "properties": {

        // The stable name of the transform application node.
        "label": { "type": "string" },

        // Whether or not it is composite, it contains a "kind" string that uniquely
        // identifies what it computes. This is a stable, cross-language string, that
        // can be used for replacement-based implementation and also to parse the node
        // to a concrete language-specific class.
        //
        // A stable, cross-language identifier identifying what the transform computes.
        // This is to be used for replacement-based implementation, whether it is a primitive
        // or composite. Examples include "GroupByKey", "Sum", "ParDo". We should likely
        // adopt a standard namespacing convention, such as URIs.
        "urn":  { "type": [ "null", "string" ] },

        // All of the inputs and outputs for the transform, whether it is composite or primitive.
        // The inputs and outputs of parent and child transforms nodes must be coherent:
        //
        // - The unexpanded inputs of every child transforms must be contained
        //   within some level of the recursive expansion of the inputs to the parent.
        // - Every level of the expanded output of a composite must be contained within
        //   some level of the expansion of some child.
        //
        // These collections of values are unordered. References to values are managed in
        // a transform-specific way. For example, a DoFn will call processContext.output(tag, value)
        // and the tag should contain sufficient information to identify the target PCollection.
        "inputs": { "type": "array", "items": { "type": "string" } },
        "outputs": { "type": "array", "items": { "type": "string" } },

        // If the node is contained within a composite, a pointer to the parent.
        "parent": { "type": [ "null", "string" ] },

        // If the node is a runner-specific replacement for a user's runner-agnostic node,
        // it contains a pointer back to it so the user's graph can be reconstructed.
        "replacementFor": { "type": [ "null", "string" ] },

        // If the node is a defunct user node that has been replaced, it contains a bit
        // to distinguish it from an active node in the graph.
        "replaced": { "type": "boolean" },

        // Static display data
        "display_data": { "type": "object", "additionalProperties": { "type": "string" } },

        // The payload must correspond to the kind string and must be null for transforms that
        // are not predefined as part of the Beam model.
        "payload": {
          "type": [ "null", "object" ],
          "oneOf": [
            { "$ref": "#/definitions/ParDoPayload" },
            { "$ref": "#/definitions/ReadPayload" },
            { "$ref": "#/definitions/WindowIntoPayload" },
            { "$ref": "#/definitions/CombinePayload" }
          ]
        }
      }
    },

    // A value node represents a PValue. There are only two primitive types:
    // A PCollection (many values per window) or a PCollectionView (one value per window).
    "Value": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        // A unique program-readable name for the value, such as "foo/baz/bar.out
        "label": { "type": "string" },

        // The node ID for the coder of this PCollection
        "coder": { "type": "string" },

        // Windowing strategy node id
        "windowingStrategy": { "type": "string" },

        // This is the static display data recently proposed
        "displayData": { "$ref": "#/definitions/DisplayData" }
      }
    },

    "DisplayData": {
      "type": "object",
      "additionalProperties": { "type": "string" }
    },

    // An coder represents a particular binary format.
    "Coder": {
      "type": "object",
      "additionalProperties": false,
      "properties": {

        // A cross-language, stable, unique identifier for the (possibly parametric) encoding.
        "urn": { "type": "string" },

        // If this coder is parametric, such as ListCoder(VarIntCoder), this is a list
        // of the components. In order for encodings to be identical, the encoding_id
        // and all components must be identical.
        "componentEncodings": { "type": "array", "items": { "type": "string" } },

        // The SDK-specific user-definable coder implementing the described encoding.
        //
        // If present, then the SDK can utilize this coder without a priori knowledge of the
        // encoded format.
        //
        // TBD: multi-SDK support
        "customCoder": { "type": [ "null", "string" ] }
      }
    },

    "OutputTime": {
      "type": "string",
      "pattern": "^latest|earliest|eow$"
    },

    "AccumulationMode": {
      "type": "string",
      "pattern": "^discarding|accumulating$"
    }
  }
}
