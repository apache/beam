// Code generated by protoc-gen-go.
// source: beam_fn_api.proto
// DO NOT EDIT!

/*
Package org_apache_beam_fn_v1 is a generated protocol buffer package.

It is generated from these files:
	beam_fn_api.proto

It has these top-level messages:
	Target
	PCollection
	PrimitiveTransform
	FunctionSpec
	SideInput
	Coder
	RemoteGrpcPort
	InstructionRequest
	InstructionResponse
	RegisterRequest
	RegisterResponse
	ProcessBundleDescriptor
	ProcessBundleRequest
	ProcessBundleResponse
	InitialSourceSplitRequest
	SourceSplit
	InitialSourceSplitResponse
	DynamicSourceSplitRequest
	DynamicSourceSplitResponse
	SourceProgressRequest
	SourceProgressResponse
	Elements
	StateRequest
	StateResponse
	Empty
	SimpleStateAppendRequest
	StateKey
	StateKeyOrIterable
	StateGetRequest
	StateGetResponse
	StateAppendRequest
	StateAppendResponse
	StateClearRequest
	StateClearResponse
	LogEntry
	LogControl
	ApiServiceDescriptor
	OAuth2ClientCredentialsGrant
	DockerContainer
*/
package org_apache_beam_fn_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"
import google_protobuf1 "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The severity of the event described in a log entry, expressed as one of the
// severity levels listed below. For your reference, the levels are
// assigned the listed numeric values. The effect of using numeric values
// other than those listed is undefined.
//
// If you are writing log entries, you should map other severity encodings to
// one of these standard levels. For example, you might map all of
// Java's FINE, FINER, and FINEST levels to `Severity.DEBUG`.
//
// This list is intentionally not comprehensive; the intent is to provide a
// common set of "good enough" severity levels so that logging front ends
// can provide filtering and searching across log types. Users of the API are
// free not to use all severity levels in their log messages.
type LogEntry_Severity int32

const (
	// Trace level information, also the default log level unless
	// another severity is specified.
	LogEntry_TRACE LogEntry_Severity = 0
	// Debugging information.
	LogEntry_DEBUG LogEntry_Severity = 10
	// Normal events.
	LogEntry_INFO LogEntry_Severity = 20
	// Normal but significant events, such as start up, shut down, or
	// configuration.
	LogEntry_NOTICE LogEntry_Severity = 30
	// Warning events might cause problems.
	LogEntry_WARN LogEntry_Severity = 40
	// Error events are likely to cause problems.
	LogEntry_ERROR LogEntry_Severity = 50
	// Critical events cause severe problems or brief outages and may
	// indicate that a person must take action.
	LogEntry_CRITICAL LogEntry_Severity = 60
)

var LogEntry_Severity_name = map[int32]string{
	0:  "TRACE",
	10: "DEBUG",
	20: "INFO",
	30: "NOTICE",
	40: "WARN",
	50: "ERROR",
	60: "CRITICAL",
}
var LogEntry_Severity_value = map[string]int32{
	"TRACE":    0,
	"DEBUG":    10,
	"INFO":     20,
	"NOTICE":   30,
	"WARN":     40,
	"ERROR":    50,
	"CRITICAL": 60,
}

func (x LogEntry_Severity) String() string {
	return proto.EnumName(LogEntry_Severity_name, int32(x))
}
func (LogEntry_Severity) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{34, 0} }

// A representation of an input or output definition on a primitive transform.
type Target struct {
	// (Required) The id of the PrimitiveTransform which is the target.
	PrimitiveTransformReference int64 `protobuf:"varint,1,opt,name=primitive_transform_reference,json=primitiveTransformReference" json:"primitive_transform_reference,omitempty"`
	// (Required) The local name of an input or output defined on the primitive
	// transform.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *Target) Reset()                    { *m = Target{} }
func (m *Target) String() string            { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()               {}
func (*Target) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Target) GetPrimitiveTransformReference() int64 {
	if m != nil {
		return m.PrimitiveTransformReference
	}
	return 0
}

func (m *Target) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// A repeated list of target definitions.
type Target_List struct {
	Target []*Target `protobuf:"bytes,1,rep,name=target" json:"target,omitempty"`
}

func (m *Target_List) Reset()                    { *m = Target_List{} }
func (m *Target_List) String() string            { return proto.CompactTextString(m) }
func (*Target_List) ProtoMessage()               {}
func (*Target_List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *Target_List) GetTarget() []*Target {
	if m != nil {
		return m.Target
	}
	return nil
}

// Information defining a PCollection
type PCollection struct {
	// (Required) A reference to a coder.
	CoderReference int64 `protobuf:"varint,1,opt,name=coder_reference,json=coderReference" json:"coder_reference,omitempty"`
}

func (m *PCollection) Reset()                    { *m = PCollection{} }
func (m *PCollection) String() string            { return proto.CompactTextString(m) }
func (*PCollection) ProtoMessage()               {}
func (*PCollection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PCollection) GetCoderReference() int64 {
	if m != nil {
		return m.CoderReference
	}
	return 0
}

// A primitive transform within Apache Beam.
type PrimitiveTransform struct {
	// (Required) A pipeline level unique id which can be used as a reference to
	// refer to this.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// (Required) A function spec that is used by this primitive
	// transform to process data.
	FunctionSpec *FunctionSpec `protobuf:"bytes,2,opt,name=function_spec,json=functionSpec" json:"function_spec,omitempty"`
	// A map of distinct input names to target definitions.
	// For example, in CoGbk this represents the tag name associated with each
	// distinct input name and a list of primitive transforms that are associated
	// with the specified input.
	Inputs map[string]*Target_List `protobuf:"bytes,3,rep,name=inputs" json:"inputs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map from local output name to PCollection definitions. For example, in
	// DoFn this represents the tag name associated with each distinct output.
	Outputs map[string]*PCollection `protobuf:"bytes,4,rep,name=outputs" json:"outputs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map of from side input names to side inputs.
	SideInputs map[string]*SideInput `protobuf:"bytes,5,rep,name=side_inputs,json=sideInputs" json:"side_inputs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The user name of this step.
	// TODO(robertwb): Consider removing if it simplifies the the SDK harness.
	StepName string `protobuf:"bytes,6,opt,name=step_name,json=stepName" json:"step_name,omitempty"`
}

func (m *PrimitiveTransform) Reset()                    { *m = PrimitiveTransform{} }
func (m *PrimitiveTransform) String() string            { return proto.CompactTextString(m) }
func (*PrimitiveTransform) ProtoMessage()               {}
func (*PrimitiveTransform) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PrimitiveTransform) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PrimitiveTransform) GetFunctionSpec() *FunctionSpec {
	if m != nil {
		return m.FunctionSpec
	}
	return nil
}

func (m *PrimitiveTransform) GetInputs() map[string]*Target_List {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *PrimitiveTransform) GetOutputs() map[string]*PCollection {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *PrimitiveTransform) GetSideInputs() map[string]*SideInput {
	if m != nil {
		return m.SideInputs
	}
	return nil
}

func (m *PrimitiveTransform) GetStepName() string {
	if m != nil {
		return m.StepName
	}
	return ""
}

// Defines the common elements of user-definable functions, to allow the SDK to
// express the information the runner needs to execute work.
type FunctionSpec struct {
	// (Required) A pipeline level unique id which can be used as a reference to
	// refer to this.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// (Required) A globally unique name representing this user definable
	// function.
	//
	// User definable functions use the urn encodings registered such that another
	// may implement the user definable function within another language.
	//
	// For example:
	//    urn:org.apache.beam:coder:kv:1.0
	Urn string `protobuf:"bytes,2,opt,name=urn" json:"urn,omitempty"`
	// (Required) Reference to specification of execution environment required to
	// invoke this function.
	EnvironmentReference int64 `protobuf:"varint,3,opt,name=environment_reference,json=environmentReference" json:"environment_reference,omitempty"`
	// Data used to parameterize this function. Depending on the urn, this may be
	// optional or required.
	Data *google_protobuf.Any `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
}

func (m *FunctionSpec) Reset()                    { *m = FunctionSpec{} }
func (m *FunctionSpec) String() string            { return proto.CompactTextString(m) }
func (*FunctionSpec) ProtoMessage()               {}
func (*FunctionSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *FunctionSpec) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FunctionSpec) GetUrn() string {
	if m != nil {
		return m.Urn
	}
	return ""
}

func (m *FunctionSpec) GetEnvironmentReference() int64 {
	if m != nil {
		return m.EnvironmentReference
	}
	return 0
}

func (m *FunctionSpec) GetData() *google_protobuf.Any {
	if m != nil {
		return m.Data
	}
	return nil
}

type SideInput struct {
	// For RunnerAPI.
	Input *Target `protobuf:"bytes,1,opt,name=input" json:"input,omitempty"`
	// For FnAPI.
	ViewFn *FunctionSpec `protobuf:"bytes,2,opt,name=view_fn,json=viewFn" json:"view_fn,omitempty"`
}

func (m *SideInput) Reset()                    { *m = SideInput{} }
func (m *SideInput) String() string            { return proto.CompactTextString(m) }
func (*SideInput) ProtoMessage()               {}
func (*SideInput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SideInput) GetInput() *Target {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *SideInput) GetViewFn() *FunctionSpec {
	if m != nil {
		return m.ViewFn
	}
	return nil
}

// Defines how to encode values into byte streams and decode values from byte
// streams. A coder can be parameterized by additional properties which may or
// may not be language agnostic.
//
// Coders using the urn:org.apache.beam:coder namespace must have their
// encodings registered such that another may implement the encoding within
// another language.
//
// For example:
//    urn:org.apache.beam:coder:kv:1.0
//    urn:org.apache.beam:coder:iterable:1.0
type Coder struct {
	// The data associated with this coder used to reconstruct it.
	FunctionSpec *FunctionSpec `protobuf:"bytes,1,opt,name=function_spec,json=functionSpec" json:"function_spec,omitempty"`
	// A list of component coder references.
	//
	// For a key-value coder, there must be exactly two component coder references
	// where the first reference represents the key coder and the second reference
	// is the value coder.
	//
	// For an iterable coder, there must be exactly one component coder reference
	// representing the value coder.
	//
	// TODO(robertwb): Perhaps this is redundant with the data of the FunctionSpec
	// for known coders?
	ComponentCoderReference []int64 `protobuf:"varint,2,rep,packed,name=component_coder_reference,json=componentCoderReference" json:"component_coder_reference,omitempty"`
}

func (m *Coder) Reset()                    { *m = Coder{} }
func (m *Coder) String() string            { return proto.CompactTextString(m) }
func (*Coder) ProtoMessage()               {}
func (*Coder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Coder) GetFunctionSpec() *FunctionSpec {
	if m != nil {
		return m.FunctionSpec
	}
	return nil
}

func (m *Coder) GetComponentCoderReference() []int64 {
	if m != nil {
		return m.ComponentCoderReference
	}
	return nil
}

// A descriptor for connecting to a remote port using the Beam Fn Data API.
// Allows for communication between two environments (for example between the
// runner and the SDK).
type RemoteGrpcPort struct {
	// (Required) An API descriptor which describes where to
	// connect to including any authentication that is required.
	ApiServiceDescriptor *ApiServiceDescriptor `protobuf:"bytes,1,opt,name=api_service_descriptor,json=apiServiceDescriptor" json:"api_service_descriptor,omitempty"`
}

func (m *RemoteGrpcPort) Reset()                    { *m = RemoteGrpcPort{} }
func (m *RemoteGrpcPort) String() string            { return proto.CompactTextString(m) }
func (*RemoteGrpcPort) ProtoMessage()               {}
func (*RemoteGrpcPort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *RemoteGrpcPort) GetApiServiceDescriptor() *ApiServiceDescriptor {
	if m != nil {
		return m.ApiServiceDescriptor
	}
	return nil
}

// A request sent by a runner which it the SDK is asked to fulfill.
type InstructionRequest struct {
	// (Required) An unique identifier provided by the runner which represents
	// this requests execution. The InstructionResponse MUST have the matching id.
	InstructionId int64 `protobuf:"varint,1,opt,name=instruction_id,json=instructionId" json:"instruction_id,omitempty"`
	// (Required) A request that the SDK Harness needs to interpret.
	//
	// Types that are valid to be assigned to Request:
	//	*InstructionRequest_Register
	//	*InstructionRequest_ProcessBundle
	//	*InstructionRequest_InitialSourceSplit
	//	*InstructionRequest_DynamicSourceSplit
	//	*InstructionRequest_SourceProgress
	Request isInstructionRequest_Request `protobuf_oneof:"request"`
}

func (m *InstructionRequest) Reset()                    { *m = InstructionRequest{} }
func (m *InstructionRequest) String() string            { return proto.CompactTextString(m) }
func (*InstructionRequest) ProtoMessage()               {}
func (*InstructionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isInstructionRequest_Request interface {
	isInstructionRequest_Request()
}

type InstructionRequest_Register struct {
	Register *RegisterRequest `protobuf:"bytes,1000,opt,name=register,oneof"`
}
type InstructionRequest_ProcessBundle struct {
	ProcessBundle *ProcessBundleRequest `protobuf:"bytes,1001,opt,name=process_bundle,json=processBundle,oneof"`
}
type InstructionRequest_InitialSourceSplit struct {
	InitialSourceSplit *InitialSourceSplitRequest `protobuf:"bytes,1002,opt,name=initial_source_split,json=initialSourceSplit,oneof"`
}
type InstructionRequest_DynamicSourceSplit struct {
	DynamicSourceSplit *DynamicSourceSplitRequest `protobuf:"bytes,1003,opt,name=dynamic_source_split,json=dynamicSourceSplit,oneof"`
}
type InstructionRequest_SourceProgress struct {
	SourceProgress *SourceProgressRequest `protobuf:"bytes,1004,opt,name=source_progress,json=sourceProgress,oneof"`
}

func (*InstructionRequest_Register) isInstructionRequest_Request()           {}
func (*InstructionRequest_ProcessBundle) isInstructionRequest_Request()      {}
func (*InstructionRequest_InitialSourceSplit) isInstructionRequest_Request() {}
func (*InstructionRequest_DynamicSourceSplit) isInstructionRequest_Request() {}
func (*InstructionRequest_SourceProgress) isInstructionRequest_Request()     {}

func (m *InstructionRequest) GetRequest() isInstructionRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *InstructionRequest) GetInstructionId() int64 {
	if m != nil {
		return m.InstructionId
	}
	return 0
}

func (m *InstructionRequest) GetRegister() *RegisterRequest {
	if x, ok := m.GetRequest().(*InstructionRequest_Register); ok {
		return x.Register
	}
	return nil
}

func (m *InstructionRequest) GetProcessBundle() *ProcessBundleRequest {
	if x, ok := m.GetRequest().(*InstructionRequest_ProcessBundle); ok {
		return x.ProcessBundle
	}
	return nil
}

func (m *InstructionRequest) GetInitialSourceSplit() *InitialSourceSplitRequest {
	if x, ok := m.GetRequest().(*InstructionRequest_InitialSourceSplit); ok {
		return x.InitialSourceSplit
	}
	return nil
}

func (m *InstructionRequest) GetDynamicSourceSplit() *DynamicSourceSplitRequest {
	if x, ok := m.GetRequest().(*InstructionRequest_DynamicSourceSplit); ok {
		return x.DynamicSourceSplit
	}
	return nil
}

func (m *InstructionRequest) GetSourceProgress() *SourceProgressRequest {
	if x, ok := m.GetRequest().(*InstructionRequest_SourceProgress); ok {
		return x.SourceProgress
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstructionRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstructionRequest_OneofMarshaler, _InstructionRequest_OneofUnmarshaler, _InstructionRequest_OneofSizer, []interface{}{
		(*InstructionRequest_Register)(nil),
		(*InstructionRequest_ProcessBundle)(nil),
		(*InstructionRequest_InitialSourceSplit)(nil),
		(*InstructionRequest_DynamicSourceSplit)(nil),
		(*InstructionRequest_SourceProgress)(nil),
	}
}

func _InstructionRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstructionRequest)
	// request
	switch x := m.Request.(type) {
	case *InstructionRequest_Register:
		b.EncodeVarint(1000<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Register); err != nil {
			return err
		}
	case *InstructionRequest_ProcessBundle:
		b.EncodeVarint(1001<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProcessBundle); err != nil {
			return err
		}
	case *InstructionRequest_InitialSourceSplit:
		b.EncodeVarint(1002<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InitialSourceSplit); err != nil {
			return err
		}
	case *InstructionRequest_DynamicSourceSplit:
		b.EncodeVarint(1003<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DynamicSourceSplit); err != nil {
			return err
		}
	case *InstructionRequest_SourceProgress:
		b.EncodeVarint(1004<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SourceProgress); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstructionRequest.Request has unexpected type %T", x)
	}
	return nil
}

func _InstructionRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstructionRequest)
	switch tag {
	case 1000: // request.register
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RegisterRequest)
		err := b.DecodeMessage(msg)
		m.Request = &InstructionRequest_Register{msg}
		return true, err
	case 1001: // request.process_bundle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ProcessBundleRequest)
		err := b.DecodeMessage(msg)
		m.Request = &InstructionRequest_ProcessBundle{msg}
		return true, err
	case 1002: // request.initial_source_split
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InitialSourceSplitRequest)
		err := b.DecodeMessage(msg)
		m.Request = &InstructionRequest_InitialSourceSplit{msg}
		return true, err
	case 1003: // request.dynamic_source_split
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DynamicSourceSplitRequest)
		err := b.DecodeMessage(msg)
		m.Request = &InstructionRequest_DynamicSourceSplit{msg}
		return true, err
	case 1004: // request.source_progress
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SourceProgressRequest)
		err := b.DecodeMessage(msg)
		m.Request = &InstructionRequest_SourceProgress{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstructionRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstructionRequest)
	// request
	switch x := m.Request.(type) {
	case *InstructionRequest_Register:
		s := proto.Size(x.Register)
		n += proto.SizeVarint(1000<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstructionRequest_ProcessBundle:
		s := proto.Size(x.ProcessBundle)
		n += proto.SizeVarint(1001<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstructionRequest_InitialSourceSplit:
		s := proto.Size(x.InitialSourceSplit)
		n += proto.SizeVarint(1002<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstructionRequest_DynamicSourceSplit:
		s := proto.Size(x.DynamicSourceSplit)
		n += proto.SizeVarint(1003<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstructionRequest_SourceProgress:
		s := proto.Size(x.SourceProgress)
		n += proto.SizeVarint(1004<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The response for an associated request the SDK had been asked to fulfill.
type InstructionResponse struct {
	// (Required) A reference provided by the runner which represents a requests
	// execution. The InstructionResponse MUST have the matching id when
	// responding to the runner.
	InstructionId int64 `protobuf:"varint,1,opt,name=instruction_id,json=instructionId" json:"instruction_id,omitempty"`
	// If this is specified, then this instruction has failed.
	// A human readable string representing the reason as to why processing has
	// failed.
	Error string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	// If the instruction did not fail, it is required to return an equivalent
	// response type depending on the request this matches.
	//
	// Types that are valid to be assigned to Response:
	//	*InstructionResponse_Register
	//	*InstructionResponse_ProcessBundle
	//	*InstructionResponse_InitialSourceSplit
	//	*InstructionResponse_DynamicSourceSplit
	//	*InstructionResponse_SourceProgress
	Response isInstructionResponse_Response `protobuf_oneof:"response"`
}

func (m *InstructionResponse) Reset()                    { *m = InstructionResponse{} }
func (m *InstructionResponse) String() string            { return proto.CompactTextString(m) }
func (*InstructionResponse) ProtoMessage()               {}
func (*InstructionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isInstructionResponse_Response interface {
	isInstructionResponse_Response()
}

type InstructionResponse_Register struct {
	Register *RegisterResponse `protobuf:"bytes,1000,opt,name=register,oneof"`
}
type InstructionResponse_ProcessBundle struct {
	ProcessBundle *ProcessBundleResponse `protobuf:"bytes,1001,opt,name=process_bundle,json=processBundle,oneof"`
}
type InstructionResponse_InitialSourceSplit struct {
	InitialSourceSplit *InitialSourceSplitResponse `protobuf:"bytes,1002,opt,name=initial_source_split,json=initialSourceSplit,oneof"`
}
type InstructionResponse_DynamicSourceSplit struct {
	DynamicSourceSplit *DynamicSourceSplitResponse `protobuf:"bytes,1003,opt,name=dynamic_source_split,json=dynamicSourceSplit,oneof"`
}
type InstructionResponse_SourceProgress struct {
	SourceProgress *SourceProgressResponse `protobuf:"bytes,1004,opt,name=source_progress,json=sourceProgress,oneof"`
}

func (*InstructionResponse_Register) isInstructionResponse_Response()           {}
func (*InstructionResponse_ProcessBundle) isInstructionResponse_Response()      {}
func (*InstructionResponse_InitialSourceSplit) isInstructionResponse_Response() {}
func (*InstructionResponse_DynamicSourceSplit) isInstructionResponse_Response() {}
func (*InstructionResponse_SourceProgress) isInstructionResponse_Response()     {}

func (m *InstructionResponse) GetResponse() isInstructionResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *InstructionResponse) GetInstructionId() int64 {
	if m != nil {
		return m.InstructionId
	}
	return 0
}

func (m *InstructionResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *InstructionResponse) GetRegister() *RegisterResponse {
	if x, ok := m.GetResponse().(*InstructionResponse_Register); ok {
		return x.Register
	}
	return nil
}

func (m *InstructionResponse) GetProcessBundle() *ProcessBundleResponse {
	if x, ok := m.GetResponse().(*InstructionResponse_ProcessBundle); ok {
		return x.ProcessBundle
	}
	return nil
}

func (m *InstructionResponse) GetInitialSourceSplit() *InitialSourceSplitResponse {
	if x, ok := m.GetResponse().(*InstructionResponse_InitialSourceSplit); ok {
		return x.InitialSourceSplit
	}
	return nil
}

func (m *InstructionResponse) GetDynamicSourceSplit() *DynamicSourceSplitResponse {
	if x, ok := m.GetResponse().(*InstructionResponse_DynamicSourceSplit); ok {
		return x.DynamicSourceSplit
	}
	return nil
}

func (m *InstructionResponse) GetSourceProgress() *SourceProgressResponse {
	if x, ok := m.GetResponse().(*InstructionResponse_SourceProgress); ok {
		return x.SourceProgress
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstructionResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstructionResponse_OneofMarshaler, _InstructionResponse_OneofUnmarshaler, _InstructionResponse_OneofSizer, []interface{}{
		(*InstructionResponse_Register)(nil),
		(*InstructionResponse_ProcessBundle)(nil),
		(*InstructionResponse_InitialSourceSplit)(nil),
		(*InstructionResponse_DynamicSourceSplit)(nil),
		(*InstructionResponse_SourceProgress)(nil),
	}
}

func _InstructionResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstructionResponse)
	// response
	switch x := m.Response.(type) {
	case *InstructionResponse_Register:
		b.EncodeVarint(1000<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Register); err != nil {
			return err
		}
	case *InstructionResponse_ProcessBundle:
		b.EncodeVarint(1001<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProcessBundle); err != nil {
			return err
		}
	case *InstructionResponse_InitialSourceSplit:
		b.EncodeVarint(1002<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InitialSourceSplit); err != nil {
			return err
		}
	case *InstructionResponse_DynamicSourceSplit:
		b.EncodeVarint(1003<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DynamicSourceSplit); err != nil {
			return err
		}
	case *InstructionResponse_SourceProgress:
		b.EncodeVarint(1004<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SourceProgress); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstructionResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _InstructionResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstructionResponse)
	switch tag {
	case 1000: // response.register
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RegisterResponse)
		err := b.DecodeMessage(msg)
		m.Response = &InstructionResponse_Register{msg}
		return true, err
	case 1001: // response.process_bundle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ProcessBundleResponse)
		err := b.DecodeMessage(msg)
		m.Response = &InstructionResponse_ProcessBundle{msg}
		return true, err
	case 1002: // response.initial_source_split
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InitialSourceSplitResponse)
		err := b.DecodeMessage(msg)
		m.Response = &InstructionResponse_InitialSourceSplit{msg}
		return true, err
	case 1003: // response.dynamic_source_split
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DynamicSourceSplitResponse)
		err := b.DecodeMessage(msg)
		m.Response = &InstructionResponse_DynamicSourceSplit{msg}
		return true, err
	case 1004: // response.source_progress
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SourceProgressResponse)
		err := b.DecodeMessage(msg)
		m.Response = &InstructionResponse_SourceProgress{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstructionResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstructionResponse)
	// response
	switch x := m.Response.(type) {
	case *InstructionResponse_Register:
		s := proto.Size(x.Register)
		n += proto.SizeVarint(1000<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstructionResponse_ProcessBundle:
		s := proto.Size(x.ProcessBundle)
		n += proto.SizeVarint(1001<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstructionResponse_InitialSourceSplit:
		s := proto.Size(x.InitialSourceSplit)
		n += proto.SizeVarint(1002<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstructionResponse_DynamicSourceSplit:
		s := proto.Size(x.DynamicSourceSplit)
		n += proto.SizeVarint(1003<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstructionResponse_SourceProgress:
		s := proto.Size(x.SourceProgress)
		n += proto.SizeVarint(1004<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A list of objects which can be referred to by the runner in
// future requests.
type RegisterRequest struct {
	// (Optional) The set of descriptors used to process bundles.
	ProcessBundleDescriptor []*ProcessBundleDescriptor `protobuf:"bytes,1,rep,name=process_bundle_descriptor,json=processBundleDescriptor" json:"process_bundle_descriptor,omitempty"`
}

func (m *RegisterRequest) Reset()                    { *m = RegisterRequest{} }
func (m *RegisterRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterRequest) ProtoMessage()               {}
func (*RegisterRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *RegisterRequest) GetProcessBundleDescriptor() []*ProcessBundleDescriptor {
	if m != nil {
		return m.ProcessBundleDescriptor
	}
	return nil
}

type RegisterResponse struct {
}

func (m *RegisterResponse) Reset()                    { *m = RegisterResponse{} }
func (m *RegisterResponse) String() string            { return proto.CompactTextString(m) }
func (*RegisterResponse) ProtoMessage()               {}
func (*RegisterResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

// A descriptor of references used when processing a bundle.
type ProcessBundleDescriptor struct {
	// (Required) A pipeline level unique id which can be used as a reference to
	// refer to this.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// (Required) A list of primitive transforms that should
	// be used to construct the bundle processing graph.
	PrimitiveTransform []*PrimitiveTransform `protobuf:"bytes,2,rep,name=primitive_transform,json=primitiveTransform" json:"primitive_transform,omitempty"`
	// (Required) The set of all coders referenced in this bundle.
	Coders []*Coder `protobuf:"bytes,4,rep,name=coders" json:"coders,omitempty"`
}

func (m *ProcessBundleDescriptor) Reset()                    { *m = ProcessBundleDescriptor{} }
func (m *ProcessBundleDescriptor) String() string            { return proto.CompactTextString(m) }
func (*ProcessBundleDescriptor) ProtoMessage()               {}
func (*ProcessBundleDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ProcessBundleDescriptor) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ProcessBundleDescriptor) GetPrimitiveTransform() []*PrimitiveTransform {
	if m != nil {
		return m.PrimitiveTransform
	}
	return nil
}

func (m *ProcessBundleDescriptor) GetCoders() []*Coder {
	if m != nil {
		return m.Coders
	}
	return nil
}

// A request to process a given bundle.
type ProcessBundleRequest struct {
	ProcessBundleDescriptorReference int64 `protobuf:"varint,1,opt,name=process_bundle_descriptor_reference,json=processBundleDescriptorReference" json:"process_bundle_descriptor_reference,omitempty"`
	// A set of elements to inject directly into the bundle, disjoint from those
	// retrieved via the data plane API.
	// TODO(robertwb): Drop this once the Python API supports the data API
	// unless there are performance advantages.
	InlineInputs *Elements `protobuf:"bytes,2,opt,name=inline_inputs,json=inlineInputs" json:"inline_inputs,omitempty"`
}

func (m *ProcessBundleRequest) Reset()                    { *m = ProcessBundleRequest{} }
func (m *ProcessBundleRequest) String() string            { return proto.CompactTextString(m) }
func (*ProcessBundleRequest) ProtoMessage()               {}
func (*ProcessBundleRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ProcessBundleRequest) GetProcessBundleDescriptorReference() int64 {
	if m != nil {
		return m.ProcessBundleDescriptorReference
	}
	return 0
}

func (m *ProcessBundleRequest) GetInlineInputs() *Elements {
	if m != nil {
		return m.InlineInputs
	}
	return nil
}

type ProcessBundleResponse struct {
	// A set of elements produced by the bundle, disjoint with those sent to
	// the data plane API.
	InlineOutputs *Elements `protobuf:"bytes,1,opt,name=inline_outputs,json=inlineOutputs" json:"inline_outputs,omitempty"`
}

func (m *ProcessBundleResponse) Reset()                    { *m = ProcessBundleResponse{} }
func (m *ProcessBundleResponse) String() string            { return proto.CompactTextString(m) }
func (*ProcessBundleResponse) ProtoMessage()               {}
func (*ProcessBundleResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ProcessBundleResponse) GetInlineOutputs() *Elements {
	if m != nil {
		return m.InlineOutputs
	}
	return nil
}

// TODO: Should this go away in favor of using a InitialSourceSplit
// URN function spec that consumes sources and produces SourceSplit?
// This would allow for splitting to produce a large number of sources.
// A request to split a source that is not being read.
type InitialSourceSplitRequest struct {
	// (Required) A reference to the source for which the split request is
	//  destined for.
	SourceReference int64 `protobuf:"varint,1,opt,name=source_reference,json=sourceReference" json:"source_reference,omitempty"`
	// (Required) The source should be split into a set of bundles where the
	// estimated size of each is approximately this many bytes.
	DesiredBundleSizeBytes int64 `protobuf:"varint,2,opt,name=desired_bundle_size_bytes,json=desiredBundleSizeBytes" json:"desired_bundle_size_bytes,omitempty"`
}

func (m *InitialSourceSplitRequest) Reset()                    { *m = InitialSourceSplitRequest{} }
func (m *InitialSourceSplitRequest) String() string            { return proto.CompactTextString(m) }
func (*InitialSourceSplitRequest) ProtoMessage()               {}
func (*InitialSourceSplitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *InitialSourceSplitRequest) GetSourceReference() int64 {
	if m != nil {
		return m.SourceReference
	}
	return 0
}

func (m *InitialSourceSplitRequest) GetDesiredBundleSizeBytes() int64 {
	if m != nil {
		return m.DesiredBundleSizeBytes
	}
	return 0
}

type SourceSplit struct {
	// (Required) The source representing this split.
	Source *FunctionSpec `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Relative size of this split compared to other splits in this split
	// response. If unspecified, the system will assign a reasonable weight
	// (e.g. assuming it is as large as the average of its siblings).
	RelativeSize float64 `protobuf:"fixed64,2,opt,name=relative_size,json=relativeSize" json:"relative_size,omitempty"`
}

func (m *SourceSplit) Reset()                    { *m = SourceSplit{} }
func (m *SourceSplit) String() string            { return proto.CompactTextString(m) }
func (*SourceSplit) ProtoMessage()               {}
func (*SourceSplit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *SourceSplit) GetSource() *FunctionSpec {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *SourceSplit) GetRelativeSize() float64 {
	if m != nil {
		return m.RelativeSize
	}
	return 0
}

type InitialSourceSplitResponse struct {
	// If left unspecified, the source can not be split. Otherwise the returned
	// set of sources represents the results of splitting the requested source.
	Splits []*SourceSplit `protobuf:"bytes,1,rep,name=splits" json:"splits,omitempty"`
}

func (m *InitialSourceSplitResponse) Reset()                    { *m = InitialSourceSplitResponse{} }
func (m *InitialSourceSplitResponse) String() string            { return proto.CompactTextString(m) }
func (*InitialSourceSplitResponse) ProtoMessage()               {}
func (*InitialSourceSplitResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *InitialSourceSplitResponse) GetSplits() []*SourceSplit {
	if m != nil {
		return m.Splits
	}
	return nil
}

// A request to split a source which is actively being read.
type DynamicSourceSplitRequest struct {
	// (Required) A reference to an active work request with the given instruction
	// id.
	InstructionReference int64 `protobuf:"varint,1,opt,name=instruction_reference,json=instructionReference" json:"instruction_reference,omitempty"`
	// (Required) A reference to the source for which the split request is
	// destined for.
	SourceReference int64 `protobuf:"varint,2,opt,name=source_reference,json=sourceReference" json:"source_reference,omitempty"`
	// (Required) A fraction at which to split the source, from 0.0 (beginning of
	// the input) to 1.0 (end of the input).
	Position float32 `protobuf:"fixed32,3,opt,name=position" json:"position,omitempty"`
}

func (m *DynamicSourceSplitRequest) Reset()                    { *m = DynamicSourceSplitRequest{} }
func (m *DynamicSourceSplitRequest) String() string            { return proto.CompactTextString(m) }
func (*DynamicSourceSplitRequest) ProtoMessage()               {}
func (*DynamicSourceSplitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *DynamicSourceSplitRequest) GetInstructionReference() int64 {
	if m != nil {
		return m.InstructionReference
	}
	return 0
}

func (m *DynamicSourceSplitRequest) GetSourceReference() int64 {
	if m != nil {
		return m.SourceReference
	}
	return 0
}

func (m *DynamicSourceSplitRequest) GetPosition() float32 {
	if m != nil {
		return m.Position
	}
	return 0
}

type DynamicSourceSplitResponse struct {
	// If the split was successful then primary_source and residual_source MUST be
	// specified. primary_source will contain the currently active source over the
	// new smaller range while residual_source will be a new source over the
	// remainder of the original range of the pre-split source. If the source
	// could not be split, then both fields should be unspecified.
	PrimarySource  *SourceSplit `protobuf:"bytes,1,opt,name=primary_source,json=primarySource" json:"primary_source,omitempty"`
	ResidualSource *SourceSplit `protobuf:"bytes,2,opt,name=residual_source,json=residualSource" json:"residual_source,omitempty"`
}

func (m *DynamicSourceSplitResponse) Reset()                    { *m = DynamicSourceSplitResponse{} }
func (m *DynamicSourceSplitResponse) String() string            { return proto.CompactTextString(m) }
func (*DynamicSourceSplitResponse) ProtoMessage()               {}
func (*DynamicSourceSplitResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *DynamicSourceSplitResponse) GetPrimarySource() *SourceSplit {
	if m != nil {
		return m.PrimarySource
	}
	return nil
}

func (m *DynamicSourceSplitResponse) GetResidualSource() *SourceSplit {
	if m != nil {
		return m.ResidualSource
	}
	return nil
}

type SourceProgressRequest struct {
	// (Required) A reference to an active work request with the given instruction
	// id.
	InstructionReference int64 `protobuf:"varint,1,opt,name=instruction_reference,json=instructionReference" json:"instruction_reference,omitempty"`
	// (Required) A reference to the source for which the split request is
	// destined for.
	SourceReference int64 `protobuf:"varint,2,opt,name=source_reference,json=sourceReference" json:"source_reference,omitempty"`
}

func (m *SourceProgressRequest) Reset()                    { *m = SourceProgressRequest{} }
func (m *SourceProgressRequest) String() string            { return proto.CompactTextString(m) }
func (*SourceProgressRequest) ProtoMessage()               {}
func (*SourceProgressRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *SourceProgressRequest) GetInstructionReference() int64 {
	if m != nil {
		return m.InstructionReference
	}
	return 0
}

func (m *SourceProgressRequest) GetSourceReference() int64 {
	if m != nil {
		return m.SourceReference
	}
	return 0
}

type SourceProgressResponse struct {
	// (Required) A fraction representing the sources progress, from 0.0
	// (beginning of the input) to 1.0 (end of the input).
	Position float32 `protobuf:"fixed32,1,opt,name=position" json:"position,omitempty"`
}

func (m *SourceProgressResponse) Reset()                    { *m = SourceProgressResponse{} }
func (m *SourceProgressResponse) String() string            { return proto.CompactTextString(m) }
func (*SourceProgressResponse) ProtoMessage()               {}
func (*SourceProgressResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *SourceProgressResponse) GetPosition() float32 {
	if m != nil {
		return m.Position
	}
	return 0
}

// Messages used to represent logical byte streams.
type Elements struct {
	// (Required) A list containing parts of logical byte streams.
	Data []*Elements_Data `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
}

func (m *Elements) Reset()                    { *m = Elements{} }
func (m *Elements) String() string            { return proto.CompactTextString(m) }
func (*Elements) ProtoMessage()               {}
func (*Elements) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *Elements) GetData() []*Elements_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

// Represents multiple encoded elements in nested context for a given named
// instruction and target.
type Elements_Data struct {
	// (Required) A reference to an active instruction request with the given
	// instruction id.
	InstructionReference int64 `protobuf:"varint,1,opt,name=instruction_reference,json=instructionReference" json:"instruction_reference,omitempty"`
	// (Required) A definition representing a consumer or producer of this data.
	// If received by a harness, this represents the consumer within that
	// harness that should consume these bytes. If sent by a harness, this
	// represents the producer of these bytes.
	//
	// Note that a single element may span multiple Data messages.
	//
	// Note that a sending/receiving pair should share the same target
	// identifier.
	Target *Target `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	// (Optional) Represents a part of a logical byte stream. Elements within
	// the logical byte stream are encoded in the nested context and
	// concatenated together.
	//
	// An empty data block represents the end of stream for the given
	// instruction and target.
	Data []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Elements_Data) Reset()                    { *m = Elements_Data{} }
func (m *Elements_Data) String() string            { return proto.CompactTextString(m) }
func (*Elements_Data) ProtoMessage()               {}
func (*Elements_Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 0} }

func (m *Elements_Data) GetInstructionReference() int64 {
	if m != nil {
		return m.InstructionReference
	}
	return 0
}

func (m *Elements_Data) GetTarget() *Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Elements_Data) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type StateRequest struct {
	// (Required) An unique identifier provided by the SDK which represents this
	// requests execution. The StateResponse must have the matching id.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// (Required) The associated instruction id of the work that is currently
	// being processed. This allows for the runner to associate any modifications
	// to state to be committed with the appropriate work execution.
	InstructionReference int64 `protobuf:"varint,2,opt,name=instruction_reference,json=instructionReference" json:"instruction_reference,omitempty"`
	// (Optional) A request to get state.
	Get []*StateGetRequest `protobuf:"bytes,3,rep,name=get" json:"get,omitempty"`
	// (Optional) A request to append to state.
	Append []*StateAppendRequest `protobuf:"bytes,4,rep,name=append" json:"append,omitempty"`
	// (Optional) A request to clear state.
	Clear []*StateClearRequest `protobuf:"bytes,5,rep,name=clear" json:"clear,omitempty"`
}

func (m *StateRequest) Reset()                    { *m = StateRequest{} }
func (m *StateRequest) String() string            { return proto.CompactTextString(m) }
func (*StateRequest) ProtoMessage()               {}
func (*StateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *StateRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StateRequest) GetInstructionReference() int64 {
	if m != nil {
		return m.InstructionReference
	}
	return 0
}

func (m *StateRequest) GetGet() []*StateGetRequest {
	if m != nil {
		return m.Get
	}
	return nil
}

func (m *StateRequest) GetAppend() []*StateAppendRequest {
	if m != nil {
		return m.Append
	}
	return nil
}

func (m *StateRequest) GetClear() []*StateClearRequest {
	if m != nil {
		return m.Clear
	}
	return nil
}

type StateResponse struct {
	// (Required) A reference provided by the SDK which represents a requests
	// execution. The StateResponse must have the matching id when responding
	// to the SDK.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// (Required) The associated instruction id of the work that is currently
	// being processed.
	InstructionReference int64 `protobuf:"varint,2,opt,name=instruction_reference,json=instructionReference" json:"instruction_reference,omitempty"`
	// (Required) A key to associate with the version of this state. Allows for
	// SDKs to share state across work items if they have the same cache key and
	// state key.
	CacheKey []byte `protobuf:"bytes,3,opt,name=cache_key,json=cacheKey,proto3" json:"cache_key,omitempty"`
	// (Optional) If this is specified, then the state request has failed.
	// A human readable string representing the reason as to why the request
	// failed.
	Error string `protobuf:"bytes,4,opt,name=error" json:"error,omitempty"`
	// (Optional) A response to getting state.
	Get []*StateGetResponse `protobuf:"bytes,5,rep,name=get" json:"get,omitempty"`
	// (Optional) A response to appending to state.
	Append []*StateAppendResponse `protobuf:"bytes,6,rep,name=append" json:"append,omitempty"`
	// (Optional) A response to clearing state.
	Clear []*StateClearResponse `protobuf:"bytes,7,rep,name=clear" json:"clear,omitempty"`
}

func (m *StateResponse) Reset()                    { *m = StateResponse{} }
func (m *StateResponse) String() string            { return proto.CompactTextString(m) }
func (*StateResponse) ProtoMessage()               {}
func (*StateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *StateResponse) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StateResponse) GetInstructionReference() int64 {
	if m != nil {
		return m.InstructionReference
	}
	return 0
}

func (m *StateResponse) GetCacheKey() []byte {
	if m != nil {
		return m.CacheKey
	}
	return nil
}

func (m *StateResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *StateResponse) GetGet() []*StateGetResponse {
	if m != nil {
		return m.Get
	}
	return nil
}

func (m *StateResponse) GetAppend() []*StateAppendResponse {
	if m != nil {
		return m.Append
	}
	return nil
}

func (m *StateResponse) GetClear() []*StateClearResponse {
	if m != nil {
		return m.Clear
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

type SimpleStateAppendRequest struct {
	StateKey *StateKey `protobuf:"bytes,1,opt,name=state_key,json=stateKey" json:"state_key,omitempty"`
	Data     [][]byte  `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *SimpleStateAppendRequest) Reset()                    { *m = SimpleStateAppendRequest{} }
func (m *SimpleStateAppendRequest) String() string            { return proto.CompactTextString(m) }
func (*SimpleStateAppendRequest) ProtoMessage()               {}
func (*SimpleStateAppendRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *SimpleStateAppendRequest) GetStateKey() *StateKey {
	if m != nil {
		return m.StateKey
	}
	return nil
}

func (m *SimpleStateAppendRequest) GetData() [][]byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type StateKey struct {
	// (Required) Represents the namespace for the state. If this state is for a
	// DoFn, then this reference is expected to point to the DoFn. If this state
	// is for a side input, then this is expected to reference the ViewFn.
	FunctionSpecReference int64 `protobuf:"varint,1,opt,name=function_spec_reference,json=functionSpecReference" json:"function_spec_reference,omitempty"`
	// (Required) The bytes of the window which this state request is for encoded
	// in the outer context.
	Window []byte `protobuf:"bytes,2,opt,name=window,proto3" json:"window,omitempty"`
	// (Required) The user key for which the value was encoded in the outer
	// context.
	Key []byte `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *StateKey) Reset()                    { *m = StateKey{} }
func (m *StateKey) String() string            { return proto.CompactTextString(m) }
func (*StateKey) ProtoMessage()               {}
func (*StateKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *StateKey) GetFunctionSpecReference() int64 {
	if m != nil {
		return m.FunctionSpecReference
	}
	return 0
}

func (m *StateKey) GetWindow() []byte {
	if m != nil {
		return m.Window
	}
	return nil
}

func (m *StateKey) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type StateKeyOrIterable struct {
	// One of the two fields below are required to be set.
	// If state key is set, then the State API should be invoked to fetch the
	// values allowing one to restart the iterable. Otherwise the bytes for the
	// entire iterable are represented and should be decoded using an iterable
	// coder using the outer context.
	StateKey *StateKey `protobuf:"bytes,1,opt,name=state_key,json=stateKey" json:"state_key,omitempty"`
	Iterable [][]byte  `protobuf:"bytes,2,rep,name=iterable,proto3" json:"iterable,omitempty"`
}

func (m *StateKeyOrIterable) Reset()                    { *m = StateKeyOrIterable{} }
func (m *StateKeyOrIterable) String() string            { return proto.CompactTextString(m) }
func (*StateKeyOrIterable) ProtoMessage()               {}
func (*StateKeyOrIterable) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *StateKeyOrIterable) GetStateKey() *StateKey {
	if m != nil {
		return m.StateKey
	}
	return nil
}

func (m *StateKeyOrIterable) GetIterable() [][]byte {
	if m != nil {
		return m.Iterable
	}
	return nil
}

// A request to get state for the given state key.
type StateGetRequest struct {
	// A state key encoded in the outer context.
	StateKey *StateKey `protobuf:"bytes,1,opt,name=state_key,json=stateKey" json:"state_key,omitempty"`
}

func (m *StateGetRequest) Reset()                    { *m = StateGetRequest{} }
func (m *StateGetRequest) String() string            { return proto.CompactTextString(m) }
func (*StateGetRequest) ProtoMessage()               {}
func (*StateGetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *StateGetRequest) GetStateKey() *StateKey {
	if m != nil {
		return m.StateKey
	}
	return nil
}

// A response to get state for the given state key.
type StateGetResponse struct {
	// A state key encoded in the outer context.
	StateKey *StateKey `protobuf:"bytes,1,opt,name=state_key,json=stateKey" json:"state_key,omitempty"`
	// Types that are valid to be assigned to State:
	//	*StateGetResponse_RemoteGrpcPort
	State isStateGetResponse_State `protobuf_oneof:"state"`
}

func (m *StateGetResponse) Reset()                    { *m = StateGetResponse{} }
func (m *StateGetResponse) String() string            { return proto.CompactTextString(m) }
func (*StateGetResponse) ProtoMessage()               {}
func (*StateGetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

type isStateGetResponse_State interface {
	isStateGetResponse_State()
}

type StateGetResponse_RemoteGrpcPort struct {
	RemoteGrpcPort *RemoteGrpcPort `protobuf:"bytes,1000,opt,name=remote_grpc_port,json=remoteGrpcPort,oneof"`
}

func (*StateGetResponse_RemoteGrpcPort) isStateGetResponse_State() {}

func (m *StateGetResponse) GetState() isStateGetResponse_State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *StateGetResponse) GetStateKey() *StateKey {
	if m != nil {
		return m.StateKey
	}
	return nil
}

func (m *StateGetResponse) GetRemoteGrpcPort() *RemoteGrpcPort {
	if x, ok := m.GetState().(*StateGetResponse_RemoteGrpcPort); ok {
		return x.RemoteGrpcPort
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StateGetResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StateGetResponse_OneofMarshaler, _StateGetResponse_OneofUnmarshaler, _StateGetResponse_OneofSizer, []interface{}{
		(*StateGetResponse_RemoteGrpcPort)(nil),
	}
}

func _StateGetResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StateGetResponse)
	// state
	switch x := m.State.(type) {
	case *StateGetResponse_RemoteGrpcPort:
		b.EncodeVarint(1000<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RemoteGrpcPort); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StateGetResponse.State has unexpected type %T", x)
	}
	return nil
}

func _StateGetResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StateGetResponse)
	switch tag {
	case 1000: // state.remote_grpc_port
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RemoteGrpcPort)
		err := b.DecodeMessage(msg)
		m.State = &StateGetResponse_RemoteGrpcPort{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StateGetResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StateGetResponse)
	// state
	switch x := m.State.(type) {
	case *StateGetResponse_RemoteGrpcPort:
		s := proto.Size(x.RemoteGrpcPort)
		n += proto.SizeVarint(1000<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A request to append state for the given state key.
type StateAppendRequest struct {
	// A state key encoded in the outer context.
	StateKey *StateKey `protobuf:"bytes,1,opt,name=state_key,json=stateKey" json:"state_key,omitempty"`
}

func (m *StateAppendRequest) Reset()                    { *m = StateAppendRequest{} }
func (m *StateAppendRequest) String() string            { return proto.CompactTextString(m) }
func (*StateAppendRequest) ProtoMessage()               {}
func (*StateAppendRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *StateAppendRequest) GetStateKey() *StateKey {
	if m != nil {
		return m.StateKey
	}
	return nil
}

// A response to append state for the given state key.
type StateAppendResponse struct {
	// A state key encoded in the outer context.
	StateKey *StateKey `protobuf:"bytes,1,opt,name=state_key,json=stateKey" json:"state_key,omitempty"`
	// Types that are valid to be assigned to State:
	//	*StateAppendResponse_RemoteGrpcPort
	State isStateAppendResponse_State `protobuf_oneof:"state"`
}

func (m *StateAppendResponse) Reset()                    { *m = StateAppendResponse{} }
func (m *StateAppendResponse) String() string            { return proto.CompactTextString(m) }
func (*StateAppendResponse) ProtoMessage()               {}
func (*StateAppendResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

type isStateAppendResponse_State interface {
	isStateAppendResponse_State()
}

type StateAppendResponse_RemoteGrpcPort struct {
	RemoteGrpcPort *RemoteGrpcPort `protobuf:"bytes,1000,opt,name=remote_grpc_port,json=remoteGrpcPort,oneof"`
}

func (*StateAppendResponse_RemoteGrpcPort) isStateAppendResponse_State() {}

func (m *StateAppendResponse) GetState() isStateAppendResponse_State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *StateAppendResponse) GetStateKey() *StateKey {
	if m != nil {
		return m.StateKey
	}
	return nil
}

func (m *StateAppendResponse) GetRemoteGrpcPort() *RemoteGrpcPort {
	if x, ok := m.GetState().(*StateAppendResponse_RemoteGrpcPort); ok {
		return x.RemoteGrpcPort
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StateAppendResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StateAppendResponse_OneofMarshaler, _StateAppendResponse_OneofUnmarshaler, _StateAppendResponse_OneofSizer, []interface{}{
		(*StateAppendResponse_RemoteGrpcPort)(nil),
	}
}

func _StateAppendResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StateAppendResponse)
	// state
	switch x := m.State.(type) {
	case *StateAppendResponse_RemoteGrpcPort:
		b.EncodeVarint(1000<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RemoteGrpcPort); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StateAppendResponse.State has unexpected type %T", x)
	}
	return nil
}

func _StateAppendResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StateAppendResponse)
	switch tag {
	case 1000: // state.remote_grpc_port
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RemoteGrpcPort)
		err := b.DecodeMessage(msg)
		m.State = &StateAppendResponse_RemoteGrpcPort{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StateAppendResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StateAppendResponse)
	// state
	switch x := m.State.(type) {
	case *StateAppendResponse_RemoteGrpcPort:
		s := proto.Size(x.RemoteGrpcPort)
		n += proto.SizeVarint(1000<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A request to clear state for the given state key.
type StateClearRequest struct {
	// A state key encoded in the outer context.
	StateKey *StateKey `protobuf:"bytes,1,opt,name=state_key,json=stateKey" json:"state_key,omitempty"`
}

func (m *StateClearRequest) Reset()                    { *m = StateClearRequest{} }
func (m *StateClearRequest) String() string            { return proto.CompactTextString(m) }
func (*StateClearRequest) ProtoMessage()               {}
func (*StateClearRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *StateClearRequest) GetStateKey() *StateKey {
	if m != nil {
		return m.StateKey
	}
	return nil
}

// A response to clear state for the given state key.
type StateClearResponse struct {
}

func (m *StateClearResponse) Reset()                    { *m = StateClearResponse{} }
func (m *StateClearResponse) String() string            { return proto.CompactTextString(m) }
func (*StateClearResponse) ProtoMessage()               {}
func (*StateClearResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

// A log entry
type LogEntry struct {
	// (Required) The severity of the log statement.
	Severity LogEntry_Severity `protobuf:"varint,1,opt,name=severity,enum=org.apache.beam.fn.v1.LogEntry_Severity" json:"severity,omitempty"`
	// (Required) The time at which this log statement occurred.
	Timestamp *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// (Required) A human readable message.
	Message string `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	// (Optional) An optional trace of the functions involved. For example, in
	// Java this can include multiple causes and multiple suppressed exceptions.
	Trace string `protobuf:"bytes,4,opt,name=trace" json:"trace,omitempty"`
	// (Optional) A reference to the instruction this log statement is associated
	// with.
	InstructionReference int64 `protobuf:"varint,5,opt,name=instruction_reference,json=instructionReference" json:"instruction_reference,omitempty"`
	// (Optional) A reference to the primitive transform this log statement is
	// associated with.
	PrimitiveTransformReference int64 `protobuf:"varint,6,opt,name=primitive_transform_reference,json=primitiveTransformReference" json:"primitive_transform_reference,omitempty"`
	// (Optional) Human-readable name of the function or method being invoked,
	// with optional context such as the class or package name. The format can
	// vary by language. For example:
	//   qual.if.ied.Class.method (Java)
	//   dir/package.func (Go)
	//   module.function (Python)
	//   file.cc:382 (C++)
	LogLocation string `protobuf:"bytes,7,opt,name=log_location,json=logLocation" json:"log_location,omitempty"`
	// (Optional) The name of the thread this log statement is associated with.
	Thread string `protobuf:"bytes,8,opt,name=thread" json:"thread,omitempty"`
}

func (m *LogEntry) Reset()                    { *m = LogEntry{} }
func (m *LogEntry) String() string            { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()               {}
func (*LogEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *LogEntry) GetSeverity() LogEntry_Severity {
	if m != nil {
		return m.Severity
	}
	return LogEntry_TRACE
}

func (m *LogEntry) GetTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *LogEntry) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *LogEntry) GetTrace() string {
	if m != nil {
		return m.Trace
	}
	return ""
}

func (m *LogEntry) GetInstructionReference() int64 {
	if m != nil {
		return m.InstructionReference
	}
	return 0
}

func (m *LogEntry) GetPrimitiveTransformReference() int64 {
	if m != nil {
		return m.PrimitiveTransformReference
	}
	return 0
}

func (m *LogEntry) GetLogLocation() string {
	if m != nil {
		return m.LogLocation
	}
	return ""
}

func (m *LogEntry) GetThread() string {
	if m != nil {
		return m.Thread
	}
	return ""
}

// A list of log entries, enables buffering and batching of multiple
// log messages using the logging API.
type LogEntry_List struct {
	// (Required) One or or more log messages.
	LogEntries []*LogEntry `protobuf:"bytes,1,rep,name=log_entries,json=logEntries" json:"log_entries,omitempty"`
}

func (m *LogEntry_List) Reset()                    { *m = LogEntry_List{} }
func (m *LogEntry_List) String() string            { return proto.CompactTextString(m) }
func (*LogEntry_List) ProtoMessage()               {}
func (*LogEntry_List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34, 0} }

func (m *LogEntry_List) GetLogEntries() []*LogEntry {
	if m != nil {
		return m.LogEntries
	}
	return nil
}

type LogControl struct {
}

func (m *LogControl) Reset()                    { *m = LogControl{} }
func (m *LogControl) String() string            { return proto.CompactTextString(m) }
func (*LogControl) ProtoMessage()               {}
func (*LogControl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

//
// Environment types
type ApiServiceDescriptor struct {
	// (Required) A pipeline level unique id which can be used as a reference to
	// refer to this.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// (Required) The URL to connect to.
	Url string `protobuf:"bytes,2,opt,name=url" json:"url,omitempty"`
	// (Optional) The method for authentication. If unspecified, access to the
	// url is already being performed in a trusted context (e.g. localhost,
	// private network).
	//
	// Types that are valid to be assigned to Authentication:
	//	*ApiServiceDescriptor_Oauth2ClientCredentialsGrant
	Authentication isApiServiceDescriptor_Authentication `protobuf_oneof:"authentication"`
}

func (m *ApiServiceDescriptor) Reset()                    { *m = ApiServiceDescriptor{} }
func (m *ApiServiceDescriptor) String() string            { return proto.CompactTextString(m) }
func (*ApiServiceDescriptor) ProtoMessage()               {}
func (*ApiServiceDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

type isApiServiceDescriptor_Authentication interface {
	isApiServiceDescriptor_Authentication()
}

type ApiServiceDescriptor_Oauth2ClientCredentialsGrant struct {
	Oauth2ClientCredentialsGrant *OAuth2ClientCredentialsGrant `protobuf:"bytes,3,opt,name=oauth2_client_credentials_grant,json=oauth2ClientCredentialsGrant,oneof"`
}

func (*ApiServiceDescriptor_Oauth2ClientCredentialsGrant) isApiServiceDescriptor_Authentication() {}

func (m *ApiServiceDescriptor) GetAuthentication() isApiServiceDescriptor_Authentication {
	if m != nil {
		return m.Authentication
	}
	return nil
}

func (m *ApiServiceDescriptor) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ApiServiceDescriptor) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ApiServiceDescriptor) GetOauth2ClientCredentialsGrant() *OAuth2ClientCredentialsGrant {
	if x, ok := m.GetAuthentication().(*ApiServiceDescriptor_Oauth2ClientCredentialsGrant); ok {
		return x.Oauth2ClientCredentialsGrant
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ApiServiceDescriptor) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ApiServiceDescriptor_OneofMarshaler, _ApiServiceDescriptor_OneofUnmarshaler, _ApiServiceDescriptor_OneofSizer, []interface{}{
		(*ApiServiceDescriptor_Oauth2ClientCredentialsGrant)(nil),
	}
}

func _ApiServiceDescriptor_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ApiServiceDescriptor)
	// authentication
	switch x := m.Authentication.(type) {
	case *ApiServiceDescriptor_Oauth2ClientCredentialsGrant:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Oauth2ClientCredentialsGrant); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ApiServiceDescriptor.Authentication has unexpected type %T", x)
	}
	return nil
}

func _ApiServiceDescriptor_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ApiServiceDescriptor)
	switch tag {
	case 3: // authentication.oauth2_client_credentials_grant
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OAuth2ClientCredentialsGrant)
		err := b.DecodeMessage(msg)
		m.Authentication = &ApiServiceDescriptor_Oauth2ClientCredentialsGrant{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ApiServiceDescriptor_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ApiServiceDescriptor)
	// authentication
	switch x := m.Authentication.(type) {
	case *ApiServiceDescriptor_Oauth2ClientCredentialsGrant:
		s := proto.Size(x.Oauth2ClientCredentialsGrant)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type OAuth2ClientCredentialsGrant struct {
	// (Required) The URL to submit a "client_credentials" grant type request for
	// an OAuth access token which will be used as a bearer token for requests.
	Url string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
}

func (m *OAuth2ClientCredentialsGrant) Reset()                    { *m = OAuth2ClientCredentialsGrant{} }
func (m *OAuth2ClientCredentialsGrant) String() string            { return proto.CompactTextString(m) }
func (*OAuth2ClientCredentialsGrant) ProtoMessage()               {}
func (*OAuth2ClientCredentialsGrant) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *OAuth2ClientCredentialsGrant) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// A Docker container configuration for launching the SDK Fn Harness to execute
// user specified functions.
type DockerContainer struct {
	// (Required) A pipeline level unique id which can be used as a reference to
	// refer to this.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// (Required) The Docker container URI
	// For example "dataflow.gcr.io/v1beta3/java-batch:1.5.1"
	Uri string `protobuf:"bytes,2,opt,name=uri" json:"uri,omitempty"`
	// (Optional) Docker registry specification.
	// If unspecified, the uri is expected to be able to be fetched without
	// requiring additional configuration by a runner.
	RegistryReference int64 `protobuf:"varint,3,opt,name=registry_reference,json=registryReference" json:"registry_reference,omitempty"`
}

func (m *DockerContainer) Reset()                    { *m = DockerContainer{} }
func (m *DockerContainer) String() string            { return proto.CompactTextString(m) }
func (*DockerContainer) ProtoMessage()               {}
func (*DockerContainer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *DockerContainer) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DockerContainer) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *DockerContainer) GetRegistryReference() int64 {
	if m != nil {
		return m.RegistryReference
	}
	return 0
}

func init() {
	proto.RegisterType((*Target)(nil), "org.apache.beam.fn.v1.Target")
	proto.RegisterType((*Target_List)(nil), "org.apache.beam.fn.v1.Target.List")
	proto.RegisterType((*PCollection)(nil), "org.apache.beam.fn.v1.PCollection")
	proto.RegisterType((*PrimitiveTransform)(nil), "org.apache.beam.fn.v1.PrimitiveTransform")
	proto.RegisterType((*FunctionSpec)(nil), "org.apache.beam.fn.v1.FunctionSpec")
	proto.RegisterType((*SideInput)(nil), "org.apache.beam.fn.v1.SideInput")
	proto.RegisterType((*Coder)(nil), "org.apache.beam.fn.v1.Coder")
	proto.RegisterType((*RemoteGrpcPort)(nil), "org.apache.beam.fn.v1.RemoteGrpcPort")
	proto.RegisterType((*InstructionRequest)(nil), "org.apache.beam.fn.v1.InstructionRequest")
	proto.RegisterType((*InstructionResponse)(nil), "org.apache.beam.fn.v1.InstructionResponse")
	proto.RegisterType((*RegisterRequest)(nil), "org.apache.beam.fn.v1.RegisterRequest")
	proto.RegisterType((*RegisterResponse)(nil), "org.apache.beam.fn.v1.RegisterResponse")
	proto.RegisterType((*ProcessBundleDescriptor)(nil), "org.apache.beam.fn.v1.ProcessBundleDescriptor")
	proto.RegisterType((*ProcessBundleRequest)(nil), "org.apache.beam.fn.v1.ProcessBundleRequest")
	proto.RegisterType((*ProcessBundleResponse)(nil), "org.apache.beam.fn.v1.ProcessBundleResponse")
	proto.RegisterType((*InitialSourceSplitRequest)(nil), "org.apache.beam.fn.v1.InitialSourceSplitRequest")
	proto.RegisterType((*SourceSplit)(nil), "org.apache.beam.fn.v1.SourceSplit")
	proto.RegisterType((*InitialSourceSplitResponse)(nil), "org.apache.beam.fn.v1.InitialSourceSplitResponse")
	proto.RegisterType((*DynamicSourceSplitRequest)(nil), "org.apache.beam.fn.v1.DynamicSourceSplitRequest")
	proto.RegisterType((*DynamicSourceSplitResponse)(nil), "org.apache.beam.fn.v1.DynamicSourceSplitResponse")
	proto.RegisterType((*SourceProgressRequest)(nil), "org.apache.beam.fn.v1.SourceProgressRequest")
	proto.RegisterType((*SourceProgressResponse)(nil), "org.apache.beam.fn.v1.SourceProgressResponse")
	proto.RegisterType((*Elements)(nil), "org.apache.beam.fn.v1.Elements")
	proto.RegisterType((*Elements_Data)(nil), "org.apache.beam.fn.v1.Elements.Data")
	proto.RegisterType((*StateRequest)(nil), "org.apache.beam.fn.v1.StateRequest")
	proto.RegisterType((*StateResponse)(nil), "org.apache.beam.fn.v1.StateResponse")
	proto.RegisterType((*Empty)(nil), "org.apache.beam.fn.v1.Empty")
	proto.RegisterType((*SimpleStateAppendRequest)(nil), "org.apache.beam.fn.v1.SimpleStateAppendRequest")
	proto.RegisterType((*StateKey)(nil), "org.apache.beam.fn.v1.StateKey")
	proto.RegisterType((*StateKeyOrIterable)(nil), "org.apache.beam.fn.v1.StateKeyOrIterable")
	proto.RegisterType((*StateGetRequest)(nil), "org.apache.beam.fn.v1.StateGetRequest")
	proto.RegisterType((*StateGetResponse)(nil), "org.apache.beam.fn.v1.StateGetResponse")
	proto.RegisterType((*StateAppendRequest)(nil), "org.apache.beam.fn.v1.StateAppendRequest")
	proto.RegisterType((*StateAppendResponse)(nil), "org.apache.beam.fn.v1.StateAppendResponse")
	proto.RegisterType((*StateClearRequest)(nil), "org.apache.beam.fn.v1.StateClearRequest")
	proto.RegisterType((*StateClearResponse)(nil), "org.apache.beam.fn.v1.StateClearResponse")
	proto.RegisterType((*LogEntry)(nil), "org.apache.beam.fn.v1.LogEntry")
	proto.RegisterType((*LogEntry_List)(nil), "org.apache.beam.fn.v1.LogEntry.List")
	proto.RegisterType((*LogControl)(nil), "org.apache.beam.fn.v1.LogControl")
	proto.RegisterType((*ApiServiceDescriptor)(nil), "org.apache.beam.fn.v1.ApiServiceDescriptor")
	proto.RegisterType((*OAuth2ClientCredentialsGrant)(nil), "org.apache.beam.fn.v1.OAuth2ClientCredentialsGrant")
	proto.RegisterType((*DockerContainer)(nil), "org.apache.beam.fn.v1.DockerContainer")
	proto.RegisterEnum("org.apache.beam.fn.v1.LogEntry_Severity", LogEntry_Severity_name, LogEntry_Severity_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BeamFnControl service

type BeamFnControlClient interface {
	// Instructions sent by the runner to the SDK requesting different types
	// of work.
	Control(ctx context.Context, opts ...grpc.CallOption) (BeamFnControl_ControlClient, error)
}

type beamFnControlClient struct {
	cc *grpc.ClientConn
}

func NewBeamFnControlClient(cc *grpc.ClientConn) BeamFnControlClient {
	return &beamFnControlClient{cc}
}

func (c *beamFnControlClient) Control(ctx context.Context, opts ...grpc.CallOption) (BeamFnControl_ControlClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BeamFnControl_serviceDesc.Streams[0], c.cc, "/org.apache.beam.fn.v1.BeamFnControl/Control", opts...)
	if err != nil {
		return nil, err
	}
	x := &beamFnControlControlClient{stream}
	return x, nil
}

type BeamFnControl_ControlClient interface {
	Send(*InstructionResponse) error
	Recv() (*InstructionRequest, error)
	grpc.ClientStream
}

type beamFnControlControlClient struct {
	grpc.ClientStream
}

func (x *beamFnControlControlClient) Send(m *InstructionResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *beamFnControlControlClient) Recv() (*InstructionRequest, error) {
	m := new(InstructionRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for BeamFnControl service

type BeamFnControlServer interface {
	// Instructions sent by the runner to the SDK requesting different types
	// of work.
	Control(BeamFnControl_ControlServer) error
}

func RegisterBeamFnControlServer(s *grpc.Server, srv BeamFnControlServer) {
	s.RegisterService(&_BeamFnControl_serviceDesc, srv)
}

func _BeamFnControl_Control_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BeamFnControlServer).Control(&beamFnControlControlServer{stream})
}

type BeamFnControl_ControlServer interface {
	Send(*InstructionRequest) error
	Recv() (*InstructionResponse, error)
	grpc.ServerStream
}

type beamFnControlControlServer struct {
	grpc.ServerStream
}

func (x *beamFnControlControlServer) Send(m *InstructionRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *beamFnControlControlServer) Recv() (*InstructionResponse, error) {
	m := new(InstructionResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _BeamFnControl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.apache.beam.fn.v1.BeamFnControl",
	HandlerType: (*BeamFnControlServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Control",
			Handler:       _BeamFnControl_Control_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "beam_fn_api.proto",
}

// Client API for BeamFnData service

type BeamFnDataClient interface {
	// Used to send data between harnesses.
	Data(ctx context.Context, opts ...grpc.CallOption) (BeamFnData_DataClient, error)
}

type beamFnDataClient struct {
	cc *grpc.ClientConn
}

func NewBeamFnDataClient(cc *grpc.ClientConn) BeamFnDataClient {
	return &beamFnDataClient{cc}
}

func (c *beamFnDataClient) Data(ctx context.Context, opts ...grpc.CallOption) (BeamFnData_DataClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BeamFnData_serviceDesc.Streams[0], c.cc, "/org.apache.beam.fn.v1.BeamFnData/Data", opts...)
	if err != nil {
		return nil, err
	}
	x := &beamFnDataDataClient{stream}
	return x, nil
}

type BeamFnData_DataClient interface {
	Send(*Elements) error
	Recv() (*Elements, error)
	grpc.ClientStream
}

type beamFnDataDataClient struct {
	grpc.ClientStream
}

func (x *beamFnDataDataClient) Send(m *Elements) error {
	return x.ClientStream.SendMsg(m)
}

func (x *beamFnDataDataClient) Recv() (*Elements, error) {
	m := new(Elements)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for BeamFnData service

type BeamFnDataServer interface {
	// Used to send data between harnesses.
	Data(BeamFnData_DataServer) error
}

func RegisterBeamFnDataServer(s *grpc.Server, srv BeamFnDataServer) {
	s.RegisterService(&_BeamFnData_serviceDesc, srv)
}

func _BeamFnData_Data_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BeamFnDataServer).Data(&beamFnDataDataServer{stream})
}

type BeamFnData_DataServer interface {
	Send(*Elements) error
	Recv() (*Elements, error)
	grpc.ServerStream
}

type beamFnDataDataServer struct {
	grpc.ServerStream
}

func (x *beamFnDataDataServer) Send(m *Elements) error {
	return x.ServerStream.SendMsg(m)
}

func (x *beamFnDataDataServer) Recv() (*Elements, error) {
	m := new(Elements)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _BeamFnData_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.apache.beam.fn.v1.BeamFnData",
	HandlerType: (*BeamFnDataServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Data",
			Handler:       _BeamFnData_Data_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "beam_fn_api.proto",
}

// Client API for BeamFnState service

type BeamFnStateClient interface {
	// Used to get/append/clear state stored by the runner on behalf of the SDK.
	State(ctx context.Context, opts ...grpc.CallOption) (BeamFnState_StateClient, error)
}

type beamFnStateClient struct {
	cc *grpc.ClientConn
}

func NewBeamFnStateClient(cc *grpc.ClientConn) BeamFnStateClient {
	return &beamFnStateClient{cc}
}

func (c *beamFnStateClient) State(ctx context.Context, opts ...grpc.CallOption) (BeamFnState_StateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BeamFnState_serviceDesc.Streams[0], c.cc, "/org.apache.beam.fn.v1.BeamFnState/State", opts...)
	if err != nil {
		return nil, err
	}
	x := &beamFnStateStateClient{stream}
	return x, nil
}

type BeamFnState_StateClient interface {
	Send(*StateRequest) error
	Recv() (*StateResponse, error)
	grpc.ClientStream
}

type beamFnStateStateClient struct {
	grpc.ClientStream
}

func (x *beamFnStateStateClient) Send(m *StateRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *beamFnStateStateClient) Recv() (*StateResponse, error) {
	m := new(StateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for BeamFnState service

type BeamFnStateServer interface {
	// Used to get/append/clear state stored by the runner on behalf of the SDK.
	State(BeamFnState_StateServer) error
}

func RegisterBeamFnStateServer(s *grpc.Server, srv BeamFnStateServer) {
	s.RegisterService(&_BeamFnState_serviceDesc, srv)
}

func _BeamFnState_State_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BeamFnStateServer).State(&beamFnStateStateServer{stream})
}

type BeamFnState_StateServer interface {
	Send(*StateResponse) error
	Recv() (*StateRequest, error)
	grpc.ServerStream
}

type beamFnStateStateServer struct {
	grpc.ServerStream
}

func (x *beamFnStateStateServer) Send(m *StateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *beamFnStateStateServer) Recv() (*StateRequest, error) {
	m := new(StateRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _BeamFnState_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.apache.beam.fn.v1.BeamFnState",
	HandlerType: (*BeamFnStateServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "State",
			Handler:       _BeamFnState_State_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "beam_fn_api.proto",
}

// Client API for SimpleBeamFnState service

type SimpleBeamFnStateClient interface {
	// Gets the elements associated with the given key.
	Get(ctx context.Context, in *StateKey, opts ...grpc.CallOption) (*Elements_Data, error)
	// Appends elements to a given state bag.
	Append(ctx context.Context, in *SimpleStateAppendRequest, opts ...grpc.CallOption) (*Empty, error)
	// Clears a given state bag.
	Clear(ctx context.Context, in *StateKey, opts ...grpc.CallOption) (*Empty, error)
}

type simpleBeamFnStateClient struct {
	cc *grpc.ClientConn
}

func NewSimpleBeamFnStateClient(cc *grpc.ClientConn) SimpleBeamFnStateClient {
	return &simpleBeamFnStateClient{cc}
}

func (c *simpleBeamFnStateClient) Get(ctx context.Context, in *StateKey, opts ...grpc.CallOption) (*Elements_Data, error) {
	out := new(Elements_Data)
	err := grpc.Invoke(ctx, "/org.apache.beam.fn.v1.SimpleBeamFnState/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simpleBeamFnStateClient) Append(ctx context.Context, in *SimpleStateAppendRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/org.apache.beam.fn.v1.SimpleBeamFnState/Append", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simpleBeamFnStateClient) Clear(ctx context.Context, in *StateKey, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/org.apache.beam.fn.v1.SimpleBeamFnState/Clear", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SimpleBeamFnState service

type SimpleBeamFnStateServer interface {
	// Gets the elements associated with the given key.
	Get(context.Context, *StateKey) (*Elements_Data, error)
	// Appends elements to a given state bag.
	Append(context.Context, *SimpleStateAppendRequest) (*Empty, error)
	// Clears a given state bag.
	Clear(context.Context, *StateKey) (*Empty, error)
}

func RegisterSimpleBeamFnStateServer(s *grpc.Server, srv SimpleBeamFnStateServer) {
	s.RegisterService(&_SimpleBeamFnState_serviceDesc, srv)
}

func _SimpleBeamFnState_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimpleBeamFnStateServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.apache.beam.fn.v1.SimpleBeamFnState/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimpleBeamFnStateServer).Get(ctx, req.(*StateKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimpleBeamFnState_Append_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimpleStateAppendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimpleBeamFnStateServer).Append(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.apache.beam.fn.v1.SimpleBeamFnState/Append",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimpleBeamFnStateServer).Append(ctx, req.(*SimpleStateAppendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimpleBeamFnState_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimpleBeamFnStateServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.apache.beam.fn.v1.SimpleBeamFnState/Clear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimpleBeamFnStateServer).Clear(ctx, req.(*StateKey))
	}
	return interceptor(ctx, in, info, handler)
}

var _SimpleBeamFnState_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.apache.beam.fn.v1.SimpleBeamFnState",
	HandlerType: (*SimpleBeamFnStateServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _SimpleBeamFnState_Get_Handler,
		},
		{
			MethodName: "Append",
			Handler:    _SimpleBeamFnState_Append_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _SimpleBeamFnState_Clear_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "beam_fn_api.proto",
}

// Client API for BeamFnLogging service

type BeamFnLoggingClient interface {
	// Allows for the SDK to emit log entries which the runner can
	// associate with the active job.
	Logging(ctx context.Context, opts ...grpc.CallOption) (BeamFnLogging_LoggingClient, error)
}

type beamFnLoggingClient struct {
	cc *grpc.ClientConn
}

func NewBeamFnLoggingClient(cc *grpc.ClientConn) BeamFnLoggingClient {
	return &beamFnLoggingClient{cc}
}

func (c *beamFnLoggingClient) Logging(ctx context.Context, opts ...grpc.CallOption) (BeamFnLogging_LoggingClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BeamFnLogging_serviceDesc.Streams[0], c.cc, "/org.apache.beam.fn.v1.BeamFnLogging/Logging", opts...)
	if err != nil {
		return nil, err
	}
	x := &beamFnLoggingLoggingClient{stream}
	return x, nil
}

type BeamFnLogging_LoggingClient interface {
	Send(*LogEntry_List) error
	Recv() (*LogControl, error)
	grpc.ClientStream
}

type beamFnLoggingLoggingClient struct {
	grpc.ClientStream
}

func (x *beamFnLoggingLoggingClient) Send(m *LogEntry_List) error {
	return x.ClientStream.SendMsg(m)
}

func (x *beamFnLoggingLoggingClient) Recv() (*LogControl, error) {
	m := new(LogControl)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for BeamFnLogging service

type BeamFnLoggingServer interface {
	// Allows for the SDK to emit log entries which the runner can
	// associate with the active job.
	Logging(BeamFnLogging_LoggingServer) error
}

func RegisterBeamFnLoggingServer(s *grpc.Server, srv BeamFnLoggingServer) {
	s.RegisterService(&_BeamFnLogging_serviceDesc, srv)
}

func _BeamFnLogging_Logging_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BeamFnLoggingServer).Logging(&beamFnLoggingLoggingServer{stream})
}

type BeamFnLogging_LoggingServer interface {
	Send(*LogControl) error
	Recv() (*LogEntry_List, error)
	grpc.ServerStream
}

type beamFnLoggingLoggingServer struct {
	grpc.ServerStream
}

func (x *beamFnLoggingLoggingServer) Send(m *LogControl) error {
	return x.ServerStream.SendMsg(m)
}

func (x *beamFnLoggingLoggingServer) Recv() (*LogEntry_List, error) {
	m := new(LogEntry_List)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _BeamFnLogging_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.apache.beam.fn.v1.BeamFnLogging",
	HandlerType: (*BeamFnLoggingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Logging",
			Handler:       _BeamFnLogging_Logging_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "beam_fn_api.proto",
}

func init() { proto.RegisterFile("beam_fn_api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2184 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x59, 0xcb, 0x73, 0x1b, 0x49,
	0x19, 0xf7, 0xe8, 0xad, 0x4f, 0xb2, 0xad, 0x74, 0x94, 0x44, 0x56, 0xb2, 0xc4, 0x3b, 0xc9, 0x12,
	0x67, 0xd9, 0x55, 0x12, 0x67, 0x37, 0x95, 0x84, 0xf0, 0xb0, 0x64, 0x3b, 0x56, 0xc5, 0x6b, 0x9b,
	0xb1, 0x17, 0x92, 0x2d, 0x60, 0x6a, 0x3c, 0x6a, 0x29, 0xcd, 0x8e, 0x66, 0x86, 0x9e, 0x91, 0x5d,
	0xda, 0x02, 0xaa, 0xb8, 0x50, 0x1c, 0xa0, 0xa0, 0x8a, 0x03, 0x47, 0xae, 0x50, 0x14, 0x55, 0x1c,
	0xb8, 0xf1, 0x07, 0xc0, 0x85, 0xff, 0x83, 0xd7, 0x1f, 0x41, 0xf5, 0x63, 0x46, 0x23, 0x69, 0x46,
	0x52, 0x92, 0xa5, 0x6a, 0x6f, 0x3d, 0xdd, 0xdf, 0xab, 0xbf, 0xfe, 0xf5, 0xaf, 0xbf, 0xee, 0x81,
	0x0b, 0xa7, 0xd8, 0xe8, 0xeb, 0x5d, 0x5b, 0x37, 0x5c, 0xd2, 0x70, 0xa9, 0xe3, 0x3b, 0xe8, 0x92,
	0x43, 0x7b, 0x0d, 0xc3, 0x35, 0xcc, 0x97, 0xb8, 0xc1, 0x46, 0x1b, 0x5d, 0xbb, 0x71, 0x76, 0xaf,
	0xbe, 0xd6, 0x73, 0x9c, 0x9e, 0x85, 0xef, 0x70, 0xa1, 0xd3, 0x41, 0xf7, 0x8e, 0x61, 0x0f, 0x85,
	0x46, 0xfd, 0xfa, 0xe4, 0x90, 0x4f, 0xfa, 0xd8, 0xf3, 0x8d, 0xbe, 0x2b, 0x04, 0xd4, 0xdf, 0x29,
	0x90, 0x3b, 0x31, 0x68, 0x0f, 0xfb, 0xa8, 0x09, 0x6f, 0xb9, 0x94, 0xf4, 0x89, 0x4f, 0xce, 0xb0,
	0xee, 0x53, 0xc3, 0xf6, 0xba, 0x0e, 0xed, 0xeb, 0x14, 0x77, 0x31, 0xc5, 0xb6, 0x89, 0x6b, 0xca,
	0xba, 0xb2, 0x91, 0xd6, 0xae, 0x86, 0x42, 0x27, 0x81, 0x8c, 0x16, 0x88, 0x20, 0x04, 0x19, 0xdb,
	0xe8, 0xe3, 0x5a, 0x6a, 0x5d, 0xd9, 0x28, 0x6a, 0xbc, 0x5d, 0xff, 0x1a, 0x64, 0xf6, 0x89, 0xe7,
	0xa3, 0x0f, 0x21, 0xe7, 0x73, 0x4f, 0x35, 0x65, 0x3d, 0xbd, 0x51, 0xda, 0x7c, 0xab, 0x11, 0x3b,
	0x9d, 0x86, 0x08, 0x47, 0x93, 0xc2, 0xea, 0x03, 0x28, 0x1d, 0xb5, 0x1c, 0xcb, 0xc2, 0xa6, 0x4f,
	0x1c, 0x1b, 0xdd, 0x82, 0x55, 0xd3, 0xe9, 0x60, 0x3a, 0x15, 0xd7, 0x0a, 0xef, 0x0e, 0x43, 0x51,
	0x7f, 0x9f, 0x05, 0x74, 0x34, 0x15, 0x2a, 0x5a, 0x81, 0x14, 0xe9, 0x48, 0x95, 0x14, 0xe9, 0xa0,
	0x3d, 0x58, 0xee, 0x0e, 0x6c, 0x6e, 0x5b, 0xf7, 0x5c, 0x6c, 0xf2, 0xd0, 0x4b, 0x9b, 0x37, 0x12,
	0x82, 0xdb, 0x95, 0xb2, 0xc7, 0x2e, 0x36, 0xb5, 0x72, 0x37, 0xf2, 0x85, 0x3e, 0x82, 0x1c, 0xb1,
	0xdd, 0x81, 0xef, 0xd5, 0xd2, 0x7c, 0x7e, 0x1f, 0x26, 0x98, 0x98, 0x0e, 0xaa, 0xd1, 0xe6, 0x7a,
	0x3b, 0xb6, 0x4f, 0x87, 0x9a, 0x34, 0x82, 0x8e, 0x20, 0xef, 0x0c, 0x7c, 0x6e, 0x2f, 0xc3, 0xed,
	0x3d, 0x58, 0xdc, 0xde, 0xa1, 0x50, 0x14, 0x06, 0x03, 0x33, 0xe8, 0x13, 0x28, 0x79, 0xa4, 0x83,
	0x75, 0x19, 0x65, 0x96, 0x5b, 0x7d, 0xb4, 0xb8, 0xd5, 0x63, 0xd2, 0xc1, 0xd1, 0x48, 0xc1, 0x0b,
	0x3b, 0xd0, 0x55, 0x28, 0x7a, 0x3e, 0x76, 0x75, 0xbe, 0xfa, 0x39, 0xbe, 0xfa, 0x05, 0xd6, 0x71,
	0xc0, 0x10, 0xf0, 0x3d, 0x28, 0x45, 0xf4, 0x50, 0x05, 0xd2, 0x9f, 0xe2, 0x21, 0x5f, 0x83, 0xa2,
	0xc6, 0x9a, 0xe8, 0x21, 0x64, 0xcf, 0x0c, 0x6b, 0x80, 0x65, 0xf2, 0xd5, 0x99, 0xc8, 0x68, 0x30,
	0x34, 0x69, 0x42, 0xe1, 0x71, 0xea, 0xa1, 0x52, 0xff, 0x3e, 0x94, 0xa3, 0x13, 0x7e, 0x7d, 0xfb,
	0x11, 0x9c, 0x45, 0xed, 0xeb, 0xb0, 0x3a, 0x31, 0xf5, 0x18, 0x17, 0x0f, 0xc6, 0x5d, 0xac, 0x27,
	0xb8, 0x08, 0x0d, 0x45, 0x1c, 0xa8, 0xbf, 0x52, 0xa0, 0x1c, 0x05, 0xd6, 0x14, 0x48, 0x2b, 0x90,
	0x1e, 0x50, 0x5b, 0xee, 0x2a, 0xd6, 0x44, 0xf7, 0xe1, 0x12, 0xb6, 0xcf, 0x08, 0x75, 0xec, 0x3e,
	0xb6, 0xfd, 0xc8, 0x66, 0x48, 0x73, 0xa5, 0x6a, 0x64, 0x70, 0xb4, 0x3b, 0x37, 0x20, 0xd3, 0x31,
	0x7c, 0xa3, 0x96, 0xe1, 0x21, 0x56, 0x1b, 0x82, 0x1c, 0x1a, 0x01, 0x39, 0x34, 0xb6, 0xec, 0xa1,
	0xc6, 0x25, 0xd4, 0x9f, 0x40, 0x31, 0x8c, 0x14, 0xdd, 0x87, 0x2c, 0x87, 0x0c, 0x0f, 0x68, 0xee,
	0xbe, 0x15, 0xb2, 0xe8, 0x09, 0xe4, 0xcf, 0x08, 0x3e, 0xd7, 0xbb, 0xf6, 0xab, 0xec, 0xa8, 0x1c,
	0xd3, 0xd9, 0xb5, 0xd5, 0x5f, 0x2a, 0x90, 0x6d, 0xb1, 0xfd, 0x3c, 0xbd, 0x3f, 0x95, 0xd7, 0xdd,
	0x9f, 0x8f, 0x61, 0xcd, 0x74, 0xfa, 0xae, 0x63, 0xb3, 0x84, 0x4d, 0x72, 0x48, 0x6a, 0x3d, 0xbd,
	0x91, 0xd6, 0xae, 0x84, 0x02, 0xad, 0x71, 0x32, 0xf1, 0x60, 0x45, 0xc3, 0x7d, 0xc7, 0xc7, 0x4f,
	0xa9, 0x6b, 0x1e, 0x39, 0xd4, 0x47, 0x06, 0x5c, 0x36, 0x5c, 0xa2, 0x7b, 0x98, 0x9e, 0x11, 0x13,
	0xeb, 0x1d, 0xec, 0x99, 0x94, 0xb8, 0xbe, 0x43, 0x65, 0x80, 0x5f, 0x49, 0x08, 0x70, 0xcb, 0x25,
	0xc7, 0x42, 0x67, 0x3b, 0x54, 0xd1, 0xaa, 0x46, 0x4c, 0xaf, 0xfa, 0x8b, 0x0c, 0xa0, 0xb6, 0xed,
	0xf9, 0x74, 0x20, 0x20, 0x89, 0x7f, 0x38, 0xc0, 0x9e, 0x8f, 0xde, 0x81, 0x15, 0x32, 0xea, 0xd5,
	0x43, 0xa0, 0x2c, 0x47, 0x7a, 0xdb, 0x1d, 0xb4, 0x03, 0x05, 0x8a, 0x7b, 0xc4, 0xf3, 0x31, 0xad,
	0xfd, 0x33, 0xcf, 0x63, 0xfa, 0x72, 0x42, 0x4c, 0x9a, 0x94, 0x93, 0x1e, 0xf6, 0x96, 0xb4, 0x50,
	0x15, 0x7d, 0x0c, 0x2b, 0x2e, 0x75, 0x4c, 0xec, 0x79, 0xfa, 0xe9, 0xc0, 0xee, 0x58, 0xb8, 0xf6,
	0xaf, 0xfc, 0xcc, 0x09, 0x1e, 0x09, 0xe9, 0x26, 0x17, 0x1e, 0x59, 0x5c, 0x76, 0xa3, 0xfd, 0x08,
	0x43, 0x95, 0xd8, 0xc4, 0x27, 0x86, 0xa5, 0x7b, 0xce, 0x80, 0x9a, 0x58, 0xf7, 0x5c, 0x8b, 0xf8,
	0xb5, 0x7f, 0x0b, 0xe3, 0x77, 0x13, 0x8c, 0xb7, 0x85, 0xce, 0x31, 0x57, 0x39, 0x66, 0x1a, 0x23,
	0x0f, 0x88, 0x4c, 0x0d, 0x32, 0x37, 0x9d, 0xa1, 0x6d, 0xf4, 0x89, 0x39, 0xee, 0xe6, 0x3f, 0xb3,
	0xdd, 0x6c, 0x0b, 0x9d, 0x78, 0x37, 0x9d, 0xa9, 0x41, 0xf4, 0x1c, 0x56, 0xa5, 0x79, 0x97, 0x3a,
	0x3d, 0x8a, 0x3d, 0xaf, 0xf6, 0x5f, 0xe1, 0xe1, 0xbd, 0x24, 0x1e, 0xe0, 0xe2, 0x47, 0x52, 0x7a,
	0x64, 0x7d, 0xc5, 0x1b, 0x1b, 0x68, 0x16, 0x21, 0x4f, 0xc5, 0xa0, 0xfa, 0x87, 0x0c, 0x5c, 0x1c,
	0x83, 0x83, 0xe7, 0x3a, 0xb6, 0x87, 0x17, 0xc5, 0x43, 0x15, 0xb2, 0x98, 0x52, 0x87, 0x4a, 0x16,
	0x11, 0x1f, 0x68, 0x77, 0x1a, 0x25, 0xb7, 0xe6, 0xa2, 0x44, 0x38, 0x1e, 0x83, 0xc9, 0xb7, 0x93,
	0x60, 0xf2, 0xde, 0x62, 0x30, 0x09, 0x4d, 0x4e, 0xe0, 0xa4, 0x3b, 0x1b, 0x27, 0xf7, 0x5e, 0x01,
	0x27, 0xa1, 0x8b, 0x38, 0xa0, 0x74, 0x67, 0x03, 0xe5, 0xde, 0x2b, 0x00, 0x65, 0xe4, 0x27, 0x06,
	0x29, 0x2f, 0x12, 0x91, 0xf2, 0xfe, 0x82, 0x48, 0x09, 0xcd, 0x4f, 0x42, 0x05, 0xd8, 0x52, 0x8a,
	0x51, 0xf5, 0xc7, 0xb0, 0x3a, 0xb1, 0xa9, 0xd1, 0x0f, 0x60, 0x6d, 0x7c, 0x85, 0xc6, 0x39, 0x8b,
	0xd5, 0x02, 0x8d, 0x45, 0xd6, 0x2a, 0x42, 0x5b, 0x57, 0xdc, 0xf8, 0x01, 0x15, 0x41, 0x65, 0x12,
	0x2d, 0xea, 0x5f, 0x15, 0xb8, 0x92, 0x60, 0x68, 0xea, 0xbc, 0xfb, 0x04, 0x2e, 0xc6, 0x94, 0xa2,
	0x9c, 0xa4, 0x4b, 0x9b, 0xb7, 0x17, 0xae, 0x58, 0x34, 0x34, 0x5d, 0xab, 0xa2, 0x0f, 0x20, 0xc7,
	0xc9, 0x3f, 0x28, 0xab, 0xae, 0x25, 0x98, 0x13, 0x27, 0x80, 0x94, 0x55, 0xff, 0xa8, 0x40, 0x35,
	0x8e, 0xd9, 0xd0, 0x47, 0x70, 0x23, 0x31, 0xad, 0x53, 0x35, 0xea, 0x7a, 0x42, 0xc2, 0x46, 0x47,
	0xf4, 0x36, 0x2c, 0x13, 0xdb, 0x22, 0x76, 0x58, 0xa5, 0x89, 0xc3, 0xf3, 0x7a, 0x42, 0x90, 0x3b,
	0x16, 0x66, 0x47, 0xbc, 0xa7, 0x95, 0x85, 0x96, 0xa8, 0x51, 0x54, 0x1d, 0x2e, 0xc5, 0xee, 0x2f,
	0xb4, 0xcb, 0xb8, 0x82, 0x9b, 0x0f, 0x6a, 0x4b, 0x65, 0x31, 0xfb, 0x32, 0x2a, 0x59, 0x67, 0xa9,
	0x3f, 0x55, 0x60, 0x2d, 0x91, 0x8b, 0xd1, 0x6d, 0xa8, 0x48, 0x90, 0x4f, 0x26, 0x40, 0x82, 0x7f,
	0x34, 0xdf, 0x47, 0xb0, 0xd6, 0xc1, 0x1e, 0xa1, 0xb8, 0x13, 0xa4, 0xcf, 0x23, 0x9f, 0x61, 0xfd,
	0x74, 0xe8, 0x63, 0x31, 0xf7, 0xb4, 0x76, 0x59, 0x0a, 0x88, 0xa9, 0x1c, 0x93, 0xcf, 0x70, 0x93,
	0x8d, 0xaa, 0x0e, 0x94, 0xa2, 0x3b, 0xeb, 0xab, 0x90, 0x13, 0xc6, 0x5f, 0xa5, 0x42, 0x90, 0x2a,
	0xe8, 0x06, 0x2c, 0x53, 0x6c, 0x19, 0x1c, 0x6f, 0x2c, 0x00, 0xee, 0x5a, 0xd1, 0xca, 0x41, 0x27,
	0xf3, 0xaa, 0x3e, 0x87, 0x7a, 0x32, 0xaf, 0xa0, 0xc7, 0x90, 0xe3, 0x94, 0xe1, 0xc9, 0xcd, 0xa4,
	0xce, 0xdc, 0xcf, 0x42, 0x57, 0x6a, 0xa8, 0xbf, 0x55, 0x60, 0x2d, 0xf1, 0xcc, 0x61, 0xb5, 0x5e,
	0x94, 0xe0, 0x27, 0x73, 0x5a, 0x25, 0xd1, 0x43, 0x21, 0x48, 0x6c, 0xdc, 0x1a, 0xa4, 0xe2, 0xd7,
	0xa0, 0x0e, 0x05, 0xd7, 0xf1, 0x08, 0xd3, 0xe7, 0xe5, 0x63, 0x4a, 0x0b, 0xbf, 0xd5, 0xbf, 0x28,
	0x50, 0x4f, 0x26, 0x39, 0xd4, 0x66, 0xb4, 0x4f, 0xfa, 0x06, 0x1d, 0xea, 0x63, 0xc9, 0x5f, 0x64,
	0xf2, 0xcb, 0x52, 0x53, 0xf4, 0xa1, 0x67, 0xb0, 0x4a, 0xb1, 0x47, 0x3a, 0x83, 0x90, 0xea, 0xe7,
	0x54, 0xeb, 0x51, 0x5b, 0x2b, 0x81, 0xaa, 0xe8, 0x54, 0xcf, 0xe1, 0x52, 0xec, 0x09, 0xfb, 0xff,
	0xce, 0xa5, 0xfa, 0x01, 0x5c, 0x8e, 0x27, 0xec, 0xb1, 0x2c, 0x2b, 0x13, 0x59, 0xfe, 0x87, 0x02,
	0x85, 0x60, 0xab, 0xa1, 0x87, 0xb2, 0x4a, 0x17, 0x30, 0xba, 0x39, 0x67, 0x67, 0x36, 0xb6, 0x0d,
	0xdf, 0x10, 0x55, 0x7b, 0xfd, 0x67, 0x0a, 0x64, 0xd8, 0xe7, 0xeb, 0xcd, 0x72, 0x74, 0x3f, 0x4f,
	0x2d, 0x52, 0xe7, 0x4b, 0x61, 0x76, 0xe5, 0xe7, 0xe1, 0x32, 0xe4, 0x94, 0xe5, 0xf5, 0xe1, 0xd7,
	0x29, 0x28, 0x1f, 0xfb, 0x86, 0x1f, 0xb2, 0xe4, 0x24, 0xc1, 0x27, 0x06, 0x98, 0x9a, 0x11, 0xe0,
	0x43, 0x48, 0xb3, 0xe8, 0xc4, 0xed, 0x3a, 0xa9, 0x96, 0xe5, 0x6e, 0x9f, 0xe2, 0x60, 0xf3, 0x68,
	0x4c, 0x05, 0x6d, 0x41, 0xce, 0x70, 0x5d, 0x6c, 0x77, 0x24, 0xe7, 0xdf, 0x9e, 0xa5, 0xbc, 0xc5,
	0x25, 0x03, 0x7d, 0xa9, 0x88, 0xbe, 0x0e, 0x59, 0xd3, 0xc2, 0x06, 0x95, 0xd7, 0xe6, 0x8d, 0x59,
	0x16, 0x5a, 0x4c, 0x30, 0x30, 0x20, 0xd4, 0xd4, 0xbf, 0xa5, 0x60, 0x59, 0xa6, 0x44, 0x02, 0xe2,
	0x73, 0xc9, 0xc9, 0x55, 0x28, 0x9a, 0x2c, 0x06, 0x9d, 0x5d, 0x47, 0xc5, 0x12, 0x14, 0x78, 0xc7,
	0x33, 0x3c, 0x1c, 0x95, 0x7c, 0x99, 0x68, 0xc9, 0xf7, 0x48, 0xa4, 0x51, 0xcc, 0xe3, 0xd6, 0xdc,
	0x34, 0x8a, 0x68, 0x45, 0x1e, 0x9b, 0x61, 0x1e, 0x73, 0x5c, 0xfb, 0xdd, 0x45, 0xf2, 0x28, 0x0d,
	0x04, 0x89, 0xfc, 0x46, 0x90, 0xc8, 0xfc, 0xfc, 0xa5, 0x90, 0x89, 0x94, 0x16, 0x64, 0x26, 0xf3,
	0x90, 0xdd, 0xe9, 0xbb, 0xfe, 0x50, 0xb5, 0xa0, 0x76, 0x4c, 0xfa, 0xae, 0x85, 0xa7, 0x97, 0x0d,
	0x3d, 0x81, 0xa2, 0xc7, 0x7a, 0xf5, 0xe0, 0x9a, 0x9e, 0x7c, 0xc6, 0x71, 0xed, 0x67, 0x78, 0xa8,
	0x15, 0x3c, 0xd9, 0x0a, 0x31, 0xcd, 0x0a, 0x8e, 0x00, 0xd3, 0x16, 0x14, 0x02, 0x49, 0xf4, 0x00,
	0xae, 0x8c, 0x5d, 0x4a, 0xa7, 0x76, 0xd8, 0xa5, 0xe8, 0xcd, 0x73, 0xb4, 0x5a, 0x97, 0x21, 0x77,
	0x4e, 0xec, 0x8e, 0x73, 0xce, 0xd7, 0xb4, 0xac, 0xc9, 0xaf, 0xe0, 0x39, 0x41, 0xac, 0x1f, 0x6b,
	0xaa, 0x36, 0xa0, 0xc0, 0xdb, 0x21, 0x6d, 0xfb, 0x98, 0x1a, 0xa7, 0x16, 0x7e, 0xc3, 0x59, 0xd5,
	0xa1, 0x40, 0xa4, 0x25, 0x39, 0xb3, 0xf0, 0x5b, 0x3d, 0x84, 0xd5, 0x89, 0x9d, 0xf3, 0x66, 0xce,
	0xd4, 0x3f, 0x29, 0x50, 0x99, 0x04, 0xd1, 0x1b, 0xc6, 0xaf, 0x41, 0x85, 0xf2, 0x4b, 0xb8, 0xde,
	0xa3, 0xae, 0xa9, 0xbb, 0x0e, 0xf5, 0x83, 0x3b, 0xcb, 0x3b, 0x89, 0x77, 0x96, 0xe8, 0xa5, 0x9d,
	0x15, 0xcd, 0x74, 0xac, 0xa7, 0x99, 0x87, 0x2c, 0xb7, 0xaf, 0x6a, 0x32, 0xe1, 0x9f, 0x23, 0x8c,
	0xd4, 0x3f, 0x2b, 0x70, 0x31, 0x66, 0x2b, 0x7c, 0x91, 0xd3, 0xf0, 0x2d, 0xb8, 0x30, 0x45, 0x61,
	0x6f, 0x98, 0x85, 0xaa, 0xcc, 0xec, 0xd8, 0x66, 0x56, 0x7f, 0x93, 0x81, 0xc2, 0xbe, 0xd3, 0x13,
	0xcf, 0x69, 0xdb, 0x50, 0xf0, 0xf0, 0x19, 0xa6, 0xc4, 0x17, 0xf6, 0x57, 0x12, 0xf9, 0x35, 0x50,
	0x69, 0x1c, 0x4b, 0x79, 0x2d, 0xd4, 0x44, 0x0f, 0xa1, 0x18, 0x3e, 0x6f, 0xcb, 0x33, 0xac, 0x3e,
	0xf5, 0xc6, 0x75, 0x12, 0x48, 0x68, 0x23, 0x61, 0x54, 0x83, 0x7c, 0x1f, 0x7b, 0x9e, 0xd1, 0x13,
	0xef, 0x67, 0x45, 0x2d, 0xf8, 0x64, 0x14, 0xea, 0x53, 0xc3, 0xc4, 0x01, 0x85, 0xf2, 0x8f, 0x64,
	0xaa, 0xce, 0xce, 0xa0, 0xea, 0xb9, 0xef, 0xeb, 0xb9, 0xf9, 0xef, 0xeb, 0x6f, 0x43, 0xd9, 0x72,
	0x7a, 0xba, 0xe5, 0x98, 0x06, 0x2f, 0x24, 0xf2, 0x3c, 0xaa, 0x92, 0xe5, 0xf4, 0xf6, 0x65, 0x17,
	0xe3, 0x18, 0xff, 0x25, 0xc5, 0x46, 0xa7, 0x56, 0xe0, 0x83, 0xf2, 0xab, 0xbe, 0x27, 0x9f, 0xe1,
	0xbf, 0x09, 0x4c, 0x5c, 0xc7, 0xb6, 0x4f, 0x09, 0x0e, 0x8a, 0xd5, 0xeb, 0x73, 0xd2, 0xad, 0x81,
	0x25, 0x5a, 0x04, 0x7b, 0xea, 0x0b, 0x28, 0x04, 0xd9, 0x47, 0x45, 0xc8, 0x9e, 0x68, 0x5b, 0xad,
	0x9d, 0xca, 0x12, 0x6b, 0x6e, 0xef, 0x34, 0x3f, 0x7e, 0x5a, 0x01, 0x54, 0x80, 0x4c, 0xfb, 0x60,
	0xf7, 0xb0, 0x52, 0x45, 0x00, 0xb9, 0x83, 0xc3, 0x93, 0x76, 0x6b, 0xa7, 0xf2, 0x25, 0xd6, 0xfb,
	0x9d, 0x2d, 0xed, 0xa0, 0xb2, 0xc1, 0x44, 0x77, 0x34, 0xed, 0x50, 0xab, 0x6c, 0xa2, 0x32, 0x14,
	0x5a, 0x5a, 0xfb, 0xa4, 0xdd, 0xda, 0xda, 0xaf, 0x3c, 0x51, 0xcb, 0x00, 0xfb, 0x4e, 0xaf, 0xe5,
	0xd8, 0x3e, 0x75, 0x2c, 0xf5, 0xef, 0x0a, 0x54, 0xe3, 0xde, 0xcb, 0xe2, 0xdf, 0x47, 0xad, 0xd1,
	0xfb, 0xa8, 0x85, 0x7e, 0x04, 0xd7, 0x1d, 0x63, 0xe0, 0xbf, 0xdc, 0xd4, 0x4d, 0x8b, 0xf0, 0x07,
	0x3f, 0x8a, 0x3b, 0xd8, 0x66, 0xc5, 0xbb, 0xa7, 0xf7, 0xa8, 0x61, 0xfb, 0x7c, 0xa5, 0x4b, 0x9b,
	0xf7, 0x13, 0x66, 0x7e, 0xb8, 0xc5, 0xb4, 0x5b, 0x5c, 0xb9, 0x35, 0xd2, 0x7d, 0xca, 0x54, 0xf7,
	0x96, 0xb4, 0x6b, 0xc2, 0x7a, 0xfc, 0x78, 0xb3, 0x02, 0x2b, 0x6c, 0x98, 0xf5, 0x89, 0x55, 0x51,
	0xef, 0xc2, 0xb5, 0x59, 0x16, 0x83, 0x19, 0x28, 0xe1, 0x0c, 0xd4, 0x53, 0x58, 0xdd, 0x76, 0xcc,
	0x4f, 0x31, 0x65, 0xd9, 0x30, 0x88, 0x8d, 0x13, 0xa6, 0x4d, 0x46, 0xd3, 0x26, 0xe8, 0x7d, 0x40,
	0xe2, 0x49, 0x86, 0x0e, 0xa7, 0xde, 0x84, 0x2f, 0x04, 0x23, 0x21, 0x9c, 0x36, 0xcf, 0x61, 0xb9,
	0x89, 0x8d, 0xfe, 0xae, 0x2d, 0x33, 0x8e, 0xba, 0x90, 0x0f, 0x9a, 0xef, 0x26, 0x3e, 0xad, 0x4c,
	0x3d, 0x41, 0xd5, 0x6f, 0x2f, 0x22, 0x2b, 0x5e, 0xb1, 0x96, 0x36, 0x94, 0xbb, 0xca, 0xe6, 0x77,
	0x01, 0x84, 0x63, 0x5e, 0xae, 0x1e, 0xc8, 0xb2, 0x75, 0xde, 0x2d, 0xb4, 0x3e, 0x4f, 0x40, 0x5a,
	0xef, 0x41, 0x49, 0x58, 0xe7, 0xbc, 0x83, 0x9e, 0x43, 0x56, 0x34, 0x6e, 0xcc, 0x22, 0x2d, 0x19,
	0x60, 0xfd, 0xe6, 0x6c, 0x21, 0x49, 0x5f, 0xc2, 0xd1, 0xcf, 0x53, 0x70, 0x41, 0x94, 0x20, 0x51,
	0x7f, 0x07, 0x90, 0x7e, 0x8a, 0x7d, 0x34, 0x8f, 0x22, 0xeb, 0x0b, 0x95, 0xf6, 0xea, 0x12, 0x7a,
	0x01, 0x39, 0x71, 0x80, 0xa0, 0x3b, 0x89, 0x7f, 0x15, 0xe2, 0xcb, 0xa0, 0x7a, 0xd2, 0xe3, 0x86,
	0x28, 0xa0, 0x96, 0xd0, 0x1e, 0x64, 0x39, 0x2d, 0xcf, 0x0f, 0x76, 0x8e, 0xa5, 0x4d, 0x12, 0x40,
	0x69, 0xdf, 0xe9, 0xf5, 0x88, 0xdd, 0x43, 0xcf, 0x21, 0x1f, 0x34, 0x6f, 0xce, 0x23, 0x73, 0x46,
	0x4c, 0xf5, 0xb7, 0x93, 0xa5, 0x02, 0x42, 0xe0, 0x59, 0x6f, 0xaa, 0x10, 0xff, 0x23, 0xb4, 0x59,
	0x14, 0x11, 0x6c, 0xb9, 0xe4, 0x34, 0xc7, 0x09, 0xff, 0xfe, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x29, 0x46, 0x86, 0xba, 0x46, 0x1d, 0x00, 0x00,
}
