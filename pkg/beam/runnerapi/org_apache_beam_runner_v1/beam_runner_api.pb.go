// Code generated by protoc-gen-go. DO NOT EDIT.
// source: beam_runner_api.proto

/*
Package org_apache_beam_runner_api_v1 is a generated protocol buffer package.

It is generated from these files:
	beam_runner_api.proto

It has these top-level messages:
	Components
	MessageWithComponents
	Pipeline
	PTransform
	PCollection
	ParDoPayload
	Parameter
	StateSpec
	ValueStateSpec
	BagStateSpec
	CombiningStateSpec
	MapStateSpec
	SetStateSpec
	TimerSpec
	ReadPayload
	WindowIntoPayload
	CombinePayload
	TestStreamPayload
	WriteFilesPayload
	Coder
	WindowingStrategy
	Trigger
	TimestampTransform
	SideInput
	Environment
	SdkFunctionSpec
	FunctionSpec
	DisplayData
*/
package org_apache_beam_runner_api_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type IsBounded int32

const (
	IsBounded_BOUNDED   IsBounded = 0
	IsBounded_UNBOUNDED IsBounded = 1
)

var IsBounded_name = map[int32]string{
	0: "BOUNDED",
	1: "UNBOUNDED",
}
var IsBounded_value = map[string]int32{
	"BOUNDED":   0,
	"UNBOUNDED": 1,
}

func (x IsBounded) String() string {
	return proto.EnumName(IsBounded_name, int32(x))
}
func (IsBounded) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Whether or not a PCollection's WindowFn is non-merging, merging, or
// merging-but-already-merged, in which case a subsequent GroupByKey is almost
// always going to do something the user does not want
type MergeStatus int32

const (
	// The WindowFn does not require merging.
	// Examples: global window, FixedWindows, SlidingWindows
	MergeStatus_NON_MERGING MergeStatus = 0
	// The WindowFn is merging and the PCollection has not had merging
	// performed.
	// Example: Sessions prior to a GroupByKey
	MergeStatus_NEEDS_MERGE MergeStatus = 1
	// The WindowFn is merging and the PCollection has had merging occur
	// already.
	// Example: Sessions after a GroupByKey
	MergeStatus_ALREADY_MERGED MergeStatus = 2
)

var MergeStatus_name = map[int32]string{
	0: "NON_MERGING",
	1: "NEEDS_MERGE",
	2: "ALREADY_MERGED",
}
var MergeStatus_value = map[string]int32{
	"NON_MERGING":    0,
	"NEEDS_MERGE":    1,
	"ALREADY_MERGED": 2,
}

func (x MergeStatus) String() string {
	return proto.EnumName(MergeStatus_name, int32(x))
}
func (MergeStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Whether or not subsequent outputs of aggregations should be entire
// replacement values or just the aggregation of inputs received since
// the prior output.
type AccumulationMode int32

const (
	// The aggregation is discarded when it is output
	AccumulationMode_DISCARDING AccumulationMode = 0
	// The aggregation is accumulated across outputs
	AccumulationMode_ACCUMULATING AccumulationMode = 1
)

var AccumulationMode_name = map[int32]string{
	0: "DISCARDING",
	1: "ACCUMULATING",
}
var AccumulationMode_value = map[string]int32{
	"DISCARDING":   0,
	"ACCUMULATING": 1,
}

func (x AccumulationMode) String() string {
	return proto.EnumName(AccumulationMode_name, int32(x))
}
func (AccumulationMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Controls whether or not an aggregating transform should output data
// when a window expires.
type ClosingBehavior int32

const (
	// Emit output when a window expires, whether or not there has been
	// any new data since the last output.
	ClosingBehavior_EMIT_ALWAYS ClosingBehavior = 0
	// Only emit output when new data has arrives since the last output
	ClosingBehavior_EMIT_IF_NONEMPTY ClosingBehavior = 1
)

var ClosingBehavior_name = map[int32]string{
	0: "EMIT_ALWAYS",
	1: "EMIT_IF_NONEMPTY",
}
var ClosingBehavior_value = map[string]int32{
	"EMIT_ALWAYS":      0,
	"EMIT_IF_NONEMPTY": 1,
}

func (x ClosingBehavior) String() string {
	return proto.EnumName(ClosingBehavior_name, int32(x))
}
func (ClosingBehavior) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// When a number of windowed, timestamped inputs are aggregated, the timestamp
// for the resulting output.
type OutputTime int32

const (
	// The output has the timestamp of the end of the window.
	OutputTime_END_OF_WINDOW OutputTime = 0
	// The output has the latest timestamp of the input elements since
	// the last output.
	OutputTime_LATEST_IN_PANE OutputTime = 1
	// The output has the earliest timestamp of the input elements since
	// the last output.
	OutputTime_EARLIEST_IN_PANE OutputTime = 2
)

var OutputTime_name = map[int32]string{
	0: "END_OF_WINDOW",
	1: "LATEST_IN_PANE",
	2: "EARLIEST_IN_PANE",
}
var OutputTime_value = map[string]int32{
	"END_OF_WINDOW":    0,
	"LATEST_IN_PANE":   1,
	"EARLIEST_IN_PANE": 2,
}

func (x OutputTime) String() string {
	return proto.EnumName(OutputTime_name, int32(x))
}
func (OutputTime) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// The different time domains in the Beam model.
type TimeDomain int32

const (
	// Event time is time from the perspective of the data
	TimeDomain_EVENT_TIME TimeDomain = 0
	// Processing time is time from the perspective of the
	// execution of your pipeline
	TimeDomain_PROCESSING_TIME TimeDomain = 1
	// Synchronized processing time is the minimum of the
	// processing time of all pending elements.
	//
	// The "processing time" of an element refers to
	// the local processing time at which it was emitted
	TimeDomain_SYNCHRONIZED_PROCESSING_TIME TimeDomain = 2
)

var TimeDomain_name = map[int32]string{
	0: "EVENT_TIME",
	1: "PROCESSING_TIME",
	2: "SYNCHRONIZED_PROCESSING_TIME",
}
var TimeDomain_value = map[string]int32{
	"EVENT_TIME":                   0,
	"PROCESSING_TIME":              1,
	"SYNCHRONIZED_PROCESSING_TIME": 2,
}

func (x TimeDomain) String() string {
	return proto.EnumName(TimeDomain_name, int32(x))
}
func (TimeDomain) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type Parameter_Type int32

const (
	Parameter_WINDOW              Parameter_Type = 0
	Parameter_PIPELINE_OPTIONS    Parameter_Type = 1
	Parameter_RESTRICTION_TRACKER Parameter_Type = 2
)

var Parameter_Type_name = map[int32]string{
	0: "WINDOW",
	1: "PIPELINE_OPTIONS",
	2: "RESTRICTION_TRACKER",
}
var Parameter_Type_value = map[string]int32{
	"WINDOW":              0,
	"PIPELINE_OPTIONS":    1,
	"RESTRICTION_TRACKER": 2,
}

func (x Parameter_Type) String() string {
	return proto.EnumName(Parameter_Type_name, int32(x))
}
func (Parameter_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

type DisplayData_Type int32

const (
	DisplayData_STRING     DisplayData_Type = 0
	DisplayData_INTEGER    DisplayData_Type = 1
	DisplayData_FLOAT      DisplayData_Type = 2
	DisplayData_BOOLEAN    DisplayData_Type = 3
	DisplayData_TIMESTAMP  DisplayData_Type = 4
	DisplayData_DURATION   DisplayData_Type = 5
	DisplayData_JAVA_CLASS DisplayData_Type = 6
)

var DisplayData_Type_name = map[int32]string{
	0: "STRING",
	1: "INTEGER",
	2: "FLOAT",
	3: "BOOLEAN",
	4: "TIMESTAMP",
	5: "DURATION",
	6: "JAVA_CLASS",
}
var DisplayData_Type_value = map[string]int32{
	"STRING":     0,
	"INTEGER":    1,
	"FLOAT":      2,
	"BOOLEAN":    3,
	"TIMESTAMP":  4,
	"DURATION":   5,
	"JAVA_CLASS": 6,
}

func (x DisplayData_Type) String() string {
	return proto.EnumName(DisplayData_Type_name, int32(x))
}
func (DisplayData_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{27, 0} }

// A set of mappings from id to message. This is included as an optional field
// on any proto message that may contain references needing resolution.
type Components struct {
	// (Required) A map from pipeline-scoped id to PTransform.
	Transforms map[string]*PTransform `protobuf:"bytes,1,rep,name=transforms" json:"transforms,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// (Required) A map from pipeline-scoped id to PCollection.
	Pcollections map[string]*PCollection `protobuf:"bytes,2,rep,name=pcollections" json:"pcollections,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// (Required) A map from pipeline-scoped id to WindowingStrategy.
	WindowingStrategies map[string]*WindowingStrategy `protobuf:"bytes,3,rep,name=windowing_strategies" json:"windowing_strategies,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// (Required) A map from pipeline-scoped id to Coder.
	Coders map[string]*Coder `protobuf:"bytes,4,rep,name=coders" json:"coders,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// (Required) A map from pipeline-scoped id to Environment.
	Environments map[string]*Environment `protobuf:"bytes,5,rep,name=environments" json:"environments,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Components) Reset()                    { *m = Components{} }
func (m *Components) String() string            { return proto.CompactTextString(m) }
func (*Components) ProtoMessage()               {}
func (*Components) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Components) GetTransforms() map[string]*PTransform {
	if m != nil {
		return m.Transforms
	}
	return nil
}

func (m *Components) GetPcollections() map[string]*PCollection {
	if m != nil {
		return m.Pcollections
	}
	return nil
}

func (m *Components) GetWindowingStrategies() map[string]*WindowingStrategy {
	if m != nil {
		return m.WindowingStrategies
	}
	return nil
}

func (m *Components) GetCoders() map[string]*Coder {
	if m != nil {
		return m.Coders
	}
	return nil
}

func (m *Components) GetEnvironments() map[string]*Environment {
	if m != nil {
		return m.Environments
	}
	return nil
}

// A disjoint union of all the things that may contain references
// that require Components to resolve.
type MessageWithComponents struct {
	// (Optional) The by-reference components of the root message,
	// enabling a standalone message.
	//
	// If this is absent, it is expected that there are no
	// references.
	Components *Components `protobuf:"bytes,1,opt,name=components" json:"components,omitempty"`
	// (Required) The root message that may contain pointers
	// that should be resolved by looking inside components.
	//
	// Types that are valid to be assigned to Root:
	//	*MessageWithComponents_Coder
	//	*MessageWithComponents_CombinePayload
	//	*MessageWithComponents_SdkFunctionSpec
	//	*MessageWithComponents_ParDoPayload
	//	*MessageWithComponents_Ptransform
	//	*MessageWithComponents_Pcollection
	//	*MessageWithComponents_ReadPayload
	//	*MessageWithComponents_SideInput
	//	*MessageWithComponents_WindowIntoPayload
	//	*MessageWithComponents_WindowingStrategy
	//	*MessageWithComponents_FunctionSpec
	Root isMessageWithComponents_Root `protobuf_oneof:"root"`
}

func (m *MessageWithComponents) Reset()                    { *m = MessageWithComponents{} }
func (m *MessageWithComponents) String() string            { return proto.CompactTextString(m) }
func (*MessageWithComponents) ProtoMessage()               {}
func (*MessageWithComponents) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isMessageWithComponents_Root interface {
	isMessageWithComponents_Root()
}

type MessageWithComponents_Coder struct {
	Coder *Coder `protobuf:"bytes,2,opt,name=coder,oneof"`
}
type MessageWithComponents_CombinePayload struct {
	CombinePayload *CombinePayload `protobuf:"bytes,3,opt,name=combine_payload,oneof"`
}
type MessageWithComponents_SdkFunctionSpec struct {
	SdkFunctionSpec *SdkFunctionSpec `protobuf:"bytes,4,opt,name=sdk_function_spec,oneof"`
}
type MessageWithComponents_ParDoPayload struct {
	ParDoPayload *ParDoPayload `protobuf:"bytes,6,opt,name=par_do_payload,oneof"`
}
type MessageWithComponents_Ptransform struct {
	Ptransform *PTransform `protobuf:"bytes,7,opt,name=ptransform,oneof"`
}
type MessageWithComponents_Pcollection struct {
	Pcollection *PCollection `protobuf:"bytes,8,opt,name=pcollection,oneof"`
}
type MessageWithComponents_ReadPayload struct {
	ReadPayload *ReadPayload `protobuf:"bytes,9,opt,name=read_payload,oneof"`
}
type MessageWithComponents_SideInput struct {
	SideInput *SideInput `protobuf:"bytes,11,opt,name=side_input,oneof"`
}
type MessageWithComponents_WindowIntoPayload struct {
	WindowIntoPayload *WindowIntoPayload `protobuf:"bytes,12,opt,name=window_into_payload,oneof"`
}
type MessageWithComponents_WindowingStrategy struct {
	WindowingStrategy *WindowingStrategy `protobuf:"bytes,13,opt,name=windowing_strategy,oneof"`
}
type MessageWithComponents_FunctionSpec struct {
	FunctionSpec *FunctionSpec `protobuf:"bytes,14,opt,name=function_spec,oneof"`
}

func (*MessageWithComponents_Coder) isMessageWithComponents_Root()             {}
func (*MessageWithComponents_CombinePayload) isMessageWithComponents_Root()    {}
func (*MessageWithComponents_SdkFunctionSpec) isMessageWithComponents_Root()   {}
func (*MessageWithComponents_ParDoPayload) isMessageWithComponents_Root()      {}
func (*MessageWithComponents_Ptransform) isMessageWithComponents_Root()        {}
func (*MessageWithComponents_Pcollection) isMessageWithComponents_Root()       {}
func (*MessageWithComponents_ReadPayload) isMessageWithComponents_Root()       {}
func (*MessageWithComponents_SideInput) isMessageWithComponents_Root()         {}
func (*MessageWithComponents_WindowIntoPayload) isMessageWithComponents_Root() {}
func (*MessageWithComponents_WindowingStrategy) isMessageWithComponents_Root() {}
func (*MessageWithComponents_FunctionSpec) isMessageWithComponents_Root()      {}

func (m *MessageWithComponents) GetRoot() isMessageWithComponents_Root {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *MessageWithComponents) GetComponents() *Components {
	if m != nil {
		return m.Components
	}
	return nil
}

func (m *MessageWithComponents) GetCoder() *Coder {
	if x, ok := m.GetRoot().(*MessageWithComponents_Coder); ok {
		return x.Coder
	}
	return nil
}

func (m *MessageWithComponents) GetCombinePayload() *CombinePayload {
	if x, ok := m.GetRoot().(*MessageWithComponents_CombinePayload); ok {
		return x.CombinePayload
	}
	return nil
}

func (m *MessageWithComponents) GetSdkFunctionSpec() *SdkFunctionSpec {
	if x, ok := m.GetRoot().(*MessageWithComponents_SdkFunctionSpec); ok {
		return x.SdkFunctionSpec
	}
	return nil
}

func (m *MessageWithComponents) GetParDoPayload() *ParDoPayload {
	if x, ok := m.GetRoot().(*MessageWithComponents_ParDoPayload); ok {
		return x.ParDoPayload
	}
	return nil
}

func (m *MessageWithComponents) GetPtransform() *PTransform {
	if x, ok := m.GetRoot().(*MessageWithComponents_Ptransform); ok {
		return x.Ptransform
	}
	return nil
}

func (m *MessageWithComponents) GetPcollection() *PCollection {
	if x, ok := m.GetRoot().(*MessageWithComponents_Pcollection); ok {
		return x.Pcollection
	}
	return nil
}

func (m *MessageWithComponents) GetReadPayload() *ReadPayload {
	if x, ok := m.GetRoot().(*MessageWithComponents_ReadPayload); ok {
		return x.ReadPayload
	}
	return nil
}

func (m *MessageWithComponents) GetSideInput() *SideInput {
	if x, ok := m.GetRoot().(*MessageWithComponents_SideInput); ok {
		return x.SideInput
	}
	return nil
}

func (m *MessageWithComponents) GetWindowIntoPayload() *WindowIntoPayload {
	if x, ok := m.GetRoot().(*MessageWithComponents_WindowIntoPayload); ok {
		return x.WindowIntoPayload
	}
	return nil
}

func (m *MessageWithComponents) GetWindowingStrategy() *WindowingStrategy {
	if x, ok := m.GetRoot().(*MessageWithComponents_WindowingStrategy); ok {
		return x.WindowingStrategy
	}
	return nil
}

func (m *MessageWithComponents) GetFunctionSpec() *FunctionSpec {
	if x, ok := m.GetRoot().(*MessageWithComponents_FunctionSpec); ok {
		return x.FunctionSpec
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MessageWithComponents) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MessageWithComponents_OneofMarshaler, _MessageWithComponents_OneofUnmarshaler, _MessageWithComponents_OneofSizer, []interface{}{
		(*MessageWithComponents_Coder)(nil),
		(*MessageWithComponents_CombinePayload)(nil),
		(*MessageWithComponents_SdkFunctionSpec)(nil),
		(*MessageWithComponents_ParDoPayload)(nil),
		(*MessageWithComponents_Ptransform)(nil),
		(*MessageWithComponents_Pcollection)(nil),
		(*MessageWithComponents_ReadPayload)(nil),
		(*MessageWithComponents_SideInput)(nil),
		(*MessageWithComponents_WindowIntoPayload)(nil),
		(*MessageWithComponents_WindowingStrategy)(nil),
		(*MessageWithComponents_FunctionSpec)(nil),
	}
}

func _MessageWithComponents_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MessageWithComponents)
	// root
	switch x := m.Root.(type) {
	case *MessageWithComponents_Coder:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Coder); err != nil {
			return err
		}
	case *MessageWithComponents_CombinePayload:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CombinePayload); err != nil {
			return err
		}
	case *MessageWithComponents_SdkFunctionSpec:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SdkFunctionSpec); err != nil {
			return err
		}
	case *MessageWithComponents_ParDoPayload:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ParDoPayload); err != nil {
			return err
		}
	case *MessageWithComponents_Ptransform:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ptransform); err != nil {
			return err
		}
	case *MessageWithComponents_Pcollection:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pcollection); err != nil {
			return err
		}
	case *MessageWithComponents_ReadPayload:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReadPayload); err != nil {
			return err
		}
	case *MessageWithComponents_SideInput:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SideInput); err != nil {
			return err
		}
	case *MessageWithComponents_WindowIntoPayload:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WindowIntoPayload); err != nil {
			return err
		}
	case *MessageWithComponents_WindowingStrategy:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WindowingStrategy); err != nil {
			return err
		}
	case *MessageWithComponents_FunctionSpec:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FunctionSpec); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MessageWithComponents.Root has unexpected type %T", x)
	}
	return nil
}

func _MessageWithComponents_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MessageWithComponents)
	switch tag {
	case 2: // root.coder
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Coder)
		err := b.DecodeMessage(msg)
		m.Root = &MessageWithComponents_Coder{msg}
		return true, err
	case 3: // root.combine_payload
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CombinePayload)
		err := b.DecodeMessage(msg)
		m.Root = &MessageWithComponents_CombinePayload{msg}
		return true, err
	case 4: // root.sdk_function_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SdkFunctionSpec)
		err := b.DecodeMessage(msg)
		m.Root = &MessageWithComponents_SdkFunctionSpec{msg}
		return true, err
	case 6: // root.par_do_payload
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ParDoPayload)
		err := b.DecodeMessage(msg)
		m.Root = &MessageWithComponents_ParDoPayload{msg}
		return true, err
	case 7: // root.ptransform
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PTransform)
		err := b.DecodeMessage(msg)
		m.Root = &MessageWithComponents_Ptransform{msg}
		return true, err
	case 8: // root.pcollection
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PCollection)
		err := b.DecodeMessage(msg)
		m.Root = &MessageWithComponents_Pcollection{msg}
		return true, err
	case 9: // root.read_payload
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReadPayload)
		err := b.DecodeMessage(msg)
		m.Root = &MessageWithComponents_ReadPayload{msg}
		return true, err
	case 11: // root.side_input
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SideInput)
		err := b.DecodeMessage(msg)
		m.Root = &MessageWithComponents_SideInput{msg}
		return true, err
	case 12: // root.window_into_payload
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WindowIntoPayload)
		err := b.DecodeMessage(msg)
		m.Root = &MessageWithComponents_WindowIntoPayload{msg}
		return true, err
	case 13: // root.windowing_strategy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WindowingStrategy)
		err := b.DecodeMessage(msg)
		m.Root = &MessageWithComponents_WindowingStrategy{msg}
		return true, err
	case 14: // root.function_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FunctionSpec)
		err := b.DecodeMessage(msg)
		m.Root = &MessageWithComponents_FunctionSpec{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MessageWithComponents_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MessageWithComponents)
	// root
	switch x := m.Root.(type) {
	case *MessageWithComponents_Coder:
		s := proto.Size(x.Coder)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MessageWithComponents_CombinePayload:
		s := proto.Size(x.CombinePayload)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MessageWithComponents_SdkFunctionSpec:
		s := proto.Size(x.SdkFunctionSpec)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MessageWithComponents_ParDoPayload:
		s := proto.Size(x.ParDoPayload)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MessageWithComponents_Ptransform:
		s := proto.Size(x.Ptransform)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MessageWithComponents_Pcollection:
		s := proto.Size(x.Pcollection)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MessageWithComponents_ReadPayload:
		s := proto.Size(x.ReadPayload)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MessageWithComponents_SideInput:
		s := proto.Size(x.SideInput)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MessageWithComponents_WindowIntoPayload:
		s := proto.Size(x.WindowIntoPayload)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MessageWithComponents_WindowingStrategy:
		s := proto.Size(x.WindowingStrategy)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MessageWithComponents_FunctionSpec:
		s := proto.Size(x.FunctionSpec)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A Pipeline is a hierarchical graph of PTransforms, linked
// by PCollections.
//
// This is represented by a number of by-reference maps to nodes,
// PCollections, SDK environments, UDF, etc., for
// supporting compact reuse and arbitrary graph structure.
//
// All of the keys in the maps here are arbitrary strings that are only
// required to be internally consistent within this proto message.
type Pipeline struct {
	// (Required) The coders, UDFs, graph nodes, etc, that make up
	// this pipeline.
	Components *Components `protobuf:"bytes,1,opt,name=components" json:"components,omitempty"`
	// (Required) The ids of all PTransforms that are not contained within another PTransform
	RootTransformIds []string `protobuf:"bytes,2,rep,name=root_transform_ids" json:"root_transform_ids,omitempty"`
	// (Optional) Static display data for the pipeline. If there is none,
	// it may be omitted.
	DisplayData *DisplayData `protobuf:"bytes,3,opt,name=display_data" json:"display_data,omitempty"`
}

func (m *Pipeline) Reset()                    { *m = Pipeline{} }
func (m *Pipeline) String() string            { return proto.CompactTextString(m) }
func (*Pipeline) ProtoMessage()               {}
func (*Pipeline) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Pipeline) GetComponents() *Components {
	if m != nil {
		return m.Components
	}
	return nil
}

func (m *Pipeline) GetRootTransformIds() []string {
	if m != nil {
		return m.RootTransformIds
	}
	return nil
}

func (m *Pipeline) GetDisplayData() *DisplayData {
	if m != nil {
		return m.DisplayData
	}
	return nil
}

// An applied PTransform! This does not contain the graph data, but only the
// fields specific to a graph node that is a Runner API transform
// between PCollections.
type PTransform struct {
	// (Required) A unique name for the application node.
	//
	// Ideally, this should be stable over multiple evolutions of a pipeline
	// for the purposes of logging and associating pipeline state with a node,
	// etc.
	//
	// If it is not stable, then the runner decides what will happen. But, most
	// importantly, it must always be here and be unique, even if it is
	// autogenerated.
	UniqueName string `protobuf:"bytes,5,opt,name=unique_name" json:"unique_name,omitempty"`
	// (Optional) A URN and payload that, together, fully defined the semantics
	// of this transform.
	//
	// If absent, this must be an "anonymous" composite transform.
	//
	// For primitive transform in the Runner API, this is required, and the
	// payloads are well-defined messages. When the URN indicates ParDo it
	// is a ParDoPayload, and so on.
	//
	// TODO: document the standardized URNs and payloads
	// TODO: separate standardized payloads into a separate proto file
	//
	// For some special composite transforms, the payload is also officially
	// defined:
	//
	//  - when the URN is "urn:beam:transforms:combine" it is a CombinePayload
	//
	Spec *FunctionSpec `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	// (Optional) if this node is a composite, a list of the ids of
	// transforms that it contains.
	Subtransforms []string `protobuf:"bytes,2,rep,name=subtransforms" json:"subtransforms,omitempty"`
	// (Required) A map from local names of inputs (unique only with this map, and
	// likely embedded in the transform payload and serialized user code) to
	// PCollection ids.
	//
	// The payload for this transform may clarify the relationship of these
	// inputs. For example:
	//
	//  - for a Flatten transform they are merged
	//  - for a ParDo transform, some may be side inputs
	//
	// All inputs are recorded here so that the topological ordering of
	// the graph is consistent whether or not the payload is understood.
	//
	Inputs map[string]string `protobuf:"bytes,3,rep,name=inputs" json:"inputs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// (Required) A map from local names of outputs (unique only within this map,
	// and likely embedded in the transform payload and serialized user code)
	// to PCollection ids.
	//
	// The URN or payload for this transform node may clarify the type and
	// relationship of these outputs. For example:
	//
	//  - for a ParDo transform, these are tags on PCollections, which will be
	//    embedded in the DoFn.
	//
	Outputs map[string]string `protobuf:"bytes,4,rep,name=outputs" json:"outputs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// (Optional) Static display data for this PTransform application. If
	// there is none, or it is not relevant (such as use by the Fn API)
	// then it may be omitted.
	DisplayData *DisplayData `protobuf:"bytes,6,opt,name=display_data" json:"display_data,omitempty"`
}

func (m *PTransform) Reset()                    { *m = PTransform{} }
func (m *PTransform) String() string            { return proto.CompactTextString(m) }
func (*PTransform) ProtoMessage()               {}
func (*PTransform) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *PTransform) GetUniqueName() string {
	if m != nil {
		return m.UniqueName
	}
	return ""
}

func (m *PTransform) GetSpec() *FunctionSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *PTransform) GetSubtransforms() []string {
	if m != nil {
		return m.Subtransforms
	}
	return nil
}

func (m *PTransform) GetInputs() map[string]string {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *PTransform) GetOutputs() map[string]string {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *PTransform) GetDisplayData() *DisplayData {
	if m != nil {
		return m.DisplayData
	}
	return nil
}

// A PCollection!
type PCollection struct {
	// (Required) A unique name for the PCollection.
	//
	// Ideally, this should be stable over multiple evolutions of a pipeline
	// for the purposes of logging and associating pipeline state with a node,
	// etc.
	//
	// If it is not stable, then the runner decides what will happen. But, most
	// importantly, it must always be here, even if it is autogenerated.
	UniqueName string `protobuf:"bytes,1,opt,name=unique_name" json:"unique_name,omitempty"`
	// (Required) The id of the Coder for this PCollection.
	CoderId string `protobuf:"bytes,2,opt,name=coder_id" json:"coder_id,omitempty"`
	// (Required) Whether this PCollection is bounded or unbounded
	IsBounded IsBounded `protobuf:"varint,3,opt,name=is_bounded,enum=org.apache.beam.runner_api.v1.IsBounded" json:"is_bounded,omitempty"`
	// (Required) The id of the windowing strategy for this PCollection.
	WindowingStrategyId string `protobuf:"bytes,4,opt,name=windowing_strategy_id" json:"windowing_strategy_id,omitempty"`
	// (Optional) Static display data for this PTransform application. If
	// there is none, or it is not relevant (such as use by the Fn API)
	// then it may be omitted.
	DisplayData *DisplayData `protobuf:"bytes,5,opt,name=display_data" json:"display_data,omitempty"`
}

func (m *PCollection) Reset()                    { *m = PCollection{} }
func (m *PCollection) String() string            { return proto.CompactTextString(m) }
func (*PCollection) ProtoMessage()               {}
func (*PCollection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PCollection) GetUniqueName() string {
	if m != nil {
		return m.UniqueName
	}
	return ""
}

func (m *PCollection) GetCoderId() string {
	if m != nil {
		return m.CoderId
	}
	return ""
}

func (m *PCollection) GetIsBounded() IsBounded {
	if m != nil {
		return m.IsBounded
	}
	return IsBounded_BOUNDED
}

func (m *PCollection) GetWindowingStrategyId() string {
	if m != nil {
		return m.WindowingStrategyId
	}
	return ""
}

func (m *PCollection) GetDisplayData() *DisplayData {
	if m != nil {
		return m.DisplayData
	}
	return nil
}

// The payload for the primitive ParDo transform.
type ParDoPayload struct {
	// (Required) The SdkFunctionSpec of the DoFn.
	DoFn *SdkFunctionSpec `protobuf:"bytes,1,opt,name=do_fn" json:"do_fn,omitempty"`
	// (Required) Additional pieces of context the DoFn may require that
	// are not otherwise represented in the payload.
	// (may force runners to execute the ParDo differently)
	Parameters []*Parameter `protobuf:"bytes,2,rep,name=parameters" json:"parameters,omitempty"`
	// (Optional) A mapping of local input names to side inputs, describing
	// the expected access pattern.
	SideInputs map[string]*SideInput `protobuf:"bytes,3,rep,name=side_inputs" json:"side_inputs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// (Optional) A mapping of local state names to state specifications.
	StateSpecs map[string]*StateSpec `protobuf:"bytes,4,rep,name=state_specs" json:"state_specs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// (Optional) A mapping of local timer names to timer specifications.
	TimerSpecs map[string]*TimerSpec `protobuf:"bytes,5,rep,name=timer_specs" json:"timer_specs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Whether the DoFn is splittable
	Splittable bool `protobuf:"varint,6,opt,name=splittable" json:"splittable,omitempty"`
}

func (m *ParDoPayload) Reset()                    { *m = ParDoPayload{} }
func (m *ParDoPayload) String() string            { return proto.CompactTextString(m) }
func (*ParDoPayload) ProtoMessage()               {}
func (*ParDoPayload) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ParDoPayload) GetDoFn() *SdkFunctionSpec {
	if m != nil {
		return m.DoFn
	}
	return nil
}

func (m *ParDoPayload) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *ParDoPayload) GetSideInputs() map[string]*SideInput {
	if m != nil {
		return m.SideInputs
	}
	return nil
}

func (m *ParDoPayload) GetStateSpecs() map[string]*StateSpec {
	if m != nil {
		return m.StateSpecs
	}
	return nil
}

func (m *ParDoPayload) GetTimerSpecs() map[string]*TimerSpec {
	if m != nil {
		return m.TimerSpecs
	}
	return nil
}

func (m *ParDoPayload) GetSplittable() bool {
	if m != nil {
		return m.Splittable
	}
	return false
}

// Parameters that a UDF might require.
//
// The details of how a runner sends these parameters to the SDK harness
// are the subject of the Fn API.
//
// The details of how an SDK harness delivers them to the UDF is entirely
// up to the SDK. (for some SDKs there may be parameters that are not
// represented here if the runner doesn't need to do anything)
//
// Here, the parameters are simply indicators to the runner that they
// need to run the function a particular way.
//
// TODO: the evolution of the Fn API will influence what needs explicit
// representation here
type Parameter struct {
	Type Parameter_Type `protobuf:"varint,1,opt,name=type,enum=org.apache.beam.runner_api.v1.Parameter_Type" json:"type,omitempty"`
}

func (m *Parameter) Reset()                    { *m = Parameter{} }
func (m *Parameter) String() string            { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()               {}
func (*Parameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Parameter) GetType() Parameter_Type {
	if m != nil {
		return m.Type
	}
	return Parameter_WINDOW
}

type StateSpec struct {
	// Types that are valid to be assigned to Spec:
	//	*StateSpec_ValueSpec
	//	*StateSpec_BagSpec
	//	*StateSpec_CombiningSpec
	//	*StateSpec_MapSpec
	//	*StateSpec_SetSpec
	Spec isStateSpec_Spec `protobuf_oneof:"spec"`
}

func (m *StateSpec) Reset()                    { *m = StateSpec{} }
func (m *StateSpec) String() string            { return proto.CompactTextString(m) }
func (*StateSpec) ProtoMessage()               {}
func (*StateSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isStateSpec_Spec interface {
	isStateSpec_Spec()
}

type StateSpec_ValueSpec struct {
	ValueSpec *ValueStateSpec `protobuf:"bytes,1,opt,name=value_spec,oneof"`
}
type StateSpec_BagSpec struct {
	BagSpec *BagStateSpec `protobuf:"bytes,2,opt,name=bag_spec,oneof"`
}
type StateSpec_CombiningSpec struct {
	CombiningSpec *CombiningStateSpec `protobuf:"bytes,3,opt,name=combining_spec,oneof"`
}
type StateSpec_MapSpec struct {
	MapSpec *MapStateSpec `protobuf:"bytes,4,opt,name=map_spec,oneof"`
}
type StateSpec_SetSpec struct {
	SetSpec *SetStateSpec `protobuf:"bytes,5,opt,name=set_spec,oneof"`
}

func (*StateSpec_ValueSpec) isStateSpec_Spec()     {}
func (*StateSpec_BagSpec) isStateSpec_Spec()       {}
func (*StateSpec_CombiningSpec) isStateSpec_Spec() {}
func (*StateSpec_MapSpec) isStateSpec_Spec()       {}
func (*StateSpec_SetSpec) isStateSpec_Spec()       {}

func (m *StateSpec) GetSpec() isStateSpec_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *StateSpec) GetValueSpec() *ValueStateSpec {
	if x, ok := m.GetSpec().(*StateSpec_ValueSpec); ok {
		return x.ValueSpec
	}
	return nil
}

func (m *StateSpec) GetBagSpec() *BagStateSpec {
	if x, ok := m.GetSpec().(*StateSpec_BagSpec); ok {
		return x.BagSpec
	}
	return nil
}

func (m *StateSpec) GetCombiningSpec() *CombiningStateSpec {
	if x, ok := m.GetSpec().(*StateSpec_CombiningSpec); ok {
		return x.CombiningSpec
	}
	return nil
}

func (m *StateSpec) GetMapSpec() *MapStateSpec {
	if x, ok := m.GetSpec().(*StateSpec_MapSpec); ok {
		return x.MapSpec
	}
	return nil
}

func (m *StateSpec) GetSetSpec() *SetStateSpec {
	if x, ok := m.GetSpec().(*StateSpec_SetSpec); ok {
		return x.SetSpec
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StateSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StateSpec_OneofMarshaler, _StateSpec_OneofUnmarshaler, _StateSpec_OneofSizer, []interface{}{
		(*StateSpec_ValueSpec)(nil),
		(*StateSpec_BagSpec)(nil),
		(*StateSpec_CombiningSpec)(nil),
		(*StateSpec_MapSpec)(nil),
		(*StateSpec_SetSpec)(nil),
	}
}

func _StateSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StateSpec)
	// spec
	switch x := m.Spec.(type) {
	case *StateSpec_ValueSpec:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ValueSpec); err != nil {
			return err
		}
	case *StateSpec_BagSpec:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BagSpec); err != nil {
			return err
		}
	case *StateSpec_CombiningSpec:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CombiningSpec); err != nil {
			return err
		}
	case *StateSpec_MapSpec:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MapSpec); err != nil {
			return err
		}
	case *StateSpec_SetSpec:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SetSpec); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StateSpec.Spec has unexpected type %T", x)
	}
	return nil
}

func _StateSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StateSpec)
	switch tag {
	case 1: // spec.value_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ValueStateSpec)
		err := b.DecodeMessage(msg)
		m.Spec = &StateSpec_ValueSpec{msg}
		return true, err
	case 2: // spec.bag_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BagStateSpec)
		err := b.DecodeMessage(msg)
		m.Spec = &StateSpec_BagSpec{msg}
		return true, err
	case 3: // spec.combining_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CombiningStateSpec)
		err := b.DecodeMessage(msg)
		m.Spec = &StateSpec_CombiningSpec{msg}
		return true, err
	case 4: // spec.map_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MapStateSpec)
		err := b.DecodeMessage(msg)
		m.Spec = &StateSpec_MapSpec{msg}
		return true, err
	case 5: // spec.set_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SetStateSpec)
		err := b.DecodeMessage(msg)
		m.Spec = &StateSpec_SetSpec{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StateSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StateSpec)
	// spec
	switch x := m.Spec.(type) {
	case *StateSpec_ValueSpec:
		s := proto.Size(x.ValueSpec)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StateSpec_BagSpec:
		s := proto.Size(x.BagSpec)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StateSpec_CombiningSpec:
		s := proto.Size(x.CombiningSpec)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StateSpec_MapSpec:
		s := proto.Size(x.MapSpec)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StateSpec_SetSpec:
		s := proto.Size(x.SetSpec)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ValueStateSpec struct {
	CoderId string `protobuf:"bytes,1,opt,name=coder_id" json:"coder_id,omitempty"`
}

func (m *ValueStateSpec) Reset()                    { *m = ValueStateSpec{} }
func (m *ValueStateSpec) String() string            { return proto.CompactTextString(m) }
func (*ValueStateSpec) ProtoMessage()               {}
func (*ValueStateSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ValueStateSpec) GetCoderId() string {
	if m != nil {
		return m.CoderId
	}
	return ""
}

type BagStateSpec struct {
	ElementCoderId string `protobuf:"bytes,1,opt,name=element_coder_id" json:"element_coder_id,omitempty"`
}

func (m *BagStateSpec) Reset()                    { *m = BagStateSpec{} }
func (m *BagStateSpec) String() string            { return proto.CompactTextString(m) }
func (*BagStateSpec) ProtoMessage()               {}
func (*BagStateSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *BagStateSpec) GetElementCoderId() string {
	if m != nil {
		return m.ElementCoderId
	}
	return ""
}

type CombiningStateSpec struct {
	AccumulatorCoderId string           `protobuf:"bytes,1,opt,name=accumulator_coder_id" json:"accumulator_coder_id,omitempty"`
	CombineFn          *SdkFunctionSpec `protobuf:"bytes,2,opt,name=combine_fn" json:"combine_fn,omitempty"`
}

func (m *CombiningStateSpec) Reset()                    { *m = CombiningStateSpec{} }
func (m *CombiningStateSpec) String() string            { return proto.CompactTextString(m) }
func (*CombiningStateSpec) ProtoMessage()               {}
func (*CombiningStateSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *CombiningStateSpec) GetAccumulatorCoderId() string {
	if m != nil {
		return m.AccumulatorCoderId
	}
	return ""
}

func (m *CombiningStateSpec) GetCombineFn() *SdkFunctionSpec {
	if m != nil {
		return m.CombineFn
	}
	return nil
}

type MapStateSpec struct {
	KeyCoderId   string `protobuf:"bytes,1,opt,name=key_coder_id" json:"key_coder_id,omitempty"`
	ValueCoderId string `protobuf:"bytes,2,opt,name=value_coder_id" json:"value_coder_id,omitempty"`
}

func (m *MapStateSpec) Reset()                    { *m = MapStateSpec{} }
func (m *MapStateSpec) String() string            { return proto.CompactTextString(m) }
func (*MapStateSpec) ProtoMessage()               {}
func (*MapStateSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *MapStateSpec) GetKeyCoderId() string {
	if m != nil {
		return m.KeyCoderId
	}
	return ""
}

func (m *MapStateSpec) GetValueCoderId() string {
	if m != nil {
		return m.ValueCoderId
	}
	return ""
}

type SetStateSpec struct {
	ElementCoderId string `protobuf:"bytes,1,opt,name=element_coder_id" json:"element_coder_id,omitempty"`
}

func (m *SetStateSpec) Reset()                    { *m = SetStateSpec{} }
func (m *SetStateSpec) String() string            { return proto.CompactTextString(m) }
func (*SetStateSpec) ProtoMessage()               {}
func (*SetStateSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SetStateSpec) GetElementCoderId() string {
	if m != nil {
		return m.ElementCoderId
	}
	return ""
}

type TimerSpec struct {
	TimeDomain TimeDomain `protobuf:"varint,1,opt,name=time_domain,enum=org.apache.beam.runner_api.v1.TimeDomain" json:"time_domain,omitempty"`
}

func (m *TimerSpec) Reset()                    { *m = TimerSpec{} }
func (m *TimerSpec) String() string            { return proto.CompactTextString(m) }
func (*TimerSpec) ProtoMessage()               {}
func (*TimerSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *TimerSpec) GetTimeDomain() TimeDomain {
	if m != nil {
		return m.TimeDomain
	}
	return TimeDomain_EVENT_TIME
}

// The payload for the primitive Read transform.
type ReadPayload struct {
	// (Required) The SdkFunctionSpec of the source for this Read.
	Source *SdkFunctionSpec `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// (Required) Whether the source is bounded or unbounded
	IsBounded IsBounded `protobuf:"varint,2,opt,name=is_bounded,enum=org.apache.beam.runner_api.v1.IsBounded" json:"is_bounded,omitempty"`
}

func (m *ReadPayload) Reset()                    { *m = ReadPayload{} }
func (m *ReadPayload) String() string            { return proto.CompactTextString(m) }
func (*ReadPayload) ProtoMessage()               {}
func (*ReadPayload) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ReadPayload) GetSource() *SdkFunctionSpec {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *ReadPayload) GetIsBounded() IsBounded {
	if m != nil {
		return m.IsBounded
	}
	return IsBounded_BOUNDED
}

// The payload for the WindowInto transform.
type WindowIntoPayload struct {
	// (Required) The SdkFunctionSpec of the WindowFn.
	WindowFn *SdkFunctionSpec `protobuf:"bytes,1,opt,name=window_fn" json:"window_fn,omitempty"`
}

func (m *WindowIntoPayload) Reset()                    { *m = WindowIntoPayload{} }
func (m *WindowIntoPayload) String() string            { return proto.CompactTextString(m) }
func (*WindowIntoPayload) ProtoMessage()               {}
func (*WindowIntoPayload) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *WindowIntoPayload) GetWindowFn() *SdkFunctionSpec {
	if m != nil {
		return m.WindowFn
	}
	return nil
}

// The payload for the special-but-not-primitive Combine transform.
type CombinePayload struct {
	// (Required) The SdkFunctionSpec of the CombineFn.
	CombineFn *SdkFunctionSpec `protobuf:"bytes,1,opt,name=combine_fn" json:"combine_fn,omitempty"`
	// (Required) A reference to the Coder to use for accumulators of the CombineFn
	AccumulatorCoderId string `protobuf:"bytes,2,opt,name=accumulator_coder_id" json:"accumulator_coder_id,omitempty"`
	// (Required) Additional pieces of context the DoFn may require that
	// are not otherwise represented in the payload.
	// (may force runners to execute the ParDo differently)
	Parameters []*Parameter `protobuf:"bytes,3,rep,name=parameters" json:"parameters,omitempty"`
	// (Optional) A mapping of local input names to side inputs, describing
	// the expected access pattern.
	SideInputs map[string]*SideInput `protobuf:"bytes,4,rep,name=side_inputs" json:"side_inputs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CombinePayload) Reset()                    { *m = CombinePayload{} }
func (m *CombinePayload) String() string            { return proto.CompactTextString(m) }
func (*CombinePayload) ProtoMessage()               {}
func (*CombinePayload) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *CombinePayload) GetCombineFn() *SdkFunctionSpec {
	if m != nil {
		return m.CombineFn
	}
	return nil
}

func (m *CombinePayload) GetAccumulatorCoderId() string {
	if m != nil {
		return m.AccumulatorCoderId
	}
	return ""
}

func (m *CombinePayload) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *CombinePayload) GetSideInputs() map[string]*SideInput {
	if m != nil {
		return m.SideInputs
	}
	return nil
}

// The payload for the test-only primitive TestStream
type TestStreamPayload struct {
	// (Required) the coder for elements in the TestStream events
	CoderId string                     `protobuf:"bytes,1,opt,name=coder_id" json:"coder_id,omitempty"`
	Events  []*TestStreamPayload_Event `protobuf:"bytes,2,rep,name=events" json:"events,omitempty"`
}

func (m *TestStreamPayload) Reset()                    { *m = TestStreamPayload{} }
func (m *TestStreamPayload) String() string            { return proto.CompactTextString(m) }
func (*TestStreamPayload) ProtoMessage()               {}
func (*TestStreamPayload) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *TestStreamPayload) GetCoderId() string {
	if m != nil {
		return m.CoderId
	}
	return ""
}

func (m *TestStreamPayload) GetEvents() []*TestStreamPayload_Event {
	if m != nil {
		return m.Events
	}
	return nil
}

type TestStreamPayload_Event struct {
	// Types that are valid to be assigned to Event:
	//	*TestStreamPayload_Event_WatermarkEvent
	//	*TestStreamPayload_Event_ProcessingTimeEvent
	//	*TestStreamPayload_Event_ElementEvent
	Event isTestStreamPayload_Event_Event `protobuf_oneof:"event"`
}

func (m *TestStreamPayload_Event) Reset()                    { *m = TestStreamPayload_Event{} }
func (m *TestStreamPayload_Event) String() string            { return proto.CompactTextString(m) }
func (*TestStreamPayload_Event) ProtoMessage()               {}
func (*TestStreamPayload_Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17, 0} }

type isTestStreamPayload_Event_Event interface {
	isTestStreamPayload_Event_Event()
}

type TestStreamPayload_Event_WatermarkEvent struct {
	WatermarkEvent *TestStreamPayload_Event_AdvanceWatermark `protobuf:"bytes,1,opt,name=watermark_event,oneof"`
}
type TestStreamPayload_Event_ProcessingTimeEvent struct {
	ProcessingTimeEvent *TestStreamPayload_Event_AdvanceProcessingTime `protobuf:"bytes,2,opt,name=processing_time_event,oneof"`
}
type TestStreamPayload_Event_ElementEvent struct {
	ElementEvent *TestStreamPayload_Event_AddElements `protobuf:"bytes,3,opt,name=element_event,oneof"`
}

func (*TestStreamPayload_Event_WatermarkEvent) isTestStreamPayload_Event_Event()      {}
func (*TestStreamPayload_Event_ProcessingTimeEvent) isTestStreamPayload_Event_Event() {}
func (*TestStreamPayload_Event_ElementEvent) isTestStreamPayload_Event_Event()        {}

func (m *TestStreamPayload_Event) GetEvent() isTestStreamPayload_Event_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *TestStreamPayload_Event) GetWatermarkEvent() *TestStreamPayload_Event_AdvanceWatermark {
	if x, ok := m.GetEvent().(*TestStreamPayload_Event_WatermarkEvent); ok {
		return x.WatermarkEvent
	}
	return nil
}

func (m *TestStreamPayload_Event) GetProcessingTimeEvent() *TestStreamPayload_Event_AdvanceProcessingTime {
	if x, ok := m.GetEvent().(*TestStreamPayload_Event_ProcessingTimeEvent); ok {
		return x.ProcessingTimeEvent
	}
	return nil
}

func (m *TestStreamPayload_Event) GetElementEvent() *TestStreamPayload_Event_AddElements {
	if x, ok := m.GetEvent().(*TestStreamPayload_Event_ElementEvent); ok {
		return x.ElementEvent
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TestStreamPayload_Event) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TestStreamPayload_Event_OneofMarshaler, _TestStreamPayload_Event_OneofUnmarshaler, _TestStreamPayload_Event_OneofSizer, []interface{}{
		(*TestStreamPayload_Event_WatermarkEvent)(nil),
		(*TestStreamPayload_Event_ProcessingTimeEvent)(nil),
		(*TestStreamPayload_Event_ElementEvent)(nil),
	}
}

func _TestStreamPayload_Event_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TestStreamPayload_Event)
	// event
	switch x := m.Event.(type) {
	case *TestStreamPayload_Event_WatermarkEvent:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WatermarkEvent); err != nil {
			return err
		}
	case *TestStreamPayload_Event_ProcessingTimeEvent:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProcessingTimeEvent); err != nil {
			return err
		}
	case *TestStreamPayload_Event_ElementEvent:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ElementEvent); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TestStreamPayload_Event.Event has unexpected type %T", x)
	}
	return nil
}

func _TestStreamPayload_Event_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TestStreamPayload_Event)
	switch tag {
	case 1: // event.watermark_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestStreamPayload_Event_AdvanceWatermark)
		err := b.DecodeMessage(msg)
		m.Event = &TestStreamPayload_Event_WatermarkEvent{msg}
		return true, err
	case 2: // event.processing_time_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestStreamPayload_Event_AdvanceProcessingTime)
		err := b.DecodeMessage(msg)
		m.Event = &TestStreamPayload_Event_ProcessingTimeEvent{msg}
		return true, err
	case 3: // event.element_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestStreamPayload_Event_AddElements)
		err := b.DecodeMessage(msg)
		m.Event = &TestStreamPayload_Event_ElementEvent{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TestStreamPayload_Event_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TestStreamPayload_Event)
	// event
	switch x := m.Event.(type) {
	case *TestStreamPayload_Event_WatermarkEvent:
		s := proto.Size(x.WatermarkEvent)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TestStreamPayload_Event_ProcessingTimeEvent:
		s := proto.Size(x.ProcessingTimeEvent)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TestStreamPayload_Event_ElementEvent:
		s := proto.Size(x.ElementEvent)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TestStreamPayload_Event_AdvanceWatermark struct {
	NewWatermark int64 `protobuf:"varint,1,opt,name=new_watermark" json:"new_watermark,omitempty"`
}

func (m *TestStreamPayload_Event_AdvanceWatermark) Reset() {
	*m = TestStreamPayload_Event_AdvanceWatermark{}
}
func (m *TestStreamPayload_Event_AdvanceWatermark) String() string { return proto.CompactTextString(m) }
func (*TestStreamPayload_Event_AdvanceWatermark) ProtoMessage()    {}
func (*TestStreamPayload_Event_AdvanceWatermark) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{17, 0, 0}
}

func (m *TestStreamPayload_Event_AdvanceWatermark) GetNewWatermark() int64 {
	if m != nil {
		return m.NewWatermark
	}
	return 0
}

type TestStreamPayload_Event_AdvanceProcessingTime struct {
	AdvanceDuration int64 `protobuf:"varint,1,opt,name=advance_duration" json:"advance_duration,omitempty"`
}

func (m *TestStreamPayload_Event_AdvanceProcessingTime) Reset() {
	*m = TestStreamPayload_Event_AdvanceProcessingTime{}
}
func (m *TestStreamPayload_Event_AdvanceProcessingTime) String() string {
	return proto.CompactTextString(m)
}
func (*TestStreamPayload_Event_AdvanceProcessingTime) ProtoMessage() {}
func (*TestStreamPayload_Event_AdvanceProcessingTime) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{17, 0, 1}
}

func (m *TestStreamPayload_Event_AdvanceProcessingTime) GetAdvanceDuration() int64 {
	if m != nil {
		return m.AdvanceDuration
	}
	return 0
}

type TestStreamPayload_Event_AddElements struct {
	Elements []*TestStreamPayload_TimestampedElement `protobuf:"bytes,1,rep,name=elements" json:"elements,omitempty"`
}

func (m *TestStreamPayload_Event_AddElements) Reset()         { *m = TestStreamPayload_Event_AddElements{} }
func (m *TestStreamPayload_Event_AddElements) String() string { return proto.CompactTextString(m) }
func (*TestStreamPayload_Event_AddElements) ProtoMessage()    {}
func (*TestStreamPayload_Event_AddElements) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{17, 0, 2}
}

func (m *TestStreamPayload_Event_AddElements) GetElements() []*TestStreamPayload_TimestampedElement {
	if m != nil {
		return m.Elements
	}
	return nil
}

type TestStreamPayload_TimestampedElement struct {
	EncodedElement []byte `protobuf:"bytes,1,opt,name=encoded_element,proto3" json:"encoded_element,omitempty"`
	Timestamp      int64  `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *TestStreamPayload_TimestampedElement) Reset()         { *m = TestStreamPayload_TimestampedElement{} }
func (m *TestStreamPayload_TimestampedElement) String() string { return proto.CompactTextString(m) }
func (*TestStreamPayload_TimestampedElement) ProtoMessage()    {}
func (*TestStreamPayload_TimestampedElement) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{17, 1}
}

func (m *TestStreamPayload_TimestampedElement) GetEncodedElement() []byte {
	if m != nil {
		return m.EncodedElement
	}
	return nil
}

func (m *TestStreamPayload_TimestampedElement) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// The payload for the special-but-not-primitive WriteFiles transform.
type WriteFilesPayload struct {
	// (Required) The SdkFunctionSpec of the FileBasedSink.
	Sink                     *SdkFunctionSpec `protobuf:"bytes,1,opt,name=sink" json:"sink,omitempty"`
	WindowedWrites           bool             `protobuf:"varint,2,opt,name=windowed_writes" json:"windowed_writes,omitempty"`
	RunnerDeterminedSharding bool             `protobuf:"varint,3,opt,name=runner_determined_sharding" json:"runner_determined_sharding,omitempty"`
}

func (m *WriteFilesPayload) Reset()                    { *m = WriteFilesPayload{} }
func (m *WriteFilesPayload) String() string            { return proto.CompactTextString(m) }
func (*WriteFilesPayload) ProtoMessage()               {}
func (*WriteFilesPayload) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *WriteFilesPayload) GetSink() *SdkFunctionSpec {
	if m != nil {
		return m.Sink
	}
	return nil
}

func (m *WriteFilesPayload) GetWindowedWrites() bool {
	if m != nil {
		return m.WindowedWrites
	}
	return false
}

func (m *WriteFilesPayload) GetRunnerDeterminedSharding() bool {
	if m != nil {
		return m.RunnerDeterminedSharding
	}
	return false
}

// A coder, the binary format for serialization and deserialization of data in
// a pipeline.
type Coder struct {
	// (Required) A specification for the coder, as a URN plus parameters. This
	// may be a cross-language agreed-upon format, or it may be a "custom coder"
	// that can only be used by a particular SDK. It does not include component
	// coders, as it is beneficial for these to be comprehensible to a runner
	// regardless of whether the binary format is agree-upon.
	Spec *SdkFunctionSpec `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	// (Optional) If this coder is parametric, such as ListCoder(VarIntCoder),
	// this is a list of the components. In order for encodings to be identical,
	// the SdkFunctionSpec and all components must be identical, recursively.
	ComponentCoderIds []string `protobuf:"bytes,2,rep,name=component_coder_ids" json:"component_coder_ids,omitempty"`
}

func (m *Coder) Reset()                    { *m = Coder{} }
func (m *Coder) String() string            { return proto.CompactTextString(m) }
func (*Coder) ProtoMessage()               {}
func (*Coder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Coder) GetSpec() *SdkFunctionSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Coder) GetComponentCoderIds() []string {
	if m != nil {
		return m.ComponentCoderIds
	}
	return nil
}

// A windowing strategy describes the window function, triggering, allowed
// lateness, and accumulation mode for a PCollection.
//
// TODO: consider inlining field on PCollection
type WindowingStrategy struct {
	// (Required) The SdkFunctionSpec of the UDF that assigns windows,
	// merges windows, and shifts timestamps before they are
	// combined according to the OutputTime.
	WindowFn *SdkFunctionSpec `protobuf:"bytes,1,opt,name=window_fn" json:"window_fn,omitempty"`
	// (Required) Whether or not the window fn is merging.
	//
	// This knowledge is required for many optimizations.
	MergeStatus MergeStatus `protobuf:"varint,2,opt,name=merge_status,enum=org.apache.beam.runner_api.v1.MergeStatus" json:"merge_status,omitempty"`
	// (Required) The coder for the windows of this PCollection.
	WindowCoderId string `protobuf:"bytes,3,opt,name=window_coder_id" json:"window_coder_id,omitempty"`
	// (Required) The trigger to use when grouping this PCollection.
	Trigger *Trigger `protobuf:"bytes,4,opt,name=trigger" json:"trigger,omitempty"`
	// (Required) The accumulation mode indicates whether new panes are a full
	// replacement for prior panes or whether they are deltas to be combined
	// with other panes (the combine should correspond to whatever the upstream
	// grouping transform is).
	AccumulationMode AccumulationMode `protobuf:"varint,5,opt,name=accumulation_mode,enum=org.apache.beam.runner_api.v1.AccumulationMode" json:"accumulation_mode,omitempty"`
	// (Required) The OutputTime specifies, for a grouping transform, how to
	// compute the aggregate timestamp. The window_fn will first possibly shift
	// it later, then the OutputTime takes the max, min, or ignores it and takes
	// the end of window.
	//
	// This is actually only for input to grouping transforms, but since they
	// may be introduced in runner-specific ways, it is carried along with the
	// windowing strategy.
	OutputTime OutputTime `protobuf:"varint,6,opt,name=output_time,enum=org.apache.beam.runner_api.v1.OutputTime" json:"output_time,omitempty"`
	// (Required) Indicate when output should be omitted upon window expiration.
	ClosingBehavior ClosingBehavior `protobuf:"varint,7,opt,name=closing_behavior,enum=org.apache.beam.runner_api.v1.ClosingBehavior" json:"closing_behavior,omitempty"`
	// (Required) The duration, in milliseconds, beyond the end of a window at
	// which the window becomes droppable.
	AllowedLateness int64 `protobuf:"varint,8,opt,name=allowed_lateness" json:"allowed_lateness,omitempty"`
}

func (m *WindowingStrategy) Reset()                    { *m = WindowingStrategy{} }
func (m *WindowingStrategy) String() string            { return proto.CompactTextString(m) }
func (*WindowingStrategy) ProtoMessage()               {}
func (*WindowingStrategy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *WindowingStrategy) GetWindowFn() *SdkFunctionSpec {
	if m != nil {
		return m.WindowFn
	}
	return nil
}

func (m *WindowingStrategy) GetMergeStatus() MergeStatus {
	if m != nil {
		return m.MergeStatus
	}
	return MergeStatus_NON_MERGING
}

func (m *WindowingStrategy) GetWindowCoderId() string {
	if m != nil {
		return m.WindowCoderId
	}
	return ""
}

func (m *WindowingStrategy) GetTrigger() *Trigger {
	if m != nil {
		return m.Trigger
	}
	return nil
}

func (m *WindowingStrategy) GetAccumulationMode() AccumulationMode {
	if m != nil {
		return m.AccumulationMode
	}
	return AccumulationMode_DISCARDING
}

func (m *WindowingStrategy) GetOutputTime() OutputTime {
	if m != nil {
		return m.OutputTime
	}
	return OutputTime_END_OF_WINDOW
}

func (m *WindowingStrategy) GetClosingBehavior() ClosingBehavior {
	if m != nil {
		return m.ClosingBehavior
	}
	return ClosingBehavior_EMIT_ALWAYS
}

func (m *WindowingStrategy) GetAllowedLateness() int64 {
	if m != nil {
		return m.AllowedLateness
	}
	return 0
}

// A small DSL for expressing when to emit new aggregations
// from a GroupByKey or CombinePerKey
//
// A trigger is described in terms of when it is _ready_ to permit output.
type Trigger struct {
	// The full disjoint union of possible triggers.
	//
	// Types that are valid to be assigned to Trigger:
	//	*Trigger_AfterAll_
	//	*Trigger_AfterAny_
	//	*Trigger_AfterEach_
	//	*Trigger_AfterEndOfWindow_
	//	*Trigger_AfterProcessingTime_
	//	*Trigger_AfterSynchronizedProcessingTime_
	//	*Trigger_Always_
	//	*Trigger_Default_
	//	*Trigger_ElementCount_
	//	*Trigger_Never_
	//	*Trigger_OrFinally_
	//	*Trigger_Repeat_
	Trigger isTrigger_Trigger `protobuf_oneof:"trigger"`
}

func (m *Trigger) Reset()                    { *m = Trigger{} }
func (m *Trigger) String() string            { return proto.CompactTextString(m) }
func (*Trigger) ProtoMessage()               {}
func (*Trigger) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

type isTrigger_Trigger interface {
	isTrigger_Trigger()
}

type Trigger_AfterAll_ struct {
	AfterAll *Trigger_AfterAll `protobuf:"bytes,1,opt,name=after_all,oneof"`
}
type Trigger_AfterAny_ struct {
	AfterAny *Trigger_AfterAny `protobuf:"bytes,2,opt,name=after_any,oneof"`
}
type Trigger_AfterEach_ struct {
	AfterEach *Trigger_AfterEach `protobuf:"bytes,3,opt,name=after_each,oneof"`
}
type Trigger_AfterEndOfWindow_ struct {
	AfterEndOfWindow *Trigger_AfterEndOfWindow `protobuf:"bytes,4,opt,name=after_end_of_window,oneof"`
}
type Trigger_AfterProcessingTime_ struct {
	AfterProcessingTime *Trigger_AfterProcessingTime `protobuf:"bytes,5,opt,name=after_processing_time,oneof"`
}
type Trigger_AfterSynchronizedProcessingTime_ struct {
	AfterSynchronizedProcessingTime *Trigger_AfterSynchronizedProcessingTime `protobuf:"bytes,6,opt,name=after_synchronized_processing_time,oneof"`
}
type Trigger_Always_ struct {
	Always *Trigger_Always `protobuf:"bytes,12,opt,name=always,oneof"`
}
type Trigger_Default_ struct {
	Default *Trigger_Default `protobuf:"bytes,7,opt,name=default,oneof"`
}
type Trigger_ElementCount_ struct {
	ElementCount *Trigger_ElementCount `protobuf:"bytes,8,opt,name=element_count,oneof"`
}
type Trigger_Never_ struct {
	Never *Trigger_Never `protobuf:"bytes,9,opt,name=never,oneof"`
}
type Trigger_OrFinally_ struct {
	OrFinally *Trigger_OrFinally `protobuf:"bytes,10,opt,name=or_finally,oneof"`
}
type Trigger_Repeat_ struct {
	Repeat *Trigger_Repeat `protobuf:"bytes,11,opt,name=repeat,oneof"`
}

func (*Trigger_AfterAll_) isTrigger_Trigger()                        {}
func (*Trigger_AfterAny_) isTrigger_Trigger()                        {}
func (*Trigger_AfterEach_) isTrigger_Trigger()                       {}
func (*Trigger_AfterEndOfWindow_) isTrigger_Trigger()                {}
func (*Trigger_AfterProcessingTime_) isTrigger_Trigger()             {}
func (*Trigger_AfterSynchronizedProcessingTime_) isTrigger_Trigger() {}
func (*Trigger_Always_) isTrigger_Trigger()                          {}
func (*Trigger_Default_) isTrigger_Trigger()                         {}
func (*Trigger_ElementCount_) isTrigger_Trigger()                    {}
func (*Trigger_Never_) isTrigger_Trigger()                           {}
func (*Trigger_OrFinally_) isTrigger_Trigger()                       {}
func (*Trigger_Repeat_) isTrigger_Trigger()                          {}

func (m *Trigger) GetTrigger() isTrigger_Trigger {
	if m != nil {
		return m.Trigger
	}
	return nil
}

func (m *Trigger) GetAfterAll() *Trigger_AfterAll {
	if x, ok := m.GetTrigger().(*Trigger_AfterAll_); ok {
		return x.AfterAll
	}
	return nil
}

func (m *Trigger) GetAfterAny() *Trigger_AfterAny {
	if x, ok := m.GetTrigger().(*Trigger_AfterAny_); ok {
		return x.AfterAny
	}
	return nil
}

func (m *Trigger) GetAfterEach() *Trigger_AfterEach {
	if x, ok := m.GetTrigger().(*Trigger_AfterEach_); ok {
		return x.AfterEach
	}
	return nil
}

func (m *Trigger) GetAfterEndOfWindow() *Trigger_AfterEndOfWindow {
	if x, ok := m.GetTrigger().(*Trigger_AfterEndOfWindow_); ok {
		return x.AfterEndOfWindow
	}
	return nil
}

func (m *Trigger) GetAfterProcessingTime() *Trigger_AfterProcessingTime {
	if x, ok := m.GetTrigger().(*Trigger_AfterProcessingTime_); ok {
		return x.AfterProcessingTime
	}
	return nil
}

func (m *Trigger) GetAfterSynchronizedProcessingTime() *Trigger_AfterSynchronizedProcessingTime {
	if x, ok := m.GetTrigger().(*Trigger_AfterSynchronizedProcessingTime_); ok {
		return x.AfterSynchronizedProcessingTime
	}
	return nil
}

func (m *Trigger) GetAlways() *Trigger_Always {
	if x, ok := m.GetTrigger().(*Trigger_Always_); ok {
		return x.Always
	}
	return nil
}

func (m *Trigger) GetDefault() *Trigger_Default {
	if x, ok := m.GetTrigger().(*Trigger_Default_); ok {
		return x.Default
	}
	return nil
}

func (m *Trigger) GetElementCount() *Trigger_ElementCount {
	if x, ok := m.GetTrigger().(*Trigger_ElementCount_); ok {
		return x.ElementCount
	}
	return nil
}

func (m *Trigger) GetNever() *Trigger_Never {
	if x, ok := m.GetTrigger().(*Trigger_Never_); ok {
		return x.Never
	}
	return nil
}

func (m *Trigger) GetOrFinally() *Trigger_OrFinally {
	if x, ok := m.GetTrigger().(*Trigger_OrFinally_); ok {
		return x.OrFinally
	}
	return nil
}

func (m *Trigger) GetRepeat() *Trigger_Repeat {
	if x, ok := m.GetTrigger().(*Trigger_Repeat_); ok {
		return x.Repeat
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Trigger) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Trigger_OneofMarshaler, _Trigger_OneofUnmarshaler, _Trigger_OneofSizer, []interface{}{
		(*Trigger_AfterAll_)(nil),
		(*Trigger_AfterAny_)(nil),
		(*Trigger_AfterEach_)(nil),
		(*Trigger_AfterEndOfWindow_)(nil),
		(*Trigger_AfterProcessingTime_)(nil),
		(*Trigger_AfterSynchronizedProcessingTime_)(nil),
		(*Trigger_Always_)(nil),
		(*Trigger_Default_)(nil),
		(*Trigger_ElementCount_)(nil),
		(*Trigger_Never_)(nil),
		(*Trigger_OrFinally_)(nil),
		(*Trigger_Repeat_)(nil),
	}
}

func _Trigger_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Trigger)
	// trigger
	switch x := m.Trigger.(type) {
	case *Trigger_AfterAll_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AfterAll); err != nil {
			return err
		}
	case *Trigger_AfterAny_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AfterAny); err != nil {
			return err
		}
	case *Trigger_AfterEach_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AfterEach); err != nil {
			return err
		}
	case *Trigger_AfterEndOfWindow_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AfterEndOfWindow); err != nil {
			return err
		}
	case *Trigger_AfterProcessingTime_:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AfterProcessingTime); err != nil {
			return err
		}
	case *Trigger_AfterSynchronizedProcessingTime_:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AfterSynchronizedProcessingTime); err != nil {
			return err
		}
	case *Trigger_Always_:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Always); err != nil {
			return err
		}
	case *Trigger_Default_:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Default); err != nil {
			return err
		}
	case *Trigger_ElementCount_:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ElementCount); err != nil {
			return err
		}
	case *Trigger_Never_:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Never); err != nil {
			return err
		}
	case *Trigger_OrFinally_:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrFinally); err != nil {
			return err
		}
	case *Trigger_Repeat_:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Repeat); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Trigger.Trigger has unexpected type %T", x)
	}
	return nil
}

func _Trigger_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Trigger)
	switch tag {
	case 1: // trigger.after_all
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Trigger_AfterAll)
		err := b.DecodeMessage(msg)
		m.Trigger = &Trigger_AfterAll_{msg}
		return true, err
	case 2: // trigger.after_any
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Trigger_AfterAny)
		err := b.DecodeMessage(msg)
		m.Trigger = &Trigger_AfterAny_{msg}
		return true, err
	case 3: // trigger.after_each
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Trigger_AfterEach)
		err := b.DecodeMessage(msg)
		m.Trigger = &Trigger_AfterEach_{msg}
		return true, err
	case 4: // trigger.after_end_of_window
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Trigger_AfterEndOfWindow)
		err := b.DecodeMessage(msg)
		m.Trigger = &Trigger_AfterEndOfWindow_{msg}
		return true, err
	case 5: // trigger.after_processing_time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Trigger_AfterProcessingTime)
		err := b.DecodeMessage(msg)
		m.Trigger = &Trigger_AfterProcessingTime_{msg}
		return true, err
	case 6: // trigger.after_synchronized_processing_time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Trigger_AfterSynchronizedProcessingTime)
		err := b.DecodeMessage(msg)
		m.Trigger = &Trigger_AfterSynchronizedProcessingTime_{msg}
		return true, err
	case 12: // trigger.always
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Trigger_Always)
		err := b.DecodeMessage(msg)
		m.Trigger = &Trigger_Always_{msg}
		return true, err
	case 7: // trigger.default
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Trigger_Default)
		err := b.DecodeMessage(msg)
		m.Trigger = &Trigger_Default_{msg}
		return true, err
	case 8: // trigger.element_count
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Trigger_ElementCount)
		err := b.DecodeMessage(msg)
		m.Trigger = &Trigger_ElementCount_{msg}
		return true, err
	case 9: // trigger.never
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Trigger_Never)
		err := b.DecodeMessage(msg)
		m.Trigger = &Trigger_Never_{msg}
		return true, err
	case 10: // trigger.or_finally
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Trigger_OrFinally)
		err := b.DecodeMessage(msg)
		m.Trigger = &Trigger_OrFinally_{msg}
		return true, err
	case 11: // trigger.repeat
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Trigger_Repeat)
		err := b.DecodeMessage(msg)
		m.Trigger = &Trigger_Repeat_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Trigger_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Trigger)
	// trigger
	switch x := m.Trigger.(type) {
	case *Trigger_AfterAll_:
		s := proto.Size(x.AfterAll)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Trigger_AfterAny_:
		s := proto.Size(x.AfterAny)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Trigger_AfterEach_:
		s := proto.Size(x.AfterEach)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Trigger_AfterEndOfWindow_:
		s := proto.Size(x.AfterEndOfWindow)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Trigger_AfterProcessingTime_:
		s := proto.Size(x.AfterProcessingTime)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Trigger_AfterSynchronizedProcessingTime_:
		s := proto.Size(x.AfterSynchronizedProcessingTime)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Trigger_Always_:
		s := proto.Size(x.Always)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Trigger_Default_:
		s := proto.Size(x.Default)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Trigger_ElementCount_:
		s := proto.Size(x.ElementCount)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Trigger_Never_:
		s := proto.Size(x.Never)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Trigger_OrFinally_:
		s := proto.Size(x.OrFinally)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Trigger_Repeat_:
		s := proto.Size(x.Repeat)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Ready when all subtriggers are ready.
type Trigger_AfterAll struct {
	Subtriggers []*Trigger `protobuf:"bytes,1,rep,name=subtriggers" json:"subtriggers,omitempty"`
}

func (m *Trigger_AfterAll) Reset()                    { *m = Trigger_AfterAll{} }
func (m *Trigger_AfterAll) String() string            { return proto.CompactTextString(m) }
func (*Trigger_AfterAll) ProtoMessage()               {}
func (*Trigger_AfterAll) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 0} }

func (m *Trigger_AfterAll) GetSubtriggers() []*Trigger {
	if m != nil {
		return m.Subtriggers
	}
	return nil
}

// Ready when any subtrigger is ready.
type Trigger_AfterAny struct {
	Subtriggers []*Trigger `protobuf:"bytes,1,rep,name=subtriggers" json:"subtriggers,omitempty"`
}

func (m *Trigger_AfterAny) Reset()                    { *m = Trigger_AfterAny{} }
func (m *Trigger_AfterAny) String() string            { return proto.CompactTextString(m) }
func (*Trigger_AfterAny) ProtoMessage()               {}
func (*Trigger_AfterAny) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 1} }

func (m *Trigger_AfterAny) GetSubtriggers() []*Trigger {
	if m != nil {
		return m.Subtriggers
	}
	return nil
}

// Starting with the first subtrigger, ready when the _current_ subtrigger
// is ready. After output, advances the current trigger by one.
type Trigger_AfterEach struct {
	Subtriggers []*Trigger `protobuf:"bytes,1,rep,name=subtriggers" json:"subtriggers,omitempty"`
}

func (m *Trigger_AfterEach) Reset()                    { *m = Trigger_AfterEach{} }
func (m *Trigger_AfterEach) String() string            { return proto.CompactTextString(m) }
func (*Trigger_AfterEach) ProtoMessage()               {}
func (*Trigger_AfterEach) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 2} }

func (m *Trigger_AfterEach) GetSubtriggers() []*Trigger {
	if m != nil {
		return m.Subtriggers
	}
	return nil
}

// Ready after the input watermark is past the end of the window.
//
// May have implicitly-repeated subtriggers for early and late firings.
// When the end of the window is reached, the trigger transitions between
// the subtriggers.
type Trigger_AfterEndOfWindow struct {
	// (Optional) A trigger governing output prior to the end of the window.
	EarlyFirings *Trigger `protobuf:"bytes,1,opt,name=early_firings" json:"early_firings,omitempty"`
	// (Optional) A trigger governing output after the end of the window.
	LateFirings *Trigger `protobuf:"bytes,2,opt,name=late_firings" json:"late_firings,omitempty"`
}

func (m *Trigger_AfterEndOfWindow) Reset()                    { *m = Trigger_AfterEndOfWindow{} }
func (m *Trigger_AfterEndOfWindow) String() string            { return proto.CompactTextString(m) }
func (*Trigger_AfterEndOfWindow) ProtoMessage()               {}
func (*Trigger_AfterEndOfWindow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 3} }

func (m *Trigger_AfterEndOfWindow) GetEarlyFirings() *Trigger {
	if m != nil {
		return m.EarlyFirings
	}
	return nil
}

func (m *Trigger_AfterEndOfWindow) GetLateFirings() *Trigger {
	if m != nil {
		return m.LateFirings
	}
	return nil
}

// After input arrives, ready when the specified delay has passed.
type Trigger_AfterProcessingTime struct {
	// (Required) The transforms to apply to an arriving element's timestamp,
	// in order
	TimestampTransforms []*TimestampTransform `protobuf:"bytes,1,rep,name=timestamp_transforms" json:"timestamp_transforms,omitempty"`
}

func (m *Trigger_AfterProcessingTime) Reset()                    { *m = Trigger_AfterProcessingTime{} }
func (m *Trigger_AfterProcessingTime) String() string            { return proto.CompactTextString(m) }
func (*Trigger_AfterProcessingTime) ProtoMessage()               {}
func (*Trigger_AfterProcessingTime) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 4} }

func (m *Trigger_AfterProcessingTime) GetTimestampTransforms() []*TimestampTransform {
	if m != nil {
		return m.TimestampTransforms
	}
	return nil
}

// Ready whenever upstream processing time has all caught up with
// the arrival time of an input element
type Trigger_AfterSynchronizedProcessingTime struct {
}

func (m *Trigger_AfterSynchronizedProcessingTime) Reset() {
	*m = Trigger_AfterSynchronizedProcessingTime{}
}
func (m *Trigger_AfterSynchronizedProcessingTime) String() string { return proto.CompactTextString(m) }
func (*Trigger_AfterSynchronizedProcessingTime) ProtoMessage()    {}
func (*Trigger_AfterSynchronizedProcessingTime) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{21, 5}
}

// The default trigger. Equivalent to Repeat { AfterEndOfWindow } but
// specially denoted to indicate the user did not alter the triggering.
type Trigger_Default struct {
}

func (m *Trigger_Default) Reset()                    { *m = Trigger_Default{} }
func (m *Trigger_Default) String() string            { return proto.CompactTextString(m) }
func (*Trigger_Default) ProtoMessage()               {}
func (*Trigger_Default) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 6} }

// Ready whenever the requisite number of input elements have arrived
type Trigger_ElementCount struct {
	ElementCount int32 `protobuf:"varint,1,opt,name=element_count" json:"element_count,omitempty"`
}

func (m *Trigger_ElementCount) Reset()                    { *m = Trigger_ElementCount{} }
func (m *Trigger_ElementCount) String() string            { return proto.CompactTextString(m) }
func (*Trigger_ElementCount) ProtoMessage()               {}
func (*Trigger_ElementCount) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 7} }

func (m *Trigger_ElementCount) GetElementCount() int32 {
	if m != nil {
		return m.ElementCount
	}
	return 0
}

// Never ready. There will only be an ON_TIME output and a final
// output at window expiration.
type Trigger_Never struct {
}

func (m *Trigger_Never) Reset()                    { *m = Trigger_Never{} }
func (m *Trigger_Never) String() string            { return proto.CompactTextString(m) }
func (*Trigger_Never) ProtoMessage()               {}
func (*Trigger_Never) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 8} }

// Always ready. This can also be expressed as ElementCount(1) but
// is more explicit.
type Trigger_Always struct {
}

func (m *Trigger_Always) Reset()                    { *m = Trigger_Always{} }
func (m *Trigger_Always) String() string            { return proto.CompactTextString(m) }
func (*Trigger_Always) ProtoMessage()               {}
func (*Trigger_Always) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 9} }

// Ready whenever either of its subtriggers are ready, but finishes output
// when the finally subtrigger fires.
type Trigger_OrFinally struct {
	// (Required) Trigger governing main output; may fire repeatedly.
	Main *Trigger `protobuf:"bytes,1,opt,name=main" json:"main,omitempty"`
	// (Required) Trigger governing termination of output.
	Finally *Trigger `protobuf:"bytes,2,opt,name=finally" json:"finally,omitempty"`
}

func (m *Trigger_OrFinally) Reset()                    { *m = Trigger_OrFinally{} }
func (m *Trigger_OrFinally) String() string            { return proto.CompactTextString(m) }
func (*Trigger_OrFinally) ProtoMessage()               {}
func (*Trigger_OrFinally) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 10} }

func (m *Trigger_OrFinally) GetMain() *Trigger {
	if m != nil {
		return m.Main
	}
	return nil
}

func (m *Trigger_OrFinally) GetFinally() *Trigger {
	if m != nil {
		return m.Finally
	}
	return nil
}

// Ready whenever the subtrigger is ready; resets state when the subtrigger
// completes.
type Trigger_Repeat struct {
	// (Require) Trigger that is run repeatedly.
	Subtrigger *Trigger `protobuf:"bytes,1,opt,name=subtrigger" json:"subtrigger,omitempty"`
}

func (m *Trigger_Repeat) Reset()                    { *m = Trigger_Repeat{} }
func (m *Trigger_Repeat) String() string            { return proto.CompactTextString(m) }
func (*Trigger_Repeat) ProtoMessage()               {}
func (*Trigger_Repeat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 11} }

func (m *Trigger_Repeat) GetSubtrigger() *Trigger {
	if m != nil {
		return m.Subtrigger
	}
	return nil
}

// A specification for a transformation on a timestamp.
//
// Primarily used by AfterProcessingTime triggers to transform
// the arrival time of input to a target time for firing.
type TimestampTransform struct {
	// Types that are valid to be assigned to TimestampTransform:
	//	*TimestampTransform_Delay_
	//	*TimestampTransform_AlignTo_
	TimestampTransform isTimestampTransform_TimestampTransform `protobuf_oneof:"timestamp_transform"`
}

func (m *TimestampTransform) Reset()                    { *m = TimestampTransform{} }
func (m *TimestampTransform) String() string            { return proto.CompactTextString(m) }
func (*TimestampTransform) ProtoMessage()               {}
func (*TimestampTransform) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

type isTimestampTransform_TimestampTransform interface {
	isTimestampTransform_TimestampTransform()
}

type TimestampTransform_Delay_ struct {
	Delay *TimestampTransform_Delay `protobuf:"bytes,1,opt,name=delay,oneof"`
}
type TimestampTransform_AlignTo_ struct {
	AlignTo *TimestampTransform_AlignTo `protobuf:"bytes,2,opt,name=align_to,oneof"`
}

func (*TimestampTransform_Delay_) isTimestampTransform_TimestampTransform()   {}
func (*TimestampTransform_AlignTo_) isTimestampTransform_TimestampTransform() {}

func (m *TimestampTransform) GetTimestampTransform() isTimestampTransform_TimestampTransform {
	if m != nil {
		return m.TimestampTransform
	}
	return nil
}

func (m *TimestampTransform) GetDelay() *TimestampTransform_Delay {
	if x, ok := m.GetTimestampTransform().(*TimestampTransform_Delay_); ok {
		return x.Delay
	}
	return nil
}

func (m *TimestampTransform) GetAlignTo() *TimestampTransform_AlignTo {
	if x, ok := m.GetTimestampTransform().(*TimestampTransform_AlignTo_); ok {
		return x.AlignTo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TimestampTransform) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TimestampTransform_OneofMarshaler, _TimestampTransform_OneofUnmarshaler, _TimestampTransform_OneofSizer, []interface{}{
		(*TimestampTransform_Delay_)(nil),
		(*TimestampTransform_AlignTo_)(nil),
	}
}

func _TimestampTransform_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TimestampTransform)
	// timestamp_transform
	switch x := m.TimestampTransform.(type) {
	case *TimestampTransform_Delay_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Delay); err != nil {
			return err
		}
	case *TimestampTransform_AlignTo_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AlignTo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TimestampTransform.TimestampTransform has unexpected type %T", x)
	}
	return nil
}

func _TimestampTransform_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TimestampTransform)
	switch tag {
	case 1: // timestamp_transform.delay
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TimestampTransform_Delay)
		err := b.DecodeMessage(msg)
		m.TimestampTransform = &TimestampTransform_Delay_{msg}
		return true, err
	case 2: // timestamp_transform.align_to
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TimestampTransform_AlignTo)
		err := b.DecodeMessage(msg)
		m.TimestampTransform = &TimestampTransform_AlignTo_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TimestampTransform_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TimestampTransform)
	// timestamp_transform
	switch x := m.TimestampTransform.(type) {
	case *TimestampTransform_Delay_:
		s := proto.Size(x.Delay)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TimestampTransform_AlignTo_:
		s := proto.Size(x.AlignTo)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TimestampTransform_Delay struct {
	// (Required) The delay, in milliseconds.
	DelayMillis int64 `protobuf:"varint,1,opt,name=delay_millis" json:"delay_millis,omitempty"`
}

func (m *TimestampTransform_Delay) Reset()                    { *m = TimestampTransform_Delay{} }
func (m *TimestampTransform_Delay) String() string            { return proto.CompactTextString(m) }
func (*TimestampTransform_Delay) ProtoMessage()               {}
func (*TimestampTransform_Delay) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22, 0} }

func (m *TimestampTransform_Delay) GetDelayMillis() int64 {
	if m != nil {
		return m.DelayMillis
	}
	return 0
}

type TimestampTransform_AlignTo struct {
	// (Required) A duration to which delays should be quantized
	// in milliseconds.
	Period int64 `protobuf:"varint,3,opt,name=period" json:"period,omitempty"`
	// (Required) An offset from 0 for the quantization specified by
	// alignment_size, in milliseconds
	Offset int64 `protobuf:"varint,4,opt,name=offset" json:"offset,omitempty"`
}

func (m *TimestampTransform_AlignTo) Reset()                    { *m = TimestampTransform_AlignTo{} }
func (m *TimestampTransform_AlignTo) String() string            { return proto.CompactTextString(m) }
func (*TimestampTransform_AlignTo) ProtoMessage()               {}
func (*TimestampTransform_AlignTo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22, 1} }

func (m *TimestampTransform_AlignTo) GetPeriod() int64 {
	if m != nil {
		return m.Period
	}
	return 0
}

func (m *TimestampTransform_AlignTo) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

// A specification for how to "side input" a PCollection.
type SideInput struct {
	// (Required) URN of the access pattern required by the `view_fn` to present
	// the desired SDK-specific interface to a UDF.
	//
	// This access pattern defines the SDK harness <-> Runner Harness RPC
	// interface for accessing a side input.
	//
	// The only access pattern intended for Beam, because of its superior
	// performance possibilities, is "urn:beam:sideinput:multimap" (or some such
	// URN)
	AccessPattern *FunctionSpec `protobuf:"bytes,1,opt,name=access_pattern" json:"access_pattern,omitempty"`
	// (Required) The SdkFunctionSpec of the UDF that adapts a particular
	// access_pattern to a user-facing view type.
	//
	// For example, View.asSingleton() may include a `view_fn` that adapts a
	// specially-designed multimap to a single value per window.
	ViewFn *SdkFunctionSpec `protobuf:"bytes,2,opt,name=view_fn" json:"view_fn,omitempty"`
	// (Required) The SdkFunctionSpec of the UDF that maps a main input window
	// to a side input window.
	//
	// For example, when the main input is in fixed windows of one hour, this
	// can specify that the side input should be accessed according to the day
	// in which that hour falls.
	WindowMappingFn *SdkFunctionSpec `protobuf:"bytes,3,opt,name=window_mapping_fn" json:"window_mapping_fn,omitempty"`
}

func (m *SideInput) Reset()                    { *m = SideInput{} }
func (m *SideInput) String() string            { return proto.CompactTextString(m) }
func (*SideInput) ProtoMessage()               {}
func (*SideInput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *SideInput) GetAccessPattern() *FunctionSpec {
	if m != nil {
		return m.AccessPattern
	}
	return nil
}

func (m *SideInput) GetViewFn() *SdkFunctionSpec {
	if m != nil {
		return m.ViewFn
	}
	return nil
}

func (m *SideInput) GetWindowMappingFn() *SdkFunctionSpec {
	if m != nil {
		return m.WindowMappingFn
	}
	return nil
}

// An environment for executing UDFs. Generally an SDK container URL, but
// there can be many for a single SDK, for example to provide dependency
// isolation.
type Environment struct {
	// (Required) The URL of a container
	//
	// TODO: reconcile with Fn API's DockerContainer structure by
	// adding adequate metadata to know how to interpret the container
	Url string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
}

func (m *Environment) Reset()                    { *m = Environment{} }
func (m *Environment) String() string            { return proto.CompactTextString(m) }
func (*Environment) ProtoMessage()               {}
func (*Environment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *Environment) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// A specification of a user defined function.
//
type SdkFunctionSpec struct {
	// (Required) A full specification of this function.
	Spec *FunctionSpec `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	// (Required) Reference to an execution environment capable of
	// invoking this function.
	EnvironmentId string `protobuf:"bytes,2,opt,name=environment_id" json:"environment_id,omitempty"`
}

func (m *SdkFunctionSpec) Reset()                    { *m = SdkFunctionSpec{} }
func (m *SdkFunctionSpec) String() string            { return proto.CompactTextString(m) }
func (*SdkFunctionSpec) ProtoMessage()               {}
func (*SdkFunctionSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *SdkFunctionSpec) GetSpec() *FunctionSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SdkFunctionSpec) GetEnvironmentId() string {
	if m != nil {
		return m.EnvironmentId
	}
	return ""
}

// A URN along with a parameter object whose schema is determined by the
// URN.
//
// This structure is reused in two distinct, but compatible, ways:
//
// 1. This can be a specification of the function over PCollections
//    that a PTransform computes.
// 2. This can be a specification of a user-defined function, possibly
//    SDK-specific. (external to this message must be adequate context
//    to indicate the environment in which the UDF can be understood).
//
// Though not explicit in this proto, there are two possibilities
// for the relationship of a runner to this specification that
// one should bear in mind:
//
// 1. The runner understands the URN. For example, it might be
//    a well-known URN like "urn:beam:transform:Top" or
//    "urn:beam:windowfn:FixedWindows" with
//    an agreed-upon payload (e.g. a number or duration,
//    respectively).
// 2. The runner does not understand the URN. It might be an
//    SDK specific URN such as "urn:beam:dofn:javasdk:1.0"
//    that indicates to the SDK what the payload is,
//    such as a serialized Java DoFn from a particular
//    version of the Beam Java SDK. The payload will often
//    then be an opaque message such as bytes in a
//    language-specific serialization format.
type FunctionSpec struct {
	// (Required) A URN that describes the accompanying payload.
	// For any URN that is not recognized (by whomever is inspecting
	// it) the parameter payload should be treated as opaque and
	// passed as-is.
	Urn string `protobuf:"bytes,1,opt,name=urn" json:"urn,omitempty"`
	// (Optional) The data specifying any parameters to the URN. If
	// the URN does not require any arguments, this may be omitted.
	Parameter *google_protobuf.Any `protobuf:"bytes,2,opt,name=parameter" json:"parameter,omitempty"`
}

func (m *FunctionSpec) Reset()                    { *m = FunctionSpec{} }
func (m *FunctionSpec) String() string            { return proto.CompactTextString(m) }
func (*FunctionSpec) ProtoMessage()               {}
func (*FunctionSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *FunctionSpec) GetUrn() string {
	if m != nil {
		return m.Urn
	}
	return ""
}

func (m *FunctionSpec) GetParameter() *google_protobuf.Any {
	if m != nil {
		return m.Parameter
	}
	return nil
}

// TODO: transfer javadoc here
type DisplayData struct {
	// (Required) The list of display data.
	Items []*DisplayData_Item `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *DisplayData) Reset()                    { *m = DisplayData{} }
func (m *DisplayData) String() string            { return proto.CompactTextString(m) }
func (*DisplayData) ProtoMessage()               {}
func (*DisplayData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *DisplayData) GetItems() []*DisplayData_Item {
	if m != nil {
		return m.Items
	}
	return nil
}

// A complete identifier for a DisplayData.Item
type DisplayData_Identifier struct {
	// (Required) The transform originating this display data.
	TransformId string `protobuf:"bytes,1,opt,name=transform_id" json:"transform_id,omitempty"`
	// (Optional) The URN indicating the type of the originating transform,
	// if there is one.
	TransformUrn string `protobuf:"bytes,2,opt,name=transform_urn" json:"transform_urn,omitempty"`
	Key          string `protobuf:"bytes,3,opt,name=key" json:"key,omitempty"`
}

func (m *DisplayData_Identifier) Reset()                    { *m = DisplayData_Identifier{} }
func (m *DisplayData_Identifier) String() string            { return proto.CompactTextString(m) }
func (*DisplayData_Identifier) ProtoMessage()               {}
func (*DisplayData_Identifier) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27, 0} }

func (m *DisplayData_Identifier) GetTransformId() string {
	if m != nil {
		return m.TransformId
	}
	return ""
}

func (m *DisplayData_Identifier) GetTransformUrn() string {
	if m != nil {
		return m.TransformUrn
	}
	return ""
}

func (m *DisplayData_Identifier) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// A single item of display data.
type DisplayData_Item struct {
	// (Required)
	Id *DisplayData_Identifier `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// (Required)
	Type DisplayData_Type `protobuf:"varint,2,opt,name=type,enum=org.apache.beam.runner_api.v1.DisplayData_Type" json:"type,omitempty"`
	// (Required)
	Value *google_protobuf.Any `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	// (Optional)
	ShortValue *google_protobuf.Any `protobuf:"bytes,4,opt,name=short_value" json:"short_value,omitempty"`
	// (Optional)
	Label string `protobuf:"bytes,5,opt,name=label" json:"label,omitempty"`
	// (Optional)
	LinkUrl string `protobuf:"bytes,6,opt,name=link_url" json:"link_url,omitempty"`
}

func (m *DisplayData_Item) Reset()                    { *m = DisplayData_Item{} }
func (m *DisplayData_Item) String() string            { return proto.CompactTextString(m) }
func (*DisplayData_Item) ProtoMessage()               {}
func (*DisplayData_Item) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27, 1} }

func (m *DisplayData_Item) GetId() *DisplayData_Identifier {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *DisplayData_Item) GetType() DisplayData_Type {
	if m != nil {
		return m.Type
	}
	return DisplayData_STRING
}

func (m *DisplayData_Item) GetValue() *google_protobuf.Any {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *DisplayData_Item) GetShortValue() *google_protobuf.Any {
	if m != nil {
		return m.ShortValue
	}
	return nil
}

func (m *DisplayData_Item) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *DisplayData_Item) GetLinkUrl() string {
	if m != nil {
		return m.LinkUrl
	}
	return ""
}

func init() {
	proto.RegisterType((*Components)(nil), "org.apache.beam.runner_api.v1.Components")
	proto.RegisterType((*MessageWithComponents)(nil), "org.apache.beam.runner_api.v1.MessageWithComponents")
	proto.RegisterType((*Pipeline)(nil), "org.apache.beam.runner_api.v1.Pipeline")
	proto.RegisterType((*PTransform)(nil), "org.apache.beam.runner_api.v1.PTransform")
	proto.RegisterType((*PCollection)(nil), "org.apache.beam.runner_api.v1.PCollection")
	proto.RegisterType((*ParDoPayload)(nil), "org.apache.beam.runner_api.v1.ParDoPayload")
	proto.RegisterType((*Parameter)(nil), "org.apache.beam.runner_api.v1.Parameter")
	proto.RegisterType((*StateSpec)(nil), "org.apache.beam.runner_api.v1.StateSpec")
	proto.RegisterType((*ValueStateSpec)(nil), "org.apache.beam.runner_api.v1.ValueStateSpec")
	proto.RegisterType((*BagStateSpec)(nil), "org.apache.beam.runner_api.v1.BagStateSpec")
	proto.RegisterType((*CombiningStateSpec)(nil), "org.apache.beam.runner_api.v1.CombiningStateSpec")
	proto.RegisterType((*MapStateSpec)(nil), "org.apache.beam.runner_api.v1.MapStateSpec")
	proto.RegisterType((*SetStateSpec)(nil), "org.apache.beam.runner_api.v1.SetStateSpec")
	proto.RegisterType((*TimerSpec)(nil), "org.apache.beam.runner_api.v1.TimerSpec")
	proto.RegisterType((*ReadPayload)(nil), "org.apache.beam.runner_api.v1.ReadPayload")
	proto.RegisterType((*WindowIntoPayload)(nil), "org.apache.beam.runner_api.v1.WindowIntoPayload")
	proto.RegisterType((*CombinePayload)(nil), "org.apache.beam.runner_api.v1.CombinePayload")
	proto.RegisterType((*TestStreamPayload)(nil), "org.apache.beam.runner_api.v1.TestStreamPayload")
	proto.RegisterType((*TestStreamPayload_Event)(nil), "org.apache.beam.runner_api.v1.TestStreamPayload.Event")
	proto.RegisterType((*TestStreamPayload_Event_AdvanceWatermark)(nil), "org.apache.beam.runner_api.v1.TestStreamPayload.Event.AdvanceWatermark")
	proto.RegisterType((*TestStreamPayload_Event_AdvanceProcessingTime)(nil), "org.apache.beam.runner_api.v1.TestStreamPayload.Event.AdvanceProcessingTime")
	proto.RegisterType((*TestStreamPayload_Event_AddElements)(nil), "org.apache.beam.runner_api.v1.TestStreamPayload.Event.AddElements")
	proto.RegisterType((*TestStreamPayload_TimestampedElement)(nil), "org.apache.beam.runner_api.v1.TestStreamPayload.TimestampedElement")
	proto.RegisterType((*WriteFilesPayload)(nil), "org.apache.beam.runner_api.v1.WriteFilesPayload")
	proto.RegisterType((*Coder)(nil), "org.apache.beam.runner_api.v1.Coder")
	proto.RegisterType((*WindowingStrategy)(nil), "org.apache.beam.runner_api.v1.WindowingStrategy")
	proto.RegisterType((*Trigger)(nil), "org.apache.beam.runner_api.v1.Trigger")
	proto.RegisterType((*Trigger_AfterAll)(nil), "org.apache.beam.runner_api.v1.Trigger.AfterAll")
	proto.RegisterType((*Trigger_AfterAny)(nil), "org.apache.beam.runner_api.v1.Trigger.AfterAny")
	proto.RegisterType((*Trigger_AfterEach)(nil), "org.apache.beam.runner_api.v1.Trigger.AfterEach")
	proto.RegisterType((*Trigger_AfterEndOfWindow)(nil), "org.apache.beam.runner_api.v1.Trigger.AfterEndOfWindow")
	proto.RegisterType((*Trigger_AfterProcessingTime)(nil), "org.apache.beam.runner_api.v1.Trigger.AfterProcessingTime")
	proto.RegisterType((*Trigger_AfterSynchronizedProcessingTime)(nil), "org.apache.beam.runner_api.v1.Trigger.AfterSynchronizedProcessingTime")
	proto.RegisterType((*Trigger_Default)(nil), "org.apache.beam.runner_api.v1.Trigger.Default")
	proto.RegisterType((*Trigger_ElementCount)(nil), "org.apache.beam.runner_api.v1.Trigger.ElementCount")
	proto.RegisterType((*Trigger_Never)(nil), "org.apache.beam.runner_api.v1.Trigger.Never")
	proto.RegisterType((*Trigger_Always)(nil), "org.apache.beam.runner_api.v1.Trigger.Always")
	proto.RegisterType((*Trigger_OrFinally)(nil), "org.apache.beam.runner_api.v1.Trigger.OrFinally")
	proto.RegisterType((*Trigger_Repeat)(nil), "org.apache.beam.runner_api.v1.Trigger.Repeat")
	proto.RegisterType((*TimestampTransform)(nil), "org.apache.beam.runner_api.v1.TimestampTransform")
	proto.RegisterType((*TimestampTransform_Delay)(nil), "org.apache.beam.runner_api.v1.TimestampTransform.Delay")
	proto.RegisterType((*TimestampTransform_AlignTo)(nil), "org.apache.beam.runner_api.v1.TimestampTransform.AlignTo")
	proto.RegisterType((*SideInput)(nil), "org.apache.beam.runner_api.v1.SideInput")
	proto.RegisterType((*Environment)(nil), "org.apache.beam.runner_api.v1.Environment")
	proto.RegisterType((*SdkFunctionSpec)(nil), "org.apache.beam.runner_api.v1.SdkFunctionSpec")
	proto.RegisterType((*FunctionSpec)(nil), "org.apache.beam.runner_api.v1.FunctionSpec")
	proto.RegisterType((*DisplayData)(nil), "org.apache.beam.runner_api.v1.DisplayData")
	proto.RegisterType((*DisplayData_Identifier)(nil), "org.apache.beam.runner_api.v1.DisplayData.Identifier")
	proto.RegisterType((*DisplayData_Item)(nil), "org.apache.beam.runner_api.v1.DisplayData.Item")
	proto.RegisterEnum("org.apache.beam.runner_api.v1.IsBounded", IsBounded_name, IsBounded_value)
	proto.RegisterEnum("org.apache.beam.runner_api.v1.MergeStatus", MergeStatus_name, MergeStatus_value)
	proto.RegisterEnum("org.apache.beam.runner_api.v1.AccumulationMode", AccumulationMode_name, AccumulationMode_value)
	proto.RegisterEnum("org.apache.beam.runner_api.v1.ClosingBehavior", ClosingBehavior_name, ClosingBehavior_value)
	proto.RegisterEnum("org.apache.beam.runner_api.v1.OutputTime", OutputTime_name, OutputTime_value)
	proto.RegisterEnum("org.apache.beam.runner_api.v1.TimeDomain", TimeDomain_name, TimeDomain_value)
	proto.RegisterEnum("org.apache.beam.runner_api.v1.Parameter_Type", Parameter_Type_name, Parameter_Type_value)
	proto.RegisterEnum("org.apache.beam.runner_api.v1.DisplayData_Type", DisplayData_Type_name, DisplayData_Type_value)
}

func init() { proto.RegisterFile("beam_runner_api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2769 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x5a, 0x5b, 0x73, 0x22, 0xc7,
	0x15, 0xe6, 0x7e, 0x39, 0x20, 0x84, 0x5a, 0x2b, 0x9b, 0x22, 0x76, 0x65, 0x43, 0x9c, 0x78, 0x57,
	0x89, 0x91, 0xd7, 0x97, 0xac, 0xed, 0xbd, 0x79, 0x80, 0x91, 0xc0, 0x2b, 0x01, 0x01, 0xb4, 0xaa,
	0x8d, 0x53, 0x35, 0x69, 0x98, 0x06, 0x4d, 0x69, 0xe8, 0x99, 0xcc, 0x0c, 0x52, 0xe1, 0xe7, 0xbc,
	0xa5, 0xe2, 0xfc, 0x89, 0x54, 0xe5, 0x25, 0x79, 0xcd, 0x1f, 0xc9, 0x5b, 0x2a, 0x2f, 0xc9, 0x53,
	0xfe, 0x41, 0x2a, 0x6f, 0xa9, 0xee, 0x1e, 0x86, 0x01, 0x6c, 0x33, 0x23, 0x25, 0x0f, 0x5b, 0x0b,
	0x43, 0x9f, 0xef, 0x74, 0x9f, 0x3e, 0xe7, 0x3b, 0x97, 0x11, 0x1c, 0x0c, 0x09, 0x9e, 0x2a, 0xd6,
	0x8c, 0x52, 0x62, 0x29, 0xd8, 0xd4, 0xaa, 0xa6, 0x65, 0x38, 0x06, 0x7a, 0xdb, 0xb0, 0x26, 0x55,
	0x6c, 0xe2, 0xd1, 0x25, 0xa9, 0xb2, 0x15, 0x55, 0xdf, 0x8a, 0xeb, 0x47, 0xe5, 0xa3, 0x89, 0xe6,
	0x5c, 0xce, 0x86, 0xd5, 0x91, 0x31, 0x3d, 0x9a, 0x18, 0x3a, 0xa6, 0x93, 0x23, 0x2e, 0x37, 0x9c,
	0x8d, 0x8f, 0x4c, 0x67, 0x6e, 0x12, 0xfb, 0x08, 0xd3, 0x39, 0xfb, 0x27, 0xf0, 0x2a, 0xbf, 0x4b,
	0x03, 0xd4, 0x8d, 0xa9, 0x69, 0x50, 0x42, 0x1d, 0x1b, 0x9d, 0x01, 0x38, 0x16, 0xa6, 0xf6, 0xd8,
	0xb0, 0xa6, 0x76, 0x29, 0x7a, 0x3f, 0xfe, 0x20, 0xf7, 0xc1, 0xa7, 0xd5, 0xef, 0xd4, 0x59, 0x5d,
	0x8a, 0x57, 0x07, 0x9e, 0xac, 0x4c, 0x1d, 0x6b, 0x8e, 0x7e, 0x0e, 0x79, 0x73, 0x64, 0xe8, 0x3a,
	0x19, 0x39, 0x9a, 0x41, 0xed, 0x52, 0x8c, 0x03, 0x3e, 0x09, 0x0e, 0xd8, 0xf5, 0x49, 0x0b, 0xc8,
	0x5f, 0xc1, 0xbd, 0x1b, 0x8d, 0xaa, 0xc6, 0x8d, 0x46, 0x27, 0x8a, 0xed, 0x58, 0xd8, 0x21, 0x13,
	0x8d, 0xd8, 0xa5, 0x38, 0x87, 0xae, 0x05, 0x87, 0xbe, 0x58, 0xa0, 0xf4, 0x3d, 0x10, 0xa1, 0x41,
	0x86, 0xd4, 0xc8, 0x50, 0x89, 0x65, 0x97, 0x12, 0x1c, 0xf3, 0xe3, 0xe0, 0x98, 0x75, 0x2e, 0xe7,
	0x9d, 0x9d, 0xd0, 0x6b, 0xcd, 0x32, 0xe8, 0x94, 0xfd, 0x56, 0x4a, 0x86, 0x3d, 0xbb, 0xec, 0x93,
	0xe6, 0x90, 0xe5, 0x5f, 0xc2, 0xee, 0xba, 0x85, 0x73, 0x10, 0xbf, 0x22, 0xf3, 0x52, 0xf4, 0x7e,
	0xf4, 0x41, 0x16, 0x7d, 0x02, 0xc9, 0x6b, 0xac, 0xcf, 0x48, 0x29, 0x76, 0x3f, 0xfa, 0x20, 0xf7,
	0xc1, 0xc3, 0x2d, 0xba, 0xba, 0x1e, 0xd8, 0x67, 0xb1, 0x4f, 0xa2, 0x65, 0x05, 0xf6, 0x36, 0xcd,
	0xbd, 0x82, 0xff, 0xe9, 0x2a, 0xfe, 0xe1, 0x36, 0xfc, 0xba, 0x87, 0xc6, 0x15, 0xe8, 0x50, 0xfa,
	0x56, 0xa3, 0xaf, 0xe8, 0x79, 0xb1, 0xaa, 0xe7, 0xfd, 0x2d, 0x7a, 0xd6, 0x41, 0xe7, 0x5c, 0x5b,
	0x1f, 0x72, 0xfe, 0xeb, 0x58, 0x51, 0xf0, 0xe1, 0xaa, 0x82, 0x77, 0xb6, 0x5e, 0x8a, 0x4a, 0xac,
	0x85, 0x8d, 0x36, 0xae, 0xe5, 0x4e, 0x36, 0xf2, 0xa1, 0x31, 0x05, 0x95, 0x7f, 0xa6, 0xe0, 0xe0,
	0x8c, 0xd8, 0x36, 0x9e, 0x90, 0x0b, 0xcd, 0xb9, 0xf4, 0x85, 0xe6, 0x33, 0x80, 0x91, 0xf7, 0x8d,
	0x2b, 0xdb, 0x7e, 0xc3, 0x3e, 0xf1, 0x8f, 0x21, 0xc9, 0xbd, 0x3a, 0xcc, 0x91, 0x9b, 0x11, 0xd4,
	0x84, 0xdd, 0x91, 0x31, 0x1d, 0x6a, 0x94, 0x28, 0x26, 0x9e, 0xeb, 0x06, 0x56, 0x4b, 0x71, 0x0e,
	0xf0, 0xde, 0x76, 0xd5, 0x4c, 0xaa, 0x2b, 0x84, 0x9a, 0x11, 0xf4, 0x12, 0xf6, 0x6c, 0xf5, 0x4a,
	0x19, 0xcf, 0x28, 0xf7, 0x08, 0xc5, 0x36, 0xc9, 0xa8, 0x94, 0xe0, 0x58, 0xd5, 0x2d, 0x58, 0x7d,
	0xf5, 0xea, 0xd8, 0x15, 0xeb, 0x9b, 0x64, 0xd4, 0x8c, 0x20, 0x19, 0x0a, 0x26, 0xb6, 0x14, 0xd5,
	0xf0, 0x76, 0x95, 0xe2, 0x48, 0x3f, 0xd9, 0xe6, 0x92, 0xd8, 0x6a, 0x18, 0xcb, 0x3d, 0xbd, 0x00,
	0x30, 0x3d, 0xbe, 0x2b, 0xa5, 0x43, 0x46, 0x4d, 0x33, 0x82, 0x24, 0xc8, 0xf9, 0x08, 0xae, 0x94,
	0x09, 0x1b, 0x17, 0xcd, 0x08, 0xaa, 0x41, 0xde, 0x22, 0x58, 0xf5, 0x0e, 0x92, 0x0d, 0x84, 0xd1,
	0x23, 0x58, 0x5d, 0x9e, 0xe3, 0x39, 0x80, 0xad, 0xa9, 0x44, 0xd1, 0xa8, 0x39, 0x73, 0x4a, 0x39,
	0x8e, 0xf0, 0x60, 0x9b, 0x51, 0x35, 0x95, 0xb4, 0xd8, 0xfa, 0x66, 0x04, 0x75, 0x60, 0x5f, 0x90,
	0xaa, 0xa2, 0x51, 0x67, 0x69, 0xd3, 0x7c, 0x88, 0xf0, 0x6b, 0x51, 0xc7, 0x67, 0xd8, 0x36, 0xa0,
	0x0d, 0x96, 0x9e, 0x97, 0x76, 0x6e, 0x17, 0xce, 0xcd, 0x08, 0x6a, 0xc0, 0xce, 0xaa, 0xe3, 0x14,
	0x02, 0x5d, 0xf7, 0xaa, 0xd7, 0xd4, 0x52, 0x90, 0xb0, 0x0c, 0xc3, 0xa9, 0xfc, 0x31, 0x0a, 0x99,
	0xae, 0x66, 0x12, 0x5d, 0xa3, 0xe4, 0xae, 0x71, 0x55, 0x06, 0xc4, 0x30, 0x15, 0xcf, 0x8d, 0x14,
	0x4d, 0x15, 0x89, 0x2e, 0x8b, 0x3e, 0x87, 0xbc, 0xaa, 0xd9, 0xa6, 0x8e, 0xe7, 0x8a, 0x8a, 0x1d,
	0xec, 0x46, 0xce, 0xb6, 0xab, 0x6d, 0x08, 0x91, 0x06, 0x76, 0x70, 0xe5, 0x0f, 0x71, 0x80, 0xa5,
	0xc3, 0xa1, 0x7d, 0xc8, 0xcd, 0xa8, 0xf6, 0xeb, 0x19, 0x51, 0x28, 0x9e, 0x92, 0x52, 0xd2, 0x65,
	0x9c, 0x04, 0x37, 0x49, 0x34, 0xb4, 0x49, 0xd0, 0x01, 0xec, 0xd8, 0xb3, 0xa1, 0x2f, 0xe3, 0x8b,
	0x7d, 0xcb, 0x90, 0xe2, 0x9e, 0xb4, 0xc8, 0xaa, 0x1f, 0x07, 0x0e, 0x89, 0x2a, 0xf7, 0x28, 0x97,
	0x17, 0x4f, 0x20, 0x6d, 0xcc, 0x1c, 0x8e, 0x23, 0x32, 0xe9, 0xcf, 0x82, 0xe3, 0x74, 0x84, 0xa0,
	0x00, 0x5a, 0xb7, 0x63, 0x2a, 0xac, 0x1d, 0xcb, 0xef, 0x41, 0xce, 0xbf, 0xb3, 0x15, 0xc6, 0xde,
	0xf1, 0x33, 0x76, 0x96, 0xd3, 0x7c, 0x15, 0xf2, 0x2b, 0x1b, 0xd8, 0xb2, 0xbe, 0xf2, 0xd7, 0x28,
	0xe4, 0x7c, 0x51, 0xbd, 0x7e, 0x4f, 0x42, 0xae, 0x08, 0x19, 0xce, 0xc0, 0x8a, 0xa6, 0x0a, 0x51,
	0xf4, 0x14, 0x40, 0xb3, 0x95, 0xa1, 0x31, 0xa3, 0x2a, 0x11, 0xbc, 0x5a, 0xd8, 0x1a, 0xb6, 0x2d,
	0xbb, 0x26, 0xd6, 0xa3, 0xb7, 0xe1, 0x60, 0x33, 0xc6, 0x18, 0x78, 0x82, 0x83, 0xaf, 0x1b, 0x2d,
	0x19, 0xda, 0xf9, 0xfe, 0x94, 0x84, 0xbc, 0x9f, 0x30, 0xd1, 0x33, 0x48, 0xaa, 0x86, 0x32, 0xa6,
	0xae, 0xab, 0x85, 0xa4, 0x6d, 0x76, 0x5c, 0x13, 0x5b, 0x78, 0x4a, 0x1c, 0x56, 0x5c, 0x89, 0x5a,
	0xf0, 0xc1, 0x76, 0xc2, 0x16, 0x02, 0xa8, 0x0b, 0xb9, 0x25, 0xc7, 0x2d, 0x3c, 0xf3, 0x49, 0x08,
	0xbe, 0x5f, 0x32, 0x9e, 0x7b, 0xab, 0x0c, 0xd1, 0xc1, 0x0e, 0xe1, 0x8c, 0xb2, 0xf0, 0xd1, 0x70,
	0x88, 0x4c, 0x9c, 0x9d, 0x6d, 0x89, 0xe8, 0x68, 0x53, 0x62, 0xb9, 0x88, 0xc9, 0xf0, 0x88, 0x03,
	0x26, 0xee, 0x43, 0x44, 0x00, 0xb6, 0xa9, 0x6b, 0x8e, 0x83, 0x87, 0x3a, 0xe1, 0x8e, 0x9f, 0x29,
	0x7f, 0x09, 0xbb, 0xeb, 0x47, 0x59, 0x71, 0xd0, 0xc7, 0xab, 0x25, 0x48, 0xe0, 0x44, 0xc0, 0x5d,
	0x9f, 0x81, 0xaf, 0x9d, 0xea, 0x4e, 0xe0, 0x0b, 0xac, 0x05, 0xf8, 0xfa, 0x01, 0xef, 0x02, 0xee,
	0x61, 0xf1, 0x20, 0xfc, 0x6d, 0x14, 0xb2, 0x4b, 0x77, 0x79, 0x02, 0x09, 0xd6, 0xef, 0x70, 0xe0,
	0xc2, 0xd6, 0x6a, 0xc5, 0x93, 0xab, 0x0e, 0xe6, 0x26, 0xa9, 0x48, 0x90, 0x60, 0xff, 0x23, 0x80,
	0xd4, 0x45, 0xab, 0xdd, 0xe8, 0x5c, 0x14, 0x23, 0xe8, 0x1e, 0x14, 0xbb, 0xad, 0xae, 0x7c, 0xda,
	0x6a, 0xcb, 0x4a, 0xa7, 0x3b, 0x68, 0x75, 0xda, 0xfd, 0x62, 0x14, 0xbd, 0x09, 0xfb, 0x3d, 0xb9,
	0x3f, 0xe8, 0xb5, 0xea, 0xec, 0x89, 0x32, 0xe8, 0x49, 0xf5, 0x97, 0x72, 0xaf, 0x18, 0xab, 0xfc,
	0x2b, 0x06, 0x59, 0xef, 0xf0, 0xa8, 0x0e, 0xc0, 0x0f, 0xa6, 0xf8, 0x98, 0x7a, 0xdb, 0x9e, 0x5e,
	0x31, 0x01, 0x0f, 0x82, 0x57, 0x2b, 0x99, 0x21, 0x9e, 0x08, 0x88, 0x58, 0x20, 0xb2, 0xaf, 0xe1,
	0x89, 0x1f, 0xe0, 0x25, 0x14, 0x44, 0x31, 0xc7, 0x19, 0x83, 0xc1, 0x88, 0x8c, 0xf4, 0x28, 0x50,
	0x2d, 0xc7, 0x33, 0xf2, 0xca, 0x6e, 0xa6, 0xd8, 0xf4, 0x97, 0x71, 0xdb, 0x76, 0x73, 0x86, 0xcd,
	0x35, 0x00, 0x9b, 0x38, 0x02, 0x20, 0x19, 0x08, 0xa0, 0x4f, 0x1c, 0x1f, 0x00, 0x4b, 0xe7, 0x4c,
	0xb8, 0x52, 0x81, 0xc2, 0xaa, 0xad, 0x56, 0xa8, 0x96, 0x7b, 0x56, 0xe5, 0x01, 0xe4, 0xfd, 0xc6,
	0x40, 0x25, 0x28, 0x12, 0x9d, 0xb0, 0xb2, 0x5b, 0x59, 0x5b, 0x79, 0x0d, 0x68, 0xf3, 0xbc, 0xe8,
	0x2d, 0xb8, 0x87, 0x47, 0xa3, 0xd9, 0x74, 0xa6, 0x63, 0xc7, 0xb0, 0xd6, 0x64, 0x50, 0x8d, 0xd7,
	0x10, 0xbc, 0x4a, 0x1e, 0x53, 0xf7, 0x6e, 0x42, 0xb2, 0x63, 0xe5, 0x29, 0xe4, 0xfd, 0x06, 0x42,
	0xf7, 0x20, 0x7f, 0x45, 0xe6, 0xeb, 0x9a, 0xde, 0x80, 0x82, 0x70, 0xa4, 0xd5, 0x54, 0xc2, 0xce,
	0xe7, 0xb7, 0xce, 0x77, 0x9c, 0xef, 0x25, 0x64, 0xbd, 0xb8, 0x41, 0xcf, 0x05, 0x61, 0x29, 0xaa,
	0x31, 0xc5, 0x1a, 0x75, 0x83, 0xe5, 0x61, 0x80, 0xb0, 0x6b, 0x70, 0x01, 0x16, 0x73, 0x39, 0x5f,
	0x29, 0x8a, 0x9e, 0x43, 0xca, 0x36, 0x66, 0xd6, 0x88, 0xdc, 0x3e, 0x45, 0xf8, 0x32, 0x62, 0x2c,
	0x5c, 0x46, 0xac, 0xbc, 0x82, 0xbd, 0x8d, 0x62, 0x14, 0x49, 0x90, 0x75, 0x6b, 0xdb, 0xdb, 0x26,
	0xae, 0xca, 0x3f, 0x62, 0x50, 0x58, 0xed, 0x67, 0xd6, 0x6e, 0xfc, 0x76, 0x87, 0xfd, 0x36, 0x9f,
	0xf2, 0x8a, 0x03, 0x5f, 0xb6, 0x8c, 0x87, 0xcc, 0x96, 0xbd, 0xd5, 0x6c, 0x29, 0x72, 0xdb, 0xb3,
	0x50, 0x3d, 0xdb, 0x7a, 0xbe, 0xfc, 0xbf, 0xe6, 0x9d, 0xca, 0x5f, 0x92, 0xb0, 0x37, 0x20, 0xb6,
	0xd3, 0x77, 0x2c, 0x82, 0xa7, 0x0b, 0x33, 0x6f, 0x04, 0x32, 0x3a, 0x86, 0x14, 0xb9, 0xe6, 0xa5,
	0x7a, 0x2c, 0x50, 0x4d, 0xb9, 0x81, 0x59, 0x95, 0x99, 0x78, 0xf9, 0x37, 0x09, 0x48, 0xf2, 0x4f,
	0x68, 0x08, 0xbb, 0x37, 0xd8, 0x21, 0xd6, 0x14, 0x5b, 0x57, 0x0a, 0xc7, 0x76, 0xef, 0xf3, 0xe4,
	0x76, 0xd0, 0x55, 0x49, 0xbd, 0xc6, 0x74, 0x44, 0x2e, 0x16, 0xa0, 0xcd, 0x08, 0x9a, 0xc2, 0x81,
	0x69, 0x19, 0x23, 0x62, 0xdb, 0x8c, 0x7a, 0x79, 0xc8, 0x09, 0x4d, 0xc2, 0x54, 0xa7, 0x77, 0xd3,
	0xd4, 0xf5, 0xa0, 0x59, 0x68, 0x36, 0x23, 0xe8, 0x4b, 0xd8, 0x59, 0x44, 0xbf, 0x50, 0x23, 0x78,
	0xbe, 0x76, 0x6b, 0x35, 0xaa, 0x2c, 0xe0, 0xec, 0x66, 0xa4, 0xfc, 0x10, 0x8a, 0xeb, 0x27, 0x64,
	0x8d, 0x04, 0x25, 0x37, 0x8a, 0x67, 0x47, 0x6e, 0xc1, 0x78, 0xf9, 0x11, 0x1c, 0x7c, 0xe3, 0x16,
	0x19, 0x3d, 0x61, 0xf1, 0x83, 0xa2, 0xce, 0x2c, 0xcc, 0x9b, 0x67, 0x21, 0xa2, 0x42, 0xce, 0xa7,
	0x0e, 0x9d, 0x43, 0xc6, 0x3d, 0xc9, 0x62, 0x1c, 0x59, 0x0f, 0x7d, 0x08, 0xa6, 0xd1, 0x76, 0xf0,
	0xd4, 0x24, 0x0b, 0xdc, 0x5a, 0x1a, 0x92, 0xdc, 0x30, 0xe5, 0xcf, 0x01, 0x6d, 0xfe, 0x8c, 0xde,
	0x84, 0x5d, 0x42, 0x99, 0xe3, 0xa9, 0x8a, 0xab, 0x9d, 0xef, 0x2e, 0x8f, 0xf6, 0x20, 0xeb, 0x2c,
	0x96, 0xf3, 0xbb, 0x8b, 0x57, 0xbe, 0x8e, 0xc2, 0xde, 0x85, 0xa5, 0x39, 0xe4, 0x58, 0xd3, 0x89,
	0xbd, 0x70, 0xdc, 0xa7, 0x90, 0xb0, 0x35, 0x7a, 0x75, 0x4b, 0x66, 0x78, 0x13, 0x76, 0x05, 0x67,
	0x11, 0x55, 0xb9, 0x61, 0xd8, 0x36, 0x57, 0x96, 0x41, 0x15, 0x28, 0xbb, 0x92, 0x2a, 0x0b, 0xf3,
	0xa9, 0x46, 0x89, 0xaa, 0xd8, 0x97, 0xd8, 0x52, 0x35, 0x3a, 0xe1, 0xb7, 0x9c, 0xa9, 0x0c, 0x21,
	0xc9, 0xa7, 0x37, 0x7c, 0x0f, 0xcb, 0x72, 0x23, 0xec, 0x1e, 0xbe, 0x07, 0xfb, 0x5e, 0x5f, 0xec,
	0x71, 0x93, 0xdb, 0x21, 0x56, 0xfe, 0x16, 0x5f, 0x50, 0xad, 0xaf, 0x4f, 0xff, 0x1f, 0x50, 0x2d,
	0xeb, 0x5a, 0xa6, 0xc4, 0x9a, 0x10, 0x85, 0x55, 0xe6, 0x33, 0xdb, 0x4d, 0x01, 0xdb, 0xba, 0x96,
	0x33, 0x26, 0xd2, 0xe7, 0x12, 0x4b, 0xdb, 0x2d, 0x09, 0x35, 0xee, 0xd2, 0x53, 0xda, 0xb1, 0xb4,
	0xc9, 0x84, 0x58, 0x6e, 0xbd, 0xf2, 0xe3, 0x6d, 0x9e, 0x24, 0x56, 0xa3, 0x2f, 0x60, 0xcf, 0xe3,
	0x69, 0xcd, 0xa0, 0xca, 0xd4, 0x50, 0x45, 0xef, 0x5d, 0xf8, 0xe0, 0x68, 0x0b, 0x84, 0xe4, 0x93,
	0x3b, 0x33, 0x54, 0xc2, 0x12, 0xae, 0xe8, 0x89, 0x39, 0x09, 0xf0, 0x82, 0x7e, 0x7b, 0xc2, 0x15,
	0xbd, 0x28, 0x0f, 0x9c, 0x26, 0x14, 0x47, 0xba, 0xc1, 0x59, 0x64, 0x48, 0x2e, 0xf1, 0xb5, 0x66,
	0x58, 0x7c, 0x6e, 0x55, 0xd8, 0x6a, 0xe9, 0xba, 0x10, 0xab, 0xb9, 0x52, 0x3c, 0x04, 0x75, 0x9d,
	0xbb, 0x98, 0x8e, 0x1d, 0x42, 0x89, 0x6d, 0xf3, 0xf9, 0x55, 0xbc, 0xf2, 0xe7, 0x1d, 0x48, 0x2f,
	0xce, 0xde, 0x80, 0x2c, 0x1e, 0x3b, 0x0c, 0x45, 0xd7, 0xdd, 0x2b, 0x3d, 0x0a, 0x66, 0xb6, 0xaa,
	0xc4, 0xe4, 0x24, 0x5d, 0xe7, 0xe3, 0x9b, 0x05, 0x0a, 0x9d, 0xbb, 0x94, 0x17, 0x0e, 0x85, 0xce,
	0x9b, 0x11, 0x74, 0x0c, 0x20, 0x50, 0x08, 0x1e, 0x5d, 0xba, 0x94, 0xf6, 0x7e, 0x18, 0x18, 0x19,
	0x8f, 0x2e, 0x9b, 0x11, 0xf4, 0x0a, 0xf6, 0x5d, 0x1c, 0xaa, 0x2a, 0xc6, 0x58, 0x11, 0xee, 0xe2,
	0x3a, 0xc5, 0xe3, 0x50, 0x80, 0x54, 0xed, 0x8c, 0x45, 0x1c, 0x70, 0xd6, 0x3d, 0x10, 0xb8, 0x6b,
	0x54, 0xef, 0x56, 0xb7, 0x9f, 0x85, 0x41, 0xde, 0xa0, 0x74, 0x07, 0x2a, 0x02, 0xdc, 0x9e, 0xd3,
	0xd1, 0xa5, 0x65, 0x50, 0xed, 0x2b, 0xa2, 0x6e, 0x68, 0x12, 0x93, 0x91, 0xe3, 0x30, 0x9a, 0xfa,
	0x3e, 0xbc, 0x0d, 0xad, 0x2f, 0x20, 0x85, 0xf5, 0x1b, 0x3c, 0xb7, 0xdd, 0x59, 0xe0, 0x7b, 0x41,
	0x91, 0xb9, 0x10, 0x1f, 0x90, 0xa6, 0x55, 0x32, 0xc6, 0x33, 0xdd, 0x71, 0xc7, 0xab, 0xd5, 0x80,
	0x08, 0x0d, 0x21, 0xd5, 0x8c, 0xa0, 0xd3, 0x65, 0x32, 0x1b, 0x19, 0x33, 0xea, 0xb8, 0x53, 0xd6,
	0x0f, 0x03, 0x02, 0xb9, 0x9c, 0x5e, 0x67, 0xa2, 0xcd, 0x08, 0x7a, 0x06, 0x49, 0x4a, 0xae, 0x89,
	0xe5, 0xce, 0x59, 0x7f, 0x1a, 0x10, 0xa5, 0xcd, 0x64, 0x84, 0x0f, 0x1a, 0x96, 0x32, 0xd6, 0x28,
	0xd6, 0xf5, 0x79, 0x09, 0x42, 0xf9, 0x60, 0xc7, 0x3a, 0x16, 0x72, 0xc2, 0xb0, 0x16, 0x31, 0x09,
	0x5e, 0x4c, 0x6b, 0x83, 0x1a, 0xb6, 0xc7, 0x85, 0x9a, 0x91, 0xf2, 0x09, 0x64, 0x16, 0x01, 0x86,
	0x9e, 0x40, 0x8e, 0x8f, 0xf1, 0xf8, 0x92, 0x45, 0x9e, 0x0c, 0xc8, 0x6e, 0x4b, 0x20, 0x3a, 0xbf,
	0x1b, 0x50, 0x13, 0xb2, 0x5e, 0x94, 0xdd, 0x0d, 0xe9, 0xf7, 0x51, 0x28, 0xae, 0xc7, 0x17, 0x7a,
	0x06, 0x3b, 0x04, 0x5b, 0xfa, 0x5c, 0x19, 0x6b, 0x96, 0x46, 0x27, 0x8b, 0x51, 0x6d, 0x50, 0x12,
	0x7f, 0x0a, 0x79, 0x46, 0x73, 0x9e, 0x74, 0x2c, 0x8c, 0x74, 0x79, 0x0c, 0xfb, 0xdf, 0x10, 0x96,
	0xa8, 0x03, 0xf7, 0xbc, 0x72, 0x40, 0xd9, 0x78, 0x71, 0xfa, 0x28, 0x40, 0x1f, 0xc5, 0x45, 0xbd,
	0xb1, 0x67, 0xf9, 0x07, 0xf0, 0xfd, 0x2d, 0x41, 0x59, 0xce, 0x42, 0xda, 0x8d, 0x8d, 0xf2, 0x8f,
	0x20, 0xef, 0xf7, 0x6e, 0x56, 0x85, 0xad, 0x46, 0x0a, 0x33, 0x51, 0xb2, 0x9c, 0x86, 0x24, 0x77,
	0xdf, 0x72, 0x06, 0x52, 0x22, 0x30, 0xcb, 0x5f, 0x41, 0xd6, 0xf3, 0x46, 0xf4, 0x11, 0x24, 0xbc,
	0xee, 0x2f, 0xb8, 0x41, 0x1f, 0x43, 0x7a, 0x11, 0x06, 0xe1, 0x6c, 0xd9, 0x80, 0x94, 0xf0, 0x62,
	0xf4, 0x19, 0xc0, 0xd2, 0x49, 0xc2, 0xa9, 0xaf, 0x65, 0xbd, 0x6c, 0x5e, 0xf9, 0x3a, 0xe6, 0x2b,
	0xe2, 0x96, 0xc3, 0xf2, 0x26, 0x24, 0x55, 0xa2, 0xe3, 0xb9, 0x0b, 0xfc, 0x38, 0xf4, 0x6d, 0x54,
	0x1b, 0x4c, 0xbc, 0x19, 0x41, 0x67, 0x90, 0xc1, 0xba, 0x36, 0xa1, 0x8a, 0x63, 0xb8, 0x67, 0xfd,
	0x34, 0x3c, 0x98, 0xc4, 0x10, 0x06, 0x46, 0x33, 0x52, 0x7e, 0x1b, 0x92, 0x1c, 0x99, 0xb5, 0xf8,
	0x7c, 0x87, 0xca, 0x54, 0xd3, 0x75, 0xcd, 0x76, 0x2b, 0xe0, 0x87, 0x90, 0x76, 0xd7, 0xa2, 0x02,
	0xa4, 0x4c, 0x62, 0x69, 0x86, 0x28, 0x61, 0xe2, 0xec, 0xbb, 0x31, 0x1e, 0xdb, 0xc4, 0xe1, 0xc9,
	0x2a, 0x5e, 0x3b, 0x80, 0xfd, 0x6f, 0xf0, 0xbf, 0xca, 0xdf, 0xa3, 0x90, 0xf5, 0xba, 0x2b, 0x54,
	0x87, 0x02, 0x1e, 0x31, 0x0f, 0x52, 0x4c, 0xec, 0x38, 0xc4, 0xa2, 0xb7, 0x79, 0x53, 0xf0, 0x02,
	0xd2, 0xd7, 0x1a, 0xb9, 0xb9, 0xf5, 0x78, 0x03, 0xb5, 0x60, 0xcf, 0x2d, 0xcb, 0xa6, 0xd8, 0x34,
	0x59, 0xc2, 0x1a, 0x53, 0x37, 0x87, 0x87, 0x6d, 0xc7, 0xcb, 0x90, 0xf3, 0xbd, 0x36, 0x65, 0x3d,
	0xe8, 0xcc, 0xd2, 0xdd, 0xe9, 0x86, 0x0a, 0xbb, 0xeb, 0x9a, 0xef, 0xf0, 0x7e, 0xe4, 0x0d, 0x28,
	0xf8, 0xde, 0xe1, 0x2f, 0xa7, 0x2d, 0x0d, 0xc8, 0xaf, 0xac, 0xe3, 0x5b, 0xa0, 0x6e, 0x87, 0xfa,
	0x2e, 0x64, 0xbd, 0xc6, 0xdd, 0x35, 0xd6, 0xbd, 0xea, 0xc4, 0x30, 0x26, 0x3a, 0xa9, 0x2e, 0xfe,
	0x18, 0xa3, 0x2a, 0xd1, 0x79, 0xe5, 0xdf, 0x71, 0xc8, 0xf9, 0xe6, 0xed, 0xe8, 0x39, 0x24, 0x35,
	0x87, 0x78, 0xf4, 0x71, 0x14, 0x7c, 0x54, 0x5f, 0x6d, 0x39, 0x64, 0x5a, 0x3e, 0x06, 0x68, 0xa9,
	0x84, 0x3a, 0xda, 0x58, 0x23, 0x16, 0x73, 0x2e, 0xff, 0x3b, 0x29, 0x77, 0x73, 0x07, 0xb0, 0xb3,
	0x7c, 0xca, 0xf6, 0x2c, 0x86, 0x0d, 0x6e, 0x1f, 0xcf, 0x0b, 0xe5, 0xf2, 0x7f, 0xa2, 0x90, 0x60,
	0x80, 0x48, 0x82, 0x98, 0x2b, 0xb8, 0xfd, 0x1d, 0xd0, 0xca, 0x6e, 0x96, 0xbb, 0x78, 0xe6, 0x8e,
	0x61, 0x63, 0x81, 0xca, 0x65, 0x3f, 0x08, 0x1f, 0xc0, 0xfe, 0x70, 0x31, 0x52, 0x88, 0x7f, 0xbb,
	0x1d, 0xd1, 0x43, 0xc8, 0xd9, 0x97, 0x86, 0xe5, 0x28, 0x62, 0x69, 0xe2, 0x3b, 0x96, 0xee, 0x40,
	0x52, 0xc7, 0x43, 0xa2, 0xbb, 0xaf, 0xce, 0x8a, 0x90, 0xd1, 0x35, 0x7a, 0xa5, 0x30, 0xff, 0x49,
	0xb9, 0xfe, 0xe3, 0x4d, 0x7e, 0xfb, 0x83, 0x5e, 0xab, 0x7d, 0x52, 0x8c, 0xa0, 0x1c, 0xa4, 0x5b,
	0xed, 0x81, 0x7c, 0x22, 0xf7, 0x8a, 0x51, 0x94, 0x85, 0xe4, 0xf1, 0x69, 0x47, 0x1a, 0x14, 0x63,
	0xec, 0x79, 0xad, 0xd3, 0x39, 0x95, 0xa5, 0x76, 0x31, 0x8e, 0x76, 0x20, 0x3b, 0x68, 0x9d, 0xc9,
	0xfd, 0x81, 0x74, 0xd6, 0x2d, 0x26, 0x50, 0x1e, 0x32, 0x8d, 0xf3, 0x9e, 0x34, 0x68, 0x75, 0xda,
	0xc5, 0x24, 0x2a, 0x00, 0x7c, 0x21, 0xbd, 0x92, 0x94, 0xfa, 0xa9, 0xd4, 0xef, 0x17, 0x53, 0x87,
	0xef, 0x42, 0x76, 0xf9, 0x1e, 0x87, 0xc3, 0x9c, 0xb7, 0x1b, 0x72, 0xa3, 0x18, 0x61, 0x30, 0xe7,
	0xed, 0xc5, 0xd7, 0xe8, 0x61, 0x1d, 0x72, 0xfe, 0xde, 0x66, 0x17, 0x72, 0xed, 0x4e, 0x5b, 0x39,
	0x93, 0x7b, 0x27, 0x62, 0x6b, 0xec, 0x81, 0x2c, 0x37, 0xfa, 0xfc, 0x91, 0x5c, 0x8c, 0x22, 0x04,
	0x05, 0xe9, 0xb4, 0x27, 0x4b, 0x8d, 0xd7, 0xe2, 0x51, 0xa3, 0x18, 0x3b, 0xfc, 0x08, 0x8a, 0x1b,
	0x7d, 0x48, 0x01, 0xa0, 0xd1, 0xea, 0xd7, 0xa5, 0x5e, 0x43, 0x00, 0x15, 0x21, 0x2f, 0xd5, 0xeb,
	0xe7, 0x67, 0xe7, 0xa7, 0xd2, 0x80, 0x3d, 0x89, 0x1e, 0x7e, 0x02, 0xbb, 0xeb, 0x2d, 0xc3, 0x2e,
	0xe4, 0xe4, 0xb3, 0xd6, 0x40, 0x91, 0x4e, 0x2f, 0xa4, 0xd7, 0x7d, 0x31, 0x13, 0xe7, 0x0f, 0x5a,
	0xc7, 0x4a, 0xbb, 0xd3, 0x96, 0xcf, 0xba, 0x83, 0xd7, 0xc5, 0xe8, 0x61, 0x0b, 0xc0, 0xd7, 0xb1,
	0xec, 0xc1, 0x8e, 0xdc, 0x6e, 0x28, 0x9d, 0x63, 0xc5, 0x1b, 0xa5, 0x23, 0x28, 0x9c, 0x4a, 0x03,
	0xb9, 0x3f, 0x50, 0x5a, 0x6d, 0xa5, 0x2b, 0xb5, 0xd9, 0xc6, 0x19, 0x94, 0xd4, 0x3b, 0x6d, 0xf9,
	0x9f, 0xc6, 0x0e, 0xfb, 0x00, 0xcb, 0x69, 0x23, 0xdb, 0xb4, 0xfc, 0x4a, 0x6e, 0x0f, 0x14, 0x66,
	0xe9, 0x62, 0x04, 0xed, 0xc3, 0x6e, 0xb7, 0xd7, 0xa9, 0xcb, 0xfd, 0x7e, 0xab, 0x7d, 0x22, 0x1e,
	0x46, 0xd1, 0x7d, 0x78, 0xab, 0xff, 0xba, 0x5d, 0x6f, 0xf6, 0x3a, 0xed, 0xd6, 0x2f, 0xe4, 0x86,
	0xb2, 0xbe, 0x22, 0x56, 0x7b, 0x04, 0xef, 0xac, 0xbb, 0xa1, 0xad, 0x5e, 0x55, 0x47, 0xc6, 0x74,
	0x6a, 0x50, 0xd7, 0x23, 0xab, 0xd7, 0x8f, 0x6a, 0xd9, 0x1e, 0xff, 0x28, 0x99, 0xda, 0x30, 0xc5,
	0xbd, 0xe8, 0xc3, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x23, 0xdd, 0x1c, 0x4f, 0x96, 0x25, 0x00,
	0x00,
}
