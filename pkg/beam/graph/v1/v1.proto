/*
 * Protocol Buffers describing graph serialization (v1)
 *
 * We need to serialize types and function symbols to be able to recreate
 * UserFns on the worker side, in particular. We use protos for compactness.
 */
syntax = "proto3";

package v1;

// Type represents a serializable reflect.Type.
message Type {
    // Kind is mostly identical to reflect.TypeKind, expect we handle certain
    // types specially, such as "error".
    enum Kind {
        INVALID = 0;

        // Primitive.
        BOOL = 1;
        INT = 2;
        INT8 = 3;
        INT16 = 4;
        INT32 = 5;
        INT64 = 6;
        UINT = 7;
        UINT8 = 8;
        UINT16 = 9;
        UINT32 = 10;
        UINT64 = 11;
        STRING = 12;

        // Aggregate.
        SLICE = 20;
        STRUCT = 21;

        // Special.
        FUNC = 30;
        CHAN = 31;
        ERROR = 32;
        UNIVERSAL = 33;
        // Add ENCODED/UNIVERSAL/TIMESTAMP/..

        // Data
        FNVALUE = 40;
        TYPE = 41;
    }
    // (Required) Type kind.
    Kind kind = 1;

    // (Optional) Element type (if SLICE or CHAN)
    Type element = 2;

    // StructField matches reflect.StructField.
    message StructField {
        string name = 1;
        string pkg_path = 2;
        Type type = 3;
        string tag = 4;
        int64 offset = 5;
        repeated int32 index = 6;
        bool anonymous = 7;
    }
    // (Optional) Fields (if STRUCT).
    repeated StructField fields = 3;

    // (Optional) Parameter types (if FUNC).
    repeated Type parameter_types = 4;
    // (Optional) Return types (if FUNC).
    repeated Type return_types = 5;
    // (Optional) Is variadic (if FUNC).
    bool is_variadic = 6;

    // ChanDir matches reflect.ChanDir.
    enum ChanDir {
        RECV = 0;
        SEND = 1;
        BOTH = 2;
    }
    // (Optional) Channel direction (if CHAN).
    ChanDir chan_dir = 7;
}

// FunctionRef represents a serialized function reference. The
// implementation is notably not serialized and must be present (and
// somehow discoverable from the symbol name) on the decoding side.
message FunctionRef {
    // (Required) Symbol name of function.
    string name = 1;
    // (Required) Function type.
    Type type = 2;
}

// CustomCoder
message CustomCoder {
    // (Required) Name of the coder. For informational purposes only.
    string name = 1;
    // (Required) Concrete type being coded.
    Type type = 2;

    // (Required) Encoding function.
    FunctionRef enc = 3;
    // (Required) Decoding function.
    FunctionRef dec = 4;

    // (Optional) JSON-serialized data.
    string data = 5;
}

// NOTE(herohde) 4/4/2017: we use (json) CoderRef to serialize coder to
// inform the service, which may change it at the edges (notably adding
// LengthPrefix). We thus have to be careful using the right one.

message Window {
    enum Kind {
        GLOBAL = 0;
    }
    Kind kind = 1;
}

// Coder represents a serialized Coder. Unused, for now.
message Coder {
    enum Kind {
        CUSTOM = 0;
        VARINT = 1;
        BYTES = 2;
        PARI = 3;
        LENGTHPREFIX = 4;
        WINDOWEDVALUE = 5;
        STREAM = 6;
    }
    Kind kind = 1;

    repeated Coder components = 2;
    CustomCoder custom = 3;
    Window window = 4;
}

message Node {
    Type type = 1;
    // Coder coder = 2;
}

// MultiEdge prepresents a serialized MultiEdge. It includes the output
// nodes, but not the input nodes.
message MultiEdge {
    // UserFn
    FunctionRef user_fn = 1;
    // (Optional) JSON-serialized data.
    string data = 2;

    message Inbound {
        Type type = 1;
    }
    repeated Inbound inbound = 3;

    message Outbound {
        Type type = 1;
        Node node = 2;
    }
    repeated Outbound outbound = 4;
}
