/*
 * Protocol Buffers describing graph serialization (v1)
 *
 * We need to serialize types and function symbols to be able to recreate
 * UserFns on the worker side, in particular. We use protos for compactness.
 */
syntax = "proto3";

package v1;

// Type represents a serializable reflect.Type.
message Type {
    // Kind is mostly identical to reflect.TypeKind, expect we handle certain
    // types specially, such as "error".
    enum Kind {
        INVALID = 0;

        // Primitive.
        BOOL = 1;
        INT = 2;
        INT8 = 3;
        INT16 = 4;
        INT32 = 5;
        INT64 = 6;
        UINT = 7;
        UINT8 = 8;
        UINT16 = 9;
        UINT32 = 10;
        UINT64 = 11;
        STRING = 12;

        // Aggregate.
        SLICE = 20;
        STRUCT = 21;

        // Special.
        FUNC = 30;
        CHAN = 31;
        ERROR = 32;
        // Add ENCODED/UNIVERSAL/TIMESTAMP/..
    }
    // (Required) Type kind.
    Kind kind = 1;

    // (Optional) Element type (if SLICE or CHAN)
    Type element = 2;

    // StructField matches reflect.StructField.
    message StructField {
        string name = 1;
        string pkg_path = 2;
        Type type = 3;
        string tag = 4;
        int64 offset = 5;
        repeated int32 index = 6;
        bool anonymous = 7;
    }
    // (Optional) Fields (if STRUCT).
    repeated StructField fields = 3;

    // (Optional) Parameter types (if FUNC).
    repeated Type parameter_types = 4;
    // (Optional) Return types (if FUNC).
    repeated Type return_types = 5;
    // (Optional) Is variadic (if FUNC).
    bool is_variadic = 6;

    // ChanDir matches reflect.ChanDir.
    enum ChanDir {
        RECV = 0;
        SEND = 1;
        BOTH = 2;
    }
    // (Optional) Channel direction (if CHAN).
    ChanDir chan_dir = 7;
}

// FunctionRef represents a serialized function reference. The
// implementation is notably not serialized and must be present (and
// somehow discoverable from the symbol name) on the decoding side.
message FunctionRef {
    // (Required) Symbol name of function.
    string name = 1;
    // (Required) Function type.
    Type type = 2;
}

// MultiEdge prepresents a serialized MultiEdge.
message MultiEdge {
    // UserFn
    FunctionRef user_fn = 1;
    // (Optional) JSON-serialized data.
    string data = 2;

    message Inbound {
        Type type = 1;
    }
    repeated Inbound inbound = 3;

    message Outbound {
        Type type = 1;
    }
    repeated Outbound outbound = 4;
}
