<!DOCTYPE html>
<!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License. See accompanying LICENSE file.
-->

<html lang="en">
  <!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License. See accompanying LICENSE file.
-->

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Beam Programming Guide</title>
  <meta name="description" content="Apache Beam is an open source, unified model and set of language-specific SDKs for defining and executing data processing workflows, and also data ingestion and integration flows, supporting Enterprise Integration Patterns (EIPs) and Domain Specific Languages (DSLs). Dataflow pipelines simplify the mechanics of large-scale batch and streaming data processing and can run on a number of runtimes like Apache Flink, Apache Spark, and Google Cloud Dataflow (a cloud service). Beam also brings DSL in different languages, allowing users to easily implement their data integration processes.
">
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400" rel="stylesheet">
  <link rel="stylesheet" href="/css/site.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <script src="/js/language-switch.js"></script>
  <script src="/js/fix-menu.js"></script>
  <script src="/js/section-nav.js"></script>
  <script src="/js/page-nav.js"></script>
  <link rel="canonical" href="https://beam.apache.org/documentation/programming-guide/" data-proofer-ignore>
  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico">
  <link rel="alternate" type="application/rss+xml" title="Apache Beam" href="https://beam.apache.org/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-73650088-1', 'auto');
    ga('send', 'pageview');
  </script>
</head>

  <body class="body" data-spy="scroll" data-target=".page-nav" data-offset="0">
    <!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License. See accompanying LICENSE file.
-->

<nav class="header navbar navbar-fixed-top">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <a href="/" class="navbar-brand" >
        <img alt="Brand" style="height: 25px" src="/images/beam_logo_navbar.png">
      </a>
    </div>

    <div class="navbar-mask closed"></div>

    <div id="navbar" class="navbar-container closed">
      <ul class="nav navbar-nav">
        <li>
          <a href="/get-started/beam-overview/">Get Started</a>
        </li>
        <li>
          <a href="/documentation/">Documentation</a>
        </li>
        <li>
          <a href="/documentation/sdks/java/">SDKS</a>
        </li>
        <li>
          <a href="/documentation/runners/capability-matrix/">RUNNERS</a>
        </li>
        <li>
          <a href="/contribute/">Contribute</a>
        </li>
        <li>
          <a href="/community/contact-us/">Community</a>
        </li>
        <li><a href="/blog">Blog</a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"><img src="https://www.apache.org/foundation/press/kit/feather_small.png" alt="Apache Logo" style="height:20px;"><span class="caret"></span></a>
          <ul class="dropdown-menu dropdown-menu-right">
            <li><a href="http://www.apache.org/">ASF Homepage</a></li>
            <li><a href="http://www.apache.org/licenses/">License</a></li>
            <li><a href="http://www.apache.org/security/">Security</a></li>
            <li><a href="http://www.apache.org/foundation/thanks.html">Thanks</a></li>
            <li><a href="http://www.apache.org/foundation/sponsorship.html">Sponsorship</a></li>
            <li><a href="https://www.apache.org/foundation/policies/conduct">Code of Conduct</a></li>
          </ul>
        </li>
      </ul>
    </div>
</nav>

    <div class="clearfix container-main-content">
      <div class="section-nav closed" data-offset-top="90" data-offset-bottom="500">
        <span class="section-nav-back glyphicon glyphicon-menu-left"></span>
        <nav>
          <ul class="section-nav-list" data-section-nav>
            <!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License. See accompanying LICENSE file.
-->

<li><span class="section-nav-list-main-title">Documentation</span></li>
<li><a href="/documentation">Using the Documentation</a></li>
<li><a href="/documentation/execution-model">Beam Execution Model</a></li>
<li class="section-nav-item--collapsible">
  <span class="section-nav-list-title">Pipeline development lifecycle</span>

  <ul class="section-nav-list">
    <li><a href="/documentation/pipelines/design-your-pipeline/">Design Your Pipeline</a></li>
    <li><a href="/documentation/pipelines/create-your-pipeline/">Create Your Pipeline</a></li>
    <li><a href="/documentation/pipelines/test-your-pipeline/">Test Your Pipeline</a></li>
  </ul>
</li>
<li class="section-nav-item--collapsible">
  <span class="section-nav-list-title">Beam programming guide</span>

  <ul class="section-nav-list">
    <li><a href="/documentation/programming-guide/">Overview</a></li>
    <li><a href="/documentation/programming-guide/#creating-a-pipeline">Pipelines</a></li>
    <li class="section-nav-item--collapsible">
      <span class="section-nav-list-title">PCollections</span>

      <ul class="section-nav-list">
        <li><a href="/documentation/programming-guide/#pcollections">Creating a PCollection</a></li>
        <li><a href="/documentation/programming-guide/#pcollection-characteristics">PCollection characteristics</a></li>
      </ul>
    </li>
    <li class="section-nav-item--collapsible">
      <span class="section-nav-list-title">Transforms</span>

      <ul class="section-nav-list">
        <li><a href="/documentation/programming-guide/#applying-transforms">Applying transforms</a></li>
        <li>
          <span class="section-nav-list-title">Core Beam transforms</span>

          <ul class="section-nav-list">
            <li><a href="/documentation/programming-guide/#pardo">ParDo</a></li>
            <li><a href="/documentation/programming-guide/#groupbykey">GroupByKey</a></li>
            <li><a href="/documentation/programming-guide/#cogroupbykey">CoGroupByKey</a></li>
            <li><a href="/documentation/programming-guide/#combine">Combine</a></li>
            <li><a href="/documentation/programming-guide/#flatten">Flatten</a></li>
            <li><a href="/documentation/programming-guide/#partition">Partition</a></li>
          </ul>
        </li>

        <li><a href="/documentation/programming-guide/#requirements-for-writing-user-code-for-beam-transforms">Requirements for user code</a></li>
        <li><a href="/documentation/programming-guide/#side-inputs">Side inputs</a></li>
        <li><a href="/documentation/programming-guide/#additional-outputs">Additional outputs</a></li>
        <li><a href="/documentation/programming-guide/#composite-transforms">Composite transforms</a></li>
      </ul>
    </li>
    <li class="section-nav-item--collapsible">
      <span class="section-nav-list-title">Pipeline I/O</span>

      <ul class="section-nav-list">
        <li><a href="/documentation/programming-guide/#pipeline-io">Using I/O transforms</a></li>
        <li><a href="/documentation/io/built-in/">Built-in I/O transforms</a></li>
        <li><a href="/documentation/io/authoring-overview/">Authoring new I/O transforms</a></li>
        <li><a href="/documentation/io/testing/">Testing I/O transforms</a></li>
      </ul>
    </li>
    <li class="section-nav-item--collapsible">
      <span class="section-nav-list-title">Data encoding and type safety</span>

      <ul class="section-nav-list">
        <li><a href="/documentation/programming-guide/#data-encoding-and-type-safety">Data encoding basics</a></li>
        <li><a href="/documentation/programming-guide/#specifying-coders">Specifying coders</a></li>
        <li><a href="/documentation/programming-guide/#default-coders-and-the-coderregistry">Default coders and the CoderRegistry</a></li>
      </ul>
    </li>
    <li class="section-nav-item--collapsible">
      <span class="section-nav-list-title">Windowing</span>

      <ul class="section-nav-list">
        <li><a href="/documentation/programming-guide/#windowing">Windowing basics</a></li>
        <li><a href="/documentation/programming-guide/#provided-windowing-functions">Provided windowing functions</a></li>
        <li><a href="/documentation/programming-guide/#setting-your-pcollections-windowing-function">Setting your PCollection’s windowing function</a></li>
        <li><a href="/documentation/programming-guide/#watermarks-and-late-data">Watermarks and late data</a></li>
        <li><a href="/documentation/programming-guide/#adding-timestamps-to-a-pcollections-elements">Adding timestamps to a PCollection’s elements</a></li>
      </ul>
    </li>
    <li class="section-nav-item--collapsible">
      <span class="section-nav-list-title">Triggers</span>

      <ul class="section-nav-list">
        <li><a href="/documentation/programming-guide/#triggers">Trigger basics</a></li>
        <li><a href="/documentation/programming-guide/#event-time-triggers">Event time triggers and the default trigger</a></li>
        <li><a href="/documentation/programming-guide/#processing-time-triggers">Processing time triggers</a></li>
        <li><a href="/documentation/programming-guide/#data-driven-triggers">Data-driven triggers</a></li>
        <li><a href="/documentation/programming-guide/#setting-a-trigger">Setting a trigger</a></li>
        <li><a href="/documentation/programming-guide/#composite-triggers">Composite triggers</a></li>
      </ul>
    </li>
    <li><a href="/documentation/resources/">Additional Resources</a></li>
  </ul>
</li>

          </ul>
        </nav>
      </div>

      <nav class="page-nav clearfix" data-offset-top="90" data-offset-bottom="500">
        <!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License. See accompanying LICENSE file.
-->



<ul class="nav">
  <li><a href="#overview">1. Overview</a></li>
  <li><a href="#creating-a-pipeline">2. Creating a pipeline</a>
    <ul>
      <li><a href="#configuring-pipeline-options">2.1. Configuring pipeline options</a></li>
    </ul>
  </li>
  <li><a href="#pcollections">3. PCollections</a>
    <ul>
      <li><a href="#creating-a-pcollection">3.1. Creating a PCollection</a></li>
      <li><a href="#pcollection-characteristics">3.2. PCollection characteristics</a></li>
    </ul>
  </li>
  <li><a href="#transforms">4. Transforms</a>
    <ul>
      <li><a href="#applying-transforms">4.1. Applying transforms</a></li>
      <li><a href="#core-beam-transforms">4.2. Core Beam transforms</a></li>
      <li><a href="#requirements-for-writing-user-code-for-beam-transforms">4.3. Requirements for writing user code for Beam transforms</a></li>
      <li><a href="#side-inputs">4.4. Side inputs</a></li>
      <li><a href="#additional-outputs">4.5. Additional outputs</a></li>
      <li><a href="#composite-transforms">4.6. Composite transforms</a></li>
    </ul>
  </li>
  <li><a href="#pipeline-io">5. Pipeline I/O</a>
    <ul>
      <li><a href="#pipeline-io-reading-data">5.1. Reading input data</a></li>
      <li><a href="#pipeline-io-writing-data">5.2. Writing output data</a></li>
      <li><a href="#file-based-data">5.3. File-based input and output data</a></li>
      <li><a href="#provided-io-transforms">5.4. Beam-provided I/O transforms</a></li>
    </ul>
  </li>
  <li><a href="#data-encoding-and-type-safety">6. Data encoding and type safety</a>
    <ul>
      <li><a href="#specifying-coders">6.1. Specifying coders</a></li>
      <li><a href="#default-coders-and-the-coderregistry">6.2. Default coders and the CoderRegistry</a></li>
    </ul>
  </li>
  <li><a href="#windowing">7. Windowing</a>
    <ul>
      <li><a href="#windowing-basics">7.1. Windowing basics</a></li>
      <li><a href="#provided-windowing-functions">7.2. Provided windowing functions</a></li>
      <li><a href="#setting-your-pcollections-windowing-function">7.3. Setting your PCollection’s windowing function</a></li>
      <li><a href="#watermarks-and-late-data">7.4. Watermarks and late data</a></li>
      <li><a href="#adding-timestamps-to-a-pcollections-elements">7.5. Adding timestamps to a PCollection’s elements</a></li>
    </ul>
  </li>
  <li><a href="#triggers">8. Triggers</a>
    <ul>
      <li><a href="#event-time-triggers">8.1. Event time triggers</a></li>
      <li><a href="#processing-time-triggers">8.2. Processing time triggers</a></li>
      <li><a href="#data-driven-triggers">8.3. Data-driven triggers</a></li>
      <li><a href="#setting-a-trigger">8.4. Setting a trigger</a></li>
      <li><a href="#composite-triggers">8.5. Composite triggers</a></li>
    </ul>
  </li>
</ul>


      </nav>

      <div class="body__contained body__section-nav">
        <!--
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<h1 id="apache-beam-programming-guide">Apache Beam Programming Guide</h1>

<p>The <strong>Beam Programming Guide</strong> is intended for Beam users who want to use the
Beam SDKs to create data processing pipelines. It provides guidance for using
the Beam SDK classes to build and test your pipeline. It is not intended as an
exhaustive reference, but as a language-agnostic, high-level guide to
programmatically building your Beam pipeline. As the programming guide is filled
out, the text will include code samples in multiple languages to help illustrate
how to implement Beam concepts in your pipelines.</p>

<nav class="language-switcher">
  <strong>Adapt for:</strong>
  <ul>
    <li data-type="language-java" class="active">Java SDK</li>
    <li data-type="language-py">Python SDK</li>
  </ul>
</nav>

<h2 id="overview">1. Overview</h2>

<p>To use Beam, you need to first create a driver program using the classes in one
of the Beam SDKs. Your driver program <em>defines</em> your pipeline, including all of
the inputs, transforms, and outputs; it also sets execution options for your
pipeline (typically passed in using command-line options). These include the
Pipeline Runner, which, in turn, determines what back-end your pipeline will run
on.</p>

<p>The Beam SDKs provide a number of abstractions that simplify the mechanics of
large-scale distributed data processing. The same Beam abstractions work with
both batch and streaming data sources. When you create your Beam pipeline, you
can think about your data processing task in terms of these abstractions. They
include:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">Pipeline</code>: A <code class="highlighter-rouge">Pipeline</code> encapsulates your entire data processing task, from
start to finish. This includes reading input data, transforming that data, and
writing output data. All Beam driver programs must create a <code class="highlighter-rouge">Pipeline</code>. When
you create the <code class="highlighter-rouge">Pipeline</code>, you must also specify the execution options that
tell the <code class="highlighter-rouge">Pipeline</code> where and how to run.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">PCollection</code>: A <code class="highlighter-rouge">PCollection</code> represents a distributed data set that your
Beam pipeline operates on. The data set can be <em>bounded</em>, meaning it comes
from a fixed source like a file, or <em>unbounded</em>, meaning it comes from a
continuously updating source via a subscription or other mechanism. Your
pipeline typically creates an initial <code class="highlighter-rouge">PCollection</code> by reading data from an
external data source, but you can also create a <code class="highlighter-rouge">PCollection</code> from in-memory
data within your driver program. From there, <code class="highlighter-rouge">PCollection</code>s are the inputs and
outputs for each step in your pipeline.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">PTransform</code>: A <code class="highlighter-rouge">PTransform</code> represents a data processing operation, or a step,
in your pipeline. Every <code class="highlighter-rouge">PTransform</code> takes one or more <code class="highlighter-rouge">PCollection</code> objects as
input, performs a processing function that you provide on the elements of that
<code class="highlighter-rouge">PCollection</code>, and produces zero or more output <code class="highlighter-rouge">PCollection</code> objects.</p>
  </li>
  <li>
    <p>I/O transforms: Beam comes with a number of “IOs” - library <code class="highlighter-rouge">PTransform</code>s that
read or write data to various external storage systems.</p>
  </li>
</ul>

<p>A typical Beam driver program works as follows:</p>

<ul>
  <li><strong>Create</strong> a <code class="highlighter-rouge">Pipeline</code> object and set the pipeline execution options, including
the Pipeline Runner.</li>
  <li>Create an initial <code class="highlighter-rouge">PCollection</code> for pipeline data, either using the IOs
to read data from an external storage system, or using a <code class="highlighter-rouge">Create</code> transform to
build a <code class="highlighter-rouge">PCollection</code> from in-memory data.</li>
  <li><strong>Apply</strong> <code class="highlighter-rouge">PTransforms</code> to each <code class="highlighter-rouge">PCollection</code>. Transforms can change, filter,
group, analyze, or otherwise process the elements in a <code class="highlighter-rouge">PCollection</code>. A
transform creates a new output <code class="highlighter-rouge">PCollection</code> <em>without modifying the input
collection</em>. A typical pipeline applies subsequent transforms to the each new
output <code class="highlighter-rouge">PCollection</code> in turn until processing is complete. However, note that
a pipeline does not have to be a single straight line of transforms applied
one after another: think of <code class="highlighter-rouge">PCollection</code>s as variables and <code class="highlighter-rouge">PTransform</code>s as
functions applied to these variables: the shape of the pipeline can be an
arbitrarily complex processing graph.</li>
  <li>Use IOs to write the final, transformed <code class="highlighter-rouge">PCollection</code>(s) to an external source.</li>
  <li><strong>Run</strong> the pipeline using the designated Pipeline Runner.</li>
</ul>

<p>When you run your Beam driver program, the Pipeline Runner that you designate
constructs a <strong>workflow graph</strong> of your pipeline based on the <code class="highlighter-rouge">PCollection</code>
objects you’ve created and transforms that you’ve applied. That graph is then
executed using the appropriate distributed processing back-end, becoming an
asynchronous “job” (or equivalent) on that back-end.</p>

<h2 id="creating-a-pipeline">2. Creating a pipeline</h2>

<p>The <code class="highlighter-rouge">Pipeline</code> abstraction encapsulates all the data and steps in your data
processing task. Your Beam driver program typically starts by constructing a
<span class="language-java"><a href="/documentation/sdks/javadoc/2.6.0/index.html?org/apache/beam/sdk/Pipeline.html">Pipeline</a></span>
<span class="language-py"><a href="https://github.com/apache/beam/blob/master/sdks/python/apache_beam/pipeline.py">Pipeline</a></span>
object, and then using that object as the basis for creating the pipeline’s data
sets as <code class="highlighter-rouge">PCollection</code>s and its operations as <code class="highlighter-rouge">Transform</code>s.</p>

<p>To use Beam, your driver program must first create an instance of the Beam SDK
class <code class="highlighter-rouge">Pipeline</code> (typically in the <code class="highlighter-rouge">main()</code> function). When you create your
<code class="highlighter-rouge">Pipeline</code>, you’ll also need to set some <strong>configuration options</strong>. You can set
your pipeline’s configuration options programatically, but it’s often easier to
set the options ahead of time (or read them from the command line) and pass them
to the <code class="highlighter-rouge">Pipeline</code> object when you create the object.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// Start by defining the options for the pipeline.</span>
<span class="n">PipelineOptions</span> <span class="n">options</span> <span class="o">=</span> <span class="n">PipelineOptionsFactory</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>

<span class="c1">// Then create the pipeline.</span>
<span class="n">Pipeline</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">options</span><span class="o">);</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">apache_beam</span> <span class="kn">as</span> <span class="nn">beam</span>
<span class="kn">from</span> <span class="nn">apache_beam.options.pipeline_options</span> <span class="kn">import</span> <span class="n">PipelineOptions</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">Pipeline</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="n">PipelineOptions</span><span class="p">())</span>

</code></pre>
</div>

<h3 id="configuring-pipeline-options">2.1. Configuring pipeline options</h3>

<p>Use the pipeline options to configure different aspects of your pipeline, such
as the pipeline runner that will execute your pipeline and any runner-specific
configuration required by the chosen runner. Your pipeline options will
potentially include information such as your project ID or a location for
storing files.</p>

<p>When you run the pipeline on a runner of your choice, a copy of the
PipelineOptions will be available to your code. For example, if you add a PipelineOptions parameter
to a DoFn’s <code class="highlighter-rouge">@ProcessElement</code> method, it will be populated by the system.</p>

<h4 id="pipeline-options-cli">2.1.1. Setting PipelineOptions from command-line arguments</h4>

<p>While you can configure your pipeline by creating a <code class="highlighter-rouge">PipelineOptions</code> object and
setting the fields directly, the Beam SDKs include a command-line parser that
you can use to set fields in <code class="highlighter-rouge">PipelineOptions</code> using command-line arguments.</p>

<p>To read options from the command-line, construct your <code class="highlighter-rouge">PipelineOptions</code> object
as demonstrated in the following example code:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">PipelineOptions</span> <span class="n">options</span> <span class="o">=</span>
    <span class="n">PipelineOptionsFactory</span><span class="o">.</span><span class="na">fromArgs</span><span class="o">(</span><span class="n">args</span><span class="o">).</span><span class="na">withValidation</span><span class="o">().</span><span class="na">create</span><span class="o">();</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">apache_beam</span> <span class="kn">as</span> <span class="nn">beam</span>
<span class="kn">from</span> <span class="nn">apache_beam.options.pipeline_options</span> <span class="kn">import</span> <span class="n">PipelineOptions</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">Pipeline</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="n">PipelineOptions</span><span class="p">())</span>

</code></pre>
</div>

<p>This interprets command-line arguments that follow the format:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>--&lt;option&gt;=&lt;value&gt;
</code></pre>
</div>

<blockquote>
  <p><strong>Note:</strong> Appending the method <code class="highlighter-rouge">.withValidation</code> will check for required
command-line arguments and validate argument values.</p>
</blockquote>

<p>Building your <code class="highlighter-rouge">PipelineOptions</code> this way lets you specify any of the options as
a command-line argument.</p>

<blockquote>
  <p><strong>Note:</strong> The <a href="/get-started/wordcount-example">WordCount example pipeline</a>
demonstrates how to set pipeline options at runtime by using command-line
options.</p>
</blockquote>

<h4 id="creating-custom-options">2.1.2. Creating custom options</h4>

<p>You can add your own custom options in addition to the standard
<code class="highlighter-rouge">PipelineOptions</code>. To add your own options, define an interface with getter and
setter methods for each option, as in the following example:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MyOptions</span> <span class="kd">extends</span> <span class="n">PipelineOptions</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">getMyCustomOption</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">setMyCustomOption</span><span class="o">(</span><span class="n">String</span> <span class="n">myCustomOption</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyOptions</span><span class="p">(</span><span class="n">PipelineOptions</span><span class="p">):</span>

  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">_add_argparse_args</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--input'</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--output'</span><span class="p">)</span>

</code></pre>
</div>

<p>You can also specify a description, which appears when a user passes <code class="highlighter-rouge">--help</code> as
a command-line argument, and a default value.</p>

<p>You set the description and default value using annotations, as follows:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MyOptions</span> <span class="kd">extends</span> <span class="n">PipelineOptions</span> <span class="o">{</span>
    <span class="nd">@Description</span><span class="o">(</span><span class="s">"My custom command line argument."</span><span class="o">)</span>
    <span class="nd">@Default</span><span class="o">.</span><span class="na">String</span><span class="o">(</span><span class="s">"DEFAULT"</span><span class="o">)</span>
    <span class="n">String</span> <span class="nf">getMyCustomOption</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">setMyCustomOption</span><span class="o">(</span><span class="n">String</span> <span class="n">myCustomOption</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyOptions</span><span class="p">(</span><span class="n">PipelineOptions</span><span class="p">):</span>

  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">_add_argparse_args</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--input'</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s">'Input for the pipeline'</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="s">'gs://my-bucket/input'</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--output'</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s">'Output for the pipeline'</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="s">'gs://my-bucket/output'</span><span class="p">)</span>

</code></pre>
</div>

<p class="language-java">It’s recommended that you register your interface with <code class="highlighter-rouge">PipelineOptionsFactory</code>
and then pass the interface when creating the <code class="highlighter-rouge">PipelineOptions</code> object. When you
register your interface with <code class="highlighter-rouge">PipelineOptionsFactory</code>, the <code class="highlighter-rouge">--help</code> can find
your custom options interface and add it to the output of the <code class="highlighter-rouge">--help</code> command.
<code class="highlighter-rouge">PipelineOptionsFactory</code> will also validate that your custom options are
compatible with all other registered options.</p>

<p class="language-java">The following example code shows how to register your custom options interface
with <code class="highlighter-rouge">PipelineOptionsFactory</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">PipelineOptionsFactory</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">MyOptions</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">MyOptions</span> <span class="n">options</span> <span class="o">=</span> <span class="n">PipelineOptionsFactory</span><span class="o">.</span><span class="na">fromArgs</span><span class="o">(</span><span class="n">args</span><span class="o">)</span>
                                                <span class="o">.</span><span class="na">withValidation</span><span class="o">()</span>
                                                <span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="n">MyOptions</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre>
</div>

<p>Now your pipeline can accept <code class="highlighter-rouge">--myCustomOption=value</code> as a command-line argument.</p>

<h2 id="pcollections">3. PCollections</h2>

<p>The <span class="language-java"><a href="/documentation/sdks/javadoc/2.6.0/index.html?org/apache/beam/sdk/values/PCollection.html">PCollection</a></span>
<span class="language-py"><code class="highlighter-rouge">PCollection</code></span> abstraction represents a
potentially distributed, multi-element data set. You can think of a
<code class="highlighter-rouge">PCollection</code> as “pipeline” data; Beam transforms use <code class="highlighter-rouge">PCollection</code> objects as
inputs and outputs. As such, if you want to work with data in your pipeline, it
must be in the form of a <code class="highlighter-rouge">PCollection</code>.</p>

<p>After you’ve created your <code class="highlighter-rouge">Pipeline</code>, you’ll need to begin by creating at least
one <code class="highlighter-rouge">PCollection</code> in some form. The <code class="highlighter-rouge">PCollection</code> you create serves as the input
for the first operation in your pipeline.</p>

<h3 id="creating-a-pcollection">3.1. Creating a PCollection</h3>

<p>You create a <code class="highlighter-rouge">PCollection</code> by either reading data from an external source using
Beam’s <a href="#pipeline-io">Source API</a>, or you can create a <code class="highlighter-rouge">PCollection</code> of data
stored in an in-memory collection class in your driver program. The former is
typically how a production pipeline would ingest data; Beam’s Source APIs
contain adapters to help you read from external sources like large cloud-based
files, databases, or subscription services. The latter is primarily useful for
testing and debugging purposes.</p>

<h4 id="reading-external-source">3.1.1. Reading from an external source</h4>

<p>To read from an external source, you use one of the <a href="#pipeline-io">Beam-provided I/O
adapters</a>. The adapters vary in their exact usage, but all of them
read from some external data source and return a <code class="highlighter-rouge">PCollection</code> whose elements
represent the data records in that source.</p>

<p>Each data source adapter has a <code class="highlighter-rouge">Read</code> transform; to read, you must apply that
transform to the <code class="highlighter-rouge">Pipeline</code> object itself.
<span class="language-java"><code class="highlighter-rouge">TextIO.Read</code></span>
<span class="language-py"><code class="highlighter-rouge">io.TextFileSource</code></span>, for example, reads from an
external text file and returns a <code class="highlighter-rouge">PCollection</code> whose elements are of type
<code class="highlighter-rouge">String</code>, each <code class="highlighter-rouge">String</code> represents one line from the text file. Here’s how you
would apply <span class="language-java"><code class="highlighter-rouge">TextIO.Read</code></span>
<span class="language-py"><code class="highlighter-rouge">io.TextFileSource</code></span> to your <code class="highlighter-rouge">Pipeline</code> to create
a <code class="highlighter-rouge">PCollection</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Create the pipeline.</span>
    <span class="n">PipelineOptions</span> <span class="n">options</span> <span class="o">=</span>
        <span class="n">PipelineOptionsFactory</span><span class="o">.</span><span class="na">fromArgs</span><span class="o">(</span><span class="n">args</span><span class="o">).</span><span class="na">create</span><span class="o">();</span>
    <span class="n">Pipeline</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">options</span><span class="o">);</span>

    <span class="c1">// Create the PCollection 'lines' by applying a 'Read' transform.</span>
    <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
      <span class="s">"ReadMyFile"</span><span class="o">,</span> <span class="n">TextIO</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">from</span><span class="o">(</span><span class="s">"protocol://path/to/some/inputData.txt"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">lines</span> <span class="o">=</span> <span class="n">p</span> <span class="o">|</span> <span class="s">'ReadMyFile'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">ReadFromText</span><span class="p">(</span><span class="s">'gs://some/inputData.txt'</span><span class="p">)</span>

</code></pre>
</div>

<p>See the <a href="#pipeline-io">section on I/O</a> to learn more about how to read from the
various data sources supported by the Beam SDK.</p>

<h4 id="creating-pcollection-in-memory">3.1.2. Creating a PCollection from in-memory data</h4>

<p class="language-java">To create a <code class="highlighter-rouge">PCollection</code> from an in-memory Java <code class="highlighter-rouge">Collection</code>, you use the
Beam-provided <code class="highlighter-rouge">Create</code> transform. Much like a data adapter’s <code class="highlighter-rouge">Read</code>, you apply
<code class="highlighter-rouge">Create</code> directly to your <code class="highlighter-rouge">Pipeline</code> object itself.</p>

<p class="language-java">As parameters, <code class="highlighter-rouge">Create</code> accepts the Java <code class="highlighter-rouge">Collection</code> and a <code class="highlighter-rouge">Coder</code> object. The
<code class="highlighter-rouge">Coder</code> specifies how the elements in the <code class="highlighter-rouge">Collection</code> should be
<a href="#element-type">encoded</a>.</p>

<p class="language-py">To create a <code class="highlighter-rouge">PCollection</code> from an in-memory <code class="highlighter-rouge">list</code>, you use the Beam-provided
<code class="highlighter-rouge">Create</code> transform. Apply this transform directly to your <code class="highlighter-rouge">Pipeline</code> object
itself.</p>

<p>The following example code shows how to create a <code class="highlighter-rouge">PCollection</code> from an in-memory
<span class="language-java"><code class="highlighter-rouge">List</code></span><span class="language-py"><code class="highlighter-rouge">list</code></span>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Create a Java Collection, in this case a List of Strings.</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">LINES</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
      <span class="s">"To be, or not to be: that is the question: "</span><span class="o">,</span>
      <span class="s">"Whether 'tis nobler in the mind to suffer "</span><span class="o">,</span>
      <span class="s">"The slings and arrows of outrageous fortune, "</span><span class="o">,</span>
      <span class="s">"Or to take arms against a sea of troubles, "</span><span class="o">);</span>

    <span class="c1">// Create the pipeline.</span>
    <span class="n">PipelineOptions</span> <span class="n">options</span> <span class="o">=</span>
        <span class="n">PipelineOptionsFactory</span><span class="o">.</span><span class="na">fromArgs</span><span class="o">(</span><span class="n">args</span><span class="o">).</span><span class="na">create</span><span class="o">();</span>
    <span class="n">Pipeline</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">options</span><span class="o">);</span>

    <span class="c1">// Apply Create, passing the list and the coder, to create the PCollection.</span>
    <span class="n">p</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">Create</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">LINES</span><span class="o">)).</span><span class="na">setCoder</span><span class="o">(</span><span class="n">StringUtf8Coder</span><span class="o">.</span><span class="na">of</span><span class="o">())</span>
<span class="o">}</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="k">with</span> <span class="n">beam</span><span class="o">.</span><span class="n">Pipeline</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="n">pipeline_options</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>

  <span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span>
           <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Create</span><span class="p">([</span>
               <span class="s">'To be, or not to be: that is the question: '</span><span class="p">,</span>
               <span class="s">'Whether </span><span class="se">\'</span><span class="s">tis nobler in the mind to suffer '</span><span class="p">,</span>
               <span class="s">'The slings and arrows of outrageous fortune, '</span><span class="p">,</span>
               <span class="s">'Or to take arms against a sea of troubles, '</span><span class="p">]))</span>

</code></pre>
</div>

<h3 id="pcollection-characteristics">3.2. PCollection characteristics</h3>

<p>A <code class="highlighter-rouge">PCollection</code> is owned by the specific <code class="highlighter-rouge">Pipeline</code> object for which it is
created; multiple pipelines cannot share a <code class="highlighter-rouge">PCollection</code>. In some respects, a
<code class="highlighter-rouge">PCollection</code> functions like a collection class. However, a <code class="highlighter-rouge">PCollection</code> can
differ in a few key ways:</p>

<h4 id="element-type">3.2.1. Element type</h4>

<p>The elements of a <code class="highlighter-rouge">PCollection</code> may be of any type, but must all be of the same
type. However, to support distributed processing, Beam needs to be able to
encode each individual element as a byte string (so elements can be passed
around to distributed workers). The Beam SDKs provide a data encoding mechanism
that includes built-in encoding for commonly-used types as well as support for
specifying custom encodings as needed.</p>

<h4 id="immutability">3.2.2. Immutability</h4>

<p>A <code class="highlighter-rouge">PCollection</code> is immutable. Once created, you cannot add, remove, or change
individual elements. A Beam Transform might process each element of a
<code class="highlighter-rouge">PCollection</code> and generate new pipeline data (as a new <code class="highlighter-rouge">PCollection</code>), <em>but it
does not consume or modify the original input collection</em>.</p>

<h4 id="random-access">3.2.3. Random access</h4>

<p>A <code class="highlighter-rouge">PCollection</code> does not support random access to individual elements. Instead,
Beam Transforms consider every element in a <code class="highlighter-rouge">PCollection</code> individually.</p>

<h4 id="size-and-boundedness">3.2.4. Size and boundedness</h4>

<p>A <code class="highlighter-rouge">PCollection</code> is a large, immutable “bag” of elements. There is no upper limit
on how many elements a <code class="highlighter-rouge">PCollection</code> can contain; any given <code class="highlighter-rouge">PCollection</code> might
fit in memory on a single machine, or it might represent a very large
distributed data set backed by a persistent data store.</p>

<p>A <code class="highlighter-rouge">PCollection</code> can be either <strong>bounded</strong> or <strong>unbounded</strong> in size. A
<strong>bounded</strong> <code class="highlighter-rouge">PCollection</code> represents a data set of a known, fixed size, while an
<strong>unbounded</strong> <code class="highlighter-rouge">PCollection</code> represents a data set of unlimited size. Whether a
<code class="highlighter-rouge">PCollection</code> is bounded or unbounded depends on the source of the data set that
it represents. Reading from a batch data source, such as a file or a database,
creates a bounded <code class="highlighter-rouge">PCollection</code>. Reading from a streaming or
continously-updating data source, such as Pub/Sub or Kafka, creates an unbounded
<code class="highlighter-rouge">PCollection</code> (unless you explicitly tell it not to).</p>

<p>The bounded (or unbounded) nature of your <code class="highlighter-rouge">PCollection</code> affects how Beam
processes your data. A bounded <code class="highlighter-rouge">PCollection</code> can be processed using a batch job,
which might read the entire data set once, and perform processing in a job of
finite length. An unbounded <code class="highlighter-rouge">PCollection</code> must be processed using a streaming
job that runs continuously, as the entire collection can never be available for
processing at any one time.</p>

<p>Beam uses <a href="#windowing">windowing</a> to divide a continuously updating unbounded
<code class="highlighter-rouge">PCollection</code> into logical windows of finite size. These logical windows are
determined by some characteristic associated with a data element, such as a
<strong>timestamp</strong>. Aggregation transforms (such as <code class="highlighter-rouge">GroupByKey</code> and <code class="highlighter-rouge">Combine</code>) work
on a per-window basis — as the data set is generated, they process each
<code class="highlighter-rouge">PCollection</code> as a succession of these finite windows.</p>

<h4 id="element-timestamps">3.2.5. Element timestamps</h4>

<p>Each element in a <code class="highlighter-rouge">PCollection</code> has an associated intrinsic <strong>timestamp</strong>. The
timestamp for each element is initially assigned by the <a href="#pipeline-io">Source</a>
that creates the <code class="highlighter-rouge">PCollection</code>. Sources that create an unbounded <code class="highlighter-rouge">PCollection</code>
often assign each new element a timestamp that corresponds to when the element
was read or added.</p>

<blockquote>
  <p><strong>Note</strong>: Sources that create a bounded <code class="highlighter-rouge">PCollection</code> for a fixed data set
also automatically assign timestamps, but the most common behavior is to
assign every element the same timestamp (<code class="highlighter-rouge">Long.MIN_VALUE</code>).</p>
</blockquote>

<p>Timestamps are useful for a <code class="highlighter-rouge">PCollection</code> that contains elements with an
inherent notion of time. If your pipeline is reading a stream of events, like
Tweets or other social media messages, each element might use the time the event
was posted as the element timestamp.</p>

<p>You can manually assign timestamps to the elements of a <code class="highlighter-rouge">PCollection</code> if the
source doesn’t do it for you. You’ll want to do this if the elements have an
inherent timestamp, but the timestamp is somewhere in the structure of the
element itself (such as a “time” field in a server log entry). Beam has
<a href="#transforms">Transforms</a> that take a <code class="highlighter-rouge">PCollection</code> as input and output an
identical <code class="highlighter-rouge">PCollection</code> with timestamps attached; see <a href="#adding-timestamps-to-a-pcollections-elements">Adding
Timestamps</a> for more information
about how to do so.</p>

<h2 id="transforms">4. Transforms</h2>

<p>Transforms are the operations in your pipeline, and provide a generic
processing framework. You provide processing logic in the form of a function
object (colloquially referred to as “user code”), and your user code is applied
to each element of an input <code class="highlighter-rouge">PCollection</code> (or more than one <code class="highlighter-rouge">PCollection</code>).
Depending on the pipeline runner and back-end that you choose, many different
workers across a cluster may execute instances of your user code in parallel.
The user code running on each worker generates the output elements that are
ultimately added to the final output <code class="highlighter-rouge">PCollection</code> that the transform produces.</p>

<p>The Beam SDKs contain a number of different transforms that you can apply to
your pipeline’s <code class="highlighter-rouge">PCollection</code>s. These include general-purpose core transforms,
such as <a href="#pardo">ParDo</a> or <a href="#combine">Combine</a>. There are also pre-written
<a href="#composite-transforms">composite transforms</a> included in the SDKs, which
combine one or more of the core transforms in a useful processing pattern, such
as counting or combining elements in a collection. You can also define your own
more complex composite transforms to fit your pipeline’s exact use case.</p>

<h3 id="applying-transforms">4.1. Applying transforms</h3>

<p>To invoke a transform, you must <strong>apply</strong> it to the input <code class="highlighter-rouge">PCollection</code>. Each
transform in the Beam SDKs has a generic <code class="highlighter-rouge">apply</code> method <span class="language-py">(or pipe operator <code class="highlighter-rouge">|</code>)</span>.
Invoking multiple Beam transforms is similar to <em>method chaining</em>, but with one
slight difference: You apply the transform to the input <code class="highlighter-rouge">PCollection</code>, passing
the transform itself as an argument, and the operation returns the output
<code class="highlighter-rouge">PCollection</code>. This takes the general form:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">[</span><span class="n">Output</span> <span class="n">PCollection</span><span class="o">]</span> <span class="o">=</span> <span class="o">[</span><span class="n">Input</span> <span class="n">PCollection</span><span class="o">].</span><span class="na">apply</span><span class="o">([</span><span class="n">Transform</span><span class="o">])</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">Output</span> <span class="n">PCollection</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Input</span> <span class="n">PCollection</span><span class="p">]</span> <span class="o">|</span> <span class="p">[</span><span class="n">Transform</span><span class="p">]</span>
</code></pre>
</div>

<p>Because Beam uses a generic <code class="highlighter-rouge">apply</code> method for <code class="highlighter-rouge">PCollection</code>, you can both chain
transforms sequentially and also apply transforms that contain other transforms
nested within (called <a href="#composite-transforms">composite transforms</a> in the Beam
SDKs).</p>

<p>How you apply your pipeline’s transforms determines the structure of your
pipeline. The best way to think of your pipeline is as a directed acyclic graph,
where the nodes are <code class="highlighter-rouge">PCollection</code>s and the edges are transforms. For example,
you can chain transforms to create a sequential pipeline, like this one:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">[</span><span class="n">Final</span> <span class="n">Output</span> <span class="n">PCollection</span><span class="o">]</span> <span class="o">=</span> <span class="o">[</span><span class="n">Initial</span> <span class="n">Input</span> <span class="n">PCollection</span><span class="o">].</span><span class="na">apply</span><span class="o">([</span><span class="n">First</span> <span class="n">Transform</span><span class="o">])</span>
<span class="o">.</span><span class="na">apply</span><span class="o">([</span><span class="n">Second</span> <span class="n">Transform</span><span class="o">])</span>
<span class="o">.</span><span class="na">apply</span><span class="o">([</span><span class="n">Third</span> <span class="n">Transform</span><span class="o">])</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">Final</span> <span class="n">Output</span> <span class="n">PCollection</span><span class="p">]</span> <span class="o">=</span> <span class="p">([</span><span class="n">Initial</span> <span class="n">Input</span> <span class="n">PCollection</span><span class="p">]</span> <span class="o">|</span> <span class="p">[</span><span class="n">First</span> <span class="n">Transform</span><span class="p">]</span>
              <span class="o">|</span> <span class="p">[</span><span class="n">Second</span> <span class="n">Transform</span><span class="p">]</span>
              <span class="o">|</span> <span class="p">[</span><span class="n">Third</span> <span class="n">Transform</span><span class="p">])</span>
</code></pre>
</div>

<p>The resulting workflow graph of the above pipeline looks like this.</p>

<p><img src="/images/design-your-pipeline-linear.png" alt="This linear pipeline starts with one input collection, sequentially applies
  three transforms, and ends with one output collection." /></p>

<p><em>Figure: A linear pipeline with three sequential transforms.</em></p>

<p>However, note that a transform <em>does not consume or otherwise alter</em> the input
collection–remember that a <code class="highlighter-rouge">PCollection</code> is immutable by definition. This means
that you can apply multiple transforms to the same input <code class="highlighter-rouge">PCollection</code> to create
a branching pipeline, like so:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">[</span><span class="n">Output</span> <span class="n">PCollection</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">[</span><span class="n">Input</span> <span class="n">PCollection</span><span class="o">].</span><span class="na">apply</span><span class="o">([</span><span class="n">Transform</span> <span class="mi">1</span><span class="o">])</span>
<span class="o">[</span><span class="n">Output</span> <span class="n">PCollection</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="o">[</span><span class="n">Input</span> <span class="n">PCollection</span><span class="o">].</span><span class="na">apply</span><span class="o">([</span><span class="n">Transform</span> <span class="mi">2</span><span class="o">])</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">Output</span> <span class="n">PCollection</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Input</span> <span class="n">PCollection</span><span class="p">]</span> <span class="o">|</span> <span class="p">[</span><span class="n">Transform</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="n">Output</span> <span class="n">PCollection</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Input</span> <span class="n">PCollection</span><span class="p">]</span> <span class="o">|</span> <span class="p">[</span><span class="n">Transform</span> <span class="mi">2</span><span class="p">]</span>
</code></pre>
</div>

<p>The resulting workflow graph from the branching pipeline above looks like this.</p>

<p><img src="/images/design-your-pipeline-multiple-pcollections.png" alt="This pipeline applies two transforms to a single input collection. Each
  transform produces an output collection." /></p>

<p><em>Figure: A branching pipeline. Two transforms are applied to a single
PCollection of database table rows.</em></p>

<p>You can also build your own <a href="#composite-transforms">composite transforms</a> that
nest multiple sub-steps inside a single, larger transform. Composite transforms
are particularly useful for building a reusable sequence of simple steps that
get used in a lot of different places.</p>

<h3 id="core-beam-transforms">4.2. Core Beam transforms</h3>

<p>Beam provides the following core transforms, each of which represents a different
processing paradigm:</p>

<ul>
  <li><code class="highlighter-rouge">ParDo</code></li>
  <li><code class="highlighter-rouge">GroupByKey</code></li>
  <li><code class="highlighter-rouge">CoGroupByKey</code></li>
  <li><code class="highlighter-rouge">Combine</code></li>
  <li><code class="highlighter-rouge">Flatten</code></li>
  <li><code class="highlighter-rouge">Partition</code></li>
</ul>

<h4 id="pardo">4.2.1. ParDo</h4>

<p><code class="highlighter-rouge">ParDo</code> is a Beam transform for generic parallel processing. The <code class="highlighter-rouge">ParDo</code>
processing paradigm is similar to the “Map” phase of a Map/Shuffle/Reduce-style
algorithm: a <code class="highlighter-rouge">ParDo</code> transform considers each element in the input
<code class="highlighter-rouge">PCollection</code>, performs some processing function (your user code) on that
element, and emits zero, one, or multiple elements to an output <code class="highlighter-rouge">PCollection</code>.</p>

<p><code class="highlighter-rouge">ParDo</code> is useful for a variety of common data processing operations, including:</p>

<ul>
  <li><strong>Filtering a data set.</strong> You can use <code class="highlighter-rouge">ParDo</code> to consider each element in a
<code class="highlighter-rouge">PCollection</code> and either output that element to a new collection, or discard
it.</li>
  <li><strong>Formatting or type-converting each element in a data set.</strong> If your input
<code class="highlighter-rouge">PCollection</code> contains elements that are of a different type or format than
you want, you can use <code class="highlighter-rouge">ParDo</code> to perform a conversion on each element and
output the result to a new <code class="highlighter-rouge">PCollection</code>.</li>
  <li><strong>Extracting parts of each element in a data set.</strong> If you have a
<code class="highlighter-rouge">PCollection</code> of records with multiple fields, for example, you can use a
<code class="highlighter-rouge">ParDo</code> to parse out just the fields you want to consider into a new
<code class="highlighter-rouge">PCollection</code>.</li>
  <li><strong>Performing computations on each element in a data set.</strong> You can use <code class="highlighter-rouge">ParDo</code>
to perform simple or complex computations on every element, or certain
elements, of a <code class="highlighter-rouge">PCollection</code> and output the results as a new <code class="highlighter-rouge">PCollection</code>.</li>
</ul>

<p>In such roles, <code class="highlighter-rouge">ParDo</code> is a common intermediate step in a pipeline. You might
use it to extract certain fields from a set of raw input records, or convert raw
input into a different format; you might also use <code class="highlighter-rouge">ParDo</code> to convert processed
data into a format suitable for output, like database table rows or printable
strings.</p>

<p>When you apply a <code class="highlighter-rouge">ParDo</code> transform, you’ll need to provide user code in the form
of a <code class="highlighter-rouge">DoFn</code> object. <code class="highlighter-rouge">DoFn</code> is a Beam SDK class that defines a distributed
processing function.</p>

<blockquote>
  <p>When you create a subclass of <code class="highlighter-rouge">DoFn</code>, note that your subclass should adhere to
the <a href="#requirements-for-writing-user-code-for-beam-transforms">Requirements for writing user code for Beam transforms</a>.</p>
</blockquote>

<h5 id="applying-pardo">4.2.1.1. Applying ParDo</h5>

<p>Like all Beam transforms, you apply <code class="highlighter-rouge">ParDo</code> by calling the <code class="highlighter-rouge">apply</code> method on the
input <code class="highlighter-rouge">PCollection</code> and passing <code class="highlighter-rouge">ParDo</code> as an argument, as shown in the
following example code:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// The input PCollection of Strings.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="o">...;</span>

<span class="c1">// The DoFn to perform on each element in the input PCollection.</span>
<span class="kd">static</span> <span class="kd">class</span> <span class="nc">ComputeWordLengthFn</span> <span class="kd">extends</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="c1">// Apply a ParDo to the PCollection "words" to compute lengths for each word.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">wordLengths</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
    <span class="n">ParDo</span>
    <span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">ComputeWordLengthFn</span><span class="o">()));</span>        <span class="c1">// The DoFn to perform on each element, which</span>
                                            <span class="c1">// we define above.</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># The input PCollection of Strings.</span>
<span class="n">words</span> <span class="o">=</span> <span class="o">...</span>

<span class="c"># The DoFn to perform on each element in the input PCollection.</span>
<span class="k">class</span> <span class="nc">ComputeWordLengthFn</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">DoFn</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">element</span><span class="p">)]</span>

<span class="c"># Apply a ParDo to the PCollection "words" to compute lengths for each word.</span>
<span class="n">word_lengths</span> <span class="o">=</span> <span class="n">words</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">ParDo</span><span class="p">(</span><span class="n">ComputeWordLengthFn</span><span class="p">())</span>
</code></pre>
</div>

<p>In the example, our input <code class="highlighter-rouge">PCollection</code> contains <code class="highlighter-rouge">String</code> values. We apply a
<code class="highlighter-rouge">ParDo</code> transform that specifies a function (<code class="highlighter-rouge">ComputeWordLengthFn</code>) to compute
the length of each string, and outputs the result to a new <code class="highlighter-rouge">PCollection</code> of
<code class="highlighter-rouge">Integer</code> values that stores the length of each word.</p>

<h5 id="4212-creating-a-dofn">4.2.1.2. Creating a DoFn</h5>

<p>The <code class="highlighter-rouge">DoFn</code> object that you pass to <code class="highlighter-rouge">ParDo</code> contains the processing logic that
gets applied to the elements in the input collection. When you use Beam, often
the most important pieces of code you’ll write are these <code class="highlighter-rouge">DoFn</code>s–they’re what
define your pipeline’s exact data processing tasks.</p>

<blockquote>
  <p><strong>Note:</strong> When you create your <code class="highlighter-rouge">DoFn</code>, be mindful of the <a href="#requirements-for-writing-user-code-for-beam-transforms">Requirements
for writing user code for Beam transforms</a>
and ensure that your code follows them.</p>
</blockquote>

<p class="language-java">A <code class="highlighter-rouge">DoFn</code> processes one element at a time from the input <code class="highlighter-rouge">PCollection</code>. When you
create a subclass of <code class="highlighter-rouge">DoFn</code>, you’ll need to provide type parameters that match
the types of the input and output elements. If your <code class="highlighter-rouge">DoFn</code> processes incoming
<code class="highlighter-rouge">String</code> elements and produces <code class="highlighter-rouge">Integer</code> elements for the output collection
(like our previous example, <code class="highlighter-rouge">ComputeWordLengthFn</code>), your class declaration would
look like this:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">class</span> <span class="nc">ComputeWordLengthFn</span> <span class="kd">extends</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre>
</div>

<p class="language-java">Inside your <code class="highlighter-rouge">DoFn</code> subclass, you’ll write a method annotated with
<code class="highlighter-rouge">@ProcessElement</code> where you provide the actual processing logic. You don’t need
to manually extract the elements from the input collection; the Beam SDKs handle
that for you. Your <code class="highlighter-rouge">@ProcessElement</code> method should accept a parameter tagged with
<code class="highlighter-rouge">@Element</code>, which will be populated with the input element. In order to output
elements, the method can also take a parameter of type <code class="highlighter-rouge">OutputReceiver</code> which
provides a method for emitting elements. The parameter types must match the input
and output types of your <code class="highlighter-rouge">DoFn</code> or the framework will raise an error. Note: @Element and
OutputReceiver were introduced in Beam 2.5.0; if using an earlier release of Beam, a
ProcessContext parameter should be used instead.</p>

<p class="language-py">Inside your <code class="highlighter-rouge">DoFn</code> subclass, you’ll write a method <code class="highlighter-rouge">process</code> where you provide
the actual processing logic. You don’t need to manually extract the elements
from the input collection; the Beam SDKs handle that for you. Your <code class="highlighter-rouge">process</code>
method should accept an object of type <code class="highlighter-rouge">element</code>. This is the input element and
output is emitted by using <code class="highlighter-rouge">yield</code> or <code class="highlighter-rouge">return</code> statement inside <code class="highlighter-rouge">process</code>
method.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">class</span> <span class="nc">ComputeWordLengthFn</span> <span class="kd">extends</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@ProcessElement</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="nd">@Element</span> <span class="n">String</span> <span class="n">word</span><span class="o">,</span> <span class="n">OutputReceiver</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Use OutputReceiver.output to emit the output element.</span>
    <span class="n">out</span><span class="o">.</span><span class="na">output</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ComputeWordLengthFn</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">DoFn</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">element</span><span class="p">)]</span>

</code></pre>
</div>

<blockquote class="language-java">
  <p><strong>Note:</strong> If the elements in your input <code class="highlighter-rouge">PCollection</code> are key/value pairs, you
can access the key or value by using <code class="highlighter-rouge">element.getKey()</code> or
<code class="highlighter-rouge">element.getValue()</code>, respectively.</p>
</blockquote>

<p>A given <code class="highlighter-rouge">DoFn</code> instance generally gets invoked one or more times to process some
arbitrary bundle of elements. However, Beam doesn’t guarantee an exact number of
invocations; it may be invoked multiple times on a given worker node to account
for failures and retries. As such, you can cache information across multiple
calls to your processing method, but if you do so, make sure the implementation
<strong>does not depend on the number of invocations</strong>.</p>

<p>In your processing method, you’ll also need to meet some immutability
requirements to ensure that Beam and the processing back-end can safely
serialize and cache the values in your pipeline. Your method should meet the
following requirements:</p>

<ul class="language-java">
  <li>You should not in any way modify an element returned by
the <code class="highlighter-rouge">@Element</code> annotation or <code class="highlighter-rouge">ProcessContext.sideInput()</code> (the incoming
elements from the input collection).</li>
  <li>Once you output a value using <code class="highlighter-rouge">OutputReceiver.output()</code> you should not modify
that value in any way.</li>
</ul>

<h5 id="lightweight-dofns">4.2.1.3. Lightweight DoFns and other abstractions</h5>

<p>If your function is relatively straightforward, you can simplify your use of
<code class="highlighter-rouge">ParDo</code> by providing a lightweight <code class="highlighter-rouge">DoFn</code> in-line, as
<span class="language-java">an anonymous inner class instance</span>
<span class="language-py">a lambda function</span>.</p>

<p>Here’s the previous example, <code class="highlighter-rouge">ParDo</code> with <code class="highlighter-rouge">ComputeLengthWordsFn</code>, with the
<code class="highlighter-rouge">DoFn</code> specified as
<span class="language-java">an anonymous inner class instance</span>
<span class="language-py">a lambda function</span>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// The input PCollection.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="o">...;</span>

<span class="c1">// Apply a ParDo with an anonymous DoFn to the PCollection words.</span>
<span class="c1">// Save the result as the PCollection wordLengths.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">wordLengths</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
  <span class="s">"ComputeWordLengths"</span><span class="o">,</span>                     <span class="c1">// the transform name</span>
  <span class="n">ParDo</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>    <span class="c1">// a DoFn as an anonymous inner class instance</span>
      <span class="nd">@ProcessElement</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="nd">@Element</span> <span class="n">String</span> <span class="n">word</span><span class="o">,</span> <span class="n">OutputReceiver</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">out</span><span class="o">.</span><span class="na">output</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
      <span class="o">}</span>
    <span class="o">}));</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># The input PCollection of strings.</span>
<span class="n">words</span> <span class="o">=</span> <span class="o">...</span>

<span class="c"># Apply a lambda function to the PCollection words.</span>
<span class="c"># Save the result as the PCollection word_lengths.</span>
<span class="n">word_lengths</span> <span class="o">=</span> <span class="n">words</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">FlatMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">word</span><span class="p">:</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)])</span>
</code></pre>
</div>

<p>If your <code class="highlighter-rouge">ParDo</code> performs a one-to-one mapping of input elements to output
elements–that is, for each input element, it applies a function that produces
<em>exactly one</em> output element, you can use the higher-level
<span class="language-java"><code class="highlighter-rouge">MapElements</code></span><span class="language-py"><code class="highlighter-rouge">Map</code></span>
transform. <span class="language-java"><code class="highlighter-rouge">MapElements</code> can accept an anonymous
Java 8 lambda function for additional brevity.</span></p>

<p>Here’s the previous example using <span class="language-java"><code class="highlighter-rouge">MapElements</code></span>
<span class="language-py"><code class="highlighter-rouge">Map</code></span>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// The input PCollection.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="o">...;</span>

<span class="c1">// Apply a MapElements with an anonymous lambda function to the PCollection words.</span>
<span class="c1">// Save the result as the PCollection wordLengths.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">wordLengths</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
  <span class="n">MapElements</span><span class="o">.</span><span class="na">into</span><span class="o">(</span><span class="n">TypeDescriptors</span><span class="o">.</span><span class="na">integers</span><span class="o">())</span>
             <span class="o">.</span><span class="na">via</span><span class="o">((</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()));</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># The input PCollection of string.</span>
<span class="n">words</span> <span class="o">=</span> <span class="o">...</span>

<span class="c"># Apply a Map with a lambda function to the PCollection words.</span>
<span class="c"># Save the result as the PCollection word_lengths.</span>
<span class="n">word_lengths</span> <span class="o">=</span> <span class="n">words</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span>
</code></pre>
</div>

<blockquote class="language-java">
  <p><strong>Note:</strong> You can use Java 8 lambda functions with several other Beam
transforms, including <code class="highlighter-rouge">Filter</code>, <code class="highlighter-rouge">FlatMapElements</code>, and <code class="highlighter-rouge">Partition</code>.</p>
</blockquote>

<h4 id="groupbykey">4.2.2. GroupByKey</h4>

<p><code class="highlighter-rouge">GroupByKey</code> is a Beam transform for processing collections of key/value pairs.
It’s a parallel reduction operation, analogous to the Shuffle phase of a
Map/Shuffle/Reduce-style algorithm. The input to <code class="highlighter-rouge">GroupByKey</code> is a collection of
key/value pairs that represents a <em>multimap</em>, where the collection contains
multiple pairs that have the same key, but different values. Given such a
collection, you use <code class="highlighter-rouge">GroupByKey</code> to collect all of the values associated with
each unique key.</p>

<p><code class="highlighter-rouge">GroupByKey</code> is a good way to aggregate data that has something in common. For
example, if you have a collection that stores records of customer orders, you
might want to group together all the orders from the same postal code (wherein
the “key” of the key/value pair is the postal code field, and the “value” is the
remainder of the record).</p>

<p>Let’s examine the mechanics of <code class="highlighter-rouge">GroupByKey</code> with a simple example case, where
our data set consists of words from a text file and the line number on which
they appear. We want to group together all the line numbers (values) that share
the same word (key), letting us see all the places in the text where a
particular word appears.</p>

<p>Our input is a <code class="highlighter-rouge">PCollection</code> of key/value pairs where each word is a key, and
the value is a line number in the file where the word appears. Here’s a list of
the key/value pairs in the input collection:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat, 1
dog, 5
and, 1
jump, 3
tree, 2
cat, 5
dog, 2
and, 2
cat, 9
and, 6
...
</code></pre>
</div>

<p><code class="highlighter-rouge">GroupByKey</code> gathers up all the values with the same key and outputs a new pair
consisting of the unique key and a collection of all of the values that were
associated with that key in the input collection. If we apply <code class="highlighter-rouge">GroupByKey</code> to
our input collection above, the output collection would look like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat, [1,5,9]
dog, [5,2]
and, [1,2,6]
jump, [3]
tree, [2]
...
</code></pre>
</div>

<p>Thus, <code class="highlighter-rouge">GroupByKey</code> represents a transform from a multimap (multiple keys to
individual values) to a uni-map (unique keys to collections of values).</p>

<h5 id="groupbykey-and-unbounded-pcollections">4.2.2.1 GroupByKey and unbounded PCollections</h5>

<p>If you are using unbounded <code class="highlighter-rouge">PCollection</code>s, you must use either <a href="#setting-your-pcollections-windowing-function">non-global
windowing</a> or an
<a href="#triggers">aggregation trigger</a> in order to perform a <code class="highlighter-rouge">GroupByKey</code> or
<a href="#cogroupbykey">CoGroupByKey</a>. This is because a bounded <code class="highlighter-rouge">GroupByKey</code> or
<code class="highlighter-rouge">CoGroupByKey</code> must wait for all the data with a certain key to be collected,
but with unbounded collections, the data is unlimited. Windowing and/or triggers
allow grouping to operate on logical, finite bundles of data within the
unbounded data streams.</p>

<p>If you do apply <code class="highlighter-rouge">GroupByKey</code> or <code class="highlighter-rouge">CoGroupByKey</code> to a group of unbounded
<code class="highlighter-rouge">PCollection</code>s without setting either a non-global windowing strategy, a trigger
strategy, or both for each collection, Beam generates an IllegalStateException
error at pipeline construction time.</p>

<p>When using <code class="highlighter-rouge">GroupByKey</code> or <code class="highlighter-rouge">CoGroupByKey</code> to group <code class="highlighter-rouge">PCollection</code>s that have a
<a href="#windowing">windowing strategy</a> applied, all of the <code class="highlighter-rouge">PCollection</code>s you want to
group <em>must use the same windowing strategy</em> and window sizing. For example, all
of the collections you are merging must use (hypothetically) identical 5-minute
fixed windows, or 4-minute sliding windows starting every 30 seconds.</p>

<p>If your pipeline attempts to use <code class="highlighter-rouge">GroupByKey</code> or <code class="highlighter-rouge">CoGroupByKey</code> to merge
<code class="highlighter-rouge">PCollection</code>s with incompatible windows, Beam generates an
IllegalStateException error at pipeline construction time.</p>

<h4 id="cogroupbykey">4.2.3. CoGroupByKey</h4>

<p><code class="highlighter-rouge">CoGroupByKey</code> performs a relational join of two or more key/value
<code class="highlighter-rouge">PCollection</code>s that have the same key type.
<a href="/documentation/pipelines/design-your-pipeline/#multiple-sources">Design Your Pipeline</a>
shows an example pipeline that uses a join.</p>

<p>Consider using <code class="highlighter-rouge">CoGroupByKey</code> if you have multiple data sets that provide
information about related things. For example, let’s say you have two different
files with user data: one file has names and email addresses; the other file
has names and phone numbers. You can join those two data sets, using the user
name as a common key and the other data as the associated values. After the
join, you have one data set that contains all of the information (email
addresses and phone numbers) associated with each name.</p>

<p>If you are using unbounded <code class="highlighter-rouge">PCollection</code>s, you must use either <a href="#setting-your-pcollections-windowing-function">non-global
windowing</a> or an
<a href="#triggers">aggregation trigger</a> in order to perform a <code class="highlighter-rouge">CoGroupByKey</code>. See
<a href="#groupbykey-and-unbounded-pcollections">GroupByKey and unbounded PCollections</a>
for more details.</p>

<p><span class="language-java">
In the Beam SDK for Java, <code class="highlighter-rouge">CoGroupByKey</code> accepts a tuple of keyed
<code class="highlighter-rouge">PCollection</code>s (<code class="highlighter-rouge">PCollection&lt;KV&lt;K, V&gt;&gt;</code>) as input. For type safety, the SDK
requires you to pass each <code class="highlighter-rouge">PCollection</code> as part of a <code class="highlighter-rouge">KeyedPCollectionTuple</code>.
You must declare a <code class="highlighter-rouge">TupleTag</code> for each input <code class="highlighter-rouge">PCollection</code> in the
<code class="highlighter-rouge">KeyedPCollectionTuple</code> that you want to pass to <code class="highlighter-rouge">CoGroupByKey</code>. As output,
<code class="highlighter-rouge">CoGroupByKey</code> returns a <code class="highlighter-rouge">PCollection&lt;KV&lt;K, CoGbkResult&gt;&gt;</code>, which groups values
from all the input <code class="highlighter-rouge">PCollection</code>s by their common keys. Each key (all of type
<code class="highlighter-rouge">K</code>) will have a different <code class="highlighter-rouge">CoGbkResult</code>, which is a map from <code class="highlighter-rouge">TupleTag&lt;T&gt;</code> to
<code class="highlighter-rouge">Iterable&lt;T&gt;</code>. You can access a specific collection in an <code class="highlighter-rouge">CoGbkResult</code> object
by using the <code class="highlighter-rouge">TupleTag</code> that you supplied with the initial collection.
</span>
<span class="language-py">
In the Beam SDK for Python, <code class="highlighter-rouge">CoGroupByKey</code> accepts a dictionary of keyed
<code class="highlighter-rouge">PCollection</code>s as input. As output, <code class="highlighter-rouge">CoGroupByKey</code> creates a single output
<code class="highlighter-rouge">PCollection</code> that contains one key/value tuple for each key in the input
<code class="highlighter-rouge">PCollection</code>s. Each key’s value is a dictionary that maps each tag to an
iterable of the values under they key in the corresponding <code class="highlighter-rouge">PCollection</code>.
</span></p>

<p>The following conceptual examples use two input collections to show the mechanics of
<code class="highlighter-rouge">CoGroupByKey</code>.</p>

<p><span class="language-java">
The first set of data has a <code class="highlighter-rouge">TupleTag&lt;String&gt;</code> called <code class="highlighter-rouge">emailsTag</code> and contains names
and email addresses. The second set of data has a <code class="highlighter-rouge">TupleTag&lt;String&gt;</code> called
<code class="highlighter-rouge">phonesTag</code> and contains names and phone numbers.
</span>
<span class="language-py">
The first set of data contains names and email addresses. The second set of
data contains names and phone numbers.
</span></p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">emailsList</span> <span class="o">=</span>
    <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="n">KV</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"amy"</span><span class="o">,</span> <span class="s">"amy@example.com"</span><span class="o">),</span>
        <span class="n">KV</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"carl"</span><span class="o">,</span> <span class="s">"carl@example.com"</span><span class="o">),</span>
        <span class="n">KV</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"julia"</span><span class="o">,</span> <span class="s">"julia@example.com"</span><span class="o">),</span>
        <span class="n">KV</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"carl"</span><span class="o">,</span> <span class="s">"carl@email.com"</span><span class="o">));</span>

<span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">phonesList</span> <span class="o">=</span>
    <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="n">KV</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"amy"</span><span class="o">,</span> <span class="s">"111-222-3333"</span><span class="o">),</span>
        <span class="n">KV</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"james"</span><span class="o">,</span> <span class="s">"222-333-4444"</span><span class="o">),</span>
        <span class="n">KV</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"amy"</span><span class="o">,</span> <span class="s">"333-444-5555"</span><span class="o">),</span>
        <span class="n">KV</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"carl"</span><span class="o">,</span> <span class="s">"444-555-6666"</span><span class="o">));</span>

<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">emails</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"CreateEmails"</span><span class="o">,</span> <span class="n">Create</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">emailsList</span><span class="o">));</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">phones</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"CreatePhones"</span><span class="o">,</span> <span class="n">Create</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">phonesList</span><span class="o">));</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">emails_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s">'amy'</span><span class="p">,</span> <span class="s">'amy@example.com'</span><span class="p">),</span>
    <span class="p">(</span><span class="s">'carl'</span><span class="p">,</span> <span class="s">'carl@example.com'</span><span class="p">),</span>
    <span class="p">(</span><span class="s">'julia'</span><span class="p">,</span> <span class="s">'julia@example.com'</span><span class="p">),</span>
    <span class="p">(</span><span class="s">'carl'</span><span class="p">,</span> <span class="s">'carl@email.com'</span><span class="p">),</span>
<span class="p">]</span>
<span class="n">phones_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s">'amy'</span><span class="p">,</span> <span class="s">'111-222-3333'</span><span class="p">),</span>
    <span class="p">(</span><span class="s">'james'</span><span class="p">,</span> <span class="s">'222-333-4444'</span><span class="p">),</span>
    <span class="p">(</span><span class="s">'amy'</span><span class="p">,</span> <span class="s">'333-444-5555'</span><span class="p">),</span>
    <span class="p">(</span><span class="s">'carl'</span><span class="p">,</span> <span class="s">'444-555-6666'</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">emails</span> <span class="o">=</span> <span class="n">p</span> <span class="o">|</span> <span class="s">'CreateEmails'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">emails_list</span><span class="p">)</span>
<span class="n">phones</span> <span class="o">=</span> <span class="n">p</span> <span class="o">|</span> <span class="s">'CreatePhones'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">phones_list</span><span class="p">)</span>
</code></pre>
</div>

<p>After <code class="highlighter-rouge">CoGroupByKey</code>, the resulting data contains all data associated with each
unique key from any of the input collections.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">final</span> <span class="n">TupleTag</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">emailsTag</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TupleTag</span><span class="o">&lt;&gt;();</span>
<span class="kd">final</span> <span class="n">TupleTag</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">phonesTag</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TupleTag</span><span class="o">&lt;&gt;();</span>

<span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">CoGbkResult</span><span class="o">&gt;&gt;</span> <span class="n">expectedResults</span> <span class="o">=</span>
    <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="n">KV</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
            <span class="s">"amy"</span><span class="o">,</span>
            <span class="n">CoGbkResult</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">emailsTag</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"amy@example.com"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">phonesTag</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"111-222-3333"</span><span class="o">,</span> <span class="s">"333-444-5555"</span><span class="o">))),</span>
        <span class="n">KV</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
            <span class="s">"carl"</span><span class="o">,</span>
            <span class="n">CoGbkResult</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">emailsTag</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"carl@email.com"</span><span class="o">,</span> <span class="s">"carl@example.com"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">phonesTag</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"444-555-6666"</span><span class="o">))),</span>
        <span class="n">KV</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
            <span class="s">"james"</span><span class="o">,</span>
            <span class="n">CoGbkResult</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">emailsTag</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">())</span>
                <span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">phonesTag</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"222-333-4444"</span><span class="o">))),</span>
        <span class="n">KV</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
            <span class="s">"julia"</span><span class="o">,</span>
            <span class="n">CoGbkResult</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">emailsTag</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"julia@example.com"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">phonesTag</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">())));</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s">'amy'</span><span class="p">,</span> <span class="p">{</span>
        <span class="s">'emails'</span><span class="p">:</span> <span class="p">[</span><span class="s">'amy@example.com'</span><span class="p">],</span>
        <span class="s">'phones'</span><span class="p">:</span> <span class="p">[</span><span class="s">'111-222-3333'</span><span class="p">,</span> <span class="s">'333-444-5555'</span><span class="p">]}),</span>
    <span class="p">(</span><span class="s">'carl'</span><span class="p">,</span> <span class="p">{</span>
        <span class="s">'emails'</span><span class="p">:</span> <span class="p">[</span><span class="s">'carl@email.com'</span><span class="p">,</span> <span class="s">'carl@example.com'</span><span class="p">],</span>
        <span class="s">'phones'</span><span class="p">:</span> <span class="p">[</span><span class="s">'444-555-6666'</span><span class="p">]}),</span>
    <span class="p">(</span><span class="s">'james'</span><span class="p">,</span> <span class="p">{</span>
        <span class="s">'emails'</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s">'phones'</span><span class="p">:</span> <span class="p">[</span><span class="s">'222-333-4444'</span><span class="p">]}),</span>
    <span class="p">(</span><span class="s">'julia'</span><span class="p">,</span> <span class="p">{</span>
        <span class="s">'emails'</span><span class="p">:</span> <span class="p">[</span><span class="s">'julia@example.com'</span><span class="p">],</span>
        <span class="s">'phones'</span><span class="p">:</span> <span class="p">[]}),</span>
<span class="p">]</span>
</code></pre>
</div>

<p>The following code example joins the two <code class="highlighter-rouge">PCollection</code>s with <code class="highlighter-rouge">CoGroupByKey</code>,
followed by a <code class="highlighter-rouge">ParDo</code> to consume the result. Then, the code uses tags to look up
and format data from each collection.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">PCollection</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">CoGbkResult</span><span class="o">&gt;&gt;</span> <span class="n">results</span> <span class="o">=</span>
    <span class="n">KeyedPCollectionTuple</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">emailsTag</span><span class="o">,</span> <span class="n">emails</span><span class="o">)</span>
        <span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">phonesTag</span><span class="o">,</span> <span class="n">phones</span><span class="o">)</span>
        <span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">CoGroupByKey</span><span class="o">.</span><span class="na">create</span><span class="o">());</span>

<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">contactLines</span> <span class="o">=</span>
    <span class="n">results</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
        <span class="n">ParDo</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
            <span class="k">new</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">CoGbkResult</span><span class="o">&gt;,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
              <span class="nd">@ProcessElement</span>
              <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="n">ProcessContext</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">CoGbkResult</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">element</span><span class="o">();</span>
                <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
                <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">emailsIter</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">getAll</span><span class="o">(</span><span class="n">emailsTag</span><span class="o">);</span>
                <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">phonesIter</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">getAll</span><span class="o">(</span><span class="n">phonesTag</span><span class="o">);</span>
                <span class="n">String</span> <span class="n">formattedResult</span> <span class="o">=</span>
                    <span class="n">Snippets</span><span class="o">.</span><span class="na">formatCoGbkResults</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">emailsIter</span><span class="o">,</span> <span class="n">phonesIter</span><span class="o">);</span>
                <span class="n">c</span><span class="o">.</span><span class="na">output</span><span class="o">(</span><span class="n">formattedResult</span><span class="o">);</span>
              <span class="o">}</span>
            <span class="o">}));</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># The result PCollection contains one key-value element for each key in the</span>
<span class="c"># input PCollections. The key of the pair will be the key from the input and</span>
<span class="c"># the value will be a dictionary with two entries: 'emails' - an iterable of</span>
<span class="c"># all values for the current key in the emails PCollection and 'phones': an</span>
<span class="c"># iterable of all values for the current key in the phones PCollection.</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">({</span><span class="s">'emails'</span><span class="p">:</span> <span class="n">emails</span><span class="p">,</span> <span class="s">'phones'</span><span class="p">:</span> <span class="n">phones</span><span class="p">}</span>
           <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">CoGroupByKey</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">join_info</span><span class="p">(</span><span class="n">name_info</span><span class="p">):</span>
  <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span> <span class="o">=</span> <span class="n">name_info</span>
  <span class="k">return</span> <span class="s">'</span><span class="si">%</span><span class="s">s; </span><span class="si">%</span><span class="s">s; </span><span class="si">%</span><span class="s">s'</span> <span class="o">%</span>\
      <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s">'emails'</span><span class="p">]),</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s">'phones'</span><span class="p">]))</span>

<span class="n">contact_lines</span> <span class="o">=</span> <span class="n">results</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">join_info</span><span class="p">)</span>
</code></pre>
</div>

<p>The formatted data looks like this:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">formattedResults</span> <span class="o">=</span>
    <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="s">"amy; ['amy@example.com']; ['111-222-3333', '333-444-5555']"</span><span class="o">,</span>
        <span class="s">"carl; ['carl@email.com', 'carl@example.com']; ['444-555-6666']"</span><span class="o">,</span>
        <span class="s">"james; []; ['222-333-4444']"</span><span class="o">,</span>
        <span class="s">"julia; ['julia@example.com']; []"</span><span class="o">);</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">formatted_results</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"amy; ['amy@example.com']; ['111-222-3333', '333-444-5555']"</span><span class="p">,</span>
    <span class="s">"carl; ['carl@email.com', 'carl@example.com']; ['444-555-6666']"</span><span class="p">,</span>
    <span class="s">"james; []; ['222-333-4444']"</span><span class="p">,</span>
    <span class="s">"julia; ['julia@example.com']; []"</span><span class="p">,</span>
<span class="p">]</span>
</code></pre>
</div>

<h4 id="combine">4.2.4. Combine</h4>

<p><span class="language-java"><a href="/documentation/sdks/javadoc/2.6.0/index.html?org/apache/beam/sdk/transforms/Combine.html"><code class="highlighter-rouge">Combine</code></a></span>
<span class="language-py"><a href="https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/core.py"><code class="highlighter-rouge">Combine</code></a></span>
is a Beam transform for combining collections of elements or values in your
data. <code class="highlighter-rouge">Combine</code> has variants that work on entire <code class="highlighter-rouge">PCollection</code>s, and some that
combine the values for each key in <code class="highlighter-rouge">PCollection</code>s of key/value pairs.</p>

<p>When you apply a <code class="highlighter-rouge">Combine</code> transform, you must provide the function that
contains the logic for combining the elements or values. The combining function
should be commutative and associative, as the function is not necessarily
invoked exactly once on all values with a given key. Because the input data
(including the value collection) may be distributed across multiple workers, the
combining function might be called multiple times to perform partial combining
on subsets of the value collection. The Beam SDK also provides some pre-built
combine functions for common numeric combination operations such as sum, min,
and max.</p>

<p>Simple combine operations, such as sums, can usually be implemented as a simple
function. More complex combination operations might require you to create a
subclass of <code class="highlighter-rouge">CombineFn</code> that has an accumulation type distinct from the
input/output type.</p>

<h5 id="simple-combines">4.2.4.1. Simple combinations using simple functions</h5>

<p>The following example code shows a simple combine function.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// Sum a collection of Integer values. The function SumInts implements the interface SerializableFunction.</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SumInts</span> <span class="kd">implements</span> <span class="n">SerializableFunction</span><span class="o">&lt;</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">apply</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">item</span> <span class="o">:</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">pc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">bounded_sum</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">bound</span><span class="p">)</span>
<span class="n">small_sum</span> <span class="o">=</span> <span class="n">pc</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">CombineGlobally</span><span class="p">(</span><span class="n">bounded_sum</span><span class="p">)</span>              <span class="c"># [500]</span>
<span class="n">large_sum</span> <span class="o">=</span> <span class="n">pc</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">CombineGlobally</span><span class="p">(</span><span class="n">bounded_sum</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>  <span class="c"># [1111]</span>
</code></pre>
</div>

<h5 id="advanced-combines">4.2.4.2. Advanced combinations using CombineFn</h5>

<p>For more complex combine functions, you can define a subclass of <code class="highlighter-rouge">CombineFn</code>.
You should use <code class="highlighter-rouge">CombineFn</code> if the combine function requires a more sophisticated
accumulator, must perform additional pre- or post-processing, might change the
output type, or takes the key into account.</p>

<p>A general combining operation consists of four operations. When you create a
subclass of <code class="highlighter-rouge">CombineFn</code>, you must provide four operations by overriding the
corresponding methods:</p>

<ol>
  <li>
    <p><strong>Create Accumulator</strong> creates a new “local” accumulator. In the example
case, taking a mean average, a local accumulator tracks the running sum of
values (the numerator value for our final average division) and the number of
values summed so far (the denominator value). It may be called any number of
times in a distributed fashion.</p>
  </li>
  <li>
    <p><strong>Add Input</strong> adds an input element to an accumulator, returning the
accumulator value. In our example, it would update the sum and increment the
count. It may also be invoked in parallel.</p>
  </li>
  <li>
    <p><strong>Merge Accumulators</strong> merges several accumulators into a single accumulator;
this is how data in multiple accumulators is combined before the final
calculation. In the case of the mean average computation, the accumulators
representing each portion of the division are merged together. It may be
called again on its outputs any number of times.</p>
  </li>
  <li>
    <p><strong>Extract Output</strong> performs the final computation. In the case of computing a
mean average, this means dividing the combined sum of all the values by the
number of values summed. It is called once on the final, merged accumulator.</p>
  </li>
</ol>

<p>The following example code shows how to define a <code class="highlighter-rouge">CombineFn</code> that computes a
mean average:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AverageFn</span> <span class="kd">extends</span> <span class="n">CombineFn</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">AverageFn</span><span class="o">.</span><span class="na">Accum</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Accum</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Accum</span> <span class="nf">createAccumulator</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Accum</span><span class="o">();</span> <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Accum</span> <span class="nf">addInput</span><span class="o">(</span><span class="n">Accum</span> <span class="n">accum</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">accum</span><span class="o">.</span><span class="na">sum</span> <span class="o">+=</span> <span class="n">input</span><span class="o">;</span>
      <span class="n">accum</span><span class="o">.</span><span class="na">count</span><span class="o">++;</span>
      <span class="k">return</span> <span class="n">accum</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Accum</span> <span class="nf">mergeAccumulators</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Accum</span><span class="o">&gt;</span> <span class="n">accums</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Accum</span> <span class="n">merged</span> <span class="o">=</span> <span class="n">createAccumulator</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Accum</span> <span class="n">accum</span> <span class="o">:</span> <span class="n">accums</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">merged</span><span class="o">.</span><span class="na">sum</span> <span class="o">+=</span> <span class="n">accum</span><span class="o">.</span><span class="na">sum</span><span class="o">;</span>
      <span class="n">merged</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="n">accum</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">merged</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Double</span> <span class="nf">extractOutput</span><span class="o">(</span><span class="n">Accum</span> <span class="n">accum</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="n">accum</span><span class="o">.</span><span class="na">sum</span><span class="o">)</span> <span class="o">/</span> <span class="n">accum</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">pc</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">AverageFn</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">CombineFn</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">create_accumulator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">add_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sum_count</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
    <span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">=</span> <span class="n">sum_count</span>
    <span class="k">return</span> <span class="nb">sum</span> <span class="o">+</span> <span class="nb">input</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

  <span class="k">def</span> <span class="nf">merge_accumulators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">accumulators</span><span class="p">):</span>
    <span class="n">sums</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">accumulators</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sums</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">extract_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sum_count</span><span class="p">):</span>
    <span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">=</span> <span class="n">sum_count</span>
    <span class="k">return</span> <span class="nb">sum</span> <span class="o">/</span> <span class="n">count</span> <span class="k">if</span> <span class="n">count</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="s">'NaN'</span><span class="p">)</span>
</code></pre>
</div>

<p>If you are combining a <code class="highlighter-rouge">PCollection</code> of key-value pairs, <a href="#combining-values-in-a-keyed-pcollection">per-key
combining</a> is often enough. If
you need the combining strategy to change based on the key (for example, MIN for
some users and MAX for other users), you can define a <code class="highlighter-rouge">KeyedCombineFn</code> to access
the key within the combining strategy.</p>

<h5 id="combining-pcollection">4.2.4.3. Combining a PCollection into a single value</h5>

<p>Use the global combine to transform all of the elements in a given <code class="highlighter-rouge">PCollection</code>
into a single value, represented in your pipeline as a new <code class="highlighter-rouge">PCollection</code>
containing one element. The following example code shows how to apply the Beam
provided sum combine function to produce a single sum value for a <code class="highlighter-rouge">PCollection</code>
of integers.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// Sum.SumIntegerFn() combines the elements in the input PCollection. The resulting PCollection, called sum,</span>
<span class="c1">// contains one value: the sum of all the elements in the input PCollection.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pc</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
   <span class="n">Combine</span><span class="o">.</span><span class="na">globally</span><span class="o">(</span><span class="k">new</span> <span class="n">Sum</span><span class="o">.</span><span class="na">SumIntegerFn</span><span class="o">()));</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># sum combines the elements in the input PCollection.</span>
<span class="c"># The resulting PCollection, called result, contains one value: the sum of all</span>
<span class="c"># the elements in the input PCollection.</span>
<span class="n">pc</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">average</span> <span class="o">=</span> <span class="n">pc</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">CombineGlobally</span><span class="p">(</span><span class="n">AverageFn</span><span class="p">())</span>
</code></pre>
</div>

<h5 id="combine-global-windowing">4.2.4.4. Combine and global windowing</h5>

<p>If your input <code class="highlighter-rouge">PCollection</code> uses the default global windowing, the default
behavior is to return a <code class="highlighter-rouge">PCollection</code> containing one item. That item’s value
comes from the accumulator in the combine function that you specified when
applying <code class="highlighter-rouge">Combine</code>. For example, the Beam provided sum combine function returns
a zero value (the sum of an empty input), while the min combine function returns
a maximal or infinite value.</p>

<p>To have <code class="highlighter-rouge">Combine</code> instead return an empty <code class="highlighter-rouge">PCollection</code> if the input is empty,
specify <code class="highlighter-rouge">.withoutDefaults</code> when you apply your <code class="highlighter-rouge">Combine</code> transform, as in the
following code example:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pc</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
  <span class="n">Combine</span><span class="o">.</span><span class="na">globally</span><span class="o">(</span><span class="k">new</span> <span class="n">Sum</span><span class="o">.</span><span class="na">SumIntegerFn</span><span class="o">()).</span><span class="na">withoutDefaults</span><span class="o">());</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">pc</span> <span class="o">=</span> <span class="o">...</span>
<span class="nb">sum</span> <span class="o">=</span> <span class="n">pc</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">CombineGlobally</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span><span class="o">.</span><span class="n">without_defaults</span><span class="p">()</span>
</code></pre>
</div>

<h5 id="combine-non-global-windowing">4.2.4.5. Combine and non-global windowing</h5>

<p>If your <code class="highlighter-rouge">PCollection</code> uses any non-global windowing function, Beam does not
provide the default behavior. You must specify one of the following options when
applying <code class="highlighter-rouge">Combine</code>:</p>

<ul>
  <li>Specify <code class="highlighter-rouge">.withoutDefaults</code>, where windows that are empty in the input
<code class="highlighter-rouge">PCollection</code> will likewise be empty in the output collection.</li>
  <li>Specify <code class="highlighter-rouge">.asSingletonView</code>, in which the output is immediately converted to a
<code class="highlighter-rouge">PCollectionView</code>, which will provide a default value for each empty window
when used as a side input. You’ll generally only need to use this option if
the result of your pipeline’s <code class="highlighter-rouge">Combine</code> is to be used as a side input later in
the pipeline.</li>
</ul>

<h5 id="combining-values-in-a-keyed-pcollection">4.2.4.6. Combining values in a keyed PCollection</h5>

<p>After creating a keyed PCollection (for example, by using a <code class="highlighter-rouge">GroupByKey</code>
transform), a common pattern is to combine the collection of values associated
with each key into a single, merged value. Drawing on the previous example from
<code class="highlighter-rouge">GroupByKey</code>, a key-grouped <code class="highlighter-rouge">PCollection</code> called <code class="highlighter-rouge">groupedWords</code> looks like this:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>  cat, [1,5,9]
  dog, [5,2]
  and, [1,2,6]
  jump, [3]
  tree, [2]
  ...
</code></pre>
</div>

<p>In the above <code class="highlighter-rouge">PCollection</code>, each element has a string key (for example, “cat”)
and an iterable of integers for its value (in the first element, containing [1,
5, 9]). If our pipeline’s next processing step combines the values (rather than
considering them individually), you can combine the iterable of integers to
create a single, merged value to be paired with each key. This pattern of a
<code class="highlighter-rouge">GroupByKey</code> followed by merging the collection of values is equivalent to
Beam’s Combine PerKey transform. The combine function you supply to Combine
PerKey must be an associative reduction function or a subclass of <code class="highlighter-rouge">CombineFn</code>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// PCollection is grouped by key and the Double values associated with each key are combined into a Double.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">salesRecords</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">totalSalesPerPerson</span> <span class="o">=</span>
  <span class="n">salesRecords</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">Combine</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span><span class="n">perKey</span><span class="o">(</span>
    <span class="k">new</span> <span class="n">Sum</span><span class="o">.</span><span class="na">SumDoubleFn</span><span class="o">()));</span>

<span class="c1">// The combined value is of a different type than the original collection of values per key. PCollection has</span>
<span class="c1">// keys of type String and values of type Integer, and the combined value is a Double.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">playerAccuracy</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">avgAccuracyPerPlayer</span> <span class="o">=</span>
  <span class="n">playerAccuracy</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">Combine</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span><span class="n">perKey</span><span class="o">(</span>
    <span class="k">new</span> <span class="nf">MeanInts</span><span class="o">())));</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># PCollection is grouped by key and the numeric values associated with each key</span>
<span class="c"># are averaged into a float.</span>
<span class="n">player_accuracies</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">avg_accuracy_per_player</span> <span class="o">=</span> <span class="p">(</span><span class="n">player_accuracies</span>
                           <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">CombinePerKey</span><span class="p">(</span>
                               <span class="n">beam</span><span class="o">.</span><span class="n">combiners</span><span class="o">.</span><span class="n">MeanCombineFn</span><span class="p">()))</span>

</code></pre>
</div>

<h4 id="flatten">4.2.5. Flatten</h4>

<p><span class="language-java"><a href="/documentation/sdks/javadoc/2.6.0/index.html?org/apache/beam/sdk/transforms/Flatten.html"><code class="highlighter-rouge">Flatten</code></a></span>
<span class="language-py"><a href="https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/core.py"><code class="highlighter-rouge">Flatten</code></a></span> and
is a Beam transform for <code class="highlighter-rouge">PCollection</code> objects that store the same data type.
<code class="highlighter-rouge">Flatten</code> merges multiple <code class="highlighter-rouge">PCollection</code> objects into a single logical
<code class="highlighter-rouge">PCollection</code>.</p>

<p>The following example shows how to apply a <code class="highlighter-rouge">Flatten</code> transform to merge multiple
<code class="highlighter-rouge">PCollection</code> objects.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// Flatten takes a PCollectionList of PCollection objects of a given type.</span>
<span class="c1">// Returns a single PCollection that contains all of the elements in the PCollection objects in that list.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">pc1</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">pc2</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">pc3</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">PCollectionList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">collections</span> <span class="o">=</span> <span class="n">PCollectionList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">pc1</span><span class="o">).</span><span class="na">and</span><span class="o">(</span><span class="n">pc2</span><span class="o">).</span><span class="na">and</span><span class="o">(</span><span class="n">pc3</span><span class="o">);</span>

<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">merged</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">Flatten</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">pCollections</span><span class="o">());</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># Flatten takes a tuple of PCollection objects.</span>
<span class="c"># Returns a single PCollection that contains all of the elements in the PCollection objects in that tuple.</span>
<span class="n">merged</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">(</span><span class="n">pcoll1</span><span class="p">,</span> <span class="n">pcoll2</span><span class="p">,</span> <span class="n">pcoll3</span><span class="p">)</span>
    <span class="c"># A list of tuples can be "piped" directly into a Flatten transform.</span>
    <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Flatten</span><span class="p">())</span>

</code></pre>
</div>

<h5 id="data-encoding-merged-collections">4.2.5.1. Data encoding in merged collections</h5>

<p>By default, the coder for the output <code class="highlighter-rouge">PCollection</code> is the same as the coder for
the first <code class="highlighter-rouge">PCollection</code> in the input <code class="highlighter-rouge">PCollectionList</code>. However, the input
<code class="highlighter-rouge">PCollection</code> objects can each use different coders, as long as they all contain
the same data type in your chosen language.</p>

<h5 id="merging-windowed-collections">4.2.5.2. Merging windowed collections</h5>

<p>When using <code class="highlighter-rouge">Flatten</code> to merge <code class="highlighter-rouge">PCollection</code> objects that have a windowing
strategy applied, all of the <code class="highlighter-rouge">PCollection</code> objects you want to merge must use a
compatible windowing strategy and window sizing. For example, all the
collections you’re merging must all use (hypothetically) identical 5-minute
fixed windows or 4-minute sliding windows starting every 30 seconds.</p>

<p>If your pipeline attempts to use <code class="highlighter-rouge">Flatten</code> to merge <code class="highlighter-rouge">PCollection</code> objects with
incompatible windows, Beam generates an <code class="highlighter-rouge">IllegalStateException</code> error when your
pipeline is constructed.</p>

<h4 id="partition">4.2.6. Partition</h4>

<p><span class="language-java"><a href="/documentation/sdks/javadoc/2.6.0/index.html?org/apache/beam/sdk/transforms/Partition.html"><code class="highlighter-rouge">Partition</code></a></span>
<span class="language-py"><a href="https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/core.py"><code class="highlighter-rouge">Partition</code></a></span>
is a Beam transform for <code class="highlighter-rouge">PCollection</code> objects that store the same data
type. <code class="highlighter-rouge">Partition</code> splits a single <code class="highlighter-rouge">PCollection</code> into a fixed number of smaller
collections.</p>

<p><code class="highlighter-rouge">Partition</code> divides the elements of a <code class="highlighter-rouge">PCollection</code> according to a partitioning
function that you provide. The partitioning function contains the logic that
determines how to split up the elements of the input <code class="highlighter-rouge">PCollection</code> into each
resulting partition <code class="highlighter-rouge">PCollection</code>. The number of partitions must be determined
at graph construction time. You can, for example, pass the number of partitions
as a command-line option at runtime (which will then be used to build your
pipeline graph), but you cannot determine the number of partitions in
mid-pipeline (based on data calculated after your pipeline graph is constructed,
for instance).</p>

<p>The following example divides a <code class="highlighter-rouge">PCollection</code> into percentile groups.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// Provide an int value with the desired number of result partitions, and a PartitionFn that represents the</span>
<span class="c1">// partitioning function. In this example, we define the PartitionFn in-line. Returns a PCollectionList</span>
<span class="c1">// containing each of the resulting partitions as individual PCollection objects.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">students</span> <span class="o">=</span> <span class="o">...;</span>
<span class="c1">// Split students up into 10 partitions, by percentile:</span>
<span class="n">PCollectionList</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">studentsByPercentile</span> <span class="o">=</span>
    <span class="n">students</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">Partition</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="k">new</span> <span class="n">PartitionFn</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">partitionFor</span><span class="o">(</span><span class="n">Student</span> <span class="n">student</span><span class="o">,</span> <span class="kt">int</span> <span class="n">numPartitions</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">student</span><span class="o">.</span><span class="na">getPercentile</span><span class="o">()</span>  <span class="c1">// 0..99</span>
                 <span class="o">*</span> <span class="n">numPartitions</span> <span class="o">/</span> <span class="mi">100</span><span class="o">;</span>
        <span class="o">}}));</span>

<span class="c1">// You can extract each partition from the PCollectionList using the get method, as follows:</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">fortiethPercentile</span> <span class="o">=</span> <span class="n">studentsByPercentile</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># Provide an int value with the desired number of result partitions, and a partitioning function (partition_fn in this example).</span>
<span class="c"># Returns a tuple of PCollection objects containing each of the resulting partitions as individual PCollection objects.</span>
<span class="n">students</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">def</span> <span class="nf">partition_fn</span><span class="p">(</span><span class="n">student</span><span class="p">,</span> <span class="n">num_partitions</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">get_percentile</span><span class="p">(</span><span class="n">student</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_partitions</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>

<span class="n">by_decile</span> <span class="o">=</span> <span class="n">students</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Partition</span><span class="p">(</span><span class="n">partition_fn</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>


<span class="c"># You can extract each partition from the tuple of PCollection objects as follows:</span>
<span class="n">fortieth_percentile</span> <span class="o">=</span> <span class="n">by_decile</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

</code></pre>
</div>

<h3 id="requirements-for-writing-user-code-for-beam-transforms">4.3. Requirements for writing user code for Beam transforms</h3>

<p>When you build user code for a Beam transform, you should keep in mind the
distributed nature of execution. For example, there might be many copies of your
function running on a lot of different machines in parallel, and those copies
function independently, without communicating or sharing state with any of the
other copies. Depending on the Pipeline Runner and processing back-end you
choose for your pipeline, each copy of your user code function may be retried or
run multiple times. As such, you should be cautious about including things like
state dependency in your user code.</p>

<p>In general, your user code must fulfill at least these requirements:</p>

<ul>
  <li>Your function object must be <strong>serializable</strong>.</li>
  <li>Your function object must be <strong>thread-compatible</strong>, and be aware that <em>the
Beam SDKs are not thread-safe</em>.</li>
</ul>

<p>In addition, it’s recommended that you make your function object <strong>idempotent</strong>.
Non-idempotent functions are supported by Beam, but require additional
thought to ensure correctness when there are external side effects.</p>

<blockquote>
  <p><strong>Note:</strong> These requirements apply to subclasses of <code class="highlighter-rouge">DoFn</code> (a function object
used with the <a href="#pardo">ParDo</a> transform), <code class="highlighter-rouge">CombineFn</code> (a function object used
with the <a href="#combine">Combine</a> transform), and <code class="highlighter-rouge">WindowFn</code> (a function object
used with the <a href="#windowing">Window</a> transform).</p>
</blockquote>

<h4 id="user-code-serializability">4.3.1. Serializability</h4>

<p>Any function object you provide to a transform must be <strong>fully serializable</strong>.
This is because a copy of the function needs to be serialized and transmitted to
a remote worker in your processing cluster. The base classes for user code, such
as <code class="highlighter-rouge">DoFn</code>, <code class="highlighter-rouge">CombineFn</code>, and <code class="highlighter-rouge">WindowFn</code>, already implement <code class="highlighter-rouge">Serializable</code>;
however, your subclass must not add any non-serializable members.</p>

<p>Some other serializability factors you should keep in mind are:</p>

<ul>
  <li>Transient fields in your function object are <em>not</em> transmitted to worker
instances, because they are not automatically serialized.</li>
  <li>Avoid loading a field with a large amount of data before serialization.</li>
  <li>Individual instances of your function object cannot share data.</li>
  <li>Mutating a function object after it gets applied will have no effect.</li>
  <li>Take care when declaring your function object inline by using an anonymous
inner class instance. In a non-static context, your inner class instance will
implicitly contain a pointer to the enclosing class and that class’ state.
That enclosing class will also be serialized, and thus the same considerations
that apply to the function object itself also apply to this outer class.</li>
</ul>

<h4 id="user-code-thread-compatibility">4.3.2. Thread-compatibility</h4>

<p>Your function object should be thread-compatible. Each instance of your function
object is accessed by a single thread at a time on a worker instance, unless you
explicitly create your own threads. Note, however, that <strong>the Beam SDKs are not
thread-safe</strong>. If you create your own threads in your user code, you must
provide your own synchronization. Note that static members in your function
object are not passed to worker instances and that multiple instances of your
function may be accessed from different threads.</p>

<h4 id="user-code-idempotence">4.3.3. Idempotence</h4>

<p>It’s recommended that you make your function object idempotent–that is, that it
can be repeated or retried as often as necessary without causing unintended side
effects. Non-idempotent functions are supported, however the Beam model provides
no guarantees as to the number of times your user code might be invoked or retried;
as such, keeping your function object idempotent keeps your pipeline’s output
deterministic, and your transforms’ behavior more predictable and easier to debug.</p>

<h3 id="side-inputs">4.4. Side inputs</h3>

<p>In addition to the main input <code class="highlighter-rouge">PCollection</code>, you can provide additional inputs
to a <code class="highlighter-rouge">ParDo</code> transform in the form of side inputs. A side input is an additional
input that your <code class="highlighter-rouge">DoFn</code> can access each time it processes an element in the input
<code class="highlighter-rouge">PCollection</code>. When you specify a side input, you create a view of some other
data that can be read from within the <code class="highlighter-rouge">ParDo</code> transform’s <code class="highlighter-rouge">DoFn</code> while procesing
each element.</p>

<p>Side inputs are useful if your <code class="highlighter-rouge">ParDo</code> needs to inject additional data when
processing each element in the input <code class="highlighter-rouge">PCollection</code>, but the additional data
needs to be determined at runtime (and not hard-coded). Such values might be
determined by the input data, or depend on a different branch of your pipeline.</p>

<h4 id="side-inputs-pardo">4.4.1. Passing side inputs to ParDo</h4>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="c1">// Pass side inputs to your ParDo transform by invoking .withSideInputs.</span>
  <span class="c1">// Inside your DoFn, access the side input by using the method DoFn.ProcessContext.sideInput.</span>

  <span class="c1">// The input PCollection to ParDo.</span>
  <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="o">...;</span>

  <span class="c1">// A PCollection of word lengths that we'll combine into a single value.</span>
  <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">wordLengths</span> <span class="o">=</span> <span class="o">...;</span> <span class="c1">// Singleton PCollection</span>

  <span class="c1">// Create a singleton PCollectionView from wordLengths using Combine.globally and View.asSingleton.</span>
  <span class="kd">final</span> <span class="n">PCollectionView</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">maxWordLengthCutOffView</span> <span class="o">=</span>
     <span class="n">wordLengths</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">Combine</span><span class="o">.</span><span class="na">globally</span><span class="o">(</span><span class="k">new</span> <span class="n">Max</span><span class="o">.</span><span class="na">MaxIntFn</span><span class="o">()).</span><span class="na">asSingletonView</span><span class="o">());</span>


  <span class="c1">// Apply a ParDo that takes maxWordLengthCutOffView as a side input.</span>
  <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">wordsBelowCutOff</span> <span class="o">=</span>
  <span class="n">words</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">ParDo</span>
      <span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
          <span class="nd">@ProcessElement</span>
          <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="nd">@Element</span> <span class="n">String</span> <span class="n">word</span><span class="o">,</span> <span class="n">OutputReceiver</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">,</span> <span class="n">ProcessContext</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// In our DoFn, access the side input.</span>
            <span class="kt">int</span> <span class="n">lengthCutOff</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">sideInput</span><span class="o">(</span><span class="n">maxWordLengthCutOffView</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">lengthCutOff</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">out</span><span class="o">.</span><span class="na">output</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
            <span class="o">}</span>
          <span class="o">}</span>
      <span class="o">}).</span><span class="na">withSideInputs</span><span class="o">(</span><span class="n">maxWordLengthCutOffView</span><span class="o">)</span>
  <span class="o">);</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># Side inputs are available as extra arguments in the DoFn's process method or Map / FlatMap's callable.</span>
<span class="c"># Optional, positional, and keyword arguments are all supported. Deferred arguments are unwrapped into their</span>
<span class="c"># actual values. For example, using pvalue.AsIteor(pcoll) at pipeline construction time results in an iterable</span>
<span class="c"># of the actual elements of pcoll being passed into each process invocation. In this example, side inputs are</span>
<span class="c"># passed to a FlatMap transform as extra arguments and consumed by filter_using_length.</span>
<span class="n">words</span> <span class="o">=</span> <span class="o">...</span>
<span class="c"># Callable takes additional arguments.</span>
<span class="k">def</span> <span class="nf">filter_using_length</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)):</span>
  <span class="k">if</span> <span class="n">lower_bound</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">upper_bound</span><span class="p">:</span>
    <span class="k">yield</span> <span class="n">word</span>

<span class="c"># Construct a deferred side input.</span>
<span class="n">avg_word_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">words</span>
                <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span>
                <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">CombineGlobally</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">combiners</span><span class="o">.</span><span class="n">MeanCombineFn</span><span class="p">()))</span>

<span class="c"># Call with explicit side inputs.</span>
<span class="n">small_words</span> <span class="o">=</span> <span class="n">words</span> <span class="o">|</span> <span class="s">'small'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">FlatMap</span><span class="p">(</span><span class="n">filter_using_length</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c"># A single deferred side input.</span>
<span class="n">larger_than_average</span> <span class="o">=</span> <span class="p">(</span><span class="n">words</span> <span class="o">|</span> <span class="s">'large'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">FlatMap</span><span class="p">(</span>
    <span class="n">filter_using_length</span><span class="p">,</span>
    <span class="n">lower_bound</span><span class="o">=</span><span class="n">pvalue</span><span class="o">.</span><span class="n">AsSingleton</span><span class="p">(</span><span class="n">avg_word_len</span><span class="p">)))</span>

<span class="c"># Mix and match.</span>
<span class="n">small_but_nontrivial</span> <span class="o">=</span> <span class="n">words</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">FlatMap</span><span class="p">(</span>
    <span class="n">filter_using_length</span><span class="p">,</span>
    <span class="n">lower_bound</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">upper_bound</span><span class="o">=</span><span class="n">pvalue</span><span class="o">.</span><span class="n">AsSingleton</span><span class="p">(</span><span class="n">avg_word_len</span><span class="p">))</span>


<span class="c"># We can also pass side inputs to a ParDo transform, which will get passed to its process method.</span>
<span class="c"># The first two arguments for the process method would be self and element.</span>

<span class="k">class</span> <span class="nc">FilterUsingLength</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">DoFn</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">lower_bound</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">upper_bound</span><span class="p">:</span>
      <span class="k">yield</span> <span class="n">element</span>

<span class="n">small_words</span> <span class="o">=</span> <span class="n">words</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">ParDo</span><span class="p">(</span><span class="n">FilterUsingLength</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="o">...</span>
</code></pre>
</div>

<h4 id="side-inputs-windowing">4.4.2. Side inputs and windowing</h4>

<p>A windowed <code class="highlighter-rouge">PCollection</code> may be infinite and thus cannot be compressed into a
single value (or single collection class). When you create a <code class="highlighter-rouge">PCollectionView</code>
of a windowed <code class="highlighter-rouge">PCollection</code>, the <code class="highlighter-rouge">PCollectionView</code> represents a single entity
per window (one singleton per window, one list per window, etc.).</p>

<p>Beam uses the window(s) for the main input element to look up the appropriate
window for the side input element. Beam projects the main input element’s window
into the side input’s window set, and then uses the side input from the
resulting window. If the main input and side inputs have identical windows, the
projection provides the exact corresponding window. However, if the inputs have
different windows, Beam uses the projection to choose the most appropriate side
input window.</p>

<p>For example, if the main input is windowed using fixed-time windows of one
minute, and the side input is windowed using fixed-time windows of one hour,
Beam projects the main input window against the side input window set and
selects the side input value from the appropriate hour-long side input window.</p>

<p>If the main input element exists in more than one window, then <code class="highlighter-rouge">processElement</code>
gets called multiple times, once for each window. Each call to <code class="highlighter-rouge">processElement</code>
projects the “current” window for the main input element, and thus might provide
a different view of the side input each time.</p>

<p>If the side input has multiple trigger firings, Beam uses the value from the
latest trigger firing. This is particularly useful if you use a side input with
a single global window and specify a trigger.</p>

<h3 id="additional-outputs">4.5. Additional outputs</h3>

<p>While <code class="highlighter-rouge">ParDo</code> always produces a main output <code class="highlighter-rouge">PCollection</code> (as the return value
from <code class="highlighter-rouge">apply</code>), you can also have your <code class="highlighter-rouge">ParDo</code> produce any number of additional
output <code class="highlighter-rouge">PCollection</code>s. If you choose to have multiple outputs, your <code class="highlighter-rouge">ParDo</code>
returns all of the output <code class="highlighter-rouge">PCollection</code>s (including the main output) bundled
together.</p>

<h4 id="output-tags">4.5.1. Tags for multiple outputs</h4>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// To emit elements to multiple output PCollections, create a TupleTag object to identify each collection</span>
<span class="c1">// that your ParDo produces. For example, if your ParDo produces three output PCollections (the main output</span>
<span class="c1">// and two additional outputs), you must create three TupleTags. The following example code shows how to</span>
<span class="c1">// create TupleTags for a ParDo with three output PCollections.</span>

  <span class="c1">// Input PCollection to our ParDo.</span>
  <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="o">...;</span>

  <span class="c1">// The ParDo will filter words whose length is below a cutoff and add them to</span>
  <span class="c1">// the main ouput PCollection&lt;String&gt;.</span>
  <span class="c1">// If a word is above the cutoff, the ParDo will add the word length to an</span>
  <span class="c1">// output PCollection&lt;Integer&gt;.</span>
  <span class="c1">// If a word starts with the string "MARKER", the ParDo will add that word to an</span>
  <span class="c1">// output PCollection&lt;String&gt;.</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">wordLengthCutOff</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

  <span class="c1">// Create three TupleTags, one for each output PCollection.</span>
  <span class="c1">// Output that contains words below the length cutoff.</span>
  <span class="kd">final</span> <span class="n">TupleTag</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">wordsBelowCutOffTag</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">TupleTag</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(){};</span>
  <span class="c1">// Output that contains word lengths.</span>
  <span class="kd">final</span> <span class="n">TupleTag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">wordLengthsAboveCutOffTag</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">TupleTag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(){};</span>
  <span class="c1">// Output that contains "MARKER" words.</span>
  <span class="kd">final</span> <span class="n">TupleTag</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">markedWordsTag</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">TupleTag</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(){};</span>

<span class="c1">// Passing Output Tags to ParDo:</span>
<span class="c1">// After you specify the TupleTags for each of your ParDo outputs, pass the tags to your ParDo by invoking</span>
<span class="c1">// .withOutputTags. You pass the tag for the main output first, and then the tags for any additional outputs</span>
<span class="c1">// in a TupleTagList. Building on our previous example, we pass the three TupleTags for our three output</span>
<span class="c1">// PCollections to our ParDo. Note that all of the outputs (including the main output PCollection) are</span>
<span class="c1">// bundled into the returned PCollectionTuple.</span>

  <span class="n">PCollectionTuple</span> <span class="n">results</span> <span class="o">=</span>
      <span class="n">words</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">ParDo</span>
          <span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="c1">// DoFn continues here.</span>
            <span class="o">...</span>
          <span class="o">})</span>
          <span class="c1">// Specify the tag for the main output.</span>
          <span class="o">.</span><span class="na">withOutputTags</span><span class="o">(</span><span class="n">wordsBelowCutOffTag</span><span class="o">,</span>
          <span class="c1">// Specify the tags for the two additional outputs as a TupleTagList.</span>
                          <span class="n">TupleTagList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">wordLengthsAboveCutOffTag</span><span class="o">)</span>
                                      <span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">markedWordsTag</span><span class="o">)));</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># To emit elements to multiple output PCollections, invoke with_outputs() on the ParDo, and specify the</span>
<span class="c"># expected tags for the outputs. with_outputs() returns a DoOutputsTuple object. Tags specified in</span>
<span class="c"># with_outputs are attributes on the returned DoOutputsTuple object. The tags give access to the</span>
<span class="c"># corresponding output PCollections.</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">(</span><span class="n">words</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">ParDo</span><span class="p">(</span><span class="n">ProcessWords</span><span class="p">(),</span> <span class="n">cutoff_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'x'</span><span class="p">)</span>
           <span class="o">.</span><span class="n">with_outputs</span><span class="p">(</span><span class="s">'above_cutoff_lengths'</span><span class="p">,</span> <span class="s">'marked strings'</span><span class="p">,</span>
                         <span class="n">main</span><span class="o">=</span><span class="s">'below_cutoff_strings'</span><span class="p">))</span>
<span class="n">below</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">below_cutoff_strings</span>
<span class="n">above</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">above_cutoff_lengths</span>
<span class="n">marked</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s">'marked strings'</span><span class="p">]</span>  <span class="c"># indexing works as well</span>


<span class="c"># The result is also iterable, ordered in the same order that the tags were passed to with_outputs(),</span>
<span class="c"># the main tag (if specified) first.</span>

<span class="n">below</span><span class="p">,</span> <span class="n">above</span><span class="p">,</span> <span class="n">marked</span> <span class="o">=</span> <span class="p">(</span><span class="n">words</span>
                        <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">ParDo</span><span class="p">(</span>
                            <span class="n">ProcessWords</span><span class="p">(),</span> <span class="n">cutoff_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'x'</span><span class="p">)</span>
                        <span class="o">.</span><span class="n">with_outputs</span><span class="p">(</span><span class="s">'above_cutoff_lengths'</span><span class="p">,</span>
                                      <span class="s">'marked strings'</span><span class="p">,</span>
                                      <span class="n">main</span><span class="o">=</span><span class="s">'below_cutoff_strings'</span><span class="p">))</span>
</code></pre>
</div>

<h4 id="multiple-outputs-dofn">4.5.2. Emitting to multiple outputs in your DoFn</h4>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// Inside your ParDo's DoFn, you can emit an element to a specific output PCollection by providing a </span>
<span class="c1">// MultiOutputReceiver to your process method, and passing in the appropriate TupleTag to obtain an OutputReceiver.</span>
<span class="c1">// After your ParDo, extract the resulting output PCollections from the returned PCollectionTuple.</span>
<span class="c1">// Based on the previous example, this shows the DoFn emitting to the main output and two additional outputs.</span>

  <span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="nd">@Element</span> <span class="n">String</span> <span class="n">word</span><span class="o">,</span> <span class="n">MultiOutputReceiver</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">wordLengthCutOff</span><span class="o">)</span> <span class="o">{</span>
         <span class="c1">// Emit short word to the main output.</span>
         <span class="c1">// In this example, it is the output with tag wordsBelowCutOffTag.</span>
         <span class="n">out</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">wordsBelowCutOffTag</span><span class="o">).</span><span class="na">output</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
       <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
         <span class="c1">// Emit long word length to the output with tag wordLengthsAboveCutOffTag.</span>
         <span class="n">out</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">wordLengthsAboveCutOffTag</span><span class="o">).</span><span class="na">output</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
       <span class="o">}</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"MARKER"</span><span class="o">))</span> <span class="o">{</span>
         <span class="c1">// Emit word to the output with tag markedWordsTag.</span>
         <span class="n">out</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">markedWordsTag</span><span class="o">).</span><span class="na">output</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
       <span class="o">}</span>
     <span class="o">}}));</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># Inside your ParDo's DoFn, you can emit an element to a specific output by wrapping the value and the output tag (str).</span>
<span class="c"># using the pvalue.OutputValue wrapper class.</span>
<span class="c"># Based on the previous example, this shows the DoFn emitting to the main output and two additional outputs.</span>

<span class="k">class</span> <span class="nc">ProcessWords</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">DoFn</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">cutoff_length</span><span class="p">,</span> <span class="n">marker</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">cutoff_length</span><span class="p">:</span>
      <span class="c"># Emit this short word to the main output.</span>
      <span class="k">yield</span> <span class="n">element</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c"># Emit this word's long length to the 'above_cutoff_lengths' output.</span>
      <span class="k">yield</span> <span class="n">pvalue</span><span class="o">.</span><span class="n">TaggedOutput</span><span class="p">(</span>
          <span class="s">'above_cutoff_lengths'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">marker</span><span class="p">):</span>
      <span class="c"># Emit this word to a different output with the 'marked strings' tag.</span>
      <span class="k">yield</span> <span class="n">pvalue</span><span class="o">.</span><span class="n">TaggedOutput</span><span class="p">(</span><span class="s">'marked strings'</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>


<span class="c"># Producing multiple outputs is also available in Map and FlatMap.</span>
<span class="c"># Here is an example that uses FlatMap and shows that the tags do not need to be specified ahead of time.</span>

<span class="k">def</span> <span class="nf">even_odd</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">yield</span> <span class="n">pvalue</span><span class="o">.</span><span class="n">TaggedOutput</span><span class="p">(</span><span class="s">'odd'</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">else</span> <span class="s">'even'</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">yield</span> <span class="n">x</span>

<span class="n">results</span> <span class="o">=</span> <span class="n">numbers</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">FlatMap</span><span class="p">(</span><span class="n">even_odd</span><span class="p">)</span><span class="o">.</span><span class="n">with_outputs</span><span class="p">()</span>

<span class="n">evens</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">even</span>
<span class="n">odds</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">odd</span>
<span class="n">tens</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>  <span class="c"># the undeclared main output</span>
</code></pre>
</div>

<h4 id="other-dofn-parameters" class="language-java">4.5.3. Accessing additional parameters in your DoFn</h4>

<p class="language-java">In addition to the element and the <code class="highlighter-rouge">OutputReceiver</code>, Beam will populate other parameters to your DoFn’s <code class="highlighter-rouge">@ProcessElement</code> method.
Any combination of these parameters can be added to your process method in any order.</p>

<p class="language-java"><strong>Timestamp:</strong>
To access the timestamp of an input element, add a parameter annotated with <code class="highlighter-rouge">@Timestamp</code> of type <code class="highlighter-rouge">Instant</code>. For example:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="nd">@Element</span> <span class="n">String</span> <span class="n">word</span><span class="o">,</span> <span class="nd">@Timestamp</span> <span class="n">Instant</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">}})</span>
</code></pre>
</div>

<p class="language-java"><strong>Window:</strong>
To access the window an input element falls into, add a parameter of the type of the window used for the input <code class="highlighter-rouge">PCollection</code>.
If the parameter is a window type (a subclass of <code class="highlighter-rouge">BoundedWindow</code>) that does not match the input <code class="highlighter-rouge">PCollection</code>, then an error
will be raised. If an element falls in multiple windows (for example, this will happen when using <code class="highlighter-rouge">SlidingWindows</code>), then the
<code class="highlighter-rouge">@ProcessElement</code> method will be invoked multiple time for the element, once for each window. For example, when fixed windows
are being used, the window is of type <code class="highlighter-rouge">IntervalWindow</code>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="nd">@Element</span> <span class="n">String</span> <span class="n">word</span><span class="o">,</span> <span class="n">IntervalWindow</span> <span class="n">window</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">}})</span>
</code></pre>
</div>

<p class="language-java"><strong>PaneInfo:</strong>
When triggers are used, Beam provides a <code class="highlighter-rouge">PaneInfo</code> object that contains information about the current firing. Using <code class="highlighter-rouge">PaneInfo</code>
you can determine whether this is an early or a late firing, and how many times this window has already fired for this key.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="nd">@Element</span> <span class="n">String</span> <span class="n">word</span><span class="o">,</span> <span class="n">PaneInfo</span> <span class="n">paneInfo</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">}})</span>
</code></pre>
</div>

<p class="language-java"><strong>PipelineOptions:</strong>
The <code class="highlighter-rouge">PipelineOptions</code> for the current pipeline can always be accessed in a process method by adding it as a parameter:</p>
<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="nd">@Element</span> <span class="n">String</span> <span class="n">word</span><span class="o">,</span> <span class="n">PipelineOptions</span> <span class="n">options</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">}})</span>
</code></pre>
</div>

<p class="language-java"><code class="highlighter-rouge">@OnTimer</code> methods can also access many of these parameters. Timestamp, window, <code class="highlighter-rouge">PipelineOptions</code>, <code class="highlighter-rouge">OutputReceiver</code>, and
<code class="highlighter-rouge">MultiOutputReceiver</code> parameters can all be accessed in an <code class="highlighter-rouge">@OnTimer</code> method. In addition, an <code class="highlighter-rouge">@OnTimer</code> method can take
a parameter of type <code class="highlighter-rouge">TimeDomain</code> which tells whether the timer is based on event time or processing time.</p>

<h3 id="composite-transforms">4.6. Composite transforms</h3>

<p>Transforms can have a nested structure, where a complex transform performs
multiple simpler transforms (such as more than one <code class="highlighter-rouge">ParDo</code>, <code class="highlighter-rouge">Combine</code>,
<code class="highlighter-rouge">GroupByKey</code>, or even other composite transforms). These transforms are called
composite transforms. Nesting multiple transforms inside a single composite
transform can make your code more modular and easier to understand.</p>

<p>The Beam SDK comes packed with many useful composite transforms. See the API
reference pages for a list of transforms:</p>
<ul>
  <li><a href="/documentation/sdks/javadoc/2.6.0/index.html?org/apache/beam/sdk/transforms/package-summary.html">Pre-written Beam transforms for Java</a></li>
  <li><a href="/documentation/sdks/pydoc/2.6.0/apache_beam.transforms.html">Pre-written Beam transforms for Python</a></li>
</ul>

<h4 id="composite-transform-example">4.6.1. An example composite transform</h4>

<p>The <code class="highlighter-rouge">CountWords</code> transform in the <a href="/get-started/wordcount-example/">WordCount example program</a>
is an example of a composite transform. <code class="highlighter-rouge">CountWords</code> is a <code class="highlighter-rouge">PTransform</code> subclass
that consists of multiple nested transforms.</p>

<p>In its <code class="highlighter-rouge">expand</code> method, the <code class="highlighter-rouge">CountWords</code> transform applies the following
transform operations:</p>

<ol>
  <li>It applies a <code class="highlighter-rouge">ParDo</code> on the input <code class="highlighter-rouge">PCollection</code> of text lines, producing
an output <code class="highlighter-rouge">PCollection</code> of individual words.</li>
  <li>It applies the Beam SDK library transform <code class="highlighter-rouge">Count</code> on the <code class="highlighter-rouge">PCollection</code> of
words, producing a <code class="highlighter-rouge">PCollection</code> of key/value pairs. Each key represents a
word in the text, and each value represents the number of times that word
appeared in the original data.</li>
</ol>

<p>Note that this is also an example of nested composite transforms, as <code class="highlighter-rouge">Count</code>
is, by itself, a composite transform.</p>

<p>Your composite transform’s parameters and return value must match the initial
input type and final return type for the entire transform, even if the
transform’s intermediate data changes type multiple times.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">CountWords</span> <span class="kd">extends</span> <span class="n">PTransform</span><span class="o">&lt;</span><span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;,</span>
      <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;&gt;</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="nf">expand</span><span class="o">(</span><span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">lines</span><span class="o">)</span> <span class="o">{</span>

      <span class="c1">// Convert lines of text into individual words.</span>
      <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
          <span class="n">ParDo</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">ExtractWordsFn</span><span class="o">()));</span>

      <span class="c1">// Count the number of times each word occurs.</span>
      <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">KV</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">wordCounts</span> <span class="o">=</span>
          <span class="n">words</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">Count</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">perElement</span><span class="o">());</span>

      <span class="k">return</span> <span class="n">wordCounts</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># The CountWords Composite Transform inside the WordCount pipeline.</span>
<span class="k">class</span> <span class="nc">CountWords</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">PTransform</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcoll</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pcoll</span>
            <span class="c"># Convert lines of text into individual words.</span>
            <span class="o">|</span> <span class="s">'ExtractWords'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">ParDo</span><span class="p">(</span><span class="n">ExtractWordsFn</span><span class="p">())</span>
            <span class="c"># Count the number of times each word occurs.</span>
            <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">combiners</span><span class="o">.</span><span class="n">Count</span><span class="o">.</span><span class="n">PerElement</span><span class="p">()</span>
            <span class="c"># Format each word and count into a printable string.</span>
            <span class="o">|</span> <span class="s">'FormatCounts'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">ParDo</span><span class="p">(</span><span class="n">FormatCountsFn</span><span class="p">()))</span>
</code></pre>
</div>

<h4 id="composite-transform-creation">4.6.2. Creating a composite transform</h4>

<p>To create your own composite transform, create a subclass of the <code class="highlighter-rouge">PTransform</code>
class and override the <code class="highlighter-rouge">expand</code> method to specify the actual processing logic.
You can then use this transform just as you would a built-in transform from the
Beam SDK.</p>

<p class="language-java">For the <code class="highlighter-rouge">PTransform</code> class type parameters, you pass the <code class="highlighter-rouge">PCollection</code> types
that your transform takes as input, and produces as output. To take multiple
<code class="highlighter-rouge">PCollection</code>s as input, or produce multiple <code class="highlighter-rouge">PCollection</code>s as output, use one
of the multi-collection types for the relevant type parameter.</p>

<p>The following code sample shows how to declare a <code class="highlighter-rouge">PTransform</code> that accepts a
<code class="highlighter-rouge">PCollection</code> of <code class="highlighter-rouge">String</code>s for input, and outputs a <code class="highlighter-rouge">PCollection</code> of <code class="highlighter-rouge">Integer</code>s:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ComputeWordLengths</span>
    <span class="kd">extends</span> <span class="n">PTransform</span><span class="o">&lt;</span><span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;,</span> <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ComputeWordLengths</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">PTransform</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcoll</span><span class="p">):</span>
    <span class="c"># Transform logic goes here.</span>
    <span class="k">return</span> <span class="n">pcoll</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre>
</div>

<p>Within your <code class="highlighter-rouge">PTransform</code> subclass, you’ll need to override the <code class="highlighter-rouge">expand</code> method.
The <code class="highlighter-rouge">expand</code> method is where you add the processing logic for the <code class="highlighter-rouge">PTransform</code>.
Your override of <code class="highlighter-rouge">expand</code> must accept the appropriate type of input
<code class="highlighter-rouge">PCollection</code> as a parameter, and specify the output <code class="highlighter-rouge">PCollection</code> as the return
value.</p>

<p>The following code sample shows how to override <code class="highlighter-rouge">expand</code> for the
<code class="highlighter-rouge">ComputeWordLengths</code> class declared in the previous example:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ComputeWordLengths</span>
      <span class="kd">extends</span> <span class="n">PTransform</span><span class="o">&lt;</span><span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;,</span> <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">expand</span><span class="o">(</span><span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;)</span> <span class="o">{</span>
      <span class="o">...</span>
      <span class="c1">// transform logic goes here</span>
      <span class="o">...</span>
    <span class="o">}</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ComputeWordLengths</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">PTransform</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcoll</span><span class="p">):</span>
    <span class="c"># Transform logic goes here.</span>
    <span class="k">return</span> <span class="n">pcoll</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre>
</div>

<p>As long as you override the <code class="highlighter-rouge">expand</code> method in your <code class="highlighter-rouge">PTransform</code> subclass to
accept the appropriate input <code class="highlighter-rouge">PCollection</code>(s) and return the corresponding
output <code class="highlighter-rouge">PCollection</code>(s), you can include as many transforms as you want. These
transforms can include core transforms, composite transforms, or the transforms
included in the Beam SDK libraries.</p>

<p><strong>Note:</strong> The <code class="highlighter-rouge">expand</code> method of a <code class="highlighter-rouge">PTransform</code> is not meant to be invoked
directly by the user of a transform. Instead, you should call the <code class="highlighter-rouge">apply</code> method
on the <code class="highlighter-rouge">PCollection</code> itself, with the transform as an argument. This allows
transforms to be nested within the structure of your pipeline.</p>

<h4 id="ptransform-style-guide">4.6.3. PTransform Style Guide</h4>

<p>The <a href="/contribute/ptransform-style-guide/">PTransform Style Guide</a>
contains additional information not included here, such as style guidelines,
logging and testing guidance, and language-specific considerations.  The guide
is a useful starting point when you want to write new composite PTransforms.</p>

<h2 id="pipeline-io">5. Pipeline I/O</h2>

<p>When you create a pipeline, you often need to read data from some external
source, such as a file or a database. Likewise, you may
want your pipeline to output its result data to an external storage system.
Beam provides read and write transforms for a <a href="/documentation/io/built-in/">number of common data storage
types</a>. If you want your pipeline
to read from or write to a data storage format that isn’t supported by the
built-in transforms, you can <a href="/documentation/io/io-toc/">implement your own read and write
transforms</a>.</p>

<h3 id="pipeline-io-reading-data">5.1. Reading input data</h3>

<p>Read transforms read data from an external source and return a <code class="highlighter-rouge">PCollection</code>
representation of the data for use by your pipeline. You can use a read
transform at any point while constructing your pipeline to create a new
<code class="highlighter-rouge">PCollection</code>, though it will be most common at the start of your pipeline.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">TextIO</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">from</span><span class="o">(</span><span class="s">"gs://some/inputData.txt"</span><span class="o">));</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">lines</span> <span class="o">=</span> <span class="n">pipeline</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">ReadFromText</span><span class="p">(</span><span class="s">'gs://some/inputData.txt'</span><span class="p">)</span>
</code></pre>
</div>

<h3 id="pipeline-io-writing-data">5.2. Writing output data</h3>

<p>Write transforms write the data in a <code class="highlighter-rouge">PCollection</code> to an external data source.
You will most often use write transforms at the end of your pipeline to output
your pipeline’s final results. However, you can use a write transform to output
a <code class="highlighter-rouge">PCollection</code>’s data at any point in your pipeline.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">output</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">TextIO</span><span class="o">.</span><span class="na">write</span><span class="o">().</span><span class="na">to</span><span class="o">(</span><span class="s">"gs://some/outputData"</span><span class="o">));</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">output</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">WriteToText</span><span class="p">(</span><span class="s">'gs://some/outputData'</span><span class="p">)</span>
</code></pre>
</div>

<h3 id="file-based-data">5.3. File-based input and output data</h3>

<h4 id="file-based-reading-multiple-locations">5.3.1. Reading from multiple locations</h4>

<p>Many read transforms support reading from multiple input files matching a glob
operator you provide. Note that glob operators are filesystem-specific and obey
filesystem-specific consistency models. The following TextIO example uses a glob
operator (*) to read all matching input files that have prefix “input-“ and the
suffix “.csv” in the given location:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">p</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="err">“</span><span class="n">ReadFromText</span><span class="err">”</span><span class="o">,</span>
    <span class="n">TextIO</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">from</span><span class="o">(</span><span class="s">"protocol://my_bucket/path/to/input-*.csv"</span><span class="o">);</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">lines</span> <span class="o">=</span> <span class="n">p</span> <span class="o">|</span> <span class="s">'ReadFromText'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">ReadFromText</span><span class="p">(</span><span class="s">'path/to/input-*.csv'</span><span class="p">)</span>

</code></pre>
</div>

<p>To read data from disparate sources into a single <code class="highlighter-rouge">PCollection</code>, read each one
independently and then use the <a href="#flatten">Flatten</a> transform to create a single
<code class="highlighter-rouge">PCollection</code>.</p>

<h4 id="file-based-writing-multiple-files">5.3.2. Writing to multiple output files</h4>

<p>For file-based output data, write transforms write to multiple output files by
default. When you pass an output file name to a write transform, the file name
is used as the prefix for all output files that the write transform produces.
You can append a suffix to each output file by specifying a suffix.</p>

<p>The following write transform example writes multiple output files to a
location. Each file has the prefix “numbers”, a numeric tag, and the suffix
“.csv”.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">records</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"WriteToText"</span><span class="o">,</span>
    <span class="n">TextIO</span><span class="o">.</span><span class="na">write</span><span class="o">().</span><span class="na">to</span><span class="o">(</span><span class="s">"protocol://my_bucket/path/to/numbers"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">withSuffix</span><span class="o">(</span><span class="s">".csv"</span><span class="o">));</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">filtered_words</span> <span class="o">|</span> <span class="s">'WriteToText'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">WriteToText</span><span class="p">(</span>
    <span class="s">'/path/to/numbers'</span><span class="p">,</span> <span class="n">file_name_suffix</span><span class="o">=</span><span class="s">'.csv'</span><span class="p">)</span>

</code></pre>
</div>

<h3 id="provided-io-transforms">5.4. Beam-provided I/O transforms</h3>

<p>See the <a href="/documentation/io/built-in/">Beam-provided I/O Transforms</a>
page for a list of the currently available I/O transforms.</p>

<h2 id="data-encoding-and-type-safety">6. Data encoding and type safety</h2>

<p>When Beam runners execute your pipeline, they often need to materialize the
intermediate data in your <code class="highlighter-rouge">PCollection</code>s, which requires converting elements to
and from byte strings. The Beam SDKs use objects called <code class="highlighter-rouge">Coder</code>s to describe how
the elements of a given <code class="highlighter-rouge">PCollection</code> may be encoded and decoded.</p>

<blockquote>
  <p>Note that coders are unrelated to parsing or formatting data when interacting
with external data sources or sinks. Such parsing or formatting should
typically be done explicitly, using transforms such as <code class="highlighter-rouge">ParDo</code> or
<code class="highlighter-rouge">MapElements</code>.</p>
</blockquote>

<p class="language-java">In the Beam SDK for Java, the type <code class="highlighter-rouge">Coder</code> provides the methods required for
encoding and decoding data. The SDK for Java provides a number of Coder
subclasses that work with a variety of standard Java types, such as Integer,
Long, Double, StringUtf8 and more. You can find all of the available Coder
subclasses in the <a href="https://github.com/apache/beam/tree/master/sdks/java/core/src/main/java/org/apache/beam/sdk/coders">Coder package</a>.</p>

<p class="language-py">In the Beam SDK for Python, the type <code class="highlighter-rouge">Coder</code> provides the methods required for
encoding and decoding data. The SDK for Python provides a number of Coder
subclasses that work with a variety of standard Python types, such as primitive
types, Tuple, Iterable, StringUtf8 and more. You can find all of the available
Coder subclasses in the
<a href="https://github.com/apache/beam/tree/master/sdks/python/apache_beam/coders">apache_beam.coders</a>
package.</p>

<blockquote>
  <p>Note that coders do not necessarily have a 1:1 relationship with types. For
example, the Integer type can have multiple valid coders, and input and output
data can use different Integer coders. A transform might have Integer-typed
input data that uses BigEndianIntegerCoder, and Integer-typed output data that
uses VarIntCoder.</p>
</blockquote>

<h3 id="specifying-coders">6.1. Specifying coders</h3>

<p>The Beam SDKs require a coder for every <code class="highlighter-rouge">PCollection</code> in your pipeline. In most
cases, the Beam SDK is able to automatically infer a <code class="highlighter-rouge">Coder</code> for a <code class="highlighter-rouge">PCollection</code>
based on its element type or the transform that produces it, however, in some
cases the pipeline author will need to specify a <code class="highlighter-rouge">Coder</code> explicitly, or develop
a <code class="highlighter-rouge">Coder</code> for their custom type.</p>

<p class="language-java">You can explicitly set the coder for an existing <code class="highlighter-rouge">PCollection</code> by using the
method <code class="highlighter-rouge">PCollection.setCoder</code>. Note that you cannot call <code class="highlighter-rouge">setCoder</code> on a
<code class="highlighter-rouge">PCollection</code> that has been finalized (e.g. by calling <code class="highlighter-rouge">.apply</code> on it).</p>

<p class="language-java">You can get the coder for an existing <code class="highlighter-rouge">PCollection</code> by using the method
<code class="highlighter-rouge">getCoder</code>. This method will fail with an <code class="highlighter-rouge">IllegalStateException</code> if a coder has
not been set and cannot be inferred for the given <code class="highlighter-rouge">PCollection</code>.</p>

<p>Beam SDKs use a variety of mechanisms when attempting to automatically infer the
<code class="highlighter-rouge">Coder</code> for a <code class="highlighter-rouge">PCollection</code>.</p>

<p class="language-java">Each pipeline object has a <code class="highlighter-rouge">CoderRegistry</code>. The <code class="highlighter-rouge">CoderRegistry</code> represents a
mapping of Java types to the default coders that the pipeline should use for
<code class="highlighter-rouge">PCollection</code>s of each type.</p>

<p class="language-py">The Beam SDK for Python has a <code class="highlighter-rouge">CoderRegistry</code> that represents a mapping of
Python types to the default coder that should be used for <code class="highlighter-rouge">PCollection</code>s of each
type.</p>

<p class="language-java">By default, the Beam SDK for Java automatically infers the <code class="highlighter-rouge">Coder</code> for the
elements of a <code class="highlighter-rouge">PCollection</code> produced by a <code class="highlighter-rouge">PTransform</code> using the type parameter
from the transform’s function object, such as <code class="highlighter-rouge">DoFn</code>. In the case of <code class="highlighter-rouge">ParDo</code>,
for example, a <code class="highlighter-rouge">DoFn&lt;Integer, String&gt;</code> function object accepts an input element
of type <code class="highlighter-rouge">Integer</code> and produces an output element of type <code class="highlighter-rouge">String</code>. In such a
case, the SDK for Java will automatically infer the default <code class="highlighter-rouge">Coder</code> for the
output <code class="highlighter-rouge">PCollection&lt;String&gt;</code> (in the default pipeline <code class="highlighter-rouge">CoderRegistry</code>, this is
<code class="highlighter-rouge">StringUtf8Coder</code>).</p>

<p class="language-py">By default, the Beam SDK for Python automatically infers the <code class="highlighter-rouge">Coder</code> for the
elements of an output <code class="highlighter-rouge">PCollection</code> using the typehints from the transform’s
function object, such as <code class="highlighter-rouge">DoFn</code>. In the case of <code class="highlighter-rouge">ParDo</code>, for example a <code class="highlighter-rouge">DoFn</code>
with the typehints <code class="highlighter-rouge">@beam.typehints.with_input_types(int)</code> and
<code class="highlighter-rouge">@beam.typehints.with_output_types(str)</code> accepts an input element of type int
and produces an output element of type str. In such a case, the Beam SDK for
Python will automatically infer the default <code class="highlighter-rouge">Coder</code> for the output <code class="highlighter-rouge">PCollection</code>
(in the default pipeline <code class="highlighter-rouge">CoderRegistry</code>, this is <code class="highlighter-rouge">BytesCoder</code>).</p>

<blockquote>
  <p>NOTE: If you create your <code class="highlighter-rouge">PCollection</code> from in-memory data by using the
<code class="highlighter-rouge">Create</code> transform, you cannot rely on coder inference and default coders.
<code class="highlighter-rouge">Create</code> does not have access to any typing information for its arguments, and
may not be able to infer a coder if the argument list contains a value whose
exact run-time class doesn’t have a default coder registered.</p>
</blockquote>

<p class="language-java">When using <code class="highlighter-rouge">Create</code>, the simplest way to ensure that you have the correct coder
is by invoking <code class="highlighter-rouge">withCoder</code> when you apply the <code class="highlighter-rouge">Create</code> transform.</p>

<h3 id="default-coders-and-the-coderregistry">6.2. Default coders and the CoderRegistry</h3>

<p>Each Pipeline object has a <code class="highlighter-rouge">CoderRegistry</code> object, which maps language types to
the default coder the pipeline should use for those types. You can use the
<code class="highlighter-rouge">CoderRegistry</code> yourself to look up the default coder for a given type, or to
register a new default coder for a given type.</p>

<p><code class="highlighter-rouge">CoderRegistry</code> contains a default mapping of coders to standard
<span class="language-java">Java</span><span class="language-py">Python</span>
types for any pipeline you create using the Beam SDK for
<span class="language-java">Java</span><span class="language-py">Python</span>.
The following table shows the standard mapping:</p>

<table class="language-java">
  <thead>
    <tr class="header">
      <th>Java Type</th>
      <th>Default Coder</th>
    </tr>
  </thead>
  <tbody>
    <tr class="odd">
      <td>Double</td>
      <td>DoubleCoder</td>
    </tr>
    <tr class="even">
      <td>Instant</td>
      <td>InstantCoder</td>
    </tr>
    <tr class="odd">
      <td>Integer</td>
      <td>VarIntCoder</td>
    </tr>
    <tr class="even">
      <td>Iterable</td>
      <td>IterableCoder</td>
    </tr>
    <tr class="odd">
      <td>KV</td>
      <td>KvCoder</td>
    </tr>
    <tr class="even">
      <td>List</td>
      <td>ListCoder</td>
    </tr>
    <tr class="odd">
      <td>Map</td>
      <td>MapCoder</td>
    </tr>
    <tr class="even">
      <td>Long</td>
      <td>VarLongCoder</td>
    </tr>
    <tr class="odd">
      <td>String</td>
      <td>StringUtf8Coder</td>
    </tr>
    <tr class="even">
      <td>TableRow</td>
      <td>TableRowJsonCoder</td>
    </tr>
    <tr class="odd">
      <td>Void</td>
      <td>VoidCoder</td>
    </tr>
    <tr class="even">
      <td>byte[ ]</td>
      <td>ByteArrayCoder</td>
    </tr>
    <tr class="odd">
      <td>TimestampedValue</td>
      <td>TimestampedValueCoder</td>
    </tr>
  </tbody>
</table>

<table class="language-py">
  <thead>
    <tr class="header">
      <th>Python Type</th>
      <th>Default Coder</th>
    </tr>
  </thead>
  <tbody>
    <tr class="odd">
      <td>int</td>
      <td>VarIntCoder</td>
    </tr>
    <tr class="even">
      <td>float</td>
      <td>FloatCoder</td>
    </tr>
    <tr class="odd">
      <td>str</td>
      <td>BytesCoder</td>
    </tr>
    <tr class="even">
      <td>bytes</td>
      <td>StrUtf8Coder</td>
    </tr>
    <tr class="odd">
      <td>Tuple</td>
      <td>TupleCoder</td>
    </tr>
  </tbody>
</table>

<h4 id="default-coder-lookup">6.2.1. Looking up a default coder</h4>

<p class="language-java">You can use the method <code class="highlighter-rouge">CoderRegistry.getCoder</code> to determine the default
Coder for a Java type. You can access the <code class="highlighter-rouge">CoderRegistry</code> for a given pipeline
by using the method <code class="highlighter-rouge">Pipeline.getCoderRegistry</code>. This allows you to determine
(or set) the default Coder for a Java type on a per-pipeline basis: i.e. “for
this pipeline, verify that Integer values are encoded using
<code class="highlighter-rouge">BigEndianIntegerCoder</code>.”</p>

<p class="language-py">You can use the method <code class="highlighter-rouge">CoderRegistry.get_coder</code> to determine the default Coder
for a Python type. You can use <code class="highlighter-rouge">coders.registry</code> to access the <code class="highlighter-rouge">CoderRegistry</code>.
This allows you to determine (or set) the default Coder for a Python type.</p>

<h4 id="setting-default-coder">6.2.2. Setting the default coder for a type</h4>

<p>To set the default Coder for a
<span class="language-java">Java</span><span class="language-py">Python</span>
type for a particular pipeline, you obtain and modify the pipeline’s
<code class="highlighter-rouge">CoderRegistry</code>. You use the method
<span class="language-java"><code class="highlighter-rouge">Pipeline.getCoderRegistry</code></span>
<span class="language-py"><code class="highlighter-rouge">coders.registry</code></span>
to get the <code class="highlighter-rouge">CoderRegistry</code> object, and then use the method
<span class="language-java"><code class="highlighter-rouge">CoderRegistry.registerCoder</code></span>
<span class="language-py"><code class="highlighter-rouge">CoderRegistry.register_coder</code></span>
to register a new <code class="highlighter-rouge">Coder</code> for the target type.</p>

<p>The following example code demonstrates how to set a default Coder, in this case
<code class="highlighter-rouge">BigEndianIntegerCoder</code>, for
<span class="language-java">Integer</span><span class="language-py">int</span>
values for a pipeline.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">PipelineOptions</span> <span class="n">options</span> <span class="o">=</span> <span class="n">PipelineOptionsFactory</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
<span class="n">Pipeline</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">options</span><span class="o">);</span>

<span class="n">CoderRegistry</span> <span class="n">cr</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getCoderRegistry</span><span class="o">();</span>
<span class="n">cr</span><span class="o">.</span><span class="na">registerCoder</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">BigEndianIntegerCoder</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre>
</div>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">apache_beam</span><span class="o">.</span><span class="n">coders</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">register_coder</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">BigEndianIntegerCoder</span><span class="p">)</span>
</code></pre>
</div>

<h4 id="annotating-custom-type-default-coder">6.2.3. Annotating a custom data type with a default coder</h4>

<p class="language-java">If your pipeline program defines a custom data type, you can use the
<code class="highlighter-rouge">@DefaultCoder</code> annotation to specify the coder to use with that type. For
example, let’s say you have a custom data type for which you want to use
<code class="highlighter-rouge">SerializableCoder</code>. You can use the <code class="highlighter-rouge">@DefaultCoder</code> annotation as follows:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="nd">@DefaultCoder</span><span class="o">(</span><span class="n">AvroCoder</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyCustomDataType</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre>
</div>

<p class="language-java">If you’ve created a custom coder to match your data type, and you want to use
the <code class="highlighter-rouge">@DefaultCoder</code> annotation, your coder class must implement a static
<code class="highlighter-rouge">Coder.of(Class&lt;T&gt;)</code> factory method.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyCustomCoder</span> <span class="kd">implements</span> <span class="n">Coder</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Coder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">of</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{...}</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="nd">@DefaultCoder</span><span class="o">(</span><span class="n">MyCustomCoder</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyCustomDataType</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre>
</div>

<p class="language-py">The Beam SDK for Python does not support annotating data types with a default
coder. If you would like to set a default coder, use the method described in the
previous section, <em>Setting the default coder for a type</em>.</p>

<h2 id="windowing">7. Windowing</h2>

<p>Windowing subdivides a <code class="highlighter-rouge">PCollection</code> according to the timestamps of its
individual elements. Transforms that aggregate multiple elements, such as
<code class="highlighter-rouge">GroupByKey</code> and <code class="highlighter-rouge">Combine</code>, work implicitly on a per-window basis — they process
each <code class="highlighter-rouge">PCollection</code> as a succession of multiple, finite windows, though the
entire collection itself may be of unbounded size.</p>

<p>A related concept, called <strong>triggers</strong>, determines when to emit the results of
aggregation as unbounded data arrives. You can use triggers to refine the
windowing strategy for your <code class="highlighter-rouge">PCollection</code>. Triggers allow you to deal with
late-arriving data or to provide early results. See the <a href="#triggers">triggers</a>
section for more information.</p>

<h3 id="windowing-basics">7.1. Windowing basics</h3>

<p>Some Beam transforms, such as <code class="highlighter-rouge">GroupByKey</code> and <code class="highlighter-rouge">Combine</code>, group multiple
elements by a common key. Ordinarily, that grouping operation groups all of the
elements that have the same key within the entire data set. With an unbounded
data set, it is impossible to collect all of the elements, since new elements
are constantly being added and may be infinitely many (e.g. streaming data). If
you are working with unbounded <code class="highlighter-rouge">PCollection</code>s, windowing is especially useful.</p>

<p>In the Beam model, any <code class="highlighter-rouge">PCollection</code> (including unbounded <code class="highlighter-rouge">PCollection</code>s) can be
subdivided into logical windows. Each element in a <code class="highlighter-rouge">PCollection</code> is assigned to
one or more windows according to the <code class="highlighter-rouge">PCollection</code>’s windowing function, and
each individual window contains a finite number of elements. Grouping transforms
then consider each <code class="highlighter-rouge">PCollection</code>’s elements on a per-window basis. <code class="highlighter-rouge">GroupByKey</code>,
for example, implicitly groups the elements of a <code class="highlighter-rouge">PCollection</code> by <em>key and
window</em>.</p>

<p><strong>Caution:</strong> Beam’s default windowing behavior is to assign all elements of a
<code class="highlighter-rouge">PCollection</code> to a single, global window and discard late data, <em>even for
unbounded <code class="highlighter-rouge">PCollection</code>s</em>. Before you use a grouping transform such as
<code class="highlighter-rouge">GroupByKey</code> on an unbounded <code class="highlighter-rouge">PCollection</code>, you must do at least one of the
following:</p>
<ul>
  <li>Set a non-global windowing function. See <a href="#setting-your-pcollections-windowing-function">Setting your PCollection’s
windowing function</a>.</li>
  <li>Set a non-default <a href="#triggers">trigger</a>. This allows the global window to emit
results under other conditions, since the default windowing behavior (waiting
for all data to arrive) will never occur.</li>
</ul>

<p>If you don’t set a non-global windowing function or a non-default trigger for
your unbounded <code class="highlighter-rouge">PCollection</code> and subsequently use a grouping transform such as
<code class="highlighter-rouge">GroupByKey</code> or <code class="highlighter-rouge">Combine</code>, your pipeline will generate an error upon
construction and your job will fail.</p>

<h4 id="windowing-constraints">7.1.1. Windowing constraints</h4>

<p>After you set the windowing function for a <code class="highlighter-rouge">PCollection</code>, the elements’ windows
are used the next time you apply a grouping transform to that <code class="highlighter-rouge">PCollection</code>.
Window grouping occurs on an as-needed basis. If you set a windowing function
using the <code class="highlighter-rouge">Window</code> transform, each element is assigned to a window, but the
windows are not considered until <code class="highlighter-rouge">GroupByKey</code> or <code class="highlighter-rouge">Combine</code> aggregates across a
window and key. This can have different effects on your pipeline.  Consider the
example pipeline in the figure below:</p>

<p><img src="/images/windowing-pipeline-unbounded.png" alt="Diagram of pipeline applying windowing" title="Pipeline applying windowing" /></p>

<p><strong>Figure:</strong> Pipeline applying windowing</p>

<p>In the above pipeline, we create an unbounded <code class="highlighter-rouge">PCollection</code> by reading a set of
key/value pairs using <code class="highlighter-rouge">KafkaIO</code>, and then apply a windowing function to that
collection using the <code class="highlighter-rouge">Window</code> transform. We then apply a <code class="highlighter-rouge">ParDo</code> to the the
collection, and then later group the result of that <code class="highlighter-rouge">ParDo</code> using <code class="highlighter-rouge">GroupByKey</code>.
The windowing function has no effect on the <code class="highlighter-rouge">ParDo</code> transform, because the
windows are not actually used until they’re needed for the <code class="highlighter-rouge">GroupByKey</code>.
Subsequent transforms, however, are applied to the result of the <code class="highlighter-rouge">GroupByKey</code> –
data is grouped by both key and window.</p>

<h4 id="windowing-bounded-collections">7.1.2. Windowing with bounded PCollections</h4>

<p>You can use windowing with fixed-size data sets in <strong>bounded</strong> <code class="highlighter-rouge">PCollection</code>s.
However, note that windowing considers only the implicit timestamps attached to
each element of a <code class="highlighter-rouge">PCollection</code>, and data sources that create fixed data sets
(such as <code class="highlighter-rouge">TextIO</code>) assign the same timestamp to every element. This means that
all the elements are by default part of a single, global window.</p>

<p>To use windowing with fixed data sets, you can assign your own timestamps to
each element. To assign timestamps to elements, use a <code class="highlighter-rouge">ParDo</code> transform with a
<code class="highlighter-rouge">DoFn</code> that outputs each element with a new timestamp (for example, the
<a href="/documentation/sdks/javadoc/2.6.0/index.html?org/apache/beam/sdk/transforms/WithTimestamps.html">WithTimestamps</a>
transform in the Beam SDK for Java).</p>

<p>To illustrate how windowing with a bounded <code class="highlighter-rouge">PCollection</code> can affect how your
pipeline processes data, consider the following pipeline:</p>

<p><img src="/images/unwindowed-pipeline-bounded.png" alt="Diagram of GroupByKey and ParDo without windowing, on a bounded collection" title="GroupByKey and ParDo without windowing, on a bounded collection" /></p>

<p><strong>Figure:</strong> <code class="highlighter-rouge">GroupByKey</code> and <code class="highlighter-rouge">ParDo</code> without windowing, on a bounded collection.</p>

<p>In the above pipeline, we create a bounded <code class="highlighter-rouge">PCollection</code> by reading a set of
key/value pairs using <code class="highlighter-rouge">TextIO</code>. We then group the collection using <code class="highlighter-rouge">GroupByKey</code>,
and apply a <code class="highlighter-rouge">ParDo</code> transform to the grouped <code class="highlighter-rouge">PCollection</code>. In this example, the
<code class="highlighter-rouge">GroupByKey</code> creates a collection of unique keys, and then <code class="highlighter-rouge">ParDo</code> gets applied
exactly once per key.</p>

<p>Note that even if you don’t set a windowing function, there is still a window –
all elements in your <code class="highlighter-rouge">PCollection</code> are assigned to a single global window.</p>

<p>Now, consider the same pipeline, but using a windowing function:</p>

<p><img src="/images/windowing-pipeline-bounded.png" alt="Diagram of GroupByKey and ParDo with windowing, on a bounded collection" title="GroupByKey and ParDo with windowing, on a bounded collection" /></p>

<p><strong>Figure:</strong> <code class="highlighter-rouge">GroupByKey</code> and <code class="highlighter-rouge">ParDo</code> with windowing, on a bounded collection.</p>

<p>As before, the pipeline creates a bounded <code class="highlighter-rouge">PCollection</code> of key/value pairs. We
then set a <a href="#setting-your-pcollections-windowing-function">windowing function</a>
for that <code class="highlighter-rouge">PCollection</code>.  The <code class="highlighter-rouge">GroupByKey</code> transform groups the elements of the
<code class="highlighter-rouge">PCollection</code> by both key and window, based on the windowing function. The
subsequent <code class="highlighter-rouge">ParDo</code> transform gets applied multiple times per key, once for each
window.</p>

<h3 id="provided-windowing-functions">7.2. Provided windowing functions</h3>

<p>You can define different kinds of windows to divide the elements of your
<code class="highlighter-rouge">PCollection</code>. Beam provides several windowing functions, including:</p>

<ul>
  <li>Fixed Time Windows</li>
  <li>Sliding Time Windows</li>
  <li>Per-Session Windows</li>
  <li>Single Global Window</li>
  <li>Calendar-based Windows (not supported by the Beam SDK for Python)</li>
</ul>

<p>You can also define your own <code class="highlighter-rouge">WindowFn</code> if you have a more complex need.</p>

<p>Note that each element can logically belong to more than one window, depending
on the windowing function you use. Sliding time windowing, for example, creates
overlapping windows wherein a single element can be assigned to multiple
windows.</p>

<h4 id="fixed-time-windows">7.2.1. Fixed time windows</h4>

<p>The simplest form of windowing is using <strong>fixed time windows</strong>: given a
timestamped <code class="highlighter-rouge">PCollection</code> which might be continuously updating, each window
might capture (for example) all elements with timestamps that fall into a five
minute interval.</p>

<p>A fixed time window represents a consistent duration, non overlapping time
interval in the data stream. Consider windows with a five-minute duration: all
of the elements in your unbounded <code class="highlighter-rouge">PCollection</code> with timestamp values from
0:00:00 up to (but not including) 0:05:00 belong to the first window, elements
with timestamp values from 0:05:00 up to (but not including) 0:10:00 belong to
the second window, and so on.</p>

<p><img src="/images/fixed-time-windows.png" alt="Diagram of fixed time windows, 30s in duration" title="Fixed time windows, 30s in duration" /></p>

<p><strong>Figure:</strong> Fixed time windows, 30s in duration.</p>

<h4 id="sliding-time-windows">7.2.2. Sliding time windows</h4>

<p>A <strong>sliding time window</strong> also represents time intervals in the data stream;
however, sliding time windows can overlap. For example, each window might
capture five minutes worth of data, but a new window starts every ten seconds.
The frequency with which sliding windows begin is called the <em>period</em>.
Therefore, our example would have a window <em>duration</em> of five minutes and a
<em>period</em> of ten seconds.</p>

<p>Because multiple windows overlap, most elements in a data set will belong to
more than one window. This kind of windowing is useful for taking running
averages of data; using sliding time windows, you can compute a running average
of the past five minutes’ worth of data, updated every ten seconds, in our
example.</p>

<p><img src="/images/sliding-time-windows.png" alt="Diagram of sliding time windows, with 1 minute window duration and 30s window period" title="Sliding time windows, with 1 minute window duration and 30s window period" /></p>

<p><strong>Figure:</strong> Sliding time windows, with 1 minute window duration and 30s window
period.</p>

<h4 id="session-windows">7.2.3. Session windows</h4>

<p>A <strong>session window</strong> function defines windows that contain elements that are
within a certain gap duration of another element. Session windowing applies on a
per-key basis and is useful for data that is irregularly distributed with
respect to time. For example, a data stream representing user mouse activity may
have long periods of idle time interspersed with high concentrations of clicks.
If data arrives after the minimum specified gap duration time, this initiates
the start of a new window.</p>

<p><img src="/images/session-windows.png" alt="Diagram of session windows with a minimum gap duration" title="Session windows, with a minimum gap duration" /></p>

<p><strong>Figure:</strong> Session windows, with a minimum gap duration. Note how each data key
has different windows, according to its data distribution.</p>

<h4 id="single-global-window">7.2.4. The single global window</h4>

<p>By default, all data in a <code class="highlighter-rouge">PCollection</code> is assigned to the single global window,
and late data is discarded. If your data set is of a fixed size, you can use the
global window default for your <code class="highlighter-rouge">PCollection</code>.</p>

<p>You can use the single global window if you are working with an unbounded data set
(e.g. from a streaming data source) but use caution when applying aggregating
transforms such as <code class="highlighter-rouge">GroupByKey</code> and <code class="highlighter-rouge">Combine</code>. The single global window with a
default trigger generally requires the entire data set to be available before
processing, which is not possible with continuously updating data. To perform
aggregations on an unbounded <code class="highlighter-rouge">PCollection</code> that uses global windowing, you
should specify a non-default trigger for that <code class="highlighter-rouge">PCollection</code>.</p>

<h3 id="setting-your-pcollections-windowing-function">7.3. Setting your PCollection’s windowing function</h3>

<p>You can set the windowing function for a <code class="highlighter-rouge">PCollection</code> by applying the <code class="highlighter-rouge">Window</code>
transform. When you apply the <code class="highlighter-rouge">Window</code> transform, you must provide a <code class="highlighter-rouge">WindowFn</code>.
The <code class="highlighter-rouge">WindowFn</code> determines the windowing function your <code class="highlighter-rouge">PCollection</code> will use for
subsequent grouping transforms, such as a fixed or sliding time window.</p>

<p>When you set a windowing function, you may also want to set a trigger for your
<code class="highlighter-rouge">PCollection</code>. The trigger determines when each individual window is aggregated
and emitted, and helps refine how the windowing function performs with respect
to late data and computing early results. See the <a href="#triggers">triggers</a> section
for more information.</p>

<h4 id="using-fixed-time-windows">7.3.1. Fixed-time windows</h4>

<p>The following example code shows how to apply <code class="highlighter-rouge">Window</code> to divide a <code class="highlighter-rouge">PCollection</code>
into fixed windows, each one minute in length:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="o">...;</span>
    <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">fixedWindowedItems</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
        <span class="n">Window</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">into</span><span class="o">(</span><span class="n">FixedWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardMinutes</span><span class="o">(</span><span class="mi">1</span><span class="o">))));</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">apache_beam</span> <span class="kn">import</span> <span class="n">window</span>
<span class="n">fixed_windowed_items</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">items</span> <span class="o">|</span> <span class="s">'window'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">WindowInto</span><span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">FixedWindows</span><span class="p">(</span><span class="mi">60</span><span class="p">)))</span>

</code></pre>
</div>

<h4 id="using-sliding-time-windows">7.3.2. Sliding time windows</h4>

<p>The following example code shows how to apply <code class="highlighter-rouge">Window</code> to divide a <code class="highlighter-rouge">PCollection</code>
into sliding time windows. Each window is 30 seconds in length, and a new window
begins every five seconds:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="o">...;</span>
    <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">slidingWindowedItems</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
        <span class="n">Window</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">into</span><span class="o">(</span><span class="n">SlidingWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardSeconds</span><span class="o">(</span><span class="mi">30</span><span class="o">)).</span><span class="na">every</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardSeconds</span><span class="o">(</span><span class="mi">5</span><span class="o">))));</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">apache_beam</span> <span class="kn">import</span> <span class="n">window</span>
<span class="n">sliding_windowed_items</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">items</span> <span class="o">|</span> <span class="s">'window'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">WindowInto</span><span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">SlidingWindows</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">5</span><span class="p">)))</span>

</code></pre>
</div>

<h4 id="using-session-windows">7.3.3. Session windows</h4>

<p>The following example code shows how to apply <code class="highlighter-rouge">Window</code> to divide a <code class="highlighter-rouge">PCollection</code>
into session windows, where each session must be separated by a time gap of at
least 10 minutes:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="o">...;</span>
    <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sessionWindowedItems</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
        <span class="n">Window</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">into</span><span class="o">(</span><span class="n">Sessions</span><span class="o">.</span><span class="na">withGapDuration</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardMinutes</span><span class="o">(</span><span class="mi">10</span><span class="o">))));</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">apache_beam</span> <span class="kn">import</span> <span class="n">window</span>
<span class="n">session_windowed_items</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">items</span> <span class="o">|</span> <span class="s">'window'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">WindowInto</span><span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">Sessions</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>

</code></pre>
</div>

<p>Note that the sessions are per-key — each key in the collection will have its
own session groupings depending on the data distribution.</p>

<h4 id="using-single-global-window">7.3.4. Single global window</h4>

<p>If your <code class="highlighter-rouge">PCollection</code> is bounded (the size is fixed), you can assign all the
elements to a single global window. The following example code shows how to set
a single global window for a <code class="highlighter-rouge">PCollection</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="o">...;</span>
    <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">batchItems</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
        <span class="n">Window</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">into</span><span class="o">(</span><span class="k">new</span> <span class="n">GlobalWindows</span><span class="o">()));</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">apache_beam</span> <span class="kn">import</span> <span class="n">window</span>
<span class="n">session_windowed_items</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">items</span> <span class="o">|</span> <span class="s">'window'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">WindowInto</span><span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">GlobalWindows</span><span class="p">()))</span>

</code></pre>
</div>

<h3 id="watermarks-and-late-data">7.4. Watermarks and late data</h3>

<p>In any data processing system, there is a certain amount of lag between the time
a data event occurs (the “event time”, determined by the timestamp on the data
element itself) and the time the actual data element gets processed at any stage
in your pipeline (the “processing time”, determined by the clock on the system
processing the element). In addition, there are no guarantees that data events
will appear in your pipeline in the same order that they were generated.</p>

<p>For example, let’s say we have a <code class="highlighter-rouge">PCollection</code> that’s using fixed-time
windowing, with windows that are five minutes long. For each window, Beam must
collect all the data with an <em>event time</em> timestamp in the given window range
(between 0:00 and 4:59 in the first window, for instance). Data with timestamps
outside that range (data from 5:00 or later) belong to a different window.</p>

<p>However, data isn’t always guaranteed to arrive in a pipeline in time order, or
to always arrive at predictable intervals. Beam tracks a <em>watermark</em>, which is
the system’s notion of when all data in a certain window can be expected to have
arrived in the pipeline. Data that arrives with a timestamp after the watermark
is considered <strong>late data</strong>.</p>

<p>From our example, suppose we have a simple watermark that assumes approximately
30s of lag time between the data timestamps (the event time) and the time the
data appears in the pipeline (the processing time), then Beam would close the
first window at 5:30. If a data record arrives at 5:34, but with a timestamp
that would put it in the 0:00-4:59 window (say, 3:38), then that record is late
data.</p>

<p>Note: For simplicity, we’ve assumed that we’re using a very straightforward
watermark that estimates the lag time. In practice, your <code class="highlighter-rouge">PCollection</code>’s data
source determines the watermark, and watermarks can be more precise or complex.</p>

<p>Beam’s default windowing configuration tries to determines when all data has
arrived (based on the type of data source) and then advances the watermark past
the end of the window. This default configuration does <em>not</em> allow late data.
<a href="#triggers">Triggers</a> allow you to modify and refine the windowing strategy for
a <code class="highlighter-rouge">PCollection</code>. You can use triggers to decide when each individual window
aggregates and reports its results, including how the window emits late
elements.</p>

<h4 id="managing-late-data">7.4.1. Managing late data</h4>

<blockquote>
  <p><strong>Note:</strong> Managing late data is not supported in the Beam SDK for Python.</p>
</blockquote>

<p>You can allow late data by invoking the <code class="highlighter-rouge">.withAllowedLateness</code> operation when
you set your <code class="highlighter-rouge">PCollection</code>’s windowing strategy. The following code example
demonstrates a windowing strategy that will allow late data up to two days after
the end of a window.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="o">...;</span>
    <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">fixedWindowedItems</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
        <span class="n">Window</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">into</span><span class="o">(</span><span class="n">FixedWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardMinutes</span><span class="o">(</span><span class="mi">1</span><span class="o">)))</span>
              <span class="o">.</span><span class="na">withAllowedLateness</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardDays</span><span class="o">(</span><span class="mi">2</span><span class="o">)));</span>
</code></pre>
</div>

<p>When you set <code class="highlighter-rouge">.withAllowedLateness</code> on a <code class="highlighter-rouge">PCollection</code>, that allowed lateness
propagates forward to any subsequent <code class="highlighter-rouge">PCollection</code> derived from the first
<code class="highlighter-rouge">PCollection</code> you applied allowed lateness to. If you want to change the allowed
lateness later in your pipeline, you must do so explictly by applying
<code class="highlighter-rouge">Window.configure().withAllowedLateness()</code>.</p>

<h3 id="adding-timestamps-to-a-pcollections-elements">7.5. Adding timestamps to a PCollection’s elements</h3>

<p>An unbounded source provides a timestamp for each element. Depending on your
unbounded source, you may need to configure how the timestamp is extracted from
the raw data stream.</p>

<p>However, bounded sources (such as a file from <code class="highlighter-rouge">TextIO</code>) do not provide
timestamps. If you need timestamps, you must add them to your <code class="highlighter-rouge">PCollection</code>’s
elements.</p>

<p>You can assign new timestamps to the elements of a <code class="highlighter-rouge">PCollection</code> by applying a
<a href="#pardo">ParDo</a> transform that outputs new elements with timestamps that you
set.</p>

<p>An example might be if your pipeline reads log records from an input file, and
each log record includes a timestamp field; since your pipeline reads the
records in from a file, the file source doesn’t assign timestamps automatically.
You can parse the timestamp field from each record and use a <code class="highlighter-rouge">ParDo</code> transform
with a <code class="highlighter-rouge">DoFn</code> to attach the timestamps to each element in your <code class="highlighter-rouge">PCollection</code>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>      <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">LogEntry</span><span class="o">&gt;</span> <span class="n">unstampedLogs</span> <span class="o">=</span> <span class="o">...;</span>
      <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">LogEntry</span><span class="o">&gt;</span> <span class="n">stampedLogs</span> <span class="o">=</span>
          <span class="n">unstampedLogs</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">ParDo</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">LogEntry</span><span class="o">,</span> <span class="n">LogEntry</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="nd">@Element</span> <span class="n">LogEntry</span> <span class="n">element</span><span class="o">,</span> <span class="n">OutputReceiver</span><span class="o">&lt;</span><span class="n">LogEntry</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
              <span class="c1">// Extract the timestamp from log entry we're currently processing.</span>
              <span class="n">Instant</span> <span class="n">logTimeStamp</span> <span class="o">=</span> <span class="n">extractTimeStampFromLogEntry</span><span class="o">(</span><span class="n">element</span><span class="o">);</span>
              <span class="c1">// Use OutputReceiver.outputWithTimestamp (rather than</span>
              <span class="c1">// OutputReceiver.output) to emit the entry with timestamp attached.</span>
              <span class="n">out</span><span class="o">.</span><span class="na">outputWithTimestamp</span><span class="o">(</span><span class="n">element</span><span class="o">,</span> <span class="n">logTimeStamp</span><span class="o">);</span>
            <span class="o">}</span>
          <span class="o">}));</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AddTimestampDoFn</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">DoFn</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
    <span class="c"># Extract the numeric Unix seconds-since-epoch timestamp to be</span>
    <span class="c"># associated with the current log entry.</span>
    <span class="n">unix_timestamp</span> <span class="o">=</span> <span class="n">extract_timestamp_from_log_entry</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="c"># Wrap and emit the current entry and new timestamp in a</span>
    <span class="c"># TimestampedValue.</span>
    <span class="k">yield</span> <span class="n">beam</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">TimestampedValue</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">unix_timestamp</span><span class="p">)</span>

<span class="n">timestamped_items</span> <span class="o">=</span> <span class="n">items</span> <span class="o">|</span> <span class="s">'timestamp'</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">ParDo</span><span class="p">(</span><span class="n">AddTimestampDoFn</span><span class="p">())</span>

</code></pre>
</div>

<h2 id="triggers">8. Triggers</h2>

<p>When collecting and grouping data into windows, Beam uses <strong>triggers</strong> to
determine when to emit the aggregated results of each window (referred to as a
<em>pane</em>). If you use Beam’s default windowing configuration and <a href="#default-trigger">default
trigger</a>, Beam outputs the aggregated result when it
<a href="#watermarks-and-late-data">estimates all data has arrived</a>, and discards all
subsequent data for that window.</p>

<p>You can set triggers for your <code class="highlighter-rouge">PCollection</code>s to change this default behavior.
Beam provides a number of pre-built triggers that you can set:</p>

<ul>
  <li><strong>Event time triggers</strong>. These triggers operate on the event time, as
indicated by the timestamp on each data element. Beam’s default trigger is
event time-based.</li>
  <li><strong>Processing time triggers</strong>. These triggers operate on the processing time
– the time when the data element is processed at any given stage in the
pipeline.</li>
  <li><strong>Data-driven triggers</strong>. These triggers operate by examining the data as it
arrives in each window, and firing when that data meets a certain property.
Currently, data-driven triggers only support firing after a certain number
of data elements.</li>
  <li><strong>Composite triggers</strong>. These triggers combine multiple triggers in various
ways.</li>
</ul>

<p>At a high level, triggers provide two additional capabilities compared to simply
outputting at the end of a window:</p>

<ul>
  <li>Triggers allow Beam to emit early results, before all the data in a given
window has arrived. For example, emitting after a certain amount of time
elapses, or after a certain number of elements arrives.</li>
  <li>Triggers allow processing of late data by triggering after the event time
watermark passes the end of the window.</li>
</ul>

<p>These capabilities allow you to control the flow of your data and balance
between different factors depending on your use case:</p>

<ul>
  <li><strong>Completeness:</strong> How important is it to have all of your data before you
compute your result?</li>
  <li><strong>Latency:</strong> How long do you want to wait for data? For example, do you wait
until you think you have all data? Do you process data as it arrives?</li>
  <li><strong>Cost:</strong> How much compute power/money are you willing to spend to lower the
latency?</li>
</ul>

<p>For example, a system that requires time-sensitive updates might use a strict
time-based trigger that emits a window every <em>N</em> seconds, valuing promptness
over data completeness. A system that values data completeness more than the
exact timing of results might choose to use Beam’s default trigger, which fires
at the end of the window.</p>

<p>You can also set a trigger for an unbounded <code class="highlighter-rouge">PCollection</code> that uses a <a href="#windowing">single
global window for its windowing function</a>. This can be useful when
you want your pipeline to provide periodic updates on an unbounded data set —
for example, a running average of all data provided to the present time, updated
every N seconds or every N elements.</p>

<h3 id="event-time-triggers">8.1. Event time triggers</h3>

<p>The <code class="highlighter-rouge">AfterWatermark</code> trigger operates on <em>event time</em>. The <code class="highlighter-rouge">AfterWatermark</code>
trigger emits the contents of a window after the
<a href="#watermarks-and-late-data">watermark</a> passes the end of the window, based on the
timestamps attached to the data elements. The watermark is a global progress
metric, and is Beam’s notion of input completeness within your pipeline at any
given point. <span class="language-java"><code class="highlighter-rouge">AfterWatermark.pastEndOfWindow()</code></span>
<span class="language-py"><code class="highlighter-rouge">AfterWatermark</code></span> <em>only</em> fires when the
watermark passes the end of the window.</p>

<p>In addition, you can configure triggers that fire if your pipeline receives data
before or after the end of the window.</p>

<p>The following example shows a billing scenario, and uses both early and late
firings:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="c1">// Create a bill at the end of the month.</span>
  <span class="n">AfterWatermark</span><span class="o">.</span><span class="na">pastEndOfWindow</span><span class="o">()</span>
      <span class="c1">// During the month, get near real-time estimates.</span>
      <span class="o">.</span><span class="na">withEarlyFirings</span><span class="o">(</span>
          <span class="n">AfterProcessingTime</span>
              <span class="o">.</span><span class="na">pastFirstElementInPane</span><span class="o">()</span>
              <span class="o">.</span><span class="na">plusDuration</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardMinutes</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
      <span class="c1">// Fire on any late data so the bill can be corrected.</span>
      <span class="o">.</span><span class="na">withLateFirings</span><span class="o">(</span><span class="n">AfterPane</span><span class="o">.</span><span class="na">elementCountAtLeast</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">AfterWatermark</span><span class="p">(</span>
    <span class="n">early</span><span class="o">=</span><span class="n">AfterProcessingTime</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">60</span><span class="p">),</span>
    <span class="n">late</span><span class="o">=</span><span class="n">AfterCount</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</code></pre>
</div>

<h4 id="default-trigger">8.1.1. Default trigger</h4>

<p>The default trigger for a <code class="highlighter-rouge">PCollection</code> is based on event time, and emits the
results of the window when the Beam’s watermark passes the end of the window,
and then fires each time late data arrives.</p>

<p>However, if you are using both the default windowing configuration and the
default trigger, the default trigger emits exactly once, and late data is
discarded. This is because the default windowing configuration has an allowed
lateness value of 0. See the Handling Late Data section for information about
modifying this behavior.</p>

<h3 id="processing-time-triggers">8.2. Processing time triggers</h3>

<p>The <code class="highlighter-rouge">AfterProcessingTime</code> trigger operates on <em>processing time</em>. For example,
the <span class="language-java"><code class="highlighter-rouge">AfterProcessingTime.pastFirstElementInPane()</code></span>
<span class="language-py"><code class="highlighter-rouge">AfterProcessingTime</code></span> trigger emits a window
after a certain amount of processing time has passed since data was received.
The processing time is determined by the system clock, rather than the data
element’s timestamp.</p>

<p>The <code class="highlighter-rouge">AfterProcessingTime</code> trigger is useful for triggering early results from a
window, particularly a window with a large time frame such as a single global
window.</p>

<h3 id="data-driven-triggers">8.3. Data-driven triggers</h3>

<p>Beam provides one data-driven trigger,
<span class="language-java"><code class="highlighter-rouge">AfterPane.elementCountAtLeast()</code></span>
<span class="language-py"><code class="highlighter-rouge">AfterCount</code></span>. This trigger works on an element
count; it fires after the current pane has collected at least <em>N</em> elements. This
allows a window to emit early results (before all the data has accumulated),
which can be particularly useful if you are using a single global window.</p>

<p>It is important to note that if, for example, you specify
<span class="language-java"><code class="highlighter-rouge">.elementCountAtLeast(50)</code></span>
<span class="language-py">AfterCount(50)</span> and only 32 elements arrive,
those 32 elements sit around forever. If the 32 elements are important to you,
consider using <a href="#composite-triggers">composite triggers</a> to combine multiple
conditions. This allows you to specify multiple firing conditions such as “fire
either when I receive 50 elements, or every 1 second”.</p>

<h3 id="setting-a-trigger">8.4. Setting a trigger</h3>

<p>When you set a windowing function for a <code class="highlighter-rouge">PCollection</code> by using the
<span class="language-java"><code class="highlighter-rouge">Window</code></span><span class="language-py"><code class="highlighter-rouge">WindowInto</code></span>
transform, you can also specify a trigger.</p>

<p class="language-java">You set the trigger(s) for a <code class="highlighter-rouge">PCollection</code> by invoking the method
<code class="highlighter-rouge">.triggering()</code> on the result of your <code class="highlighter-rouge">Window.into()</code> transform. This code
sample sets a time-based trigger for a <code class="highlighter-rouge">PCollection</code>, which emits results one
minute after the first element in that window has been processed.  The last line
in the code sample, <code class="highlighter-rouge">.discardingFiredPanes()</code>, sets the window’s <strong>accumulation
mode</strong>.</p>

<p class="language-py">You set the trigger(s) for a <code class="highlighter-rouge">PCollection</code> by setting the <code class="highlighter-rouge">trigger</code> parameter
when you use the <code class="highlighter-rouge">WindowInto</code> transform. This code sample sets a time-based
trigger for a <code class="highlighter-rouge">PCollection</code>, which emits results one minute after the first
element in that window has been processed. The <code class="highlighter-rouge">accumulation_mode</code> parameter
sets the window’s <strong>accumulation mode</strong>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">pc</span> <span class="o">=</span> <span class="o">...;</span>
  <span class="n">pc</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">Window</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">into</span><span class="o">(</span><span class="n">FixedWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MINUTES</span><span class="o">))</span>
                               <span class="o">.</span><span class="na">triggering</span><span class="o">(</span><span class="n">AfterProcessingTime</span><span class="o">.</span><span class="na">pastFirstElementInPane</span><span class="o">()</span>
                                                              <span class="o">.</span><span class="na">plusDelayOf</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardMinutes</span><span class="o">(</span><span class="mi">1</span><span class="o">)))</span>
                               <span class="o">.</span><span class="na">discardingFiredPanes</span><span class="o">());</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">pcollection</span> <span class="o">|</span> <span class="n">WindowInto</span><span class="p">(</span>
    <span class="n">FixedWindows</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">60</span><span class="p">),</span>
    <span class="n">trigger</span><span class="o">=</span><span class="n">AfterProcessingTime</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="mi">60</span><span class="p">),</span>
    <span class="n">accumulation_mode</span><span class="o">=</span><span class="n">AccumulationMode</span><span class="o">.</span><span class="n">DISCARDING</span><span class="p">)</span>
</code></pre>
</div>

<h4 id="window-accumulation-modes">8.4.1. Window accumulation modes</h4>

<p>When you specify a trigger, you must also set the the window’s <strong>accumulation
mode</strong>. When a trigger fires, it emits the current contents of the window as a
pane. Since a trigger can fire multiple times, the accumulation mode determines
whether the system <em>accumulates</em> the window panes as the trigger fires, or
<em>discards</em> them.</p>

<p class="language-java">To set a window to accumulate the panes that are produced when the trigger
fires, invoke<code class="highlighter-rouge">.accumulatingFiredPanes()</code> when you set the trigger. To set a
window to discard fired panes, invoke <code class="highlighter-rouge">.discardingFiredPanes()</code>.</p>

<p class="language-py">To set a window to accumulate the panes that are produced when the trigger
fires, set the <code class="highlighter-rouge">accumulation_mode</code> parameter to <code class="highlighter-rouge">ACCUMULATING</code> when you set the
trigger. To set a window to discard fired panes, set <code class="highlighter-rouge">accumulation_mode</code> to
<code class="highlighter-rouge">DISCARDING</code>.</p>

<p>Let’s look an example that uses a <code class="highlighter-rouge">PCollection</code> with fixed-time windowing and a
data-based trigger. This is something you might do if, for example, each window
represented a ten-minute running average, but you wanted to display the current
value of the average in a UI more frequently than every ten minutes. We’ll
assume the following conditions:</p>

<ul>
  <li>The <code class="highlighter-rouge">PCollection</code> uses 10-minute fixed-time windows.</li>
  <li>The <code class="highlighter-rouge">PCollection</code> has a repeating trigger that fires every time 3 elements
arrive.</li>
</ul>

<p>The following diagram shows data events for key X as they arrive in the
PCollection and are assigned to windows. To keep the diagram a bit simpler,
we’ll assume that the events all arrive in the pipeline in order.</p>

<p><img src="/images/trigger-accumulation.png" alt="Diagram of data events for acculumating mode example" title="Data events for accumulating mode example" /></p>

<h5 id="accumulating-mode">8.4.1.1. Accumulating mode</h5>

<p>If our trigger is set to accumulating mode, the trigger emits the following
values each time it fires. Keep in mind that the trigger fires every time three
elements arrive:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  First trigger firing:  [5, 8, 3]
  Second trigger firing: [5, 8, 3, 15, 19, 23]
  Third trigger firing:  [5, 8, 3, 15, 19, 23, 9, 13, 10]
</code></pre>
</div>

<h5 id="discarding-mode">8.4.1.2. Discarding mode</h5>

<p>If our trigger is set to discarding mode, the trigger emits the following values
on each firing:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  First trigger firing:  [5, 8, 3]
  Second trigger firing:           [15, 19, 23]
  Third trigger firing:                         [9, 13, 10]
</code></pre>
</div>

<h4 id="handling-late-data">8.4.2. Handling late data</h4>

<blockquote>
  <p>The Beam SDK for Python does not currently support allowed lateness.</p>
</blockquote>

<p>If you want your pipeline to process data that arrives after the watermark
passes the end of the window, you can apply an <em>allowed lateness</em> when you set
your windowing configuration. This gives your trigger the opportunity to react
to the late data. If allowed lateness is set, the default trigger will emit new
results immediately whenever late data arrives.</p>

<p>You set the allowed lateness by using <code class="highlighter-rouge">.withAllowedLateness()</code> when you set your
windowing function:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="n">PCollection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">pc</span> <span class="o">=</span> <span class="o">...;</span>
  <span class="n">pc</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">Window</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">into</span><span class="o">(</span><span class="n">FixedWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MINUTES</span><span class="o">))</span>
                              <span class="o">.</span><span class="na">triggering</span><span class="o">(</span><span class="n">AfterProcessingTime</span><span class="o">.</span><span class="na">pastFirstElementInPane</span><span class="o">()</span>
                                                             <span class="o">.</span><span class="na">plusDelayOf</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardMinutes</span><span class="o">(</span><span class="mi">1</span><span class="o">)))</span>
                              <span class="o">.</span><span class="na">withAllowedLateness</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardMinutes</span><span class="o">(</span><span class="mi">30</span><span class="o">));</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code>  <span class="c"># The Beam SDK for Python does not currently support allowed lateness.</span>
</code></pre>
</div>

<p>This allowed lateness propagates to all <code class="highlighter-rouge">PCollection</code>s derived as a result of
applying transforms to the original <code class="highlighter-rouge">PCollection</code>. If you want to change the
allowed lateness later in your pipeline, you can apply
<code class="highlighter-rouge">Window.configure().withAllowedLateness()</code> again, explicitly.</p>

<h3 id="composite-triggers">8.5. Composite triggers</h3>

<p>You can combine multiple triggers to form <strong>composite triggers</strong>, and can
specify a trigger to emit results repeatedly, at most once, or under other
custom conditions.</p>

<h4 id="composite-trigger-types">8.5.1. Composite trigger types</h4>

<p>Beam includes the following composite triggers:</p>

<ul>
  <li>You can add additional early firings or late firings to
<code class="highlighter-rouge">AfterWatermark.pastEndOfWindow</code> via <code class="highlighter-rouge">.withEarlyFirings</code> and
<code class="highlighter-rouge">.withLateFirings</code>.</li>
  <li><code class="highlighter-rouge">Repeatedly.forever</code> specifies a trigger that executes forever. Any time the
trigger’s conditions are met, it causes a window to emit results and then
resets and starts over. It can be useful to combine <code class="highlighter-rouge">Repeatedly.forever</code>
with <code class="highlighter-rouge">.orFinally</code> to specify a condition that causes the repeating trigger
to stop.</li>
  <li><code class="highlighter-rouge">AfterEach.inOrder</code> combines multiple triggers to fire in a specific
sequence. Each time a trigger in the sequence emits a window, the sequence
advances to the next trigger.</li>
  <li><code class="highlighter-rouge">AfterFirst</code> takes multiple triggers and emits the first time <em>any</em> of its
argument triggers is satisfied. This is equivalent to a logical OR operation
for multiple triggers.</li>
  <li><code class="highlighter-rouge">AfterAll</code> takes multiple triggers and emits when <em>all</em> of its argument
triggers are satisfied. This is equivalent to a logical AND operation for
multiple triggers.</li>
  <li><code class="highlighter-rouge">orFinally</code> can serve as a final condition to cause any trigger to fire one
final time and never fire again.</li>
</ul>

<h4 id="composite-afterwatermark">8.5.2. Composition with AfterWatermark</h4>

<p>Some of the most useful composite triggers fire a single time when Beam
estimates that all the data has arrived (i.e. when the watermark passes the end
of the window) combined with either, or both, of the following:</p>

<ul>
  <li>
    <p>Speculative firings that precede the watermark passing the end of the window
to allow faster processing of partial results.</p>
  </li>
  <li>
    <p>Late firings that happen after the watermark passes the end of the window,
to allow for handling late-arriving data</p>
  </li>
</ul>

<p>You can express this pattern using <code class="highlighter-rouge">AfterWatermark</code>. For example, the following
example trigger code fires on the following conditions:</p>

<ul>
  <li>
    <p>On Beam’s estimate that all the data has arrived (the watermark passes the
end of the window)</p>
  </li>
  <li>
    <p>Any time late data arrives, after a ten-minute delay</p>
  </li>
</ul>

<ul class="language-java">
  <li>After two days, we assume no more data of interest will arrive, and the
trigger stops executing</li>
</ul>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">Window</span>
      <span class="o">.</span><span class="na">configure</span><span class="o">()</span>
      <span class="o">.</span><span class="na">triggering</span><span class="o">(</span><span class="n">AfterWatermark</span>
           <span class="o">.</span><span class="na">pastEndOfWindow</span><span class="o">()</span>
           <span class="o">.</span><span class="na">withLateFirings</span><span class="o">(</span><span class="n">AfterProcessingTime</span>
                <span class="o">.</span><span class="na">pastFirstElementInPane</span><span class="o">()</span>
                <span class="o">.</span><span class="na">plusDelayOf</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardMinutes</span><span class="o">(</span><span class="mi">10</span><span class="o">))))</span>
      <span class="o">.</span><span class="na">withAllowedLateness</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardDays</span><span class="o">(</span><span class="mi">2</span><span class="o">)));</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">pcollection</span> <span class="o">|</span> <span class="n">WindowInto</span><span class="p">(</span>
    <span class="n">FixedWindows</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">60</span><span class="p">),</span>
    <span class="n">trigger</span><span class="o">=</span><span class="n">AfterWatermark</span><span class="p">(</span>
        <span class="n">late</span><span class="o">=</span><span class="n">AfterProcessingTime</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)),</span>
    <span class="n">accumulation_mode</span><span class="o">=</span><span class="n">AccumulationMode</span><span class="o">.</span><span class="n">DISCARDING</span><span class="p">)</span>
</code></pre>
</div>

<h4 id="other-composite-triggers">8.5.3. Other composite triggers</h4>

<p>You can also build other sorts of composite triggers. The following example code
shows a simple composite trigger that fires whenever the pane has at least 100
elements, or after a minute.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="n">Repeatedly</span><span class="o">.</span><span class="na">forever</span><span class="o">(</span><span class="n">AfterFirst</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
      <span class="n">AfterPane</span><span class="o">.</span><span class="na">elementCountAtLeast</span><span class="o">(</span><span class="mi">100</span><span class="o">),</span>
      <span class="n">AfterProcessingTime</span><span class="o">.</span><span class="na">pastFirstElementInPane</span><span class="o">().</span><span class="na">plusDelayOf</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">standardMinutes</span><span class="o">(</span><span class="mi">1</span><span class="o">))))</span>
</code></pre>
</div>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">pcollection</span> <span class="o">|</span> <span class="n">WindowInto</span><span class="p">(</span>
    <span class="n">FixedWindows</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">60</span><span class="p">),</span>
    <span class="n">trigger</span><span class="o">=</span><span class="n">Repeatedly</span><span class="p">(</span>
        <span class="n">AfterAny</span><span class="p">(</span>
            <span class="n">AfterCount</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
            <span class="n">AfterProcessingTime</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">60</span><span class="p">))),</span>
    <span class="n">accumulation_mode</span><span class="o">=</span><span class="n">AccumulationMode</span><span class="o">.</span><span class="n">DISCARDING</span><span class="p">)</span>
</code></pre>
</div>

      </div>
    </div>
    <!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License. See accompanying LICENSE file.
-->

<footer class="footer">
  <div class="footer__contained">
    <div class="footer__cols">
      <div class="footer__cols__col">
        <div class="footer__cols__col__logo">
          <img src="/images/beam_logo_circle.svg" class="footer__logo" alt="Beam logo">
        </div>
        <div class="footer__cols__col__logo">
          <img src="/images/apache_logo_circle.svg" class="footer__logo" alt="Apache logo">
        </div>
      </div>
      <div class="footer__cols__col footer__cols__col--md">
        <div class="footer__cols__col__title">Start</div>
        <div class="footer__cols__col__link"><a href="/get-started/beam-overview/">Overview</a></div>
        <div class="footer__cols__col__link"><a href="/get-started/quickstart-java/">Quickstart (Java)</a></div>
        <div class="footer__cols__col__link"><a href="/get-started/quickstart-py/">Quickstart (Python)</a></div>
        <div class="footer__cols__col__link"><a href="/get-started/quickstart-go/">Quickstart (Go)</a></div>
        <div class="footer__cols__col__link"><a href="/get-started/downloads/">Downloads</a></div>
      </div>
      <div class="footer__cols__col footer__cols__col--md">
        <div class="footer__cols__col__title">Docs</div>
        <div class="footer__cols__col__link"><a href="/documentation/programming-guide/">Concepts</a></div>
        <div class="footer__cols__col__link"><a href="/documentation/pipelines/design-your-pipeline/">Pipelines</a></div>
        <div class="footer__cols__col__link"><a href="/documentation/runners/capability-matrix/">Runners</a></div>
      </div>
      <div class="footer__cols__col footer__cols__col--md">
        <div class="footer__cols__col__title">Community</div>
        <div class="footer__cols__col__link"><a href="/contribute/">Contribute</a></div>
        <div class="footer__cols__col__link"><a href="https://projects.apache.org/committee.html?beam" target="_blank">Team<img src="/images/external-link-icon.png"
                                                                                                                                width="14" height="14"
                                                                                                                                alt="External link."></a></div>
        <div class="footer__cols__col__link"><a href="/contribute/presentation-materials/">Media</a></div>
      </div>
      <div class="footer__cols__col footer__cols__col--md">
        <div class="footer__cols__col__title">Resources</div>
        <div class="footer__cols__col__link"><a href="/blog/">Blog</a></div>
        <div class="footer__cols__col__link"><a href="/get-started/support/">Support</a></div>
        <div class="footer__cols__col__link"><a href="https://github.com/apache/beam">GitHub</a></div>
      </div>
    </div>
  </div>
  <div class="footer__bottom">
    &copy;
    <a href="http://www.apache.org">The Apache Software Foundation</a>
    | <a href="/privacy_policy">Privacy Policy</a>
    | <a href="/feed.xml">RSS Feed</a>
    <br><br>
    Apache Beam, Apache, Beam, the Beam logo, and the Apache feather logo are
    either registered trademarks or trademarks of The Apache Software
    Foundation. All other products or name brands are trademarks of their
    respective holders, including The Apache Software Foundation.
  </div>
</footer>

  </body>
</html>
