<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Beam Programming Guide</title><meta name=description content="Apache Beam is an open source, unified model and set of language-specific SDKs for defining and executing data processing workflows, and also data ingestion and integration flows, supporting Enterprise Integration Patterns (EIPs) and Domain Specific Languages (DSLs). Dataflow pipelines simplify the mechanics of large-scale batch and streaming data processing and can run on a number of runtimes like Apache Flink, Apache Spark, and Google Cloud Dataflow (a cloud service). Beam also brings DSL in different languages, allowing users to easily implement their data integration processes."><link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400" rel=stylesheet><link rel=preload href=/scss/main.min.7bfa213b38fe814e9a5d5af502d4d2e0d4e9e7dfe8a528843e32a858c6c92bc2.css as=style><link href=/scss/main.min.7bfa213b38fe814e9a5d5af502d4d2e0d4e9e7dfe8a528843e32a858c6c92bc2.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-2.2.4.min.js></script><style>.body__contained img{max-width:100%}</style><script src=/js/bootstrap.min.js></script><script src=/js/language-switch.js></script><script src=/js/fix-menu.js></script><script src=/js/section-nav.js></script><script src=/js/page-nav.js></script><link rel=alternate type=application/rss+xml title="Apache Beam" href=/feed.xml><link rel=canonical href=/documentation/programming-guide/ data-proofer-ignore><link rel="shortcut icon" type=image/x-icon href=/images/favicon.ico><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.4.1/css/all.css integrity=sha384-5sAR7xN1Nv6T6+dT2mhtzEpVJvfS3NScPQTrOxhwjIuvcA67KV2R5Jz6kr4abQsz crossorigin=anonymous><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-73650088-1','auto');ga('send','pageview');</script></head><body class=body data-spy=scroll data-target=.page-nav data-offset=0><nav class="header navbar navbar-fixed-top"><div class=navbar-header><button type=button class=navbar-toggle aria-expanded=false aria-controls=navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a href=/ class=navbar-brand><img alt=Brand style=height:25px src=/images/beam_logo_navbar.png></a></div><div class="navbar-mask closed"></div><div id=navbar class="navbar-container closed"><ul class="nav navbar-nav"><li><a href=/get-started/beam-overview/>Get Started</a></li><li><a href=/documentation/>Documentation</a></li><li><a href=/documentation/sdks/java/>Languages</a></li><li><a href=/documentation/runners/capability-matrix/>RUNNERS</a></li><li><a href=/roadmap/>Roadmap</a></li><li><a href=/contribute/>Contribute</a></li><li><a href=/community/contact-us/>Community</a></li><li><a href=/blog/>Blog</a></li></ul><ul class="nav navbar-nav navbar-right"><li><div style=width:300px><script>(function(){var cx='012923275103528129024:4emlchv9wzi';var gcse=document.createElement('script');gcse.type='text/javascript';gcse.async=true;gcse.src='https://cse.google.com/cse.js?cx='+cx;var s=document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse,s);})();</script><gcse:search></gcse:search></div></li><li class=dropdown><a href=# class=dropdown-toggle data-toggle=dropdown role=button aria-haspopup=true aria-expanded=false><img src=https://www.apache.org/foundation/press/kit/feather_small.png alt="Apache Logo" style=height:20px><span class=caret></span></a><ul class="dropdown-menu dropdown-menu-right"><li><a href=http://www.apache.org/>ASF Homepage</a></li><li><a href=http://www.apache.org/licenses/>License</a></li><li><a href=http://www.apache.org/security/>Security</a></li><li><a href=http://www.apache.org/foundation/thanks.html>Thanks</a></li><li><a href=http://www.apache.org/foundation/sponsorship.html>Sponsorship</a></li><li><a href=https://www.apache.org/foundation/policies/conduct>Code of Conduct</a></li></ul></li><li><a href=https://github.com/apache/beam/edit/master/website/www/site/content/en/documentation/programming-guide.md data-proofer-ignore><i class="far fa-edit fa-lg" alt="Edit on GitHub" title="Edit on GitHub"></i></a></li></ul></div></nav><div class="clearfix container-main-content"><div class="section-nav closed" data-offset-top=90 data-offset-bottom=500><span class="section-nav-back glyphicon glyphicon-menu-left"></span><nav><ul class=section-nav-list data-section-nav><li><span class=section-nav-list-main-title>Documentation</span></li><li><a href=/documentation>Using the Documentation</a></li><li><span class=section-nav-list-title>Pipeline development lifecycle</span><ul class=section-nav-list><li><a href=/documentation/pipelines/design-your-pipeline/>Design Your Pipeline</a></li><li><a href=/documentation/pipelines/create-your-pipeline/>Create Your Pipeline</a></li><li><a href=/documentation/pipelines/test-your-pipeline/>Test Your Pipeline</a></li></ul></li><li><span class=section-nav-list-title>Beam programming guide</span><ul class=section-nav-list><li><a href=/documentation/programming-guide/>Overview</a></li><li><a href=/documentation/programming-guide/#creating-a-pipeline>Pipelines</a></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>PCollections</span><ul class=section-nav-list><li><a href=/documentation/programming-guide/#pcollections>Creating a PCollection</a></li><li><a href=/documentation/programming-guide/#pcollection-characteristics>PCollection characteristics</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Transforms</span><ul class=section-nav-list><li><a href=/documentation/programming-guide/#applying-transforms>Applying transforms</a></li><li><span class=section-nav-list-title>Core Beam transforms</span><ul class=section-nav-list><li><a href=/documentation/programming-guide/#pardo>ParDo</a></li><li><a href=/documentation/programming-guide/#groupbykey>GroupByKey</a></li><li><a href=/documentation/programming-guide/#cogroupbykey>CoGroupByKey</a></li><li><a href=/documentation/programming-guide/#combine>Combine</a></li><li><a href=/documentation/programming-guide/#flatten>Flatten</a></li><li><a href=/documentation/programming-guide/#partition>Partition</a></li></ul></li><li><a href=/documentation/programming-guide/#requirements-for-writing-user-code-for-beam-transforms>Requirements for user code</a></li><li><a href=/documentation/programming-guide/#side-inputs>Side inputs</a></li><li><a href=/documentation/programming-guide/#additional-outputs>Additional outputs</a></li><li><a href=/documentation/programming-guide/#composite-transforms>Composite transforms</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Pipeline I/O</span><ul class=section-nav-list><li><a href=/documentation/programming-guide/#pipeline-io>Using I/O transforms</a></li><li><a href=/documentation/io/built-in/>Built-in I/O connectors</a></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Built-in I/O connector guides</span><ul class=section-nav-list><li><a href=/documentation/io/built-in/parquet/>Apache Parquet I/O connector</a></li><li><a href=/documentation/io/built-in/hadoop/>Hadoop Input/Output Format IO</a></li><li><a href=/documentation/io/built-in/hcatalog/>HCatalog IO</a></li><li><a href=/documentation/io/built-in/google-bigquery/>Google BigQuery I/O connector</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Developing new I/O connectors</span><ul class=section-nav-list><li><a href=/documentation/io/developing-io-overview/>Overview: Developing connectors</a></li><li><a href=/documentation/io/developing-io-java/>Developing connectors (Java)</a></li><li><a href=/documentation/io/developing-io-python/>Developing connectors (Python)</a></li></ul></li><li><a href=/documentation/io/testing/>Testing I/O transforms</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Schemas</span><ul class=section-nav-list><li><a href=/documentation/programming-guide/#what-is-a-schema>What is a schema</a></li><li><a href=/documentation/programming-guide/#schemas-for-pl-types>Schemas for programming language types</a></li><li><a href=/documentation/programming-guide/#schema-definition>Schema definition</a></li><li><a href=/documentation/programming-guide/#logical-types>Logical types</a></li><li><a href=/documentation/programming-guide/#creating-schemas>Creating schemas</a></li><li><a href=/documentation/programming-guide/#using-schemas>Using schemas</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Data encoding and type safety</span><ul class=section-nav-list><li><a href=/documentation/programming-guide/#data-encoding-and-type-safety>Data encoding basics</a></li><li><a href=/documentation/programming-guide/#specifying-coders>Specifying coders</a></li><li><a href=/documentation/programming-guide/#default-coders-and-the-coderregistry>Default coders and the CoderRegistry</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Windowing</span><ul class=section-nav-list><li><a href=/documentation/programming-guide/#windowing>Windowing basics</a></li><li><a href=/documentation/programming-guide/#provided-windowing-functions>Provided windowing functions</a></li><li><a href=/documentation/programming-guide/#setting-your-pcollections-windowing-function>Setting your PCollection’s windowing function</a></li><li><a href=/documentation/programming-guide/#watermarks-and-late-data>Watermarks and late data</a></li><li><a href=/documentation/programming-guide/#adding-timestamps-to-a-pcollections-elements>Adding timestamps to a PCollection’s elements</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Triggers</span><ul class=section-nav-list><li><a href=/documentation/programming-guide/#triggers>Trigger basics</a></li><li><a href=/documentation/programming-guide/#event-time-triggers>Event time triggers and the default trigger</a></li><li><a href=/documentation/programming-guide/#processing-time-triggers>Processing time triggers</a></li><li><a href=/documentation/programming-guide/#data-driven-triggers>Data-driven triggers</a></li><li><a href=/documentation/programming-guide/#setting-a-trigger>Setting a trigger</a></li><li><a href=/documentation/programming-guide/#composite-triggers>Composite triggers</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Metrics</span><ul class=section-nav-list><li><a href=/documentation/programming-guide/#metrics>Metrics basics</a></li><li><a href=/documentation/programming-guide/#types-of-metrics>Types of metrics</a></li><li><a href=/documentation/programming-guide/#querying-metrics>Querying metrics</a></li><li><a href=/documentation/programming-guide/#using-metrics>Using metrics in pipeline</a></li><li><a href=/documentation/programming-guide/#export-metrics>Export metrics</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>State and Timers</span><ul class=section-nav-list><li><a href=/documentation/programming-guide/#types-of-state>Types of state</a></li><li><a href=/documentation/programming-guide/#deferred-state-reads>Deferred state reads</a></li><li><a href=/documentation/programming-guide/#timers>Timers</a></li><li><a href=/documentation/programming-guide/#garbage-collecting-state>Garbage collecting state</a></li><li><a href=/documentation/programming-guide/#state-timers-examples>State and timers examples</a></li></ul></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Transform catalog</span><ul class=section-nav-list><li class=section-nav-item--collapsible><span class=section-nav-list-title>Python</span><ul class=section-nav-list><li><a href=/documentation/transforms/python/overview/>Overview</a></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Element-wise</span><ul class=section-nav-list><li><a href=/documentation/transforms/python/elementwise/filter/>Filter</a></li><li><a href=/documentation/transforms/python/elementwise/flatmap/>FlatMap</a></li><li><a href=/documentation/transforms/python/elementwise/keys/>Keys</a></li><li><a href=/documentation/transforms/python/elementwise/kvswap/>KvSwap</a></li><li><a href=/documentation/transforms/python/elementwise/map/>Map</a></li><li><a href=/documentation/transforms/python/elementwise/pardo/>ParDo</a></li><li><a href=/documentation/transforms/python/elementwise/partition/>Partition</a></li><li><a href=/documentation/transforms/python/elementwise/regex/>Regex</a></li><li><a href=/documentation/transforms/python/elementwise/reify/>Reify</a></li><li><a href=/documentation/transforms/python/elementwise/tostring/>ToString</a></li><li><a href=/documentation/transforms/python/elementwise/values/>Values</a></li><li><a href=/documentation/transforms/python/elementwise/withtimestamps/>WithTimestamps</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Aggregation</span><ul class=section-nav-list><li><a href=/documentation/transforms/python/aggregation/cogroupbykey/>CoGroupByKey</a></li><li><a href=/documentation/transforms/python/aggregation/combineglobally/>CombineGlobally</a></li><li><a href=/documentation/transforms/python/aggregation/combineperkey/>CombinePerKey</a></li><li><a href=/documentation/transforms/python/aggregation/count/>Count</a></li><li><a href=/documentation/transforms/python/aggregation/distinct/>Distinct</a></li><li><a href=/documentation/transforms/python/aggregation/groupbykey/>GroupByKey</a></li><li><a href=/documentation/transforms/python/aggregation/mean/>Mean</a></li><li><a href=/documentation/transforms/python/aggregation/sample/>Sample</a></li><li><a href=/documentation/transforms/python/aggregation/top/>Top</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Other</span><ul class=section-nav-list><li><a href=/documentation/transforms/python/other/create/>Create</a></li><li><a href=/documentation/transforms/python/other/flatten/>Flatten</a></li><li><a href=/documentation/transforms/python/other/reshuffle/>Reshuffle</a></li><li><a href=/documentation/transforms/python/other/windowinto/>WindowInto</a></li></ul></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Java</span><ul class=section-nav-list><li><a href=/documentation/transforms/java/overview/>Overview</a></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Element-wise</span><ul class=section-nav-list><li><a href=/documentation/transforms/java/elementwise/filter/>Filter</a></li><li><a href=/documentation/transforms/java/elementwise/flatmapelements/>FlatMapElements</a></li><li><a href=/documentation/transforms/java/elementwise/keys/>Keys</a></li><li><a href=/documentation/transforms/java/elementwise/kvswap/>KvSwap</a></li><li><a href=/documentation/transforms/java/elementwise/mapelements/>MapElements</a></li><li><a href=/documentation/transforms/java/elementwise/pardo/>ParDo</a></li><li><a href=/documentation/transforms/java/elementwise/partition/>Partition</a></li><li><a href=/documentation/transforms/java/elementwise/regex/>Regex</a></li><li><a href=/documentation/transforms/java/elementwise/reify/>Reify</a></li><li><a href=/documentation/transforms/java/elementwise/values/>Values</a></li><li><a href=/documentation/transforms/java/elementwise/tostring/>ToString</a></li><li><a href=/documentation/transforms/java/elementwise/withkeys/>WithKeys</a></li><li><a href=/documentation/transforms/java/elementwise/withtimestamps/>WithTimestamps</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Aggregation</span><ul class=section-nav-list><li><a href=/documentation/transforms/java/aggregation/approximatequantiles/>ApproximateQuantiles</a></li><li><a href=/documentation/transforms/java/aggregation/approximateunique/>ApproximateUnique</a></li><li><a href=/documentation/transforms/java/aggregation/cogroupbykey/>CoGroupByKey</a></li><li><a href=/documentation/transforms/java/aggregation/combine/>Combine</a></li><li><a href=/documentation/transforms/java/aggregation/combinewithcontext/>CombineWithContext</a></li><li><a href=/documentation/transforms/java/aggregation/count/>Count</a></li><li><a href=/documentation/transforms/java/aggregation/distinct/>Distinct</a></li><li><a href=/documentation/transforms/java/aggregation/groupbykey/>GroupByKey</a></li><li><a href=/documentation/transforms/java/aggregation/groupintobatches/>GroupIntoBatches</a></li><li><a href=/documentation/transforms/java/aggregation/hllcount/>HllCount</a></li><li><a href=/documentation/transforms/java/aggregation/latest/>Latest</a></li><li><a href=/documentation/transforms/java/aggregation/max/>Max</a></li><li><a href=/documentation/transforms/java/aggregation/mean/>Mean</a></li><li><a href=/documentation/transforms/java/aggregation/min/>Min</a></li><li><a href=/documentation/transforms/java/aggregation/sample/>Sample</a></li><li><a href=/documentation/transforms/java/aggregation/sum/>Sum</a></li><li><a href=/documentation/transforms/java/aggregation/top/>Top</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Other</span><ul class=section-nav-list><li><a href=/documentation/transforms/java/other/create/>Create</a></li><li><a href=/documentation/transforms/java/other/flatten/>Flatten</a></li><li><a href=/documentation/transforms/java/other/passert/>PAssert</a></li><li><a href=/documentation/transforms/java/other/view/>View</a></li><li><a href=/documentation/transforms/java/other/window/>Window</a></li></ul></li></ul></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Common pipeline patterns</span><ul class=section-nav-list><li><a href=/documentation/patterns/overview/>Overview</a></li><li><a href=/documentation/patterns/file-processing/>File processing</a></li><li><a href=/documentation/patterns/side-inputs/>Side inputs</a></li><li><a href=/documentation/patterns/pipeline-options/>Pipeline options</a></li><li><a href=/documentation/patterns/custom-io/>Custom I/O</a></li><li><a href=/documentation/patterns/custom-windows/>Custom windows</a></li><li><a href=/documentation/patterns/bigqueryio/>BigQueryIO</a></li><li><a href=/documentation/patterns/ai-platform/>AI Platform</a></li><li><a href=/documentation/patterns/schema/>Schema</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Runtime systems</span><ul class=section-nav-list><li><a href=/documentation/runtime/model/>Execution model</a></li><li><a href=/documentation/runtime/environments/>Container environments</a></li><li><a href=/documentation/runtime/sdk-harness-config/>SDK Harness Configuration</a></li></ul></li><li class=section-nav-item--collapsible><span class=section-nav-list-title>Learning resources</span><ul class=section-nav-list><li><a href=/documentation/resources/learning-resources/#getting-started>Getting Started</a></li><li><a href=/documentation/resources/learning-resources/#articles>Articles</a></li><li><a href=/documentation/resources/learning-resources/#interactive-labs>Interactive Labs</a></li><li><a href=/documentation/resources/learning-resources/#beam-katas>Beam Katas</a></li><li><a href=/documentation/resources/learning-resources/#code-examples>Code Examples</a></li><li><a href=/documentation/resources/learning-resources/#api-reference>API Reference</a></li><li><a href=/documentation/resources/learning-resources/#feedback-and-suggestions>Feedback and Suggestions</a></li><li><a href=/documentation/resources/learning-resources/#how-to-contribute>How to Contribute</a></li><li><a href=/documentation/resources/videos-and-podcasts>Videos and Podcasts</a></li></ul></li><li><a href=https://cwiki.apache.org/confluence/display/BEAM/Apache+Beam>Beam Wiki</a></li></ul></nav></div><nav class="page-nav clearfix" data-offset-top=90 data-offset-bottom=500><nav id=TableOfContents><ul><li><a href=#overview>1. Overview</a></li><li><a href=#creating-a-pipeline>2. Creating a pipeline</a><ul><li><a href=#configuring-pipeline-options>2.1. Configuring pipeline options</a><ul><li><a href=#pipeline-options-cli>2.1.1. Setting PipelineOptions from command-line arguments</a></li><li><a href=#creating-custom-options>2.1.2. Creating custom options</a></li></ul></li></ul></li><li><a href=#pcollections>3. PCollections</a><ul><li><a href=#creating-a-pcollection>3.1. Creating a PCollection</a><ul><li><a href=#reading-external-source>3.1.1. Reading from an external source</a></li><li><a href=#creating-pcollection-in-memory>3.1.2. Creating a PCollection from in-memory data</a></li></ul></li><li><a href=#pcollection-characteristics>3.2. PCollection characteristics</a><ul><li><a href=#element-type>3.2.1. Element type</a></li><li><a href=#element-schema>3.2.2. Element schema</a></li><li><a href=#immutability>3.2.3. Immutability</a></li><li><a href=#random-access>3.2.4. Random access</a></li><li><a href=#size-and-boundedness>3.2.5. Size and boundedness</a></li><li><a href=#element-timestamps>3.2.6. Element timestamps</a></li></ul></li></ul></li><li><a href=#transforms>4. Transforms</a><ul><li><a href=#applying-transforms>4.1. Applying transforms</a></li><li><a href=#core-beam-transforms>4.2. Core Beam transforms</a><ul><li><a href=#pardo>4.2.1. ParDo</a></li><li><a href=#groupbykey>4.2.2. GroupByKey</a></li><li><a href=#cogroupbykey>4.2.3. CoGroupByKey</a></li><li><a href=#combine>4.2.4. Combine</a></li><li><a href=#flatten>4.2.5. Flatten</a></li><li><a href=#partition>4.2.6. Partition</a></li></ul></li><li><a href=#requirements-for-writing-user-code-for-beam-transforms>4.3. Requirements for writing user code for Beam transforms</a><ul><li><a href=#user-code-serializability>4.3.1. Serializability</a></li><li><a href=#user-code-thread-compatibility>4.3.2. Thread-compatibility</a></li><li><a href=#user-code-idempotence>4.3.3. Idempotence</a></li></ul></li><li><a href=#side-inputs>4.4. Side inputs</a><ul><li><a href=#side-inputs-pardo>4.4.1. Passing side inputs to ParDo</a></li><li><a href=#side-inputs-windowing>4.4.2. Side inputs and windowing</a></li></ul></li><li><a href=#additional-outputs>4.5. Additional outputs</a><ul><li><a href=#output-tags>4.5.1. Tags for multiple outputs</a></li><li><a href=#multiple-outputs-dofn>4.5.2. Emitting to multiple outputs in your DoFn</a></li><li><a href=#other-dofn-parameters>4.5.3. Accessing additional parameters in your DoFn</a></li></ul></li><li><a href=#composite-transforms>4.6. Composite transforms</a><ul><li><a href=#composite-transform-example>4.6.1. An example composite transform</a></li><li><a href=#composite-transform-creation>4.6.2. Creating a composite transform</a></li><li><a href=#ptransform-style-guide>4.6.3. PTransform Style Guide</a></li></ul></li></ul></li><li><a href=#pipeline-io>5. Pipeline I/O</a><ul><li><a href=#pipeline-io-reading-data>5.1. Reading input data</a></li><li><a href=#pipeline-io-writing-data>5.2. Writing output data</a></li><li><a href=#file-based-data>5.3. File-based input and output data</a><ul><li><a href=#file-based-reading-multiple-locations>5.3.1. Reading from multiple locations</a></li><li><a href=#file-based-writing-multiple-files>5.3.2. Writing to multiple output files</a></li></ul></li><li><a href=#provided-io-transforms>5.4. Beam-provided I/O transforms</a></li></ul></li><li><a href=#schemas>6. Schemas</a><ul><li><a href=#what-is-a-schema>6.1. What is a schema?</a></li><li><a href=#schemas-for-pl-types>6.2. Schemas for programming language types</a></li><li><a href=#schema-definition>6.3. Schema definition</a></li><li><a href=#logical-types>6.4. Logical types</a><ul><li><a href=#defining-a-logical-type>6.4.1. Defining a logical type</a></li><li><a href=#built-in-logical-types>6.4.2. Useful logical types</a></li></ul></li><li><a href=#creating-schemas>6.5. Creating Schemas</a><ul><li><a href=#inferring-schemas>6.5.1. Inferring schemas</a></li></ul></li><li><a href=#using-schemas>6.6. Using Schema Transforms</a><ul><li><a href=#661-field-selection-syntax>6.6.1. Field selection syntax</a></li><li><a href=#662-schema-transforms>6.6.2. Schema transforms</a></li><li><a href=#663-schemas-in-pardo>6.6.3. Schemas in ParDo</a></li></ul></li></ul></li><li><a href=#data-encoding-and-type-safety>7. Data encoding and type safety</a><ul><li><a href=#specifying-coders>7.1. Specifying coders</a></li><li><a href=#default-coders-and-the-coderregistry>7.2. Default coders and the CoderRegistry</a><ul><li><a href=#default-coder-lookup>7.2.1. Looking up a default coder</a></li><li><a href=#setting-default-coder>7.2.2. Setting the default coder for a type</a></li><li><a href=#annotating-custom-type-default-coder>7.2.3. Annotating a custom data type with a default coder</a></li></ul></li></ul></li><li><a href=#windowing>8. Windowing</a><ul><li><a href=#windowing-basics>8.1. Windowing basics</a><ul><li><a href=#windowing-constraints>8.1.1. Windowing constraints</a></li><li><a href=#windowing-bounded-collections>8.1.2. Windowing with bounded PCollections</a></li></ul></li><li><a href=#provided-windowing-functions>8.2. Provided windowing functions</a><ul><li><a href=#fixed-time-windows>8.2.1. Fixed time windows</a></li><li><a href=#sliding-time-windows>8.2.2. Sliding time windows</a></li><li><a href=#session-windows>8.2.3. Session windows</a></li><li><a href=#single-global-window>8.2.4. The single global window</a></li></ul></li><li><a href=#setting-your-pcollections-windowing-function>8.3. Setting your PCollection&rsquo;s windowing function</a><ul><li><a href=#using-fixed-time-windows>8.3.1. Fixed-time windows</a></li><li><a href=#using-sliding-time-windows>8.3.2. Sliding time windows</a></li><li><a href=#using-session-windows>8.3.3. Session windows</a></li><li><a href=#using-single-global-window>8.3.4. Single global window</a></li></ul></li><li><a href=#watermarks-and-late-data>8.4. Watermarks and late data</a><ul><li><a href=#managing-late-data>8.4.1. Managing late data</a></li></ul></li><li><a href=#adding-timestamps-to-a-pcollections-elements>8.5. Adding timestamps to a PCollection&rsquo;s elements</a></li></ul></li><li><a href=#triggers>9. Triggers</a><ul><li><a href=#event-time-triggers>9.1. Event time triggers</a><ul><li><a href=#default-trigger>9.1.1. Default trigger</a></li></ul></li><li><a href=#processing-time-triggers>9.2. Processing time triggers</a></li><li><a href=#data-driven-triggers>9.3. Data-driven triggers</a></li><li><a href=#setting-a-trigger>9.4. Setting a trigger</a><ul><li><a href=#window-accumulation-modes>9.4.1. Window accumulation modes</a></li><li><a href=#handling-late-data>9.4.2. Handling late data</a></li></ul></li><li><a href=#composite-triggers>9.5. Composite triggers</a><ul><li><a href=#composite-trigger-types>9.5.1. Composite trigger types</a></li><li><a href=#composite-afterwatermark>9.5.2. Composition with AfterWatermark</a></li><li><a href=#other-composite-triggers>9.5.3. Other composite triggers</a></li></ul></li></ul></li><li><a href=#metrics>10. Metrics</a><ul><li><a href=#101-the-main-concepts-of-beam-metrics>10.1 The main concepts of Beam metrics</a></li><li><a href=#types-of-metrics>10.2 Types of metrics</a></li><li><a href=#querying-metrics>10.3 Querying metrics</a></li><li><a href=#using-metrics>10.4 Using metrics in pipeline</a></li><li><a href=#export-metrics>10.5 Export metrics</a></li></ul></li><li><a href=#state-and-timers>11. State and Timers</a><ul><li><a href=#types-of-state>11.1 Types of state</a><ul><li><a href=#valuestate>ValueState</a></li><li><a href=#combiningstate>CombiningState</a></li><li><a href=#bagstate>BagState</a></li></ul></li><li><a href=#deferred-state-reads>11.2 Deferred state reads</a></li><li><a href=#timers>11.3 Timers</a><ul><li><a href=#event-time-timers>11.3.1 Event-time timers</a></li><li><a href=#processing-time-timers>11.3.2 Processing-time timers</a></li><li><a href=#dynamic-timer-tags>11.3.3 Dynamic timer tags</a></li><li><a href=#timer-output-timestamps>11.3.4 Timer output timestamps</a></li></ul></li><li><a href=#garbage-collecting-state>11.4 Garbage collecting state</a><ul><li></li></ul></li><li><a href=#state-timers-examples>11.5 State and timers examples</a><ul><li><a href=#joining-clicks-and-views>11.5.1. Joining clicks and views</a></li><li><a href=#batching-rpcs>11.5.2 Batching RPCs</a></li></ul></li></ul></li></ul></nav></nav><div class="body__contained body__section-nav"><h1 id=apache-beam-programming-guide>Apache Beam Programming Guide</h1><p>The <strong>Beam Programming Guide</strong> is intended for Beam users who want to use the
Beam SDKs to create data processing pipelines. It provides guidance for using
the Beam SDK classes to build and test your pipeline. It is not intended as an
exhaustive reference, but as a language-agnostic, high-level guide to
programmatically building your Beam pipeline. As the programming guide is filled
out, the text will include code samples in multiple languages to help illustrate
how to implement Beam concepts in your pipelines.</p><nav class=language-switcher><strong>Adapt for:</strong><ul><li data-type=language-java class=active>Java SDK</li><li data-type=language-py>Python SDK</li></ul></nav><p class=language-py>The Python SDK supports Python 2.7, 3.5, 3.6, and 3.7. New Python SDK releases will stop supporting Python 2.7 in 2020 (<a href=https://issues.apache.org/jira/browse/BEAM-8371>BEAM-8371</a>). For best results, use Beam with Python 3.</p><h2 id=overview>1. Overview</h2><p>To use Beam, you need to first create a driver program using the classes in one
of the Beam SDKs. Your driver program <em>defines</em> your pipeline, including all of
the inputs, transforms, and outputs; it also sets execution options for your
pipeline (typically passed in using command-line options). These include the
Pipeline Runner, which, in turn, determines what back-end your pipeline will run
on.</p><p>The Beam SDKs provide a number of abstractions that simplify the mechanics of
large-scale distributed data processing. The same Beam abstractions work with
both batch and streaming data sources. When you create your Beam pipeline, you
can think about your data processing task in terms of these abstractions. They
include:</p><ul><li><p><code>Pipeline</code>: A <code>Pipeline</code> encapsulates your entire data processing task, from
start to finish. This includes reading input data, transforming that data, and
writing output data. All Beam driver programs must create a <code>Pipeline</code>. When
you create the <code>Pipeline</code>, you must also specify the execution options that
tell the <code>Pipeline</code> where and how to run.</p></li><li><p><code>PCollection</code>: A <code>PCollection</code> represents a distributed data set that your
Beam pipeline operates on. The data set can be <em>bounded</em>, meaning it comes
from a fixed source like a file, or <em>unbounded</em>, meaning it comes from a
continuously updating source via a subscription or other mechanism. Your
pipeline typically creates an initial <code>PCollection</code> by reading data from an
external data source, but you can also create a <code>PCollection</code> from in-memory
data within your driver program. From there, <code>PCollection</code>s are the inputs and
outputs for each step in your pipeline.</p></li><li><p><code>PTransform</code>: A <code>PTransform</code> represents a data processing operation, or a step,
in your pipeline. Every <code>PTransform</code> takes one or more <code>PCollection</code> objects as
input, performs a processing function that you provide on the elements of that
<code>PCollection</code>, and produces zero or more output <code>PCollection</code> objects.</p></li><li><p>I/O transforms: Beam comes with a number of &ldquo;IOs&rdquo; - library <code>PTransform</code>s that
read or write data to various external storage systems.</p></li></ul><p>A typical Beam driver program works as follows:</p><ul><li><strong>Create</strong> a <code>Pipeline</code> object and set the pipeline execution options, including
the Pipeline Runner.</li><li>Create an initial <code>PCollection</code> for pipeline data, either using the IOs
to read data from an external storage system, or using a <code>Create</code> transform to
build a <code>PCollection</code> from in-memory data.</li><li><strong>Apply</strong> <code>PTransform</code>s to each <code>PCollection</code>. Transforms can change, filter,
group, analyze, or otherwise process the elements in a <code>PCollection</code>. A
transform creates a new output <code>PCollection</code> <em>without modifying the input
collection</em>. A typical pipeline applies subsequent transforms to each new
output <code>PCollection</code> in turn until processing is complete. However, note that
a pipeline does not have to be a single straight line of transforms applied
one after another: think of <code>PCollection</code>s as variables and <code>PTransform</code>s as
functions applied to these variables: the shape of the pipeline can be an
arbitrarily complex processing graph.</li><li>Use IOs to write the final, transformed <code>PCollection</code>(s) to an external source.</li><li><strong>Run</strong> the pipeline using the designated Pipeline Runner.</li></ul><p>When you run your Beam driver program, the Pipeline Runner that you designate
constructs a <strong>workflow graph</strong> of your pipeline based on the <code>PCollection</code>
objects you&rsquo;ve created and transforms that you&rsquo;ve applied. That graph is then
executed using the appropriate distributed processing back-end, becoming an
asynchronous &ldquo;job&rdquo; (or equivalent) on that back-end.</p><h2 id=creating-a-pipeline>2. Creating a pipeline</h2><p>The <code>Pipeline</code> abstraction encapsulates all the data and steps in your data
processing task. Your Beam driver program typically starts by constructing a
<span class=language-java><a href=https://beam.apache.org/releases/javadoc/2.22.0/index.html?org/apache/beam/sdk/Pipeline.html>Pipeline</a></span>
<span class=language-py><a href=https://github.com/apache/beam/blob/master/sdks/python/apache_beam/pipeline.py>Pipeline</a></span>
object, and then using that object as the basis for creating the pipeline&rsquo;s data
sets as <code>PCollection</code>s and its operations as <code>Transform</code>s.</p><p>To use Beam, your driver program must first create an instance of the Beam SDK
class <code>Pipeline</code> (typically in the <code>main()</code> function). When you create your
<code>Pipeline</code>, you&rsquo;ll also need to set some <strong>configuration options</strong>. You can set
your pipeline&rsquo;s configuration options programmatically, but it&rsquo;s often easier to
set the options ahead of time (or read them from the command line) and pass them
to the <code>Pipeline</code> object when you create the object.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// Start by defining the options for the pipeline.
</span><span class=c1></span><span class=n>PipelineOptions</span> <span class=n>options</span> <span class=o>=</span> <span class=n>PipelineOptionsFactory</span><span class=o>.</span><span class=na>create</span><span class=o>();</span>

<span class=c1>// Then create the pipeline.
</span><span class=c1></span><span class=n>Pipeline</span> <span class=n>p</span> <span class=o>=</span> <span class=n>Pipeline</span><span class=o>.</span><span class=na>create</span><span class=o>(</span><span class=n>options</span><span class=o>);</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=kn>import</span> <span class=nn>apache_beam</span> <span class=kn>as</span> <span class=nn>beam</span>
<span class=kn>from</span> <span class=nn>apache_beam.options.pipeline_options</span> <span class=kn>import</span> <span class=n>PipelineOptions</span>

<span class=k>with</span> <span class=n>beam</span><span class=o>.</span><span class=n>Pipeline</span><span class=p>(</span><span class=n>options</span><span class=o>=</span><span class=n>PipelineOptions</span><span class=p>())</span> <span class=k>as</span> <span class=n>p</span><span class=p>:</span>
  <span class=k>pass</span>  <span class=c1># build your pipeline here</span></code></pre></div></div><div class=language-go><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>// In order to start creating the pipeline for execution, a Pipeline object and a Scope object are needed.
</span><span class=c1></span><span class=nx>p</span><span class=p>,</span> <span class=nx>s</span> <span class=o>:=</span> <span class=nx>beam</span><span class=p>.</span><span class=nf>NewPipelineWithRoot</span><span class=p>()</span></code></pre></div></div><h3 id=configuring-pipeline-options>2.1. Configuring pipeline options</h3><p>Use the pipeline options to configure different aspects of your pipeline, such
as the pipeline runner that will execute your pipeline and any runner-specific
configuration required by the chosen runner. Your pipeline options will
potentially include information such as your project ID or a location for
storing files.</p><p>When you run the pipeline on a runner of your choice, a copy of the
PipelineOptions will be available to your code. For example, if you add a PipelineOptions parameter
to a DoFn&rsquo;s <code>@ProcessElement</code> method, it will be populated by the system.</p><h4 id=pipeline-options-cli>2.1.1. Setting PipelineOptions from command-line arguments</h4><p>While you can configure your pipeline by creating a <code>PipelineOptions</code> object and
setting the fields directly, the Beam SDKs include a command-line parser that
you can use to set fields in <code>PipelineOptions</code> using command-line arguments.</p><p>To read options from the command-line, construct your <code>PipelineOptions</code> object
as demonstrated in the following example code:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PipelineOptions</span> <span class=n>options</span> <span class=o>=</span>
    <span class=n>PipelineOptionsFactory</span><span class=o>.</span><span class=na>fromArgs</span><span class=o>(</span><span class=n>args</span><span class=o>).</span><span class=na>withValidation</span><span class=o>().</span><span class=na>create</span><span class=o>();</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=kn>import</span> <span class=nn>apache_beam</span> <span class=kn>as</span> <span class=nn>beam</span>
<span class=kn>from</span> <span class=nn>apache_beam.options.pipeline_options</span> <span class=kn>import</span> <span class=n>PipelineOptions</span>

<span class=k>with</span> <span class=n>beam</span><span class=o>.</span><span class=n>Pipeline</span><span class=p>(</span><span class=n>options</span><span class=o>=</span><span class=n>PipelineOptions</span><span class=p>())</span> <span class=k>as</span> <span class=n>p</span><span class=p>:</span>
  <span class=k>pass</span>  <span class=c1># build your pipeline here</span></code></pre></div></div><div class=language-go><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>// If beamx or Go flags are used, flags must be parsed first.
</span><span class=c1></span><span class=nx>flag</span><span class=p>.</span><span class=nf>Parse</span><span class=p>()</span></code></pre></div></div><p>This interprets command-line arguments that follow the format:</p><pre><code>--&lt;option&gt;=&lt;value&gt;
</code></pre><blockquote><p><strong>Note:</strong> Appending the method <code>.withValidation</code> will check for required
command-line arguments and validate argument values.</p></blockquote><p>Building your <code>PipelineOptions</code> this way lets you specify any of the options as
a command-line argument.</p><blockquote><p><strong>Note:</strong> The <a href=/get-started/wordcount-example>WordCount example pipeline</a>
demonstrates how to set pipeline options at runtime by using command-line
options.</p></blockquote><h4 id=creating-custom-options>2.1.2. Creating custom options</h4><p>You can add your own custom options in addition to the standard
<code>PipelineOptions</code>. To add your own options, define an interface with getter and
setter methods for each option, as in the following example for
adding <code>input</code> and <code>output</code> custom options:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>MyOptions</span> <span class=kd>extends</span> <span class=n>PipelineOptions</span> <span class=o>{</span>
    <span class=n>String</span> <span class=nf>getInput</span><span class=o>();</span>
    <span class=kt>void</span> <span class=nf>setInput</span><span class=o>(</span><span class=n>String</span> <span class=n>input</span><span class=o>);</span>
    
    <span class=n>String</span> <span class=nf>getOutput</span><span class=o>();</span>
    <span class=kt>void</span> <span class=nf>setOutput</span><span class=o>(</span><span class=n>String</span> <span class=n>output</span><span class=o>);</span>
<span class=o>}</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=kn>from</span> <span class=nn>apache_beam.options.pipeline_options</span> <span class=kn>import</span> <span class=n>PipelineOptions</span>

<span class=k>class</span> <span class=nc>MyOptions</span><span class=p>(</span><span class=n>PipelineOptions</span><span class=p>):</span>
  <span class=nd>@classmethod</span>
  <span class=k>def</span> <span class=nf>_add_argparse_args</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=n>parser</span><span class=p>):</span>
    <span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span><span class=s1>&#39;--input&#39;</span><span class=p>)</span>
    <span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span><span class=s1>&#39;--output&#39;</span><span class=p>)</span></code></pre></div></div><div class=language-go><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=p>(</span>
  <span class=nx>input</span> <span class=p>=</span> <span class=nx>flag</span><span class=p>.</span><span class=nf>String</span><span class=p>(</span><span class=s>&#34;input&#34;</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>)</span>
  <span class=nx>output</span> <span class=p>=</span> <span class=nx>flag</span><span class=p>.</span><span class=nf>String</span><span class=p>(</span><span class=s>&#34;output&#34;</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>)</span>
<span class=p>)</span></code></pre></div></div><p>You can also specify a description, which appears when a user passes <code>--help</code> as
a command-line argument, and a default value.</p><p>You set the description and default value using annotations, as follows:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>MyOptions</span> <span class=kd>extends</span> <span class=n>PipelineOptions</span> <span class=o>{</span>
    <span class=nd>@Description</span><span class=o>(</span><span class=s>&#34;Input for the pipeline&#34;</span><span class=o>)</span>
    <span class=nd>@Default.String</span><span class=o>(</span><span class=s>&#34;gs://my-bucket/input&#34;</span><span class=o>)</span>
    <span class=n>String</span> <span class=nf>getInput</span><span class=o>();</span>
    <span class=kt>void</span> <span class=nf>setInput</span><span class=o>(</span><span class=n>String</span> <span class=n>input</span><span class=o>);</span>

    <span class=nd>@Description</span><span class=o>(</span><span class=s>&#34;Output for the pipeline&#34;</span><span class=o>)</span>
    <span class=nd>@Default.String</span><span class=o>(</span><span class=s>&#34;gs://my-bucket/output&#34;</span><span class=o>)</span>
    <span class=n>String</span> <span class=nf>getOutput</span><span class=o>();</span>
    <span class=kt>void</span> <span class=nf>setOutput</span><span class=o>(</span><span class=n>String</span> <span class=n>output</span><span class=o>);</span>
<span class=o>}</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=kn>from</span> <span class=nn>apache_beam.options.pipeline_options</span> <span class=kn>import</span> <span class=n>PipelineOptions</span>

<span class=k>class</span> <span class=nc>MyOptions</span><span class=p>(</span><span class=n>PipelineOptions</span><span class=p>):</span>
  <span class=nd>@classmethod</span>
  <span class=k>def</span> <span class=nf>_add_argparse_args</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=n>parser</span><span class=p>):</span>
    <span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span>
        <span class=s1>&#39;--input&#39;</span><span class=p>,</span>
        <span class=n>help</span><span class=o>=</span><span class=s1>&#39;Input for the pipeline&#39;</span><span class=p>,</span>
        <span class=n>default</span><span class=o>=</span><span class=s1>&#39;gs://my-bucket/input&#39;</span><span class=p>)</span>
    <span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span>
        <span class=s1>&#39;--output&#39;</span><span class=p>,</span>
        <span class=n>help</span><span class=o>=</span><span class=s1>&#39;Output for the pipeline&#39;</span><span class=p>,</span>
        <span class=n>default</span><span class=o>=</span><span class=s1>&#39;gs://my-bucket/output&#39;</span><span class=p>)</span></code></pre></div></div><div class=language-go><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=p>(</span>
  <span class=nx>input</span> <span class=p>=</span> <span class=nx>flag</span><span class=p>.</span><span class=nf>String</span><span class=p>(</span><span class=s>&#34;input&#34;</span><span class=p>,</span> <span class=s>&#34;gs://my-bucket/input&#34;</span><span class=p>,</span> <span class=s>&#34;Input for the pipeline&#34;</span><span class=p>)</span>
  <span class=nx>output</span> <span class=p>=</span> <span class=nx>flag</span><span class=p>.</span><span class=nf>String</span><span class=p>(</span><span class=s>&#34;output&#34;</span><span class=p>,</span> <span class=s>&#34;gs://my-bucket/output&#34;</span><span class=p>,</span> <span class=s>&#34;Output for the pipeline&#34;</span><span class=p>)</span>
<span class=p>)</span></code></pre></div></div><p class=language-java>It&rsquo;s recommended that you register your interface with <code>PipelineOptionsFactory</code>
and then pass the interface when creating the <code>PipelineOptions</code> object. When you
register your interface with <code>PipelineOptionsFactory</code>, the <code>--help</code> can find
your custom options interface and add it to the output of the <code>--help</code> command.
<code>PipelineOptionsFactory</code> will also validate that your custom options are
compatible with all other registered options.</p><p class=language-java>The following example code shows how to register your custom options interface
with <code>PipelineOptionsFactory</code>:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PipelineOptionsFactory</span><span class=o>.</span><span class=na>register</span><span class=o>(</span><span class=n>MyOptions</span><span class=o>.</span><span class=na>class</span><span class=o>);</span>
<span class=n>MyOptions</span> <span class=n>options</span> <span class=o>=</span> <span class=n>PipelineOptionsFactory</span><span class=o>.</span><span class=na>fromArgs</span><span class=o>(</span><span class=n>args</span><span class=o>)</span>
                                                <span class=o>.</span><span class=na>withValidation</span><span class=o>()</span>
                                                <span class=o>.</span><span class=na>as</span><span class=o>(</span><span class=n>MyOptions</span><span class=o>.</span><span class=na>class</span><span class=o>);</span></code></pre></div></div><p>Now your pipeline can accept <code>--input=value</code> and <code>--output=value</code> as command-line arguments.</p><h2 id=pcollections>3. PCollections</h2><p>The <span class=language-java><a href=https://beam.apache.org/releases/javadoc/2.22.0/index.html?org/apache/beam/sdk/values/PCollection.html>PCollection</a></span>
<span class=language-py><code>PCollection</code></span> abstraction represents a
potentially distributed, multi-element data set. You can think of a
<code>PCollection</code> as &ldquo;pipeline&rdquo; data; Beam transforms use <code>PCollection</code> objects as
inputs and outputs. As such, if you want to work with data in your pipeline, it
must be in the form of a <code>PCollection</code>.</p><p>After you&rsquo;ve created your <code>Pipeline</code>, you&rsquo;ll need to begin by creating at least
one <code>PCollection</code> in some form. The <code>PCollection</code> you create serves as the input
for the first operation in your pipeline.</p><h3 id=creating-a-pcollection>3.1. Creating a PCollection</h3><p>You create a <code>PCollection</code> by either reading data from an external source using
Beam&rsquo;s <a href=#pipeline-io>Source API</a>, or you can create a <code>PCollection</code> of data
stored in an in-memory collection class in your driver program. The former is
typically how a production pipeline would ingest data; Beam&rsquo;s Source APIs
contain adapters to help you read from external sources like large cloud-based
files, databases, or subscription services. The latter is primarily useful for
testing and debugging purposes.</p><h4 id=reading-external-source>3.1.1. Reading from an external source</h4><p>To read from an external source, you use one of the <a href=#pipeline-io>Beam-provided I/O
adapters</a>. The adapters vary in their exact usage, but all of them
read from some external data source and return a <code>PCollection</code> whose elements
represent the data records in that source.</p><p>Each data source adapter has a <code>Read</code> transform; to read, you must apply that
transform to the <code>Pipeline</code> object itself.
<span class=language-java><code>TextIO.Read</code></span>
<span class=language-py><code>io.TextFileSource</code></span>, for example, reads from an
external text file and returns a <code>PCollection</code> whose elements are of type
<code>String</code>, each <code>String</code> represents one line from the text file. Here&rsquo;s how you
would apply <span class=language-java><code>TextIO.Read</code></span>
<span class=language-py><code>io.TextFileSource</code></span> to your <code>Pipeline</code> to create
a <code>PCollection</code>:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// Create the pipeline.
</span><span class=c1></span>    <span class=n>PipelineOptions</span> <span class=n>options</span> <span class=o>=</span>
        <span class=n>PipelineOptionsFactory</span><span class=o>.</span><span class=na>fromArgs</span><span class=o>(</span><span class=n>args</span><span class=o>).</span><span class=na>create</span><span class=o>();</span>
    <span class=n>Pipeline</span> <span class=n>p</span> <span class=o>=</span> <span class=n>Pipeline</span><span class=o>.</span><span class=na>create</span><span class=o>(</span><span class=n>options</span><span class=o>);</span>

    <span class=c1>// Create the PCollection &#39;lines&#39; by applying a &#39;Read&#39; transform.
</span><span class=c1></span>    <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>lines</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
      <span class=s>&#34;ReadMyFile&#34;</span><span class=o>,</span> <span class=n>TextIO</span><span class=o>.</span><span class=na>read</span><span class=o>().</span><span class=na>from</span><span class=o>(</span><span class=s>&#34;gs://some/inputData.txt&#34;</span><span class=o>));</span>
<span class=o>}</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>lines</span> <span class=o>=</span> <span class=n>p</span> <span class=o>|</span> <span class=s1>&#39;ReadMyFile&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>ReadFromText</span><span class=p>(</span>
    <span class=s1>&#39;gs://some/inputData.txt&#39;</span><span class=p>)</span></code></pre></div></div><div class=language-go><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=nx>lines</span> <span class=o>:=</span> <span class=nx>textio</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=s>&#34;gs://some/inputData.txt&#34;</span><span class=p>)</span></code></pre></div></div><p>See the <a href=#pipeline-io>section on I/O</a> to learn more about how to read from the
various data sources supported by the Beam SDK.</p><h4 id=creating-pcollection-in-memory>3.1.2. Creating a PCollection from in-memory data</h4><p class=language-java>To create a <code>PCollection</code> from an in-memory Java <code>Collection</code>, you use the
Beam-provided <code>Create</code> transform. Much like a data adapter&rsquo;s <code>Read</code>, you apply
<code>Create</code> directly to your <code>Pipeline</code> object itself.</p><p class=language-java>As parameters, <code>Create</code> accepts the Java <code>Collection</code> and a <code>Coder</code> object. The
<code>Coder</code> specifies how the elements in the <code>Collection</code> should be
<a href=#element-type>encoded</a>.</p><p class=language-py>To create a <code>PCollection</code> from an in-memory <code>list</code>, you use the Beam-provided
<code>Create</code> transform. Apply this transform directly to your <code>Pipeline</code> object
itself.</p><p>The following example code shows how to create a <code>PCollection</code> from an in-memory
<span class=language-java><code>List</code></span><span class=language-py><code>list</code></span>:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// Create a Java Collection, in this case a List of Strings.
</span><span class=c1></span>    <span class=kd>final</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>LINES</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span>
      <span class=s>&#34;To be, or not to be: that is the question: &#34;</span><span class=o>,</span>
      <span class=s>&#34;Whether &#39;tis nobler in the mind to suffer &#34;</span><span class=o>,</span>
      <span class=s>&#34;The slings and arrows of outrageous fortune, &#34;</span><span class=o>,</span>
      <span class=s>&#34;Or to take arms against a sea of troubles, &#34;</span><span class=o>);</span>

    <span class=c1>// Create the pipeline.
</span><span class=c1></span>    <span class=n>PipelineOptions</span> <span class=n>options</span> <span class=o>=</span>
        <span class=n>PipelineOptionsFactory</span><span class=o>.</span><span class=na>fromArgs</span><span class=o>(</span><span class=n>args</span><span class=o>).</span><span class=na>create</span><span class=o>();</span>
    <span class=n>Pipeline</span> <span class=n>p</span> <span class=o>=</span> <span class=n>Pipeline</span><span class=o>.</span><span class=na>create</span><span class=o>(</span><span class=n>options</span><span class=o>);</span>

    <span class=c1>// Apply Create, passing the list and the coder, to create the PCollection.
</span><span class=c1></span>    <span class=n>p</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Create</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>LINES</span><span class=o>)).</span><span class=na>setCoder</span><span class=o>(</span><span class=n>StringUtf8Coder</span><span class=o>.</span><span class=na>of</span><span class=o>());</span>
<span class=o>}</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=kn>import</span> <span class=nn>apache_beam</span> <span class=kn>as</span> <span class=nn>beam</span>
<span class=kn>from</span> <span class=nn>apache_beam.options.pipeline_options</span> <span class=kn>import</span> <span class=n>PipelineOptions</span>

<span class=c1># argv = None  # if None, uses sys.argv</span>
<span class=n>pipeline_options</span> <span class=o>=</span> <span class=n>PipelineOptions</span><span class=p>(</span><span class=n>argv</span><span class=p>)</span>
<span class=k>with</span> <span class=n>beam</span><span class=o>.</span><span class=n>Pipeline</span><span class=p>(</span><span class=n>options</span><span class=o>=</span><span class=n>pipeline_options</span><span class=p>)</span> <span class=k>as</span> <span class=n>pipeline</span><span class=p>:</span>
  <span class=n>lines</span> <span class=o>=</span> <span class=p>(</span>
      <span class=n>pipeline</span>
      <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>Create</span><span class=p>([</span>
          <span class=s1>&#39;To be, or not to be: that is the question: &#39;</span><span class=p>,</span>
          <span class=s2>&#34;Whether &#39;tis nobler in the mind to suffer &#34;</span><span class=p>,</span>
          <span class=s1>&#39;The slings and arrows of outrageous fortune, &#39;</span><span class=p>,</span>
          <span class=s1>&#39;Or to take arms against a sea of troubles, &#39;</span><span class=p>,</span>
      <span class=p>]))</span></code></pre></div></div><h3 id=pcollection-characteristics>3.2. PCollection characteristics</h3><p>A <code>PCollection</code> is owned by the specific <code>Pipeline</code> object for which it is
created; multiple pipelines cannot share a <code>PCollection</code>. <span language=java>In some respects, a <code>PCollection</code> functions like a <code>Collection</code> class. However,
a <code>PCollection</code> can differ in a few key ways:</span></p><h4 id=element-type>3.2.1. Element type</h4><p>The elements of a <code>PCollection</code> may be of any type, but must all be of the same
type. However, to support distributed processing, Beam needs to be able to
encode each individual element as a byte string (so elements can be passed
around to distributed workers). The Beam SDKs provide a data encoding mechanism
that includes built-in encoding for commonly-used types as well as support for
specifying custom encodings as needed.</p><h4 id=element-schema>3.2.2. Element schema</h4><p>In many cases, the element type in a <code>PCollection</code> has a structure that can introspected.
Examples are JSON, Protocol Buffer, Avro, and database records. Schemas provide a way to
express types as a set of named fields, allowing for more-expressive aggregations.</p><h4 id=immutability>3.2.3. Immutability</h4><p>A <code>PCollection</code> is immutable. Once created, you cannot add, remove, or change
individual elements. A Beam Transform might process each element of a
<code>PCollection</code> and generate new pipeline data (as a new <code>PCollection</code>), <em>but it
does not consume or modify the original input collection</em>.</p><h4 id=random-access>3.2.4. Random access</h4><p>A <code>PCollection</code> does not support random access to individual elements. Instead,
Beam Transforms consider every element in a <code>PCollection</code> individually.</p><h4 id=size-and-boundedness>3.2.5. Size and boundedness</h4><p>A <code>PCollection</code> is a large, immutable &ldquo;bag&rdquo; of elements. There is no upper limit
on how many elements a <code>PCollection</code> can contain; any given <code>PCollection</code> might
fit in memory on a single machine, or it might represent a very large
distributed data set backed by a persistent data store.</p><p>A <code>PCollection</code> can be either <strong>bounded</strong> or <strong>unbounded</strong> in size. A
<strong>bounded</strong> <code>PCollection</code> represents a data set of a known, fixed size, while an
<strong>unbounded</strong> <code>PCollection</code> represents a data set of unlimited size. Whether a
<code>PCollection</code> is bounded or unbounded depends on the source of the data set that
it represents. Reading from a batch data source, such as a file or a database,
creates a bounded <code>PCollection</code>. Reading from a streaming or
continuously-updating data source, such as Pub/Sub or Kafka, creates an unbounded
<code>PCollection</code> (unless you explicitly tell it not to).</p><p>The bounded (or unbounded) nature of your <code>PCollection</code> affects how Beam
processes your data. A bounded <code>PCollection</code> can be processed using a batch job,
which might read the entire data set once, and perform processing in a job of
finite length. An unbounded <code>PCollection</code> must be processed using a streaming
job that runs continuously, as the entire collection can never be available for
processing at any one time.</p><p>Beam uses <a href=#windowing>windowing</a> to divide a continuously updating unbounded
<code>PCollection</code> into logical windows of finite size. These logical windows are
determined by some characteristic associated with a data element, such as a
<strong>timestamp</strong>. Aggregation transforms (such as <code>GroupByKey</code> and <code>Combine</code>) work
on a per-window basis — as the data set is generated, they process each
<code>PCollection</code> as a succession of these finite windows.</p><h4 id=element-timestamps>3.2.6. Element timestamps</h4><p>Each element in a <code>PCollection</code> has an associated intrinsic <strong>timestamp</strong>. The
timestamp for each element is initially assigned by the <a href=#pipeline-io>Source</a>
that creates the <code>PCollection</code>. Sources that create an unbounded <code>PCollection</code>
often assign each new element a timestamp that corresponds to when the element
was read or added.</p><blockquote><p><strong>Note</strong>: Sources that create a bounded <code>PCollection</code> for a fixed data set
also automatically assign timestamps, but the most common behavior is to
assign every element the same timestamp (<code>Long.MIN_VALUE</code>).</p></blockquote><p>Timestamps are useful for a <code>PCollection</code> that contains elements with an
inherent notion of time. If your pipeline is reading a stream of events, like
Tweets or other social media messages, each element might use the time the event
was posted as the element timestamp.</p><p>You can manually assign timestamps to the elements of a <code>PCollection</code> if the
source doesn&rsquo;t do it for you. You&rsquo;ll want to do this if the elements have an
inherent timestamp, but the timestamp is somewhere in the structure of the
element itself (such as a &ldquo;time&rdquo; field in a server log entry). Beam has
<a href=#transforms>Transforms</a> that take a <code>PCollection</code> as input and output an
identical <code>PCollection</code> with timestamps attached; see <a href=#adding-timestamps-to-a-pcollections-elements>Adding
Timestamps</a> for more information
about how to do so.</p><h2 id=transforms>4. Transforms</h2><p>Transforms are the operations in your pipeline, and provide a generic
processing framework. You provide processing logic in the form of a function
object (colloquially referred to as &ldquo;user code&rdquo;), and your user code is applied
to each element of an input <code>PCollection</code> (or more than one <code>PCollection</code>).
Depending on the pipeline runner and back-end that you choose, many different
workers across a cluster may execute instances of your user code in parallel.
The user code running on each worker generates the output elements that are
ultimately added to the final output <code>PCollection</code> that the transform produces.</p><p>The Beam SDKs contain a number of different transforms that you can apply to
your pipeline&rsquo;s <code>PCollection</code>s. These include general-purpose core transforms,
such as <a href=#pardo>ParDo</a> or <a href=#combine>Combine</a>. There are also pre-written
<a href=#composite-transforms>composite transforms</a> included in the SDKs, which
combine one or more of the core transforms in a useful processing pattern, such
as counting or combining elements in a collection. You can also define your own
more complex composite transforms to fit your pipeline&rsquo;s exact use case.</p><h3 id=applying-transforms>4.1. Applying transforms</h3><p>To invoke a transform, you must <strong>apply</strong> it to the input <code>PCollection</code>. Each
transform in the Beam SDKs has a generic <code>apply</code> method <span class=language-py>(or pipe operator <code>|</code>)</span>.
Invoking multiple Beam transforms is similar to <em>method chaining</em>, but with one
slight difference: You apply the transform to the input <code>PCollection</code>, passing
the transform itself as an argument, and the operation returns the output
<code>PCollection</code>. This takes the general form:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=o>[</span><span class=n>Output</span> <span class=n>PCollection</span><span class=o>]</span> <span class=o>=</span> <span class=o>[</span><span class=n>Input</span> <span class=n>PCollection</span><span class=o>].</span><span class=na>apply</span><span class=o>([</span><span class=n>Transform</span><span class=o>])</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=p>[</span><span class=n>Output</span> <span class=n>PCollection</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=n>Input</span> <span class=n>PCollection</span><span class=p>]</span> <span class=o>|</span> <span class=p>[</span><span class=n>Transform</span><span class=p>]</span></code></pre></div></div><p>Because Beam uses a generic <code>apply</code> method for <code>PCollection</code>, you can both chain
transforms sequentially and also apply transforms that contain other transforms
nested within (called <a href=#composite-transforms>composite transforms</a> in the Beam
SDKs).</p><p>How you apply your pipeline&rsquo;s transforms determines the structure of your
pipeline. The best way to think of your pipeline is as a directed acyclic graph,
where <code>PTransform</code> nodes are subroutines that accept <code>PCollection</code> nodes as
inputs and emit <code>PCollection</code> nodes as outputs. For example, you can chain
together transforms to create a pipeline that successively modifies input data:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=o>[</span><span class=n>Final</span> <span class=n>Output</span> <span class=n>PCollection</span><span class=o>]</span> <span class=o>=</span> <span class=o>[</span><span class=n>Initial</span> <span class=n>Input</span> <span class=n>PCollection</span><span class=o>].</span><span class=na>apply</span><span class=o>([</span><span class=n>First</span> <span class=n>Transform</span><span class=o>])</span>
<span class=o>.</span><span class=na>apply</span><span class=o>([</span><span class=n>Second</span> <span class=n>Transform</span><span class=o>])</span>
<span class=o>.</span><span class=na>apply</span><span class=o>([</span><span class=n>Third</span> <span class=n>Transform</span><span class=o>])</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=p>[</span><span class=n>Final</span> <span class=n>Output</span> <span class=n>PCollection</span><span class=p>]</span> <span class=o>=</span> <span class=p>([</span><span class=n>Initial</span> <span class=n>Input</span> <span class=n>PCollection</span><span class=p>]</span> <span class=o>|</span> <span class=p>[</span><span class=n>First</span> <span class=n>Transform</span><span class=p>]</span>
              <span class=o>|</span> <span class=p>[</span><span class=n>Second</span> <span class=n>Transform</span><span class=p>]</span>
              <span class=o>|</span> <span class=p>[</span><span class=n>Third</span> <span class=n>Transform</span><span class=p>])</span></code></pre></div></div><p>The graph of this pipeline looks like the following:</p><p><img src=/images/design-your-pipeline-linear.svg alt="This linear pipeline starts with one input collection, sequentially appliesthree transforms, and ends with one output collection."></p><p><em>Figure 1: A linear pipeline with three sequential transforms.</em></p><p>However, note that a transform <em>does not consume or otherwise alter</em> the input
collection — remember that a <code>PCollection</code> is immutable by definition. This means
that you can apply multiple transforms to the same input <code>PCollection</code> to create
a branching pipeline, like so:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=o>[</span><span class=n>PCollection</span> <span class=n>of</span> <span class=n>database</span> <span class=n>table</span> <span class=n>rows</span><span class=o>]</span> <span class=o>=</span> <span class=o>[</span><span class=n>Database</span> <span class=n>Table</span> <span class=n>Reader</span><span class=o>].</span><span class=na>apply</span><span class=o>([</span><span class=n>Read</span> <span class=n>Transform</span><span class=o>])</span>
<span class=o>[</span><span class=n>PCollection</span> <span class=n>of</span> <span class=sc>&#39;A&#39;</span> <span class=n>names</span><span class=o>]</span> <span class=o>=</span> <span class=o>[</span><span class=n>PCollection</span> <span class=n>of</span> <span class=n>database</span> <span class=n>table</span> <span class=n>rows</span><span class=o>].</span><span class=na>apply</span><span class=o>([</span><span class=n>Transform</span> <span class=n>A</span><span class=o>])</span>
<span class=o>[</span><span class=n>PCollection</span> <span class=n>of</span> <span class=sc>&#39;B&#39;</span> <span class=n>names</span><span class=o>]</span> <span class=o>=</span> <span class=o>[</span><span class=n>PCollection</span> <span class=n>of</span> <span class=n>database</span> <span class=n>table</span> <span class=n>rows</span><span class=o>].</span><span class=na>apply</span><span class=o>([</span><span class=n>Transform</span> <span class=n>B</span><span class=o>])</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=p>[</span><span class=n>PCollection</span> <span class=n>of</span> <span class=n>database</span> <span class=n>table</span> <span class=n>rows</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=n>Database</span> <span class=n>Table</span> <span class=n>Reader</span><span class=p>]</span> <span class=o>|</span> <span class=p>[</span><span class=n>Read</span> <span class=n>Transform</span><span class=p>]</span>
<span class=p>[</span><span class=n>PCollection</span> <span class=n>of</span> <span class=s1>&#39;A&#39;</span> <span class=n>names</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=n>PCollection</span> <span class=n>of</span> <span class=n>database</span> <span class=n>table</span> <span class=n>rows</span><span class=p>]</span> <span class=o>|</span> <span class=p>[</span><span class=n>Transform</span> <span class=n>A</span><span class=p>]</span>
<span class=p>[</span><span class=n>PCollection</span> <span class=n>of</span> <span class=s1>&#39;B&#39;</span> <span class=n>names</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=n>PCollection</span> <span class=n>of</span> <span class=n>database</span> <span class=n>table</span> <span class=n>rows</span><span class=p>]</span> <span class=o>|</span> <span class=p>[</span><span class=n>Transform</span> <span class=n>B</span><span class=p>]</span></code></pre></div></div><p>The graph of this branching pipeline looks like the following:</p><p><img src=/images/design-your-pipeline-multiple-pcollections.svg alt="This pipeline applies two transforms to a single input collection. Eachtransform produces an output collection."></p><p><em>Figure 2: A branching pipeline. Two transforms are applied to a single
PCollection of database table rows.</em></p><p>You can also build your own <a href=#composite-transforms>composite transforms</a> that
nest multiple transforms inside a single, larger transform. Composite transforms
are particularly useful for building a reusable sequence of simple steps that
get used in a lot of different places.</p><h3 id=core-beam-transforms>4.2. Core Beam transforms</h3><p>Beam provides the following core transforms, each of which represents a different
processing paradigm:</p><ul><li><code>ParDo</code></li><li><code>GroupByKey</code></li><li><code>CoGroupByKey</code></li><li><code>Combine</code></li><li><code>Flatten</code></li><li><code>Partition</code></li></ul><h4 id=pardo>4.2.1. ParDo</h4><p><code>ParDo</code> is a Beam transform for generic parallel processing. The <code>ParDo</code>
processing paradigm is similar to the &ldquo;Map&rdquo; phase of a
<a href=https://en.wikipedia.org/wiki/MapReduce>Map/Shuffle/Reduce</a>-style
algorithm: a <code>ParDo</code> transform considers each element in the input
<code>PCollection</code>, performs some processing function (your user code) on that
element, and emits zero, one, or multiple elements to an output <code>PCollection</code>.</p><p><code>ParDo</code> is useful for a variety of common data processing operations, including:</p><ul><li><strong>Filtering a data set.</strong> You can use <code>ParDo</code> to consider each element in a
<code>PCollection</code> and either output that element to a new collection or discard
it.</li><li><strong>Formatting or type-converting each element in a data set.</strong> If your input
<code>PCollection</code> contains elements that are of a different type or format than
you want, you can use <code>ParDo</code> to perform a conversion on each element and
output the result to a new <code>PCollection</code>.</li><li><strong>Extracting parts of each element in a data set.</strong> If you have a
<code>PCollection</code> of records with multiple fields, for example, you can use a
<code>ParDo</code> to parse out just the fields you want to consider into a new
<code>PCollection</code>.</li><li><strong>Performing computations on each element in a data set.</strong> You can use <code>ParDo</code>
to perform simple or complex computations on every element, or certain
elements, of a <code>PCollection</code> and output the results as a new <code>PCollection</code>.</li></ul><p>In such roles, <code>ParDo</code> is a common intermediate step in a pipeline. You might
use it to extract certain fields from a set of raw input records, or convert raw
input into a different format; you might also use <code>ParDo</code> to convert processed
data into a format suitable for output, like database table rows or printable
strings.</p><p>When you apply a <code>ParDo</code> transform, you&rsquo;ll need to provide user code in the form
of a <code>DoFn</code> object. <code>DoFn</code> is a Beam SDK class that defines a distributed
processing function.</p><blockquote><p>When you create a subclass of <code>DoFn</code>, note that your subclass should adhere to
the <a href=#requirements-for-writing-user-code-for-beam-transforms>Requirements for writing user code for Beam transforms</a>.</p></blockquote><h5 id=applying-pardo>4.2.1.1. Applying ParDo</h5><p>Like all Beam transforms, you apply <code>ParDo</code> by calling the <code>apply</code> method on the
input <code>PCollection</code> and passing <code>ParDo</code> as an argument, as shown in the
following example code:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// The input PCollection of Strings.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>words</span> <span class=o>=</span> <span class=o>...;</span>

<span class=c1>// The DoFn to perform on each element in the input PCollection.
</span><span class=c1></span><span class=kd>static</span> <span class=kd>class</span> <span class=nc>ComputeWordLengthFn</span> <span class=kd>extends</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span> <span class=o>...</span> <span class=o>}</span>

<span class=c1>// Apply a ParDo to the PCollection &#34;words&#34; to compute lengths for each word.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>wordLengths</span> <span class=o>=</span> <span class=n>words</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
    <span class=n>ParDo</span>
    <span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>ComputeWordLengthFn</span><span class=o>()));</span>        <span class=c1>// The DoFn to perform on each element, which
</span><span class=c1></span>                                            <span class=o>//</span> <span class=n>we</span> <span class=n>define</span> <span class=n>above</span><span class=o>.</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># The input PCollection of Strings.</span>
<span class=n>words</span> <span class=o>=</span> <span class=o>...</span>

<span class=c1># The DoFn to perform on each element in the input PCollection.</span>

<span class=k>class</span> <span class=nc>ComputeWordLengthFn</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=p>):</span>
  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>element</span><span class=p>):</span>
    <span class=k>return</span> <span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>element</span><span class=p>)]</span>



<span class=c1># Apply a ParDo to the PCollection &#34;words&#34; to compute lengths for each word.</span>
<span class=n>word_lengths</span> <span class=o>=</span> <span class=n>words</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span><span class=n>ComputeWordLengthFn</span><span class=p>())</span></code></pre></div></div><div class=language-go><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>// words is the input PCollection of strings
</span><span class=c1></span><span class=kd>var</span> <span class=nx>words</span> <span class=nx>beam</span><span class=p>.</span><span class=nx>PCollection</span> <span class=p>=</span> <span class=o>...</span>

<span class=kd>func</span> <span class=nf>computeWordLengthFn</span><span class=p>(</span><span class=nx>word</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
      <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>word</span><span class=p>)</span>
<span class=p>}</span>

<span class=nx>wordLengths</span> <span class=o>:=</span> <span class=nx>beam</span><span class=p>.</span><span class=nf>ParDo</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>computeWordLengthFn</span><span class=p>,</span> <span class=nx>words</span><span class=p>)</span></code></pre></div></div><p>In the example, our input <code>PCollection</code> contains <code>String</code> values. We apply a
<code>ParDo</code> transform that specifies a function (<code>ComputeWordLengthFn</code>) to compute
the length of each string, and outputs the result to a new <code>PCollection</code> of
<code>Integer</code> values that stores the length of each word.</p><h5 id=4212-creating-a-dofn>4.2.1.2. Creating a DoFn</h5><p>The <code>DoFn</code> object that you pass to <code>ParDo</code> contains the processing logic that
gets applied to the elements in the input collection. When you use Beam, often
the most important pieces of code you&rsquo;ll write are these <code>DoFn</code>s - they&rsquo;re what
define your pipeline&rsquo;s exact data processing tasks.</p><blockquote><p><strong>Note:</strong> When you create your <code>DoFn</code>, be mindful of the <a href=#requirements-for-writing-user-code-for-beam-transforms>Requirements
for writing user code for Beam transforms</a>
and ensure that your code follows them.</p></blockquote><p class=language-java>A <code>DoFn</code> processes one element at a time from the input <code>PCollection</code>. When you
create a subclass of <code>DoFn</code>, you&rsquo;ll need to provide type parameters that match
the types of the input and output elements. If your <code>DoFn</code> processes incoming
<code>String</code> elements and produces <code>Integer</code> elements for the output collection
(like our previous example, <code>ComputeWordLengthFn</code>), your class declaration would
look like this:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>static</span> <span class=kd>class</span> <span class=nc>ComputeWordLengthFn</span> <span class=kd>extends</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span> <span class=o>...</span> <span class=o>}</span></code></pre></div></div><p class=language-java>Inside your <code>DoFn</code> subclass, you&rsquo;ll write a method annotated with
<code>@ProcessElement</code> where you provide the actual processing logic. You don&rsquo;t need
to manually extract the elements from the input collection; the Beam SDKs handle
that for you. Your <code>@ProcessElement</code> method should accept a parameter tagged with
<code>@Element</code>, which will be populated with the input element. In order to output
elements, the method can also take a parameter of type <code>OutputReceiver</code> which
provides a method for emitting elements. The parameter types must match the input
and output types of your <code>DoFn</code> or the framework will raise an error. Note: <code>@Element</code> and
<code>OutputReceiver</code> were introduced in Beam 2.5.0; if using an earlier release of Beam, a
<code>ProcessContext</code> parameter should be used instead.</p><p class=language-py>Inside your <code>DoFn</code> subclass, you&rsquo;ll write a method <code>process</code> where you provide
the actual processing logic. You don&rsquo;t need to manually extract the elements
from the input collection; the Beam SDKs handle that for you. Your <code>process</code> method
should accept an argument <code>element</code>, which is the input element, and return an
iterable with its output values. You can accomplish this by emitting individual
elements with <code>yield</code> statements. You can also use a <code>return</code> statement
with an iterable, like a list or a generator.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>static</span> <span class=kd>class</span> <span class=nc>ComputeWordLengthFn</span> <span class=kd>extends</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>
  <span class=nd>@ProcessElement</span>
  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>String</span> <span class=n>word</span><span class=o>,</span> <span class=n>OutputReceiver</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>out</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// Use OutputReceiver.output to emit the output element.
</span><span class=c1></span>    <span class=n>out</span><span class=o>.</span><span class=na>output</span><span class=o>(</span><span class=n>word</span><span class=o>.</span><span class=na>length</span><span class=o>());</span>
  <span class=o>}</span>
<span class=o>}</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=k>class</span> <span class=nc>ComputeWordLengthFn</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=p>):</span>
  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>element</span><span class=p>):</span>
    <span class=k>return</span> <span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>element</span><span class=p>)]</span></code></pre></div></div><p class=language-java><blockquote><p><strong>Note:</strong> If the elements in your input <code>PCollection</code> are key/value pairs, you
can access the key or value by using <code>element.getKey()</code> or
<code>element.getValue()</code>, respectively.</p></blockquote></p><p>A given <code>DoFn</code> instance generally gets invoked one or more times to process some
arbitrary bundle of elements. However, Beam doesn&rsquo;t guarantee an exact number of
invocations; it may be invoked multiple times on a given worker node to account
for failures and retries. As such, you can cache information across multiple
calls to your processing method, but if you do so, make sure the implementation
<strong>does not depend on the number of invocations</strong>.</p><p>In your processing method, you&rsquo;ll also need to meet some immutability
requirements to ensure that Beam and the processing back-end can safely
serialize and cache the values in your pipeline. Your method should meet the
following requirements:</p><p class=language-java><ul><li>You should not in any way modify an element returned by
the <code>@Element</code> annotation or <code>ProcessContext.sideInput()</code> (the incoming
elements from the input collection).</li><li>Once you output a value using <code>OutputReceiver.output()</code> you should not modify
that value in any way.</li></ul></p><p class=language-python><ul><li>You should not in any way modify the <code>element</code> argument provided to the
<code>process</code> method, or any side inputs.</li><li>Once you output a value using <code>yield</code> or <code>return</code>, you should not modify
that value in any way.</li></ul></p><h5 id=lightweight-dofns>4.2.1.3. Lightweight DoFns and other abstractions</h5><p>If your function is relatively straightforward, you can simplify your use of
<code>ParDo</code> by providing a lightweight <code>DoFn</code> in-line, as
<span class=language-java>an anonymous inner class instance</span>
<span class=language-py>a lambda function</span>.</p><p>Here&rsquo;s the previous example, <code>ParDo</code> with <code>ComputeLengthWordsFn</code>, with the
<code>DoFn</code> specified as
<span class=language-java>an anonymous inner class instance</span>
<span class=language-py>a lambda function</span>:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// The input PCollection.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>words</span> <span class=o>=</span> <span class=o>...;</span>

<span class=c1>// Apply a ParDo with an anonymous DoFn to the PCollection words.
</span><span class=c1>// Save the result as the PCollection wordLengths.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>wordLengths</span> <span class=o>=</span> <span class=n>words</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
  <span class=s>&#34;ComputeWordLengths&#34;</span><span class=o>,</span>                     <span class=c1>// the transform name
</span><span class=c1></span>  <span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;()</span> <span class=o>{</span>    <span class=c1>// a DoFn as an anonymous inner class instance
</span><span class=c1></span>      <span class=nd>@ProcessElement</span>
      <span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>String</span> <span class=n>word</span><span class=o>,</span> <span class=n>OutputReceiver</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>out</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>out</span><span class=o>.</span><span class=na>output</span><span class=o>(</span><span class=n>word</span><span class=o>.</span><span class=na>length</span><span class=o>());</span>
      <span class=o>}</span>
    <span class=o>}));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># The input PCollection of strings.</span>
<span class=n>words</span> <span class=o>=</span> <span class=o>...</span>

<span class=c1># Apply a lambda function to the PCollection words.</span>
<span class=c1># Save the result as the PCollection word_lengths.</span>

<span class=n>word_lengths</span> <span class=o>=</span> <span class=n>words</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>FlatMap</span><span class=p>(</span><span class=k>lambda</span> <span class=n>word</span><span class=p>:</span> <span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>word</span><span class=p>)])</span></code></pre></div></div><div class=language-go><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>// words is the input PCollection of strings
</span><span class=c1></span><span class=kd>var</span> <span class=nx>words</span> <span class=nx>beam</span><span class=p>.</span><span class=nx>PCollection</span> <span class=p>=</span> <span class=o>...</span>

<span class=nx>lengths</span> <span class=o>:=</span> <span class=nx>beam</span><span class=p>.</span><span class=nf>ParDo</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=kd>func</span> <span class=p>(</span><span class=nx>word</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
      <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>word</span><span class=p>)</span>
<span class=p>},</span> <span class=nx>words</span><span class=p>)</span></code></pre></div></div><p>If your <code>ParDo</code> performs a one-to-one mapping of input elements to output
elements&ndash;that is, for each input element, it applies a function that produces
<em>exactly one</em> output element, you can use the higher-level
<span class=language-java><code>MapElements</code></span><span class=language-py><code>Map</code></span>
transform. <span class=language-java><code>MapElements</code> can accept an anonymous
Java 8 lambda function for additional brevity.</span></p><p>Here&rsquo;s the previous example using <span class=language-java><code>MapElements</code></span>
<span class=language-py><code>Map</code></span>:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// The input PCollection.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>words</span> <span class=o>=</span> <span class=o>...;</span>

<span class=c1>// Apply a MapElements with an anonymous lambda function to the PCollection words.
</span><span class=c1>// Save the result as the PCollection wordLengths.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>wordLengths</span> <span class=o>=</span> <span class=n>words</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
  <span class=n>MapElements</span><span class=o>.</span><span class=na>into</span><span class=o>(</span><span class=n>TypeDescriptors</span><span class=o>.</span><span class=na>integers</span><span class=o>())</span>
             <span class=o>.</span><span class=na>via</span><span class=o>((</span><span class=n>String</span> <span class=n>word</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>word</span><span class=o>.</span><span class=na>length</span><span class=o>()));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># The input PCollection of string.</span>
<span class=n>words</span> <span class=o>=</span> <span class=o>...</span>

<span class=c1># Apply a Map with a lambda function to the PCollection words.</span>
<span class=c1># Save the result as the PCollection word_lengths.</span>

<span class=n>word_lengths</span> <span class=o>=</span> <span class=n>words</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>Map</span><span class=p>(</span><span class=nb>len</span><span class=p>)</span></code></pre></div></div><p class=language-java><blockquote><p><strong>Note:</strong> You can use Java 8 lambda functions with several other Beam
transforms, including <code>Filter</code>, <code>FlatMapElements</code>, and <code>Partition</code>.</p></blockquote></p><h5 id=dofn>4.2.1.4. DoFn lifecycle</h5><p>Here is a sequence diagram that shows the lifecycle of the DoFn during
the execution of the ParDo transform. The comments give useful
information to pipeline developers such as the constraints that
apply to the objects or particular cases such as failover or
instance reuse. They also give instantiation use cases.</p><p><img src=/images/dofn-sequence-diagram.svg alt="This is a sequence diagram that shows the lifecycle of the DoFn"></p><h4 id=groupbykey>4.2.2. GroupByKey</h4><p><code>GroupByKey</code> is a Beam transform for processing collections of key/value pairs.
It&rsquo;s a parallel reduction operation, analogous to the Shuffle phase of a
Map/Shuffle/Reduce-style algorithm. The input to <code>GroupByKey</code> is a collection of
key/value pairs that represents a <em>multimap</em>, where the collection contains
multiple pairs that have the same key, but different values. Given such a
collection, you use <code>GroupByKey</code> to collect all of the values associated with
each unique key.</p><p><code>GroupByKey</code> is a good way to aggregate data that has something in common. For
example, if you have a collection that stores records of customer orders, you
might want to group together all the orders from the same postal code (wherein
the &ldquo;key&rdquo; of the key/value pair is the postal code field, and the &ldquo;value&rdquo; is the
remainder of the record).</p><p>Let&rsquo;s examine the mechanics of <code>GroupByKey</code> with a simple example case, where
our data set consists of words from a text file and the line number on which
they appear. We want to group together all the line numbers (values) that share
the same word (key), letting us see all the places in the text where a
particular word appears.</p><p>Our input is a <code>PCollection</code> of key/value pairs where each word is a key, and
the value is a line number in the file where the word appears. Here&rsquo;s a list of
the key/value pairs in the input collection:</p><pre><code>cat, 1
dog, 5
and, 1
jump, 3
tree, 2
cat, 5
dog, 2
and, 2
cat, 9
and, 6
...
</code></pre><p><code>GroupByKey</code> gathers up all the values with the same key and outputs a new pair
consisting of the unique key and a collection of all of the values that were
associated with that key in the input collection. If we apply <code>GroupByKey</code> to
our input collection above, the output collection would look like this:</p><pre><code>cat, [1,5,9]
dog, [5,2]
and, [1,2,6]
jump, [3]
tree, [2]
...
</code></pre><p>Thus, <code>GroupByKey</code> represents a transform from a multimap (multiple keys to
individual values) to a uni-map (unique keys to collections of values).</p><h5 id=groupbykey-and-unbounded-pcollections>4.2.2.1 GroupByKey and unbounded PCollections</h5><p>If you are using unbounded <code>PCollection</code>s, you must use either <a href=#setting-your-pcollections-windowing-function>non-global
windowing</a> or an
<a href=#triggers>aggregation trigger</a> in order to perform a <code>GroupByKey</code> or
<a href=#cogroupbykey>CoGroupByKey</a>. This is because a bounded <code>GroupByKey</code> or
<code>CoGroupByKey</code> must wait for all the data with a certain key to be collected,
but with unbounded collections, the data is unlimited. Windowing and/or triggers
allow grouping to operate on logical, finite bundles of data within the
unbounded data streams.</p><p>If you do apply <code>GroupByKey</code> or <code>CoGroupByKey</code> to a group of unbounded
<code>PCollection</code>s without setting either a non-global windowing strategy, a trigger
strategy, or both for each collection, Beam generates an IllegalStateException
error at pipeline construction time.</p><p>When using <code>GroupByKey</code> or <code>CoGroupByKey</code> to group <code>PCollection</code>s that have a
<a href=#windowing>windowing strategy</a> applied, all of the <code>PCollection</code>s you want to
group <em>must use the same windowing strategy</em> and window sizing. For example, all
of the collections you are merging must use (hypothetically) identical 5-minute
fixed windows, or 4-minute sliding windows starting every 30 seconds.</p><p>If your pipeline attempts to use <code>GroupByKey</code> or <code>CoGroupByKey</code> to merge
<code>PCollection</code>s with incompatible windows, Beam generates an
IllegalStateException error at pipeline construction time.</p><h4 id=cogroupbykey>4.2.3. CoGroupByKey</h4><p><code>CoGroupByKey</code> performs a relational join of two or more key/value
<code>PCollection</code>s that have the same key type.
<a href=/documentation/pipelines/design-your-pipeline/#multiple-sources>Design Your Pipeline</a>
shows an example pipeline that uses a join.</p><p>Consider using <code>CoGroupByKey</code> if you have multiple data sets that provide
information about related things. For example, let&rsquo;s say you have two different
files with user data: one file has names and email addresses; the other file
has names and phone numbers. You can join those two data sets, using the user
name as a common key and the other data as the associated values. After the
join, you have one data set that contains all of the information (email
addresses and phone numbers) associated with each name.</p><p>If you are using unbounded <code>PCollection</code>s, you must use either <a href=#setting-your-pcollections-windowing-function>non-global
windowing</a> or an
<a href=#triggers>aggregation trigger</a> in order to perform a <code>CoGroupByKey</code>. See
<a href=#groupbykey-and-unbounded-pcollections>GroupByKey and unbounded PCollections</a>
for more details.</p><span class=language-java>In the Beam SDK for Java, `CoGroupByKey` accepts a tuple of keyed
`PCollection`s (`PCollection<kv<k, v>>`) as input. For type safety, the SDK
requires you to pass each `PCollection` as part of a `KeyedPCollectionTuple`.
You must declare a `TupleTag` for each input `PCollection` in the
`KeyedPCollectionTuple` that you want to pass to `CoGroupByKey`. As output,
`CoGroupByKey` returns a `PCollection<kv<k, cogbkresult>>`, which groups values
from all the input `PCollection`s by their common keys. Each key (all of type
`K`) will have a different `CoGbkResult`, which is a map from `TupleTag<t>` to
`Iterable<t>`. You can access a specific collection in an `CoGbkResult` object
by using the `TupleTag` that you supplied with the initial collection.</span>
<span class=language-py>In the Beam SDK for Python, `CoGroupByKey` accepts a dictionary of keyed
`PCollection`s as input. As output, `CoGroupByKey` creates a single output
`PCollection` that contains one key/value tuple for each key in the input
`PCollection`s. Each key's value is a dictionary that maps each tag to an
iterable of the values under they key in the corresponding `PCollection`.</span><p>The following conceptual examples use two input collections to show the mechanics of
<code>CoGroupByKey</code>.</p><span class=language-java>The first set of data has a `TupleTag<string>` called `emailsTag` and contains names
and email addresses. The second set of data has a `TupleTag<string>` called
`phonesTag` and contains names and phone numbers.</span>
<span class=language-py>The first set of data contains names and email addresses. The second set of
data contains names and phone numbers.</span><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>final</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;&gt;</span> <span class=n>emailsList</span> <span class=o>=</span>
    <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span>
        <span class=n>KV</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;amy&#34;</span><span class=o>,</span> <span class=s>&#34;amy@example.com&#34;</span><span class=o>),</span>
        <span class=n>KV</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;carl&#34;</span><span class=o>,</span> <span class=s>&#34;carl@example.com&#34;</span><span class=o>),</span>
        <span class=n>KV</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;julia&#34;</span><span class=o>,</span> <span class=s>&#34;julia@example.com&#34;</span><span class=o>),</span>
        <span class=n>KV</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;carl&#34;</span><span class=o>,</span> <span class=s>&#34;carl@email.com&#34;</span><span class=o>));</span>

<span class=kd>final</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;&gt;</span> <span class=n>phonesList</span> <span class=o>=</span>
    <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span>
        <span class=n>KV</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;amy&#34;</span><span class=o>,</span> <span class=s>&#34;111-222-3333&#34;</span><span class=o>),</span>
        <span class=n>KV</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;james&#34;</span><span class=o>,</span> <span class=s>&#34;222-333-4444&#34;</span><span class=o>),</span>
        <span class=n>KV</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;amy&#34;</span><span class=o>,</span> <span class=s>&#34;333-444-5555&#34;</span><span class=o>),</span>
        <span class=n>KV</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;carl&#34;</span><span class=o>,</span> <span class=s>&#34;444-555-6666&#34;</span><span class=o>));</span>

<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;&gt;</span> <span class=n>emails</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=s>&#34;CreateEmails&#34;</span><span class=o>,</span> <span class=n>Create</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>emailsList</span><span class=o>));</span>
<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;&gt;</span> <span class=n>phones</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=s>&#34;CreatePhones&#34;</span><span class=o>,</span> <span class=n>Create</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>phonesList</span><span class=o>));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>emails_list</span> <span class=o>=</span> <span class=p>[</span>
    <span class=p>(</span><span class=s1>&#39;amy&#39;</span><span class=p>,</span> <span class=s1>&#39;amy@example.com&#39;</span><span class=p>),</span>
    <span class=p>(</span><span class=s1>&#39;carl&#39;</span><span class=p>,</span> <span class=s1>&#39;carl@example.com&#39;</span><span class=p>),</span>
    <span class=p>(</span><span class=s1>&#39;julia&#39;</span><span class=p>,</span> <span class=s1>&#39;julia@example.com&#39;</span><span class=p>),</span>
    <span class=p>(</span><span class=s1>&#39;carl&#39;</span><span class=p>,</span> <span class=s1>&#39;carl@email.com&#39;</span><span class=p>),</span>
<span class=p>]</span>
<span class=n>phones_list</span> <span class=o>=</span> <span class=p>[</span>
    <span class=p>(</span><span class=s1>&#39;amy&#39;</span><span class=p>,</span> <span class=s1>&#39;111-222-3333&#39;</span><span class=p>),</span>
    <span class=p>(</span><span class=s1>&#39;james&#39;</span><span class=p>,</span> <span class=s1>&#39;222-333-4444&#39;</span><span class=p>),</span>
    <span class=p>(</span><span class=s1>&#39;amy&#39;</span><span class=p>,</span> <span class=s1>&#39;333-444-5555&#39;</span><span class=p>),</span>
    <span class=p>(</span><span class=s1>&#39;carl&#39;</span><span class=p>,</span> <span class=s1>&#39;444-555-6666&#39;</span><span class=p>),</span>
<span class=p>]</span>

<span class=n>emails</span> <span class=o>=</span> <span class=n>p</span> <span class=o>|</span> <span class=s1>&#39;CreateEmails&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>Create</span><span class=p>(</span><span class=n>emails_list</span><span class=p>)</span>
<span class=n>phones</span> <span class=o>=</span> <span class=n>p</span> <span class=o>|</span> <span class=s1>&#39;CreatePhones&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>Create</span><span class=p>(</span><span class=n>phones_list</span><span class=p>)</span></code></pre></div></div><p>After <code>CoGroupByKey</code>, the resulting data contains all data associated with each
unique key from any of the input collections.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>final</span> <span class=n>TupleTag</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>emailsTag</span> <span class=o>=</span> <span class=k>new</span> <span class=n>TupleTag</span><span class=o>&lt;&gt;();</span>
<span class=kd>final</span> <span class=n>TupleTag</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>phonesTag</span> <span class=o>=</span> <span class=k>new</span> <span class=n>TupleTag</span><span class=o>&lt;&gt;();</span>

<span class=kd>final</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>CoGbkResult</span><span class=o>&gt;&gt;</span> <span class=n>expectedResults</span> <span class=o>=</span>
    <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span>
        <span class=n>KV</span><span class=o>.</span><span class=na>of</span><span class=o>(</span>
            <span class=s>&#34;amy&#34;</span><span class=o>,</span>
            <span class=n>CoGbkResult</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>emailsTag</span><span class=o>,</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=s>&#34;amy@example.com&#34;</span><span class=o>))</span>
                <span class=o>.</span><span class=na>and</span><span class=o>(</span><span class=n>phonesTag</span><span class=o>,</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=s>&#34;111-222-3333&#34;</span><span class=o>,</span> <span class=s>&#34;333-444-5555&#34;</span><span class=o>))),</span>
        <span class=n>KV</span><span class=o>.</span><span class=na>of</span><span class=o>(</span>
            <span class=s>&#34;carl&#34;</span><span class=o>,</span>
            <span class=n>CoGbkResult</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>emailsTag</span><span class=o>,</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=s>&#34;carl@email.com&#34;</span><span class=o>,</span> <span class=s>&#34;carl@example.com&#34;</span><span class=o>))</span>
                <span class=o>.</span><span class=na>and</span><span class=o>(</span><span class=n>phonesTag</span><span class=o>,</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=s>&#34;444-555-6666&#34;</span><span class=o>))),</span>
        <span class=n>KV</span><span class=o>.</span><span class=na>of</span><span class=o>(</span>
            <span class=s>&#34;james&#34;</span><span class=o>,</span>
            <span class=n>CoGbkResult</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>emailsTag</span><span class=o>,</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>())</span>
                <span class=o>.</span><span class=na>and</span><span class=o>(</span><span class=n>phonesTag</span><span class=o>,</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=s>&#34;222-333-4444&#34;</span><span class=o>))),</span>
        <span class=n>KV</span><span class=o>.</span><span class=na>of</span><span class=o>(</span>
            <span class=s>&#34;julia&#34;</span><span class=o>,</span>
            <span class=n>CoGbkResult</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>emailsTag</span><span class=o>,</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=s>&#34;julia@example.com&#34;</span><span class=o>))</span>
                <span class=o>.</span><span class=na>and</span><span class=o>(</span><span class=n>phonesTag</span><span class=o>,</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>())));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>results</span> <span class=o>=</span> <span class=p>[</span>
    <span class=p>(</span>
        <span class=s1>&#39;amy&#39;</span><span class=p>,</span>
        <span class=p>{</span>
            <span class=s1>&#39;emails&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;amy@example.com&#39;</span><span class=p>],</span>
            <span class=s1>&#39;phones&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;111-222-3333&#39;</span><span class=p>,</span> <span class=s1>&#39;333-444-5555&#39;</span><span class=p>]</span>
        <span class=p>}),</span>
    <span class=p>(</span>
        <span class=s1>&#39;carl&#39;</span><span class=p>,</span>
        <span class=p>{</span>
            <span class=s1>&#39;emails&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;carl@email.com&#39;</span><span class=p>,</span> <span class=s1>&#39;carl@example.com&#39;</span><span class=p>],</span>
            <span class=s1>&#39;phones&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;444-555-6666&#39;</span><span class=p>]</span>
        <span class=p>}),</span>
    <span class=p>(</span><span class=s1>&#39;james&#39;</span><span class=p>,</span> <span class=p>{</span>
        <span class=s1>&#39;emails&#39;</span><span class=p>:</span> <span class=p>[],</span> <span class=s1>&#39;phones&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;222-333-4444&#39;</span><span class=p>]</span>
    <span class=p>}),</span>
    <span class=p>(</span><span class=s1>&#39;julia&#39;</span><span class=p>,</span> <span class=p>{</span>
        <span class=s1>&#39;emails&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;julia@example.com&#39;</span><span class=p>],</span> <span class=s1>&#39;phones&#39;</span><span class=p>:</span> <span class=p>[]</span>
    <span class=p>}),</span>
<span class=p>]</span></code></pre></div></div><p>The following code example joins the two <code>PCollection</code>s with <code>CoGroupByKey</code>,
followed by a <code>ParDo</code> to consume the result. Then, the code uses tags to look up
and format data from each collection.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>CoGbkResult</span><span class=o>&gt;&gt;</span> <span class=n>results</span> <span class=o>=</span>
    <span class=n>KeyedPCollectionTuple</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>emailsTag</span><span class=o>,</span> <span class=n>emails</span><span class=o>)</span>
        <span class=o>.</span><span class=na>and</span><span class=o>(</span><span class=n>phonesTag</span><span class=o>,</span> <span class=n>phones</span><span class=o>)</span>
        <span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>CoGroupByKey</span><span class=o>.</span><span class=na>create</span><span class=o>());</span>

<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>contactLines</span> <span class=o>=</span>
    <span class=n>results</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
        <span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span>
            <span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>CoGbkResult</span><span class=o>&gt;,</span> <span class=n>String</span><span class=o>&gt;()</span> <span class=o>{</span>
              <span class=nd>@ProcessElement</span>
              <span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=n>ProcessContext</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
                <span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>CoGbkResult</span><span class=o>&gt;</span> <span class=n>e</span> <span class=o>=</span> <span class=n>c</span><span class=o>.</span><span class=na>element</span><span class=o>();</span>
                <span class=n>String</span> <span class=n>name</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>getKey</span><span class=o>();</span>
                <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>emailsIter</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>getValue</span><span class=o>().</span><span class=na>getAll</span><span class=o>(</span><span class=n>emailsTag</span><span class=o>);</span>
                <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>phonesIter</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>getValue</span><span class=o>().</span><span class=na>getAll</span><span class=o>(</span><span class=n>phonesTag</span><span class=o>);</span>
                <span class=n>String</span> <span class=n>formattedResult</span> <span class=o>=</span>
                    <span class=n>Snippets</span><span class=o>.</span><span class=na>formatCoGbkResults</span><span class=o>(</span><span class=n>name</span><span class=o>,</span> <span class=n>emailsIter</span><span class=o>,</span> <span class=n>phonesIter</span><span class=o>);</span>
                <span class=n>c</span><span class=o>.</span><span class=na>output</span><span class=o>(</span><span class=n>formattedResult</span><span class=o>);</span>
              <span class=o>}</span>
            <span class=o>}));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># The result PCollection contains one key-value element for each key in the</span>
<span class=c1># input PCollections. The key of the pair will be the key from the input and</span>
<span class=c1># the value will be a dictionary with two entries: &#39;emails&#39; - an iterable of</span>
<span class=c1># all values for the current key in the emails PCollection and &#39;phones&#39;: an</span>
<span class=c1># iterable of all values for the current key in the phones PCollection.</span>
<span class=n>results</span> <span class=o>=</span> <span class=p>({</span><span class=s1>&#39;emails&#39;</span><span class=p>:</span> <span class=n>emails</span><span class=p>,</span> <span class=s1>&#39;phones&#39;</span><span class=p>:</span> <span class=n>phones</span><span class=p>}</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>CoGroupByKey</span><span class=p>())</span>

<span class=k>def</span> <span class=nf>join_info</span><span class=p>(</span><span class=n>name_info</span><span class=p>):</span>
  <span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>info</span><span class=p>)</span> <span class=o>=</span> <span class=n>name_info</span>
  <span class=k>return</span> <span class=s1>&#39;</span><span class=si>%s</span><span class=s1>; </span><span class=si>%s</span><span class=s1>; </span><span class=si>%s</span><span class=s1>&#39;</span> <span class=o>%</span>\
      <span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>info</span><span class=p>[</span><span class=s1>&#39;emails&#39;</span><span class=p>]),</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>info</span><span class=p>[</span><span class=s1>&#39;phones&#39;</span><span class=p>]))</span>

<span class=n>contact_lines</span> <span class=o>=</span> <span class=n>results</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>Map</span><span class=p>(</span><span class=n>join_info</span><span class=p>)</span></code></pre></div></div><p>The formatted data looks like this:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>final</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>formattedResults</span> <span class=o>=</span>
    <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span>
        <span class=s>&#34;amy; [&#39;amy@example.com&#39;]; [&#39;111-222-3333&#39;, &#39;333-444-5555&#39;]&#34;</span><span class=o>,</span>
        <span class=s>&#34;carl; [&#39;carl@email.com&#39;, &#39;carl@example.com&#39;]; [&#39;444-555-6666&#39;]&#34;</span><span class=o>,</span>
        <span class=s>&#34;james; []; [&#39;222-333-4444&#39;]&#34;</span><span class=o>,</span>
        <span class=s>&#34;julia; [&#39;julia@example.com&#39;]; []&#34;</span><span class=o>);</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>formatted_results</span> <span class=o>=</span> <span class=p>[</span>
    <span class=s2>&#34;amy; [&#39;amy@example.com&#39;]; [&#39;111-222-3333&#39;, &#39;333-444-5555&#39;]&#34;</span><span class=p>,</span>
    <span class=s2>&#34;carl; [&#39;carl@email.com&#39;, &#39;carl@example.com&#39;]; [&#39;444-555-6666&#39;]&#34;</span><span class=p>,</span>
    <span class=s2>&#34;james; []; [&#39;222-333-4444&#39;]&#34;</span><span class=p>,</span>
    <span class=s2>&#34;julia; [&#39;julia@example.com&#39;]; []&#34;</span><span class=p>,</span>
<span class=p>]</span></code></pre></div></div><h4 id=combine>4.2.4. Combine</h4><p><span class=language-java><a href=https://beam.apache.org/releases/javadoc/2.22.0/index.html?org/apache/beam/sdk/transforms/Combine.html><code>Combine</code></a></span>
<span class=language-py><a href=https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/core.py><code>Combine</code></a></span>
is a Beam transform for combining collections of elements or values in your
data. <code>Combine</code> has variants that work on entire <code>PCollection</code>s, and some that
combine the values for each key in <code>PCollection</code>s of key/value pairs.</p><p>When you apply a <code>Combine</code> transform, you must provide the function that
contains the logic for combining the elements or values. The combining function
should be commutative and associative, as the function is not necessarily
invoked exactly once on all values with a given key. Because the input data
(including the value collection) may be distributed across multiple workers, the
combining function might be called multiple times to perform partial combining
on subsets of the value collection. The Beam SDK also provides some pre-built
combine functions for common numeric combination operations such as sum, min,
and max.</p><p>Simple combine operations, such as sums, can usually be implemented as a simple
function. More complex combination operations might require you to create a
subclass of <code>CombineFn</code> that has an accumulation type distinct from the
input/output type.</p><h5 id=simple-combines>4.2.4.1. Simple combinations using simple functions</h5><p>The following example code shows a simple combine function.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// Sum a collection of Integer values. The function SumInts implements the interface SerializableFunction.
</span><span class=c1></span><span class=kd>public</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>SumInts</span> <span class=kd>implements</span> <span class=n>SerializableFunction</span><span class=o>&lt;</span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>
  <span class=nd>@Override</span>
  <span class=kd>public</span> <span class=n>Integer</span> <span class=nf>apply</span><span class=o>(</span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>input</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>item</span> <span class=o>:</span> <span class=n>input</span><span class=o>)</span> <span class=o>{</span>
      <span class=n>sum</span> <span class=o>+=</span> <span class=n>item</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>sum</span><span class=o>;</span>
  <span class=o>}</span>
<span class=o>}</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>pc</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>1000</span><span class=p>]</span>

<span class=k>def</span> <span class=nf>bounded_sum</span><span class=p>(</span><span class=n>values</span><span class=p>,</span> <span class=n>bound</span><span class=o>=</span><span class=mi>500</span><span class=p>):</span>
  <span class=k>return</span> <span class=nb>min</span><span class=p>(</span><span class=nb>sum</span><span class=p>(</span><span class=n>values</span><span class=p>),</span> <span class=n>bound</span><span class=p>)</span>

<span class=n>small_sum</span> <span class=o>=</span> <span class=n>pc</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>CombineGlobally</span><span class=p>(</span><span class=n>bounded_sum</span><span class=p>)</span>  <span class=c1># [500]</span>
<span class=n>large_sum</span> <span class=o>=</span> <span class=n>pc</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>CombineGlobally</span><span class=p>(</span><span class=n>bounded_sum</span><span class=p>,</span> <span class=n>bound</span><span class=o>=</span><span class=mi>5000</span><span class=p>)</span>  <span class=c1># [1111]</span></code></pre></div></div><h5 id=advanced-combines>4.2.4.2. Advanced combinations using CombineFn</h5><p>For more complex combine functions, you can define a subclass of <code>CombineFn</code>.
You should use <code>CombineFn</code> if the combine function requires a more sophisticated
accumulator, must perform additional pre- or post-processing, might change the
output type, or takes the key into account.</p><p>A general combining operation consists of four operations. When you create a
subclass of <code>CombineFn</code>, you must provide four operations by overriding the
corresponding methods:</p><ol><li><p><strong>Create Accumulator</strong> creates a new &ldquo;local&rdquo; accumulator. In the example
case, taking a mean average, a local accumulator tracks the running sum of
values (the numerator value for our final average division) and the number of
values summed so far (the denominator value). It may be called any number of
times in a distributed fashion.</p></li><li><p><strong>Add Input</strong> adds an input element to an accumulator, returning the
accumulator value. In our example, it would update the sum and increment the
count. It may also be invoked in parallel.</p></li><li><p><strong>Merge Accumulators</strong> merges several accumulators into a single accumulator;
this is how data in multiple accumulators is combined before the final
calculation. In the case of the mean average computation, the accumulators
representing each portion of the division are merged together. It may be
called again on its outputs any number of times.</p></li><li><p><strong>Extract Output</strong> performs the final computation. In the case of computing a
mean average, this means dividing the combined sum of all the values by the
number of values summed. It is called once on the final, merged accumulator.</p></li></ol><p>The following example code shows how to define a <code>CombineFn</code> that computes a
mean average:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>AverageFn</span> <span class=kd>extends</span> <span class=n>CombineFn</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>AverageFn</span><span class=o>.</span><span class=na>Accum</span><span class=o>,</span> <span class=n>Double</span><span class=o>&gt;</span> <span class=o>{</span>
  <span class=kd>public</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Accum</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
  <span class=o>}</span>

  <span class=nd>@Override</span>
  <span class=kd>public</span> <span class=n>Accum</span> <span class=nf>createAccumulator</span><span class=o>()</span> <span class=o>{</span> <span class=k>return</span> <span class=k>new</span> <span class=n>Accum</span><span class=o>();</span> <span class=o>}</span>

  <span class=nd>@Override</span>
  <span class=kd>public</span> <span class=n>Accum</span> <span class=nf>addInput</span><span class=o>(</span><span class=n>Accum</span> <span class=n>accum</span><span class=o>,</span> <span class=n>Integer</span> <span class=n>input</span><span class=o>)</span> <span class=o>{</span>
      <span class=n>accum</span><span class=o>.</span><span class=na>sum</span> <span class=o>+=</span> <span class=n>input</span><span class=o>;</span>
      <span class=n>accum</span><span class=o>.</span><span class=na>count</span><span class=o>++;</span>
      <span class=k>return</span> <span class=n>accum</span><span class=o>;</span>
  <span class=o>}</span>

  <span class=nd>@Override</span>
  <span class=kd>public</span> <span class=n>Accum</span> <span class=nf>mergeAccumulators</span><span class=o>(</span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Accum</span><span class=o>&gt;</span> <span class=n>accums</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>Accum</span> <span class=n>merged</span> <span class=o>=</span> <span class=n>createAccumulator</span><span class=o>();</span>
    <span class=k>for</span> <span class=o>(</span><span class=n>Accum</span> <span class=n>accum</span> <span class=o>:</span> <span class=n>accums</span><span class=o>)</span> <span class=o>{</span>
      <span class=n>merged</span><span class=o>.</span><span class=na>sum</span> <span class=o>+=</span> <span class=n>accum</span><span class=o>.</span><span class=na>sum</span><span class=o>;</span>
      <span class=n>merged</span><span class=o>.</span><span class=na>count</span> <span class=o>+=</span> <span class=n>accum</span><span class=o>.</span><span class=na>count</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>merged</span><span class=o>;</span>
  <span class=o>}</span>

  <span class=nd>@Override</span>
  <span class=kd>public</span> <span class=n>Double</span> <span class=nf>extractOutput</span><span class=o>(</span><span class=n>Accum</span> <span class=n>accum</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>return</span> <span class=o>((</span><span class=kt>double</span><span class=o>)</span> <span class=n>accum</span><span class=o>.</span><span class=na>sum</span><span class=o>)</span> <span class=o>/</span> <span class=n>accum</span><span class=o>.</span><span class=na>count</span><span class=o>;</span>
  <span class=o>}</span>
<span class=o>}</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>pc</span> <span class=o>=</span> <span class=o>...</span>

<span class=k>class</span> <span class=nc>AverageFn</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>CombineFn</span><span class=p>):</span>
  <span class=k>def</span> <span class=nf>create_accumulator</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
    <span class=k>return</span> <span class=p>(</span><span class=mf>0.0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>

  <span class=k>def</span> <span class=nf>add_input</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>sum_count</span><span class=p>,</span> <span class=nb>input</span><span class=p>):</span>
    <span class=p>(</span><span class=nb>sum</span><span class=p>,</span> <span class=n>count</span><span class=p>)</span> <span class=o>=</span> <span class=n>sum_count</span>
    <span class=k>return</span> <span class=nb>sum</span> <span class=o>+</span> <span class=nb>input</span><span class=p>,</span> <span class=n>count</span> <span class=o>+</span> <span class=mi>1</span>

  <span class=k>def</span> <span class=nf>merge_accumulators</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>accumulators</span><span class=p>):</span>
    <span class=n>sums</span><span class=p>,</span> <span class=n>counts</span> <span class=o>=</span> <span class=nb>zip</span><span class=p>(</span><span class=o>*</span><span class=n>accumulators</span><span class=p>)</span>
    <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>sums</span><span class=p>),</span> <span class=nb>sum</span><span class=p>(</span><span class=n>counts</span><span class=p>)</span>

  <span class=k>def</span> <span class=nf>extract_output</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>sum_count</span><span class=p>):</span>
    <span class=p>(</span><span class=nb>sum</span><span class=p>,</span> <span class=n>count</span><span class=p>)</span> <span class=o>=</span> <span class=n>sum_count</span>
    <span class=k>return</span> <span class=nb>sum</span> <span class=o>/</span> <span class=n>count</span> <span class=k>if</span> <span class=n>count</span> <span class=k>else</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;NaN&#39;</span><span class=p>)</span></code></pre></div></div><h5 id=combining-pcollection>4.2.4.3. Combining a PCollection into a single value</h5><p>Use the global combine to transform all of the elements in a given <code>PCollection</code>
into a single value, represented in your pipeline as a new <code>PCollection</code>
containing one element. The following example code shows how to apply the Beam
provided sum combine function to produce a single sum value for a <code>PCollection</code>
of integers.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// Sum.SumIntegerFn() combines the elements in the input PCollection. The resulting PCollection, called sum,
</span><span class=c1>// contains one value: the sum of all the elements in the input PCollection.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>pc</span> <span class=o>=</span> <span class=o>...;</span>
<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>pc</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
   <span class=n>Combine</span><span class=o>.</span><span class=na>globally</span><span class=o>(</span><span class=k>new</span> <span class=n>Sum</span><span class=o>.</span><span class=na>SumIntegerFn</span><span class=o>()));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># sum combines the elements in the input PCollection.</span>
<span class=c1># The resulting PCollection, called result, contains one value: the sum of all</span>
<span class=c1># the elements in the input PCollection.</span>
<span class=n>pc</span> <span class=o>=</span> <span class=o>...</span>

<span class=n>average</span> <span class=o>=</span> <span class=n>pc</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>CombineGlobally</span><span class=p>(</span><span class=n>AverageFn</span><span class=p>())</span></code></pre></div></div><h5 id=combine-global-windowing>4.2.4.4. Combine and global windowing</h5><p>If your input <code>PCollection</code> uses the default global windowing, the default
behavior is to return a <code>PCollection</code> containing one item. That item&rsquo;s value
comes from the accumulator in the combine function that you specified when
applying <code>Combine</code>. For example, the Beam provided sum combine function returns
a zero value (the sum of an empty input), while the min combine function returns
a maximal or infinite value.</p><p>To have <code>Combine</code> instead return an empty <code>PCollection</code> if the input is empty,
specify <code>.withoutDefaults</code> when you apply your <code>Combine</code> transform, as in the
following code example:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>pc</span> <span class=o>=</span> <span class=o>...;</span>
<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>pc</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
  <span class=n>Combine</span><span class=o>.</span><span class=na>globally</span><span class=o>(</span><span class=k>new</span> <span class=n>Sum</span><span class=o>.</span><span class=na>SumIntegerFn</span><span class=o>()).</span><span class=na>withoutDefaults</span><span class=o>());</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>pc</span> <span class=o>=</span> <span class=o>...</span>
<span class=nb>sum</span> <span class=o>=</span> <span class=n>pc</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>CombineGlobally</span><span class=p>(</span><span class=nb>sum</span><span class=p>)</span><span class=o>.</span><span class=n>without_defaults</span><span class=p>()</span></code></pre></div></div><h5 id=combine-non-global-windowing>4.2.4.5. Combine and non-global windowing</h5><p>If your <code>PCollection</code> uses any non-global windowing function, Beam does not
provide the default behavior. You must specify one of the following options when
applying <code>Combine</code>:</p><ul><li>Specify <code>.withoutDefaults</code>, where windows that are empty in the input
<code>PCollection</code> will likewise be empty in the output collection.</li><li>Specify <code>.asSingletonView</code>, in which the output is immediately converted to a
<code>PCollectionView</code>, which will provide a default value for each empty window
when used as a side input. You&rsquo;ll generally only need to use this option if
the result of your pipeline&rsquo;s <code>Combine</code> is to be used as a side input later in
the pipeline.</li></ul><h5 id=combining-values-in-a-keyed-pcollection>4.2.4.6. Combining values in a keyed PCollection</h5><p>After creating a keyed PCollection (for example, by using a <code>GroupByKey</code>
transform), a common pattern is to combine the collection of values associated
with each key into a single, merged value. Drawing on the previous example from
<code>GroupByKey</code>, a key-grouped <code>PCollection</code> called <code>groupedWords</code> looks like this:</p><pre><code>  cat, [1,5,9]
  dog, [5,2]
  and, [1,2,6]
  jump, [3]
  tree, [2]
  ...
</code></pre><p>In the above <code>PCollection</code>, each element has a string key (for example, &ldquo;cat&rdquo;)
and an iterable of integers for its value (in the first element, containing [1,
5, 9]). If our pipeline&rsquo;s next processing step combines the values (rather than
considering them individually), you can combine the iterable of integers to
create a single, merged value to be paired with each key. This pattern of a
<code>GroupByKey</code> followed by merging the collection of values is equivalent to
Beam&rsquo;s Combine PerKey transform. The combine function you supply to Combine
PerKey must be an associative reduction function or a subclass of <code>CombineFn</code>.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// PCollection is grouped by key and the Double values associated with each key are combined into a Double.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Double</span><span class=o>&gt;&gt;</span> <span class=n>salesRecords</span> <span class=o>=</span> <span class=o>...;</span>
<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Double</span><span class=o>&gt;&gt;</span> <span class=n>totalSalesPerPerson</span> <span class=o>=</span>
  <span class=n>salesRecords</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Combine</span><span class=o>.&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Double</span><span class=o>,</span> <span class=n>Double</span><span class=o>&gt;</span><span class=n>perKey</span><span class=o>(</span>
    <span class=k>new</span> <span class=n>Sum</span><span class=o>.</span><span class=na>SumDoubleFn</span><span class=o>()));</span>

<span class=c1>// The combined value is of a different type than the original collection of values per key. PCollection has
</span><span class=c1>// keys of type String and values of type Integer, and the combined value is a Double.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>playerAccuracy</span> <span class=o>=</span> <span class=o>...;</span>
<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Double</span><span class=o>&gt;&gt;</span> <span class=n>avgAccuracyPerPlayer</span> <span class=o>=</span>
  <span class=n>playerAccuracy</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Combine</span><span class=o>.&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>,</span> <span class=n>Double</span><span class=o>&gt;</span><span class=n>perKey</span><span class=o>(</span>
    <span class=k>new</span> <span class=n>MeanInts</span><span class=o>())));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># PCollection is grouped by key and the numeric values associated with each key</span>
<span class=c1># are averaged into a float.</span>
<span class=n>player_accuracies</span> <span class=o>=</span> <span class=o>...</span>

<span class=n>avg_accuracy_per_player</span> <span class=o>=</span> <span class=p>(</span>
    <span class=n>player_accuracies</span>
    <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>CombinePerKey</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>combiners</span><span class=o>.</span><span class=n>MeanCombineFn</span><span class=p>()))</span></code></pre></div></div><h4 id=flatten>4.2.5. Flatten</h4><p><span class=language-java><a href=https://beam.apache.org/releases/javadoc/2.22.0/index.html?org/apache/beam/sdk/transforms/Flatten.html><code>Flatten</code></a></span>
<span class=language-py><a href=https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/core.py><code>Flatten</code></a></span>
is a Beam transform for <code>PCollection</code> objects that store the same data type.
<code>Flatten</code> merges multiple <code>PCollection</code> objects into a single logical
<code>PCollection</code>.</p><p>The following example shows how to apply a <code>Flatten</code> transform to merge multiple
<code>PCollection</code> objects.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// Flatten takes a PCollectionList of PCollection objects of a given type.
</span><span class=c1>// Returns a single PCollection that contains all of the elements in the PCollection objects in that list.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>pc1</span> <span class=o>=</span> <span class=o>...;</span>
<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>pc2</span> <span class=o>=</span> <span class=o>...;</span>
<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>pc3</span> <span class=o>=</span> <span class=o>...;</span>
<span class=n>PCollectionList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>collections</span> <span class=o>=</span> <span class=n>PCollectionList</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>pc1</span><span class=o>).</span><span class=na>and</span><span class=o>(</span><span class=n>pc2</span><span class=o>).</span><span class=na>and</span><span class=o>(</span><span class=n>pc3</span><span class=o>);</span>

<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>merged</span> <span class=o>=</span> <span class=n>collections</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Flatten</span><span class=o>.&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=n>pCollections</span><span class=o>());</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># Flatten takes a tuple of PCollection objects.</span>
<span class=c1># Returns a single PCollection that contains all of the elements in the PCollection objects in that tuple.</span>

<span class=n>merged</span> <span class=o>=</span> <span class=p>(</span>
    <span class=p>(</span><span class=n>pcoll1</span><span class=p>,</span> <span class=n>pcoll2</span><span class=p>,</span> <span class=n>pcoll3</span><span class=p>)</span>
    <span class=c1># A list of tuples can be &#34;piped&#34; directly into a Flatten transform.</span>
    <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>Flatten</span><span class=p>())</span></code></pre></div></div><h5 id=data-encoding-merged-collections>4.2.5.1. Data encoding in merged collections</h5><p>By default, the coder for the output <code>PCollection</code> is the same as the coder for
the first <code>PCollection</code> in the input <code>PCollectionList</code>. However, the input
<code>PCollection</code> objects can each use different coders, as long as they all contain
the same data type in your chosen language.</p><h5 id=merging-windowed-collections>4.2.5.2. Merging windowed collections</h5><p>When using <code>Flatten</code> to merge <code>PCollection</code> objects that have a windowing
strategy applied, all of the <code>PCollection</code> objects you want to merge must use a
compatible windowing strategy and window sizing. For example, all the
collections you&rsquo;re merging must all use (hypothetically) identical 5-minute
fixed windows or 4-minute sliding windows starting every 30 seconds.</p><p>If your pipeline attempts to use <code>Flatten</code> to merge <code>PCollection</code> objects with
incompatible windows, Beam generates an <code>IllegalStateException</code> error when your
pipeline is constructed.</p><h4 id=partition>4.2.6. Partition</h4><p><span class=language-java><a href=https://beam.apache.org/releases/javadoc/2.22.0/index.html?org/apache/beam/sdk/transforms/Partition.html><code>Partition</code></a></span>
<span class=language-py><a href=https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/core.py><code>Partition</code></a></span>
is a Beam transform for <code>PCollection</code> objects that store the same data
type. <code>Partition</code> splits a single <code>PCollection</code> into a fixed number of smaller
collections.</p><p><code>Partition</code> divides the elements of a <code>PCollection</code> according to a partitioning
function that you provide. The partitioning function contains the logic that
determines how to split up the elements of the input <code>PCollection</code> into each
resulting partition <code>PCollection</code>. The number of partitions must be determined
at graph construction time. You can, for example, pass the number of partitions
as a command-line option at runtime (which will then be used to build your
pipeline graph), but you cannot determine the number of partitions in
mid-pipeline (based on data calculated after your pipeline graph is constructed,
for instance).</p><p>The following example divides a <code>PCollection</code> into percentile groups.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// Provide an int value with the desired number of result partitions, and a PartitionFn that represents the
</span><span class=c1>// partitioning function. In this example, we define the PartitionFn in-line. Returns a PCollectionList
</span><span class=c1>// containing each of the resulting partitions as individual PCollection objects.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Student</span><span class=o>&gt;</span> <span class=n>students</span> <span class=o>=</span> <span class=o>...;</span>
<span class=c1>// Split students up into 10 partitions, by percentile:
</span><span class=c1></span><span class=n>PCollectionList</span><span class=o>&lt;</span><span class=n>Student</span><span class=o>&gt;</span> <span class=n>studentsByPercentile</span> <span class=o>=</span>
    <span class=n>students</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Partition</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>10</span><span class=o>,</span> <span class=k>new</span> <span class=n>PartitionFn</span><span class=o>&lt;</span><span class=n>Student</span><span class=o>&gt;()</span> <span class=o>{</span>
        <span class=kd>public</span> <span class=kt>int</span> <span class=nf>partitionFor</span><span class=o>(</span><span class=n>Student</span> <span class=n>student</span><span class=o>,</span> <span class=kt>int</span> <span class=n>numPartitions</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>return</span> <span class=n>student</span><span class=o>.</span><span class=na>getPercentile</span><span class=o>()</span>  <span class=c1>// 0..99
</span><span class=c1></span>                 <span class=o>*</span> <span class=n>numPartitions</span> <span class=o>/</span> <span class=n>100</span><span class=o>;</span>
        <span class=o>}}));</span>

<span class=c1>// You can extract each partition from the PCollectionList using the get method, as follows:
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Student</span><span class=o>&gt;</span> <span class=n>fortiethPercentile</span> <span class=o>=</span> <span class=n>studentsByPercentile</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>4</span><span class=o>);</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># Provide an int value with the desired number of result partitions, and a partitioning function (partition_fn in this example).</span>
<span class=c1># Returns a tuple of PCollection objects containing each of the resulting partitions as individual PCollection objects.</span>
<span class=n>students</span> <span class=o>=</span> <span class=o>...</span>

<span class=k>def</span> <span class=nf>partition_fn</span><span class=p>(</span><span class=n>student</span><span class=p>,</span> <span class=n>num_partitions</span><span class=p>):</span>
  <span class=k>return</span> <span class=nb>int</span><span class=p>(</span><span class=n>get_percentile</span><span class=p>(</span><span class=n>student</span><span class=p>)</span> <span class=o>*</span> <span class=n>num_partitions</span> <span class=o>/</span> <span class=mi>100</span><span class=p>)</span>

<span class=n>by_decile</span> <span class=o>=</span> <span class=n>students</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>Partition</span><span class=p>(</span><span class=n>partition_fn</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>


<span class=c1># You can extract each partition from the tuple of PCollection objects as follows:</span>

<span class=n>fortieth_percentile</span> <span class=o>=</span> <span class=n>by_decile</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span></code></pre></div></div><h3 id=requirements-for-writing-user-code-for-beam-transforms>4.3. Requirements for writing user code for Beam transforms</h3><p>When you build user code for a Beam transform, you should keep in mind the
distributed nature of execution. For example, there might be many copies of your
function running on a lot of different machines in parallel, and those copies
function independently, without communicating or sharing state with any of the
other copies. Depending on the Pipeline Runner and processing back-end you
choose for your pipeline, each copy of your user code function may be retried or
run multiple times. As such, you should be cautious about including things like
state dependency in your user code.</p><p>In general, your user code must fulfill at least these requirements:</p><ul><li>Your function object must be <strong>serializable</strong>.</li><li>Your function object must be <strong>thread-compatible</strong>, and be aware that <em>the
Beam SDKs are not thread-safe</em>.</li></ul><p>In addition, it&rsquo;s recommended that you make your function object <strong>idempotent</strong>.
Non-idempotent functions are supported by Beam, but require additional
thought to ensure correctness when there are external side effects.</p><blockquote><p><strong>Note:</strong> These requirements apply to subclasses of <code>DoFn</code> (a function object
used with the <a href=#pardo>ParDo</a> transform), <code>CombineFn</code> (a function object used
with the <a href=#combine>Combine</a> transform), and <code>WindowFn</code> (a function object
used with the <a href=#windowing>Window</a> transform).</p></blockquote><h4 id=user-code-serializability>4.3.1. Serializability</h4><p>Any function object you provide to a transform must be <strong>fully serializable</strong>.
This is because a copy of the function needs to be serialized and transmitted to
a remote worker in your processing cluster. The base classes for user code, such
as <code>DoFn</code>, <code>CombineFn</code>, and <code>WindowFn</code>, already implement <code>Serializable</code>;
however, your subclass must not add any non-serializable members.</p><p>Some other serializability factors you should keep in mind are:</p><ul><li>Transient fields in your function object are <em>not</em> transmitted to worker
instances, because they are not automatically serialized.</li><li>Avoid loading a field with a large amount of data before serialization.</li><li>Individual instances of your function object cannot share data.</li><li>Mutating a function object after it gets applied will have no effect.</li><li>Take care when declaring your function object inline by using an anonymous
inner class instance. In a non-static context, your inner class instance will
implicitly contain a pointer to the enclosing class and that class&rsquo; state.
That enclosing class will also be serialized, and thus the same considerations
that apply to the function object itself also apply to this outer class.</li></ul><h4 id=user-code-thread-compatibility>4.3.2. Thread-compatibility</h4><p>Your function object should be thread-compatible. Each instance of your function
object is accessed by a single thread at a time on a worker instance, unless you
explicitly create your own threads. Note, however, that <strong>the Beam SDKs are not
thread-safe</strong>. If you create your own threads in your user code, you must
provide your own synchronization. Note that static members in your function
object are not passed to worker instances and that multiple instances of your
function may be accessed from different threads.</p><h4 id=user-code-idempotence>4.3.3. Idempotence</h4><p>It&rsquo;s recommended that you make your function object idempotent&ndash;that is, that it
can be repeated or retried as often as necessary without causing unintended side
effects. Non-idempotent functions are supported, however the Beam model provides
no guarantees as to the number of times your user code might be invoked or retried;
as such, keeping your function object idempotent keeps your pipeline&rsquo;s output
deterministic, and your transforms&rsquo; behavior more predictable and easier to debug.</p><h3 id=side-inputs>4.4. Side inputs</h3><p>In addition to the main input <code>PCollection</code>, you can provide additional inputs
to a <code>ParDo</code> transform in the form of side inputs. A side input is an additional
input that your <code>DoFn</code> can access each time it processes an element in the input
<code>PCollection</code>. When you specify a side input, you create a view of some other
data that can be read from within the <code>ParDo</code> transform&rsquo;s <code>DoFn</code> while processing
each element.</p><p>Side inputs are useful if your <code>ParDo</code> needs to inject additional data when
processing each element in the input <code>PCollection</code>, but the additional data
needs to be determined at runtime (and not hard-coded). Such values might be
determined by the input data, or depend on a different branch of your pipeline.</p><h4 id=side-inputs-pardo>4.4.1. Passing side inputs to ParDo</h4><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>  <span class=c1>// Pass side inputs to your ParDo transform by invoking .withSideInputs.
</span><span class=c1></span>  <span class=c1>// Inside your DoFn, access the side input by using the method DoFn.ProcessContext.sideInput.
</span><span class=c1></span>
  <span class=c1>// The input PCollection to ParDo.
</span><span class=c1></span>  <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>words</span> <span class=o>=</span> <span class=o>...;</span>

  <span class=c1>// A PCollection of word lengths that we&#39;ll combine into a single value.
</span><span class=c1></span>  <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>wordLengths</span> <span class=o>=</span> <span class=o>...;</span> <span class=c1>// Singleton PCollection
</span><span class=c1></span>
  <span class=c1>// Create a singleton PCollectionView from wordLengths using Combine.globally and View.asSingleton.
</span><span class=c1></span>  <span class=kd>final</span> <span class=n>PCollectionView</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>maxWordLengthCutOffView</span> <span class=o>=</span>
     <span class=n>wordLengths</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Combine</span><span class=o>.</span><span class=na>globally</span><span class=o>(</span><span class=k>new</span> <span class=n>Max</span><span class=o>.</span><span class=na>MaxIntFn</span><span class=o>()).</span><span class=na>asSingletonView</span><span class=o>());</span>


  <span class=c1>// Apply a ParDo that takes maxWordLengthCutOffView as a side input.
</span><span class=c1></span>  <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>wordsBelowCutOff</span> <span class=o>=</span>
  <span class=n>words</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span>
      <span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;()</span> <span class=o>{</span>
          <span class=nd>@ProcessElement</span>
          <span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>String</span> <span class=n>word</span><span class=o>,</span> <span class=n>OutputReceiver</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>out</span><span class=o>,</span> <span class=n>ProcessContext</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// In our DoFn, access the side input.
</span><span class=c1></span>            <span class=kt>int</span> <span class=n>lengthCutOff</span> <span class=o>=</span> <span class=n>c</span><span class=o>.</span><span class=na>sideInput</span><span class=o>(</span><span class=n>maxWordLengthCutOffView</span><span class=o>);</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>word</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>&lt;=</span> <span class=n>lengthCutOff</span><span class=o>)</span> <span class=o>{</span>
              <span class=n>out</span><span class=o>.</span><span class=na>output</span><span class=o>(</span><span class=n>word</span><span class=o>);</span>
            <span class=o>}</span>
          <span class=o>}</span>
      <span class=o>}).</span><span class=na>withSideInputs</span><span class=o>(</span><span class=n>maxWordLengthCutOffView</span><span class=o>)</span>
  <span class=o>);</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># Side inputs are available as extra arguments in the DoFn&#39;s process method or Map / FlatMap&#39;s callable.</span>
<span class=c1># Optional, positional, and keyword arguments are all supported. Deferred arguments are unwrapped into their</span>
<span class=c1># actual values. For example, using pvalue.AsIteor(pcoll) at pipeline construction time results in an iterable</span>
<span class=c1># of the actual elements of pcoll being passed into each process invocation. In this example, side inputs are</span>
<span class=c1># passed to a FlatMap transform as extra arguments and consumed by filter_using_length.</span>
<span class=n>words</span> <span class=o>=</span> <span class=o>...</span>

<span class=c1># Callable takes additional arguments.</span>
<span class=k>def</span> <span class=nf>filter_using_length</span><span class=p>(</span><span class=n>word</span><span class=p>,</span> <span class=n>lower_bound</span><span class=p>,</span> <span class=n>upper_bound</span><span class=o>=</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)):</span>
  <span class=k>if</span> <span class=n>lower_bound</span> <span class=o>&lt;=</span> <span class=nb>len</span><span class=p>(</span><span class=n>word</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=n>upper_bound</span><span class=p>:</span>
    <span class=k>yield</span> <span class=n>word</span>

<span class=c1># Construct a deferred side input.</span>
<span class=n>avg_word_len</span> <span class=o>=</span> <span class=p>(</span>
    <span class=n>words</span>
    <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>Map</span><span class=p>(</span><span class=nb>len</span><span class=p>)</span>
    <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>CombineGlobally</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>combiners</span><span class=o>.</span><span class=n>MeanCombineFn</span><span class=p>()))</span>

<span class=c1># Call with explicit side inputs.</span>
<span class=n>small_words</span> <span class=o>=</span> <span class=n>words</span> <span class=o>|</span> <span class=s1>&#39;small&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>FlatMap</span><span class=p>(</span><span class=n>filter_using_length</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>

<span class=c1># A single deferred side input.</span>
<span class=n>larger_than_average</span> <span class=o>=</span> <span class=p>(</span>
    <span class=n>words</span> <span class=o>|</span> <span class=s1>&#39;large&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>FlatMap</span><span class=p>(</span>
        <span class=n>filter_using_length</span><span class=p>,</span> <span class=n>lower_bound</span><span class=o>=</span><span class=n>pvalue</span><span class=o>.</span><span class=n>AsSingleton</span><span class=p>(</span><span class=n>avg_word_len</span><span class=p>))</span>
<span class=p>)</span>

<span class=c1># Mix and match.</span>
<span class=n>small_but_nontrivial</span> <span class=o>=</span> <span class=n>words</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>FlatMap</span><span class=p>(</span>
    <span class=n>filter_using_length</span><span class=p>,</span>
    <span class=n>lower_bound</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span>
    <span class=n>upper_bound</span><span class=o>=</span><span class=n>pvalue</span><span class=o>.</span><span class=n>AsSingleton</span><span class=p>(</span><span class=n>avg_word_len</span><span class=p>))</span>


<span class=c1># We can also pass side inputs to a ParDo transform, which will get passed to its process method.</span>
<span class=c1># The first two arguments for the process method would be self and element.</span>


<span class=k>class</span> <span class=nc>FilterUsingLength</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=p>):</span>
  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>element</span><span class=p>,</span> <span class=n>lower_bound</span><span class=p>,</span> <span class=n>upper_bound</span><span class=o>=</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)):</span>
    <span class=k>if</span> <span class=n>lower_bound</span> <span class=o>&lt;=</span> <span class=nb>len</span><span class=p>(</span><span class=n>element</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=n>upper_bound</span><span class=p>:</span>
      <span class=k>yield</span> <span class=n>element</span>

<span class=n>small_words</span> <span class=o>=</span> <span class=n>words</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span><span class=n>FilterUsingLength</span><span class=p>(),</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>

<span class=o>...</span></code></pre></div></div><h4 id=side-inputs-windowing>4.4.2. Side inputs and windowing</h4><p>A windowed <code>PCollection</code> may be infinite and thus cannot be compressed into a
single value (or single collection class). When you create a <code>PCollectionView</code>
of a windowed <code>PCollection</code>, the <code>PCollectionView</code> represents a single entity
per window (one singleton per window, one list per window, etc.).</p><p>Beam uses the window(s) for the main input element to look up the appropriate
window for the side input element. Beam projects the main input element&rsquo;s window
into the side input&rsquo;s window set, and then uses the side input from the
resulting window. If the main input and side inputs have identical windows, the
projection provides the exact corresponding window. However, if the inputs have
different windows, Beam uses the projection to choose the most appropriate side
input window.</p><p>For example, if the main input is windowed using fixed-time windows of one
minute, and the side input is windowed using fixed-time windows of one hour,
Beam projects the main input window against the side input window set and
selects the side input value from the appropriate hour-long side input window.</p><p>If the main input element exists in more than one window, then <code>processElement</code>
gets called multiple times, once for each window. Each call to <code>processElement</code>
projects the &ldquo;current&rdquo; window for the main input element, and thus might provide
a different view of the side input each time.</p><p>If the side input has multiple trigger firings, Beam uses the value from the
latest trigger firing. This is particularly useful if you use a side input with
a single global window and specify a trigger.</p><h3 id=additional-outputs>4.5. Additional outputs</h3><p>While <code>ParDo</code> always produces a main output <code>PCollection</code> (as the return value
from <code>apply</code>), you can also have your <code>ParDo</code> produce any number of additional
output <code>PCollection</code>s. If you choose to have multiple outputs, your <code>ParDo</code>
returns all of the output <code>PCollection</code>s (including the main output) bundled
together.</p><h4 id=output-tags>4.5.1. Tags for multiple outputs</h4><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// To emit elements to multiple output PCollections, create a TupleTag object to identify each collection
</span><span class=c1>// that your ParDo produces. For example, if your ParDo produces three output PCollections (the main output
</span><span class=c1>// and two additional outputs), you must create three TupleTags. The following example code shows how to
</span><span class=c1>// create TupleTags for a ParDo with three output PCollections.
</span><span class=c1></span>
  <span class=c1>// Input PCollection to our ParDo.
</span><span class=c1></span>  <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>words</span> <span class=o>=</span> <span class=o>...;</span>

  <span class=c1>// The ParDo will filter words whose length is below a cutoff and add them to
</span><span class=c1></span>  <span class=c1>// the main output PCollection&lt;String&gt;.
</span><span class=c1></span>  <span class=c1>// If a word is above the cutoff, the ParDo will add the word length to an
</span><span class=c1></span>  <span class=c1>// output PCollection&lt;Integer&gt;.
</span><span class=c1></span>  <span class=c1>// If a word starts with the string &#34;MARKER&#34;, the ParDo will add that word to an
</span><span class=c1></span>  <span class=c1>// output PCollection&lt;String&gt;.
</span><span class=c1></span>  <span class=kd>final</span> <span class=kt>int</span> <span class=n>wordLengthCutOff</span> <span class=o>=</span> <span class=n>10</span><span class=o>;</span>

  <span class=c1>// Create three TupleTags, one for each output PCollection.
</span><span class=c1></span>  <span class=c1>// Output that contains words below the length cutoff.
</span><span class=c1></span>  <span class=kd>final</span> <span class=n>TupleTag</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>wordsBelowCutOffTag</span> <span class=o>=</span>
      <span class=k>new</span> <span class=n>TupleTag</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;(){};</span>
  <span class=c1>// Output that contains word lengths.
</span><span class=c1></span>  <span class=kd>final</span> <span class=n>TupleTag</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>wordLengthsAboveCutOffTag</span> <span class=o>=</span>
      <span class=k>new</span> <span class=n>TupleTag</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;(){};</span>
  <span class=c1>// Output that contains &#34;MARKER&#34; words.
</span><span class=c1></span>  <span class=kd>final</span> <span class=n>TupleTag</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>markedWordsTag</span> <span class=o>=</span>
      <span class=k>new</span> <span class=n>TupleTag</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;(){};</span>

<span class=c1>// Passing Output Tags to ParDo:
</span><span class=c1>// After you specify the TupleTags for each of your ParDo outputs, pass the tags to your ParDo by invoking
</span><span class=c1>// .withOutputTags. You pass the tag for the main output first, and then the tags for any additional outputs
</span><span class=c1>// in a TupleTagList. Building on our previous example, we pass the three TupleTags for our three output
</span><span class=c1>// PCollections to our ParDo. Note that all of the outputs (including the main output PCollection) are
</span><span class=c1>// bundled into the returned PCollectionTuple.
</span><span class=c1></span>
  <span class=n>PCollectionTuple</span> <span class=n>results</span> <span class=o>=</span>
      <span class=n>words</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span>
          <span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;()</span> <span class=o>{</span>
            <span class=c1>// DoFn continues here.
</span><span class=c1></span>            <span class=o>...</span>
          <span class=o>})</span>
          <span class=c1>// Specify the tag for the main output.
</span><span class=c1></span>          <span class=o>.</span><span class=na>withOutputTags</span><span class=o>(</span><span class=n>wordsBelowCutOffTag</span><span class=o>,</span>
          <span class=c1>// Specify the tags for the two additional outputs as a TupleTagList.
</span><span class=c1></span>                          <span class=n>TupleTagList</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>wordLengthsAboveCutOffTag</span><span class=o>)</span>
                                      <span class=o>.</span><span class=na>and</span><span class=o>(</span><span class=n>markedWordsTag</span><span class=o>)));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># To emit elements to multiple output PCollections, invoke with_outputs() on the ParDo, and specify the</span>
<span class=c1># expected tags for the outputs. with_outputs() returns a DoOutputsTuple object. Tags specified in</span>
<span class=c1># with_outputs are attributes on the returned DoOutputsTuple object. The tags give access to the</span>
<span class=c1># corresponding output PCollections.</span>


<span class=n>results</span> <span class=o>=</span> <span class=p>(</span>
    <span class=n>words</span>
    <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span><span class=n>ProcessWords</span><span class=p>(),</span> <span class=n>cutoff_length</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>marker</span><span class=o>=</span><span class=s1>&#39;x&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>with_outputs</span><span class=p>(</span>
        <span class=s1>&#39;above_cutoff_lengths&#39;</span><span class=p>,</span>
        <span class=s1>&#39;marked strings&#39;</span><span class=p>,</span>
        <span class=n>main</span><span class=o>=</span><span class=s1>&#39;below_cutoff_strings&#39;</span><span class=p>))</span>
<span class=n>below</span> <span class=o>=</span> <span class=n>results</span><span class=o>.</span><span class=n>below_cutoff_strings</span>
<span class=n>above</span> <span class=o>=</span> <span class=n>results</span><span class=o>.</span><span class=n>above_cutoff_lengths</span>
<span class=n>marked</span> <span class=o>=</span> <span class=n>results</span><span class=p>[</span><span class=s1>&#39;marked strings&#39;</span><span class=p>]</span>  <span class=c1># indexing works as well</span>


<span class=c1># The result is also iterable, ordered in the same order that the tags were passed to with_outputs(),</span>
<span class=c1># the main tag (if specified) first.</span>


<span class=n>below</span><span class=p>,</span> <span class=n>above</span><span class=p>,</span> <span class=n>marked</span> <span class=o>=</span> <span class=p>(</span><span class=n>words</span>
                        <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span>
                            <span class=n>ProcessWords</span><span class=p>(),</span> <span class=n>cutoff_length</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>marker</span><span class=o>=</span><span class=s1>&#39;x&#39;</span><span class=p>)</span>
                        <span class=o>.</span><span class=n>with_outputs</span><span class=p>(</span><span class=s1>&#39;above_cutoff_lengths&#39;</span><span class=p>,</span>
                                      <span class=s1>&#39;marked strings&#39;</span><span class=p>,</span>
                                      <span class=n>main</span><span class=o>=</span><span class=s1>&#39;below_cutoff_strings&#39;</span><span class=p>))</span></code></pre></div></div><h4 id=multiple-outputs-dofn>4.5.2. Emitting to multiple outputs in your DoFn</h4><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// Inside your ParDo&#39;s DoFn, you can emit an element to a specific output PCollection by providing a
</span><span class=c1>// MultiOutputReceiver to your process method, and passing in the appropriate TupleTag to obtain an OutputReceiver.
</span><span class=c1>// After your ParDo, extract the resulting output PCollections from the returned PCollectionTuple.
</span><span class=c1>// Based on the previous example, this shows the DoFn emitting to the main output and two additional outputs.
</span><span class=c1></span>
  <span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;()</span> <span class=o>{</span>
     <span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>String</span> <span class=n>word</span><span class=o>,</span> <span class=n>MultiOutputReceiver</span> <span class=n>out</span><span class=o>)</span> <span class=o>{</span>
       <span class=k>if</span> <span class=o>(</span><span class=n>word</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>&lt;=</span> <span class=n>wordLengthCutOff</span><span class=o>)</span> <span class=o>{</span>
         <span class=c1>// Emit short word to the main output.
</span><span class=c1></span>         <span class=c1>// In this example, it is the output with tag wordsBelowCutOffTag.
</span><span class=c1></span>         <span class=n>out</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>wordsBelowCutOffTag</span><span class=o>).</span><span class=na>output</span><span class=o>(</span><span class=n>word</span><span class=o>);</span>
       <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
         <span class=c1>// Emit long word length to the output with tag wordLengthsAboveCutOffTag.
</span><span class=c1></span>         <span class=n>out</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>wordLengthsAboveCutOffTag</span><span class=o>).</span><span class=na>output</span><span class=o>(</span><span class=n>word</span><span class=o>.</span><span class=na>length</span><span class=o>());</span>
       <span class=o>}</span>
       <span class=k>if</span> <span class=o>(</span><span class=n>word</span><span class=o>.</span><span class=na>startsWith</span><span class=o>(</span><span class=s>&#34;MARKER&#34;</span><span class=o>))</span> <span class=o>{</span>
         <span class=c1>// Emit word to the output with tag markedWordsTag.
</span><span class=c1></span>         <span class=n>out</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>markedWordsTag</span><span class=o>).</span><span class=na>output</span><span class=o>(</span><span class=n>word</span><span class=o>);</span>
       <span class=o>}</span>
     <span class=o>}}));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># Inside your ParDo&#39;s DoFn, you can emit an element to a specific output by wrapping the value and the output tag (str).</span>
<span class=c1># using the pvalue.OutputValue wrapper class.</span>
<span class=c1># Based on the previous example, this shows the DoFn emitting to the main output and two additional outputs.</span>


<span class=k>class</span> <span class=nc>ProcessWords</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=p>):</span>
  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>element</span><span class=p>,</span> <span class=n>cutoff_length</span><span class=p>,</span> <span class=n>marker</span><span class=p>):</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>element</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=n>cutoff_length</span><span class=p>:</span>
      <span class=c1># Emit this short word to the main output.</span>
      <span class=k>yield</span> <span class=n>element</span>
    <span class=k>else</span><span class=p>:</span>
      <span class=c1># Emit this word&#39;s long length to the &#39;above_cutoff_lengths&#39; output.</span>
      <span class=k>yield</span> <span class=n>pvalue</span><span class=o>.</span><span class=n>TaggedOutput</span><span class=p>(</span><span class=s1>&#39;above_cutoff_lengths&#39;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>element</span><span class=p>))</span>
    <span class=k>if</span> <span class=n>element</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=n>marker</span><span class=p>):</span>
      <span class=c1># Emit this word to a different output with the &#39;marked strings&#39; tag.</span>
      <span class=k>yield</span> <span class=n>pvalue</span><span class=o>.</span><span class=n>TaggedOutput</span><span class=p>(</span><span class=s1>&#39;marked strings&#39;</span><span class=p>,</span> <span class=n>element</span><span class=p>)</span>



<span class=c1># Producing multiple outputs is also available in Map and FlatMap.</span>
<span class=c1># Here is an example that uses FlatMap and shows that the tags do not need to be specified ahead of time.</span>


<span class=k>def</span> <span class=nf>even_odd</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
  <span class=k>yield</span> <span class=n>pvalue</span><span class=o>.</span><span class=n>TaggedOutput</span><span class=p>(</span><span class=s1>&#39;odd&#39;</span> <span class=k>if</span> <span class=n>x</span> <span class=o>%</span> <span class=mi>2</span> <span class=k>else</span> <span class=s1>&#39;even&#39;</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span>
  <span class=k>if</span> <span class=n>x</span> <span class=o>%</span> <span class=mi>10</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
    <span class=k>yield</span> <span class=n>x</span>

<span class=n>results</span> <span class=o>=</span> <span class=n>numbers</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>FlatMap</span><span class=p>(</span><span class=n>even_odd</span><span class=p>)</span><span class=o>.</span><span class=n>with_outputs</span><span class=p>()</span>

<span class=n>evens</span> <span class=o>=</span> <span class=n>results</span><span class=o>.</span><span class=n>even</span>
<span class=n>odds</span> <span class=o>=</span> <span class=n>results</span><span class=o>.</span><span class=n>odd</span>
<span class=n>tens</span> <span class=o>=</span> <span class=n>results</span><span class=p>[</span><span class=bp>None</span><span class=p>]</span>  <span class=c1># the undeclared main output</span></code></pre></div></div><h4 id=other-dofn-parameters>4.5.3. Accessing additional parameters in your DoFn</h4><p class=language-java>In addition to the element and the <code>OutputReceiver</code>, Beam will populate other parameters to your DoFn&rsquo;s <code>@ProcessElement</code> method.
Any combination of these parameters can be added to your process method in any order.</p><p class=language-py>In addition to the element, Beam will populate other parameters to your DoFn&rsquo;s <code>process</code> method.
Any combination of these parameters can be added to your process method in any order.</p><p class=language-java><strong>Timestamp:</strong>
To access the timestamp of an input element, add a parameter annotated with <code>@Timestamp</code> of type <code>Instant</code>. For example:</p><p class=language-py><strong>Timestamp:</strong>
To access the timestamp of an input element, add a keyword parameter default to <code>DoFn.TimestampParam</code>. For example:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;()</span> <span class=o>{</span>
     <span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>String</span> <span class=n>word</span><span class=o>,</span> <span class=nd>@Timestamp</span> <span class=n>Instant</span> <span class=n>timestamp</span><span class=o>)</span> <span class=o>{</span>
  <span class=o>}})</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=kn>import</span> <span class=nn>apache_beam</span> <span class=kn>as</span> <span class=nn>beam</span>

<span class=k>class</span> <span class=nc>ProcessRecord</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=p>):</span>

  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>element</span><span class=p>,</span> <span class=n>timestamp</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>TimestampParam</span><span class=p>):</span>
     <span class=c1># access timestamp of element.</span>
     <span class=k>pass</span>  
  </code></pre></div></div><p class=language-java><strong>Window:</strong>
To access the window an input element falls into, add a parameter of the type of the window used for the input <code>PCollection</code>.
If the parameter is a window type (a subclass of <code>BoundedWindow</code>) that does not match the input <code>PCollection</code>, then an error
will be raised. If an element falls in multiple windows (for example, this will happen when using <code>SlidingWindows</code>), then the
<code>@ProcessElement</code> method will be invoked multiple time for the element, once for each window. For example, when fixed windows
are being used, the window is of type <code>IntervalWindow</code>.</p><p class=language-py><strong>Window:</strong>
To access the window an input element falls into, add a keyword parameter default to <code>DoFn.WindowParam</code>.
If an element falls in multiple windows (for example, this will happen when using <code>SlidingWindows</code>), then the
<code>process</code> method will be invoked multiple time for the element, once for each window.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;()</span> <span class=o>{</span>
     <span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>String</span> <span class=n>word</span><span class=o>,</span> <span class=n>IntervalWindow</span> <span class=n>window</span><span class=o>)</span> <span class=o>{</span>
  <span class=o>}})</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=kn>import</span> <span class=nn>apache_beam</span> <span class=kn>as</span> <span class=nn>beam</span>

<span class=k>class</span> <span class=nc>ProcessRecord</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=p>):</span>

  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>element</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>WindowParam</span><span class=p>):</span>
     <span class=c1># access window e.g. window.end.micros</span>
     <span class=k>pass</span>  
  </code></pre></div></div><p class=language-java><strong>PaneInfo:</strong>
When triggers are used, Beam provides a <code>PaneInfo</code> object that contains information about the current firing. Using <code>PaneInfo</code>
you can determine whether this is an early or a late firing, and how many times this window has already fired for this key.</p><p class=language-py><strong>PaneInfo:</strong>
When triggers are used, Beam provides a <code>DoFn.PaneInfoParam</code> object that contains information about the current firing. Using <code>DoFn.PaneInfoParam</code>
you can determine whether this is an early or a late firing, and how many times this window has already fired for this key.
This feature implementation in Python SDK is not fully completed; see more at <a href=https://issues.apache.org/jira/browse/BEAM-3759>BEAM-3759</a>.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;()</span> <span class=o>{</span>
     <span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>String</span> <span class=n>word</span><span class=o>,</span> <span class=n>PaneInfo</span> <span class=n>paneInfo</span><span class=o>)</span> <span class=o>{</span>
  <span class=o>}})</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=kn>import</span> <span class=nn>apache_beam</span> <span class=kn>as</span> <span class=nn>beam</span>

<span class=k>class</span> <span class=nc>ProcessRecord</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=p>):</span>

  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>element</span><span class=p>,</span> <span class=n>pane_info</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>PaneInfoParam</span><span class=p>):</span>
     <span class=c1># access pane info, e.g. pane_info.is_first, pane_info.is_last, pane_info.timing</span>
     <span class=k>pass</span>  
  </code></pre></div></div><p class=language-java><strong>PipelineOptions:</strong>
The <code>PipelineOptions</code> for the current pipeline can always be accessed in a process method by adding it
as a parameter:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;()</span> <span class=o>{</span>
     <span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>String</span> <span class=n>word</span><span class=o>,</span> <span class=n>PipelineOptions</span> <span class=n>options</span><span class=o>)</span> <span class=o>{</span>
  <span class=o>}})</span></code></pre></div></div><p class=language-java><code>@OnTimer</code> methods can also access many of these parameters. Timestamp, Window, key, <code>PipelineOptions</code>, <code>OutputReceiver</code>, and
<code>MultiOutputReceiver</code> parameters can all be accessed in an <code>@OnTimer</code> method. In addition, an <code>@OnTimer</code> method can take
a parameter of type <code>TimeDomain</code> which tells whether the timer is based on event time or processing time.
Timers are explained in more detail in the
<a href=/blog/2017/08/28/timely-processing.html>Timely (and Stateful) Processing with Apache Beam</a> blog post.</p><p class=language-py><strong>Timer and State:</strong>
In addition to aforementioned parameters, user defined Timer and State parameters can be used in a stateful DoFn.
Timers and States are explained in more detail in the
<a href=/blog/2017/08/28/timely-processing.html>Timely (and Stateful) Processing with Apache Beam</a> blog post.</p><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=k>class</span> <span class=nc>StatefulDoFn</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=p>):</span>
  <span class=s2>&#34;&#34;&#34;An example stateful DoFn with state and timer&#34;&#34;&#34;</span>

  <span class=n>BUFFER_STATE_1</span> <span class=o>=</span> <span class=n>BagStateSpec</span><span class=p>(</span><span class=s1>&#39;buffer1&#39;</span><span class=p>,</span> <span class=n>beam</span><span class=o>.</span><span class=n>BytesCoder</span><span class=p>())</span>
  <span class=n>BUFFER_STATE_2</span> <span class=o>=</span> <span class=n>BagStateSpec</span><span class=p>(</span><span class=s1>&#39;buffer2&#39;</span><span class=p>,</span> <span class=n>beam</span><span class=o>.</span><span class=n>VarIntCoder</span><span class=p>())</span>
  <span class=n>WATERMARK_TIMER</span> <span class=o>=</span> <span class=n>TimerSpec</span><span class=p>(</span><span class=s1>&#39;watermark_timer&#39;</span><span class=p>,</span> <span class=n>TimeDomain</span><span class=o>.</span><span class=n>WATERMARK</span><span class=p>)</span>

  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span>
              <span class=n>element</span><span class=p>,</span>
              <span class=n>timestamp</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>TimestampParam</span><span class=p>,</span>
              <span class=n>window</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>WindowParam</span><span class=p>,</span>
              <span class=n>buffer_1</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>BUFFER_STATE_1</span><span class=p>),</span>
              <span class=n>buffer_2</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>BUFFER_STATE_2</span><span class=p>),</span>
              <span class=n>watermark_timer</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>TimerParam</span><span class=p>(</span><span class=n>WATERMARK_TIMER</span><span class=p>)):</span>

    <span class=c1># Do your processing here</span>
    <span class=n>key</span><span class=p>,</span> <span class=n>value</span> <span class=o>=</span> <span class=n>element</span>
    <span class=c1># Read all the data from buffer1</span>
    <span class=n>all_values_in_buffer_1</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>buffer_1</span><span class=o>.</span><span class=n>read</span><span class=p>()]</span>

    <span class=k>if</span> <span class=n>StatefulDoFn</span><span class=o>.</span><span class=n>_is_clear_buffer_1_required</span><span class=p>(</span><span class=n>all_values_in_buffer_1</span><span class=p>):</span>
        <span class=c1># clear the buffer data if required conditions are met.</span>
        <span class=n>buffer_1</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>

    <span class=c1># add the value to buffer 2</span>
    <span class=n>buffer_2</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>value</span><span class=p>)</span>

    <span class=k>if</span> <span class=n>StatefulDoFn</span><span class=o>.</span><span class=n>_all_condition_met</span><span class=p>():</span>
      <span class=c1># Clear the timer if certain condition met and you don&#39;t want to trigger</span>
      <span class=c1># the callback method.</span>
      <span class=n>watermark_timer</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>

    <span class=k>yield</span> <span class=n>element</span>

  <span class=nd>@on_timer</span><span class=p>(</span><span class=n>WATERMARK_TIMER</span><span class=p>)</span>
  <span class=k>def</span> <span class=nf>on_expiry_1</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span>
                  <span class=n>timestamp</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>TimestampParam</span><span class=p>,</span>
                  <span class=n>window</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>WindowParam</span><span class=p>,</span>
                  <span class=n>key</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>KeyParam</span><span class=p>,</span>
                  <span class=n>buffer_1</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>BUFFER_STATE_1</span><span class=p>),</span>
                  <span class=n>buffer_2</span><span class=o>=</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>BUFFER_STATE_2</span><span class=p>)):</span>
    <span class=c1># Window and key parameters are really useful especially for debugging issues.</span>
    <span class=k>yield</span> <span class=s1>&#39;expired1&#39;</span>

  <span class=nd>@staticmethod</span>
  <span class=k>def</span> <span class=nf>_all_condition_met</span><span class=p>():</span>
      <span class=c1># some logic</span>
      <span class=k>return</span> <span class=bp>True</span>

  <span class=nd>@staticmethod</span>
  <span class=k>def</span> <span class=nf>_is_clear_buffer_1_required</span><span class=p>(</span><span class=n>buffer_1_data</span><span class=p>):</span>
      <span class=c1># Some business logic</span>
      <span class=k>return</span> <span class=bp>True</span></code></pre></div></div><h3 id=composite-transforms>4.6. Composite transforms</h3><p>Transforms can have a nested structure, where a complex transform performs
multiple simpler transforms (such as more than one <code>ParDo</code>, <code>Combine</code>,
<code>GroupByKey</code>, or even other composite transforms). These transforms are called
composite transforms. Nesting multiple transforms inside a single composite
transform can make your code more modular and easier to understand.</p><p>The Beam SDK comes packed with many useful composite transforms. See the API
reference pages for a list of transforms:</p><ul><li><a href=https://beam.apache.org/releases/javadoc/2.22.0/index.html?org/apache/beam/sdk/transforms/package-summary.html>Pre-written Beam transforms for Java</a></li><li><a href=https://beam.apache.org/releases/pydoc/2.22.0/apache_beam.transforms.html>Pre-written Beam transforms for Python</a></li></ul><h4 id=composite-transform-example>4.6.1. An example composite transform</h4><p>The <code>CountWords</code> transform in the <a href=/get-started/wordcount-example/>WordCount example program</a>
is an example of a composite transform. <code>CountWords</code> is a <code>PTransform</code> subclass
that consists of multiple nested transforms.</p><p>In its <code>expand</code> method, the <code>CountWords</code> transform applies the following
transform operations:</p><ol><li>It applies a <code>ParDo</code> on the input <code>PCollection</code> of text lines, producing
an output <code>PCollection</code> of individual words.</li><li>It applies the Beam SDK library transform <code>Count</code> on the <code>PCollection</code> of
words, producing a <code>PCollection</code> of key/value pairs. Each key represents a
word in the text, and each value represents the number of times that word
appeared in the original data.</li></ol><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>  <span class=kd>public</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>CountWords</span> <span class=kd>extends</span> <span class=n>PTransform</span><span class=o>&lt;</span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;,</span>
      <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Long</span><span class=o>&gt;&gt;&gt;</span> <span class=o>{</span>
    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Long</span><span class=o>&gt;&gt;</span> <span class=nf>expand</span><span class=o>(</span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>lines</span><span class=o>)</span> <span class=o>{</span>

      <span class=c1>// Convert lines of text into individual words.
</span><span class=c1></span>      <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>words</span> <span class=o>=</span> <span class=n>lines</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
          <span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>ExtractWordsFn</span><span class=o>()));</span>

      <span class=c1>// Count the number of times each word occurs.
</span><span class=c1></span>      <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Long</span><span class=o>&gt;&gt;</span> <span class=n>wordCounts</span> <span class=o>=</span>
          <span class=n>words</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Count</span><span class=o>.&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=n>perElement</span><span class=o>());</span>

      <span class=k>return</span> <span class=n>wordCounts</span><span class=o>;</span>
    <span class=o>}</span>
  <span class=o>}</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># The CountWords Composite Transform inside the WordCount pipeline.</span>
<span class=k>class</span> <span class=nc>CountWords</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>PTransform</span><span class=p>):</span>
  <span class=k>def</span> <span class=nf>expand</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>pcoll</span><span class=p>):</span>
    <span class=k>return</span> <span class=p>(</span>
        <span class=n>pcoll</span>
        <span class=c1># Convert lines of text into individual words.</span>
        <span class=o>|</span> <span class=s1>&#39;ExtractWords&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span><span class=n>ExtractWordsFn</span><span class=p>())</span>
        <span class=c1># Count the number of times each word occurs.</span>
        <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>combiners</span><span class=o>.</span><span class=n>Count</span><span class=o>.</span><span class=n>PerElement</span><span class=p>()</span>
        <span class=c1># Format each word and count into a printable string.</span>
        <span class=o>|</span> <span class=s1>&#39;FormatCounts&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span><span class=n>FormatCountsFn</span><span class=p>()))</span></code></pre></div></div><blockquote><p><strong>Note:</strong> Because <code>Count</code> is itself a composite transform,
<code>CountWords</code> is also a nested composite transform.</p></blockquote><h4 id=composite-transform-creation>4.6.2. Creating a composite transform</h4><p>To create your own composite transform, create a subclass of the <code>PTransform</code>
class and override the <code>expand</code> method to specify the actual processing logic.
You can then use this transform just as you would a built-in transform from the
Beam SDK.</p><p class=language-java>For the <code>PTransform</code> class type parameters, you pass the <code>PCollection</code> types
that your transform takes as input, and produces as output. To take multiple
<code>PCollection</code>s as input, or produce multiple <code>PCollection</code>s as output, use one
of the multi-collection types for the relevant type parameter.</p><p>The following code sample shows how to declare a <code>PTransform</code> that accepts a
<code>PCollection</code> of <code>String</code>s for input, and outputs a <code>PCollection</code> of <code>Integer</code>s:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>  <span class=kd>static</span> <span class=kd>class</span> <span class=nc>ComputeWordLengths</span>
    <span class=kd>extends</span> <span class=n>PTransform</span><span class=o>&lt;</span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;,</span> <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=o>{</span>
    <span class=o>...</span>
  <span class=o>}</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=k>class</span> <span class=nc>ComputeWordLengths</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>PTransform</span><span class=p>):</span>
  <span class=k>def</span> <span class=nf>expand</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>pcoll</span><span class=p>):</span>
    <span class=c1># Transform logic goes here.</span>
    <span class=k>return</span> <span class=n>pcoll</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>Map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>))</span></code></pre></div></div><p>Within your <code>PTransform</code> subclass, you&rsquo;ll need to override the <code>expand</code> method.
The <code>expand</code> method is where you add the processing logic for the <code>PTransform</code>.
Your override of <code>expand</code> must accept the appropriate type of input
<code>PCollection</code> as a parameter, and specify the output <code>PCollection</code> as the return
value.</p><p>The following code sample shows how to override <code>expand</code> for the
<code>ComputeWordLengths</code> class declared in the previous example:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>  <span class=kd>static</span> <span class=kd>class</span> <span class=nc>ComputeWordLengths</span>
      <span class=kd>extends</span> <span class=n>PTransform</span><span class=o>&lt;</span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;,</span> <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=o>{</span>
    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>expand</span><span class=o>(</span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;)</span> <span class=o>{</span>
      <span class=o>...</span>
      <span class=c1>// transform logic goes here
</span><span class=c1></span>      <span class=o>...</span>
    <span class=o>}</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=k>class</span> <span class=nc>ComputeWordLengths</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>PTransform</span><span class=p>):</span>
  <span class=k>def</span> <span class=nf>expand</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>pcoll</span><span class=p>):</span>
    <span class=c1># Transform logic goes here.</span>
    <span class=k>return</span> <span class=n>pcoll</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>Map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>))</span></code></pre></div></div><p>As long as you override the <code>expand</code> method in your <code>PTransform</code> subclass to
accept the appropriate input <code>PCollection</code>(s) and return the corresponding
output <code>PCollection</code>(s), you can include as many transforms as you want. These
transforms can include core transforms, composite transforms, or the transforms
included in the Beam SDK libraries.</p><p>Your composite transform&rsquo;s parameters and return value must match the initial
input type and final return type for the entire transform, even if the
transform&rsquo;s intermediate data changes type multiple times.</p><p><strong>Note:</strong> The <code>expand</code> method of a <code>PTransform</code> is not meant to be invoked
directly by the user of a transform. Instead, you should call the <code>apply</code> method
on the <code>PCollection</code> itself, with the transform as an argument. This allows
transforms to be nested within the structure of your pipeline.</p><h4 id=ptransform-style-guide>4.6.3. PTransform Style Guide</h4><p>The <a href=/contribute/ptransform-style-guide/>PTransform Style Guide</a>
contains additional information not included here, such as style guidelines,
logging and testing guidance, and language-specific considerations. The guide
is a useful starting point when you want to write new composite PTransforms.</p><h2 id=pipeline-io>5. Pipeline I/O</h2><p>When you create a pipeline, you often need to read data from some external
source, such as a file or a database. Likewise, you may
want your pipeline to output its result data to an external storage system.
Beam provides read and write transforms for a <a href=/documentation/io/built-in/>number of common data storage
types</a>. If you want your pipeline
to read from or write to a data storage format that isn&rsquo;t supported by the
built-in transforms, you can <a href=/documentation/io/developing-io-overview/>implement your own read and write
transforms</a>.</p><h3 id=pipeline-io-reading-data>5.1. Reading input data</h3><p>Read transforms read data from an external source and return a <code>PCollection</code>
representation of the data for use by your pipeline. You can use a read
transform at any point while constructing your pipeline to create a new
<code>PCollection</code>, though it will be most common at the start of your pipeline.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>lines</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>TextIO</span><span class=o>.</span><span class=na>read</span><span class=o>().</span><span class=na>from</span><span class=o>(</span><span class=s>&#34;gs://some/inputData.txt&#34;</span><span class=o>));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>lines</span> <span class=o>=</span> <span class=n>pipeline</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>ReadFromText</span><span class=p>(</span><span class=s1>&#39;gs://some/inputData.txt&#39;</span><span class=p>)</span></code></pre></div></div><h3 id=pipeline-io-writing-data>5.2. Writing output data</h3><p>Write transforms write the data in a <code>PCollection</code> to an external data source.
You will most often use write transforms at the end of your pipeline to output
your pipeline&rsquo;s final results. However, you can use a write transform to output
a <code>PCollection</code>'s data at any point in your pipeline.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>output</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>TextIO</span><span class=o>.</span><span class=na>write</span><span class=o>().</span><span class=na>to</span><span class=o>(</span><span class=s>&#34;gs://some/outputData&#34;</span><span class=o>));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>output</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>WriteToText</span><span class=p>(</span><span class=s1>&#39;gs://some/outputData&#39;</span><span class=p>)</span></code></pre></div></div><h3 id=file-based-data>5.3. File-based input and output data</h3><h4 id=file-based-reading-multiple-locations>5.3.1. Reading from multiple locations</h4><p>Many read transforms support reading from multiple input files matching a glob
operator you provide. Note that glob operators are filesystem-specific and obey
filesystem-specific consistency models. The following TextIO example uses a glob
operator (<code>*</code>) to read all matching input files that have prefix &ldquo;input-&rdquo; and the
suffix &ldquo;.csv&rdquo; in the given location:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>p</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=s>&#34;ReadFromText&#34;</span><span class=o>,</span>
    <span class=n>TextIO</span><span class=o>.</span><span class=na>read</span><span class=o>().</span><span class=na>from</span><span class=o>(</span><span class=s>&#34;protocol://my_bucket/path/to/input-*.csv&#34;</span><span class=o>));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>lines</span> <span class=o>=</span> <span class=n>p</span> <span class=o>|</span> <span class=s1>&#39;ReadFromText&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>ReadFromText</span><span class=p>(</span><span class=s1>&#39;path/to/input-*.csv&#39;</span><span class=p>)</span></code></pre></div></div><p>To read data from disparate sources into a single <code>PCollection</code>, read each one
independently and then use the <a href=#flatten>Flatten</a> transform to create a single
<code>PCollection</code>.</p><h4 id=file-based-writing-multiple-files>5.3.2. Writing to multiple output files</h4><p>For file-based output data, write transforms write to multiple output files by
default. When you pass an output file name to a write transform, the file name
is used as the prefix for all output files that the write transform produces.
You can append a suffix to each output file by specifying a suffix.</p><p>The following write transform example writes multiple output files to a
location. Each file has the prefix &ldquo;numbers&rdquo;, a numeric tag, and the suffix
&ldquo;.csv&rdquo;.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>records</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=s>&#34;WriteToText&#34;</span><span class=o>,</span>
    <span class=n>TextIO</span><span class=o>.</span><span class=na>write</span><span class=o>().</span><span class=na>to</span><span class=o>(</span><span class=s>&#34;protocol://my_bucket/path/to/numbers&#34;</span><span class=o>)</span>
                <span class=o>.</span><span class=na>withSuffix</span><span class=o>(</span><span class=s>&#34;.csv&#34;</span><span class=o>));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>filtered_words</span> <span class=o>|</span> <span class=s1>&#39;WriteToText&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>WriteToText</span><span class=p>(</span>
    <span class=s1>&#39;/path/to/numbers&#39;</span><span class=p>,</span> <span class=n>file_name_suffix</span><span class=o>=</span><span class=s1>&#39;.csv&#39;</span><span class=p>)</span></code></pre></div></div><h3 id=provided-io-transforms>5.4. Beam-provided I/O transforms</h3><p>See the <a href=/documentation/io/built-in/>Beam-provided I/O Transforms</a>
page for a list of the currently available I/O transforms.</p><h2 id=schemas>6. Schemas</h2><p>Often, the types of the records being processed have an obvious structure. Common Beam sources produce
JSON, Avro, Protocol Buffer, or database row objects; all of these types have well defined structures,
structures that can often be determined by examining the type. Even within a SDK pipeline, Simple Java POJOs
(or equivalent structures in other languages) are often used as intermediate types, and these also have a
clear structure that can be inferred by inspecting the class. By understanding the structure of a pipeline’s
records, we can provide much more concise APIs for data processing.</p><h3 id=what-is-a-schema>6.1. What is a schema?</h3><p>Most structured records share some common characteristics:</p><ul><li>They can be subdivided into separate named fields. Fields usually have string names, but sometimes - as in the case of indexed
tuples - have numerical indices instead.</li><li>There is a confined list of primitive types that a field can have. These often match primitive types in most programming
languages: int, long, string, etc.</li><li>Often a field type can be marked as optional (sometimes referred to as nullable) or required.</li></ul><p>Often records have a nested structure. A nested structure occurs when a field itself has subfields so the
type of the field itself has a schema. Fields that are array or map types is also a common feature of these structured
records.</p><p>For example, consider the following schema, representing actions in a fictitious e-commerce company:</p><p><strong>Purchase</strong></p><table><thead><tr class=header><th><b>Field Name</b></th><th><b>Field Type</b></th></tr></thead><tbody><tr><td>userId</td><td>STRING</td></tr><tr><td>itemId</td><td>INT64</td></tr><tr><td>shippingAddress</td><td>ROW(ShippingAddress)</td></tr><tr><td>cost</td><td>INT64</td></tr><tr><td>transactions</td><td>ARRAY[ROW(Transaction)]</td></tr></tbody></table><br><p><strong>ShippingAddress</strong></p><table><thead><tr class=header><th><b>Field Name</b></th><th><b>Field Type</b></th></tr></thead><tbody><tr><td>streetAddress</td><td>STRING</td></tr><tr><td>city</td><td>STRING</td></tr><tr><td>state</td><td>nullable STRING</td></tr><tr><td>country</td><td>STRING</td></tr><tr><td>postCode</td><td>STRING</td></tr></tbody></table><br><p><strong>Transaction</strong></p><table><thead><tr class=header><th><b>Field Name</b></th><th><b>Field Type</b></th></tr></thead><tbody><tr><td>bank</td><td>STRING</td></tr><tr><td>purchaseAmount</td><td>DOUBLE</td></tr></tbody></table><br><p>Purchase event records are represented by the above purchase schema. Each purchase event contains a shipping address, which
is a nested row containing its own schema. Each purchase also contains an array of credit-card transactions
(a list, because a purchase might be split across multiple credit cards); each item in the transaction list is a row
with its own schema.</p><p>This provides an abstract description of the types involved, one that is abstracted away from any specific programming
language.</p><p>Schemas provide us a type-system for Beam records that is independent of any specific programming-language type. There
might be multiple Java classes that all have the same schema (for example a Protocol-Buffer class or a POJO class),
and Beam will allow us to seamlessly convert between these types. Schemas also provide a simple way to reason about
types across different programming-language APIs.</p><p>A <code>PCollection</code> with a schema does not need to have a <code>Coder</code> specified, as Beam knows how to encode and decode
Schema rows; Beam uses a special coder to encode schema types.</p><h3 id=schemas-for-pl-types>6.2. Schemas for programming language types</h3><p>While schemas themselves are language independent, they are designed to embed naturally into the programming languages
of the Beam SDK being used. This allows Beam users to continue using native types while reaping the advantage of
having Beam understand their element schemas.</p><p class=language-java>In Java you could use the following set of classes to represent the purchase schema. Beam will automatically<br>infer the correct schema based on the members of the class.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@DefaultSchema</span><span class=o>(</span><span class=n>JavaBeanSchema</span><span class=o>.</span><span class=na>class</span><span class=o>)</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>Purchase</span> <span class=o>{</span>
  <span class=kd>public</span> <span class=n>String</span> <span class=nf>getUserId</span><span class=o>();</span>  <span class=c1>// Returns the id of the user who made the purchase.
</span><span class=c1></span>  <span class=kd>public</span> <span class=kt>long</span> <span class=nf>getItemId</span><span class=o>();</span>  <span class=c1>// Returns the identifier of the item that was purchased.
</span><span class=c1></span>  <span class=kd>public</span> <span class=n>ShippingAddress</span> <span class=nf>getShippingAddress</span><span class=o>();</span>  <span class=c1>// Returns the shipping address, a nested type.
</span><span class=c1></span>  <span class=kd>public</span> <span class=kt>long</span> <span class=nf>getCostCents</span><span class=o>();</span>  <span class=c1>// Returns the cost of the item.
</span><span class=c1></span>  <span class=kd>public</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Transaction</span><span class=o>&gt;</span> <span class=nf>getTransactions</span><span class=o>();</span>  <span class=c1>// Returns the transactions that paid for this purchase (returns a list, since the purchase might be spread out over multiple credit cards).
</span><span class=c1></span>  
  <span class=nd>@SchemaCreate</span>
  <span class=kd>public</span> <span class=nf>Purchase</span><span class=o>(</span><span class=n>String</span> <span class=n>userId</span><span class=o>,</span> <span class=kt>long</span> <span class=n>itemId</span><span class=o>,</span> <span class=n>ShippingAddress</span> <span class=n>shippingAddress</span><span class=o>,</span> <span class=kt>long</span> <span class=n>costCents</span><span class=o>,</span> 
                  <span class=n>List</span><span class=o>&lt;</span><span class=n>Transaction</span><span class=o>&gt;</span> <span class=n>transactions</span><span class=o>)</span> <span class=o>{</span>
      <span class=o>...</span>
  <span class=o>}</span>
<span class=o>}</span>

<span class=nd>@DefaultSchema</span><span class=o>(</span><span class=n>JavaBeanSchema</span><span class=o>.</span><span class=na>class</span><span class=o>)</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>ShippingAddress</span> <span class=o>{</span>
  <span class=kd>public</span> <span class=n>String</span> <span class=nf>getStreetAddress</span><span class=o>();</span>
  <span class=kd>public</span> <span class=n>String</span> <span class=nf>getCity</span><span class=o>();</span>
  <span class=nd>@Nullable</span> <span class=kd>public</span> <span class=n>String</span> <span class=nf>getState</span><span class=o>();</span>
  <span class=kd>public</span> <span class=n>String</span> <span class=nf>getCountry</span><span class=o>();</span>
  <span class=kd>public</span> <span class=n>String</span> <span class=nf>getPostCode</span><span class=o>();</span>
  
  <span class=nd>@SchemaCreate</span>
  <span class=kd>public</span> <span class=nf>ShippingAddress</span><span class=o>(</span><span class=n>String</span> <span class=n>streetAddress</span><span class=o>,</span> <span class=n>String</span> <span class=n>city</span><span class=o>,</span> <span class=nd>@Nullable</span> <span class=n>String</span> <span class=n>state</span><span class=o>,</span> <span class=n>String</span> <span class=n>country</span><span class=o>,</span>
                         <span class=n>String</span> <span class=n>postCode</span><span class=o>)</span> <span class=o>{</span>
     <span class=o>...</span>
  <span class=o>}</span>
<span class=o>}</span>

<span class=nd>@DefaultSchema</span><span class=o>(</span><span class=n>JavaBeanSchema</span><span class=o>.</span><span class=na>class</span><span class=o>)</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>Transaction</span> <span class=o>{</span>
  <span class=kd>public</span> <span class=n>String</span> <span class=nf>getBank</span><span class=o>();</span>
  <span class=kd>public</span> <span class=kt>double</span> <span class=nf>getPurchaseAmount</span><span class=o>();</span>
 
  <span class=nd>@SchemaCreate</span>
  <span class=kd>public</span> <span class=nf>Transaction</span><span class=o>(</span><span class=n>String</span> <span class=n>bank</span><span class=o>,</span> <span class=kt>double</span> <span class=n>purchaseAmount</span><span class=o>)</span> <span class=o>{</span>
     <span class=o>...</span>
  <span class=o>}</span>
<span class=o>}</span></code></pre></div></div><p>Using JavaBean classes as above is one way to map a schema to Java classes. However multiple Java classes might have
the same schema, in which case the different Java types can often be used interchangeably. Beam will add implicit
conversions between types that have matching schemas. For example, the above
<code>Transaction</code> class has the same schema as the following class:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@DefaultSchema</span><span class=o>(</span><span class=n>JavaFieldSchema</span><span class=o>.</span><span class=na>class</span><span class=o>)</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>TransactionPojo</span> <span class=o>{</span>
  <span class=kd>public</span> <span class=n>String</span> <span class=n>bank</span><span class=o>;</span>
  <span class=kd>public</span> <span class=kt>double</span> <span class=n>purchaseAmount</span><span class=o>;</span>
<span class=o>}</span></code></pre></div></div><p>So if we had two <code>PCollection</code>s as follows</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Transaction</span><span class=o>&gt;</span> <span class=n>transactionBeans</span> <span class=o>=</span> <span class=n>readTransactionsAsJavaBean</span><span class=o>();</span>
<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>TransactionPojos</span><span class=o>&gt;</span> <span class=n>transactionPojos</span> <span class=o>=</span> <span class=n>readTransactionsAsPojo</span><span class=o>();</span></code></pre></div></div><p>Then these two <code>PCollection</code>s would have the same schema, even though their Java types would be different. This means
for example the following two code snippets are valid:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>transactionBeans</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;...&gt;()</span> <span class=o>{</span>
   <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>TransactionPojo</span> <span class=n>pojo</span><span class=o>)</span> <span class=o>{</span>
      <span class=o>...</span>
   <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><p>and<div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>transactionPojos</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;...&gt;()</span> <span class=o>{</span>
   <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>Transaction</span> <span class=n>row</span><span class=o>)</span> <span class=o>{</span>
    <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div></p><p>Even though the in both cases the <code>@Element</code> parameter differs from the the <code>PCollection</code>'s Java type, since the
schemas are the same Beam will automatically make the conversion. The built-in <code>Convert</code> transform can also be used
to translate between Java types of equivalent schemas, as detailed below.</p><h3 id=schema-definition>6.3. Schema definition</h3><p>The schema for a <code>PCollection</code> defines elements of that <code>PCollection</code> as an ordered list of named fields. Each field
has a name, a type, and possibly a set of user options. The type of a field can be primitive or composite. The following
are the primitive types currently supported by Beam:</p><table><thead><tr class=header><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>BYTE</td><td>An 8-bit signed value</td></tr><tr><td>INT16</td><td>A 16-bit signed value</td></tr><tr><td>INT32</td><td>A 32-bit signed value</td></tr><tr><td>INT64</td><td>A 64-bit signed value</td></tr><tr><td>DECIMAL</td><td>An arbitrary-precision decimal type</td></tr><tr><td>FLOAT</td><td>A 32-bit IEEE 754 floating point number</td></tr><tr><td>DOUBLE</td><td>A 64-bit IEEE 754 floating point number</td></tr><tr><td>STRING</td><td>A string</td></tr><tr><td>DATETIME</td><td>A timestamp represented as milliseconds since the epoch</td></tr><tr><td>BOOLEAN</td><td>A boolean value</td></tr><tr><td>BYTES</td><td>A raw byte array</td></tr></tbody></table><br><p>A field can also reference a nested schema. In this case, the field will have type ROW, and the nested schema will
be an attribute of this field type.</p><p>Three collection types are supported as field types: ARRAY, ITERABLE and MAP:</p><ul><li><strong>ARRAY</strong> This represents a repeated value type, where the repeated elements can have any supported type. Arrays of
nested rows are supported, as are arrays of arrays.</li><li><strong>ITERABLE</strong> This is very similar to the array type, it represents a repeated value, but one in which the full list of
items is not known until iterated over. This is intended for the case where an iterable might be larger than the
available memory, and backed by external storage (for example, this can happen with the iterable returned by a
<code>GroupByKey</code>). The repeated elements can have any supported type.</li><li><strong>MAP</strong> This represents an associative map from keys to values. All schema types are supported for both keys and values.
Values that contain map types cannot be used as keys in any grouping operation.</li></ul><h3 id=logical-types>6.4. Logical types</h3><p>Users can extend the schema type system to add custom logical types that can be used as a field. A logical type is
identified by a unique identifier and an argument. A logical type also specifies an underlying schema type to be used
for storage, along with conversions to and from that type. As an example, a logical union can always be represented as
a row with nullable fields, where the user ensures that only one of those fields is ever set at a time. However this can
be tedious and complex to manage. The OneOf logical type provides a value class that makes it easier to manage the type
as a union, while still using a row with nullable fields as its underlying storage. Each logical type also has a
unique identifier, so they can be interpreted by other languages as well. More examples of logical types are listed
below.</p><h4 id=defining-a-logical-type>6.4.1. Defining a logical type</h4><p>To define a logical type you must specify a Schema type to be used to represent the underlying type as well as a unique
identifier for that type. A logical type imposes additional semantics on top a schema type. For example, a logical
type to represent nanosecond timestamps is represented as a schema containing an INT64 and an INT32 field. This schema
alone does not say anything about how to interpret this type, however the logical type tells you that this represents
a nanosecond timestamp, with the INT64 field representing seconds and the INT32 field representing nanoseconds.</p><p>Logical types are also specified by an argument, which allows creating a class of related types. For example, a
limited-precision decimal type would have an integer argument indicating how many digits of precision are represented.
The argument is represented by a schema type, so can itself be a complex type.</p><p class=language-java>In Java, a logical type is specified as a subclass of the <code>LogicalType</code> class. A custom Java class can be specified to represent the logical type and conversion functions must be supplied to convert back and forth between this Java class and the underlying Schema type representation. For example, the logical type representing nanosecond timestamp might be implemented as follows</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// A Logical type using java.time.Instant to represent the logical type.
</span><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>TimestampNanos</span> <span class=kd>implements</span> <span class=n>LogicalType</span><span class=o>&lt;</span><span class=n>Instant</span><span class=o>,</span> <span class=n>Row</span><span class=o>&gt;</span> <span class=o>{</span>
  <span class=c1>// The underlying schema used to represent rows.
</span><span class=c1></span>  <span class=kd>private</span> <span class=kd>final</span> <span class=n>Schema</span> <span class=n>SCHEMA</span> <span class=o>=</span> <span class=n>Schema</span><span class=o>.</span><span class=na>builder</span><span class=o>().</span><span class=na>addInt64Field</span><span class=o>(</span><span class=s>&#34;seconds&#34;</span><span class=o>).</span><span class=na>addInt32Field</span><span class=o>(</span><span class=s>&#34;nanos&#34;</span><span class=o>).</span><span class=na>build</span><span class=o>();</span>
  <span class=nd>@Override</span> <span class=kd>public</span> <span class=n>String</span> <span class=nf>getIdentifier</span><span class=o>()</span> <span class=o>{</span> <span class=k>return</span> <span class=s>&#34;timestampNanos&#34;</span><span class=o>;</span> <span class=o>}</span>
  <span class=nd>@Override</span> <span class=kd>public</span> <span class=n>FieldType</span> <span class=nf>getBaseType</span><span class=o>()</span> <span class=o>{</span> <span class=k>return</span> <span class=n>schema</span><span class=o>;</span> <span class=o>}</span>
  
  <span class=c1>// Convert the representation type to the underlying Row type. Called by Beam when necessary.
</span><span class=c1></span>  <span class=nd>@Override</span> <span class=kd>public</span> <span class=n>Row</span> <span class=nf>toBaseType</span><span class=o>(</span><span class=n>Instant</span> <span class=n>instant</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>return</span> <span class=n>Row</span><span class=o>.</span><span class=na>withSchema</span><span class=o>(</span><span class=n>schema</span><span class=o>).</span><span class=na>addValues</span><span class=o>(</span><span class=n>instant</span><span class=o>.</span><span class=na>getEpochSecond</span><span class=o>(),</span> <span class=n>instant</span><span class=o>.</span><span class=na>getNano</span><span class=o>()).</span><span class=na>build</span><span class=o>();</span>
  <span class=o>}</span>
  
  <span class=c1>// Convert the underlying Row type to and Instant. Called by Beam when necessary.
</span><span class=c1></span>  <span class=nd>@Override</span> <span class=kd>public</span> <span class=n>Instant</span> <span class=nf>toInputType</span><span class=o>(</span><span class=n>Row</span> <span class=n>base</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>return</span> <span class=n>Instant</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>row</span><span class=o>.</span><span class=na>getInt64</span><span class=o>(</span><span class=s>&#34;seconds&#34;</span><span class=o>),</span> <span class=n>row</span><span class=o>.</span><span class=na>getInt32</span><span class=o>(</span><span class=s>&#34;nanos&#34;</span><span class=o>));</span>
  <span class=o>}</span>

     <span class=o>...</span>
<span class=o>}</span></code></pre></div></div><h4 id=built-in-logical-types>6.4.2. Useful logical types</h4><h5 id=enumerationtype><strong>EnumerationType</strong></h5><p>This logical type allows creating an enumeration type consisting of a set of named constants.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Schema</span> <span class=n>schema</span> <span class=o>=</span> <span class=n>Schema</span><span class=o>.</span><span class=na>builder</span><span class=o>()</span>
               <span class=err>…</span>
     <span class=o>.</span><span class=na>addLogicalTypeField</span><span class=o>(</span><span class=s>&#34;color&#34;</span><span class=o>,</span> <span class=n>EnumerationType</span><span class=o>.</span><span class=na>create</span><span class=o>(</span><span class=s>&#34;RED&#34;</span><span class=o>,</span> <span class=s>&#34;GREEN&#34;</span><span class=o>,</span> <span class=s>&#34;BLUE&#34;</span><span class=o>))</span>
     <span class=o>.</span><span class=na>build</span><span class=o>();</span></code></pre></div></div><p>The value of this field is stored in the row as an INT32 type, however the logical type defines a value type that lets
you access the enumeration either as a string or a value. For example:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>EnumerationType</span><span class=o>.</span><span class=na>Value</span> <span class=n>enumValue</span> <span class=o>=</span> <span class=n>enumType</span><span class=o>.</span><span class=na>valueOf</span><span class=o>(</span><span class=s>&#34;RED&#34;</span><span class=o>);</span>
<span class=n>enumValue</span><span class=o>.</span><span class=na>getValue</span><span class=o>();</span>  <span class=c1>// Returns 0, the integer value of the constant.
</span><span class=c1></span><span class=n>enumValue</span><span class=o>.</span><span class=na>toString</span><span class=o>();</span>  <span class=o>//</span> <span class=n>Returns</span> <span class=s>&#34;RED&#34;</span><span class=o>,</span> <span class=n>the</span> <span class=n>string</span> <span class=n>value</span> <span class=n>of</span> <span class=n>the</span> <span class=n>constant</span></code></pre></div></div><p>Given a row object with an enumeration field, you can also extract the field as the enumeration value.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>EnumerationType</span><span class=o>.</span><span class=na>Value</span> <span class=n>enumValue</span> <span class=o>=</span> <span class=n>row</span><span class=o>.</span><span class=na>getLogicalTypeValue</span><span class=o>(</span><span class=s>&#34;color&#34;</span><span class=o>,</span> <span class=n>EnumerationType</span><span class=o>.</span><span class=na>Value</span><span class=o>.</span><span class=na>class</span><span class=o>);</span></code></pre></div></div><p>Automatic schema inference from Java POJOs and JavaBeans automatically converts Java enums to EnumerationType logical
types.</p><h5 id=oneoftype><strong>OneOfType</strong></h5><p>OneOfType allows creating a disjoint union type over a set of schema fields. For example:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Schema</span> <span class=n>schema</span> <span class=o>=</span> <span class=n>Schema</span><span class=o>.</span><span class=na>builder</span><span class=o>()</span>
               <span class=err>…</span>
     <span class=o>.</span><span class=na>addLogicalTypeField</span><span class=o>(</span><span class=s>&#34;oneOfField&#34;</span><span class=o>,</span> 
        <span class=n>OneOfType</span><span class=o>.</span><span class=na>create</span><span class=o>(</span><span class=n>Field</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;intField&#34;</span><span class=o>,</span> <span class=n>FieldType</span><span class=o>.</span><span class=na>INT32</span><span class=o>),</span>
                         <span class=n>Field</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;stringField&#34;</span><span class=o>,</span> <span class=n>FieldType</span><span class=o>.</span><span class=na>STRING</span><span class=o>),</span>
                         <span class=n>Field</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;bytesField&#34;</span><span class=o>,</span> <span class=n>FieldType</span><span class=o>.</span><span class=na>BYTES</span><span class=o>)))</span>
      <span class=o>.</span><span class=na>build</span><span class=o>();</span></code></pre></div></div><p>The value of this field is stored in the row as another Row type, where all the fields are marked as nullable. The
logical type however defines a Value object that contains an enumeration value indicating which field was set and allows
getting just that field:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// Returns an enumeration indicating all possible case values for the enum.
</span><span class=c1>// For the above example, this will be 
</span><span class=c1>// EnumerationType.create(&#34;intField&#34;, &#34;stringField&#34;, &#34;bytesField&#34;);
</span><span class=c1></span><span class=n>EnumerationType</span> <span class=n>oneOfEnum</span> <span class=o>=</span> <span class=n>onOfType</span><span class=o>.</span><span class=na>getCaseEnumType</span><span class=o>();</span>

<span class=c1>// Creates an instance of the union with the string field set.
</span><span class=c1></span><span class=n>OneOfType</span><span class=o>.</span><span class=na>Value</span> <span class=n>oneOfValue</span> <span class=o>=</span> <span class=n>oneOfType</span><span class=o>.</span><span class=na>createValue</span><span class=o>(</span><span class=s>&#34;stringField&#34;</span><span class=o>,</span> <span class=s>&#34;foobar&#34;</span><span class=o>);</span>

<span class=c1>// Handle the oneof
</span><span class=c1></span><span class=k>switch</span> <span class=o>(</span><span class=n>oneOfValue</span><span class=o>.</span><span class=na>getCaseEnumType</span><span class=o>().</span><span class=na>toString</span><span class=o>())</span> <span class=o>{</span>
  <span class=k>case</span> <span class=s>&#34;intField&#34;</span><span class=o>:</span>  
    <span class=k>return</span> <span class=n>processInt</span><span class=o>(</span><span class=n>oneOfValue</span><span class=o>.</span><span class=na>getValue</span><span class=o>(</span><span class=n>Integer</span><span class=o>.</span><span class=na>class</span><span class=o>));</span>
  <span class=k>case</span> <span class=s>&#34;stringField&#34;</span><span class=o>:</span>
    <span class=k>return</span> <span class=n>processString</span><span class=o>(</span><span class=n>oneOfValue</span><span class=o>.</span><span class=na>getValue</span><span class=o>(</span><span class=n>String</span><span class=o>.</span><span class=na>class</span><span class=o>));</span>
  <span class=k>case</span> <span class=s>&#34;bytesField&#34;</span><span class=o>:</span>
    <span class=k>return</span> <span class=n>processBytes</span><span class=o>(</span><span class=n>oneOfValue</span><span class=o>.</span><span class=na>getValue</span><span class=o>(</span><span class=n>bytes</span><span class=o>[].</span><span class=na>class</span><span class=o>));</span>
<span class=o>}</span></code></pre></div></div><p>In the above example we used the field names in the switch statement for clarity, however the enum integer values could
also be used.</p><h3 id=creating-schemas>6.5. Creating Schemas</h3><p>In order to take advantage of schemas, your <code>PCollection</code>s must have a schema attached to it. Often, the source itself will attach a schema to the PCollection. For example, when using <code>AvroIO</code> to read Avro files, the source can automatically infer a Beam schema from the Avro schema and attach that to the Beam <code>PCollection</code>. However not all sources produce schemas. In addition, often Beam pipelines have intermediate stages and types, and those also can benefit from the expressiveness of schemas.</p><h4 id=inferring-schemas>6.5.1. Inferring schemas</h4><p class=language-java>Beam is able to infer schemas from a variety of common Java types. The <code>@DefaultSchema</code> annotation can be used to tell Beam to infer schemas from a specific type. The annotation takes a <code>SchemaProvider</code> as an argument, and <code>SchemaProvider</code> classes are already built in for common Java types. The <code>SchemaRegistry</code> can also be invoked programmatically for cases where it is not practical to annotate the Java type itself.</p><h5 id=java-pojos><strong>Java POJOs</strong></h5><p>A POJO (Plain Old Java Object) is a Java object that is not bound by any restriction other than the Java Language
Specification. A POJO can contain member variables that are primitives, that are other POJOs, or are collections maps or
arrays thereof. POJOs do not have to extend prespecified classes or extend any specific interfaces.</p><p>If a POJO class is annotated with <code>@DefaultSchema(JavaFieldSchema.class)</code>, Beam will automatically infer a schema for
this class. Nested classes are supported as are classes with <code>List</code>, array, and <code>Map</code> fields.</p><p>For example, annotating the following class tells Beam to infer a schema from this POJO class and apply it to any
<code>PCollection&lt;TransactionPojo></code>.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@DefaultSchema</span><span class=o>(</span><span class=n>JavaFieldSchema</span><span class=o>.</span><span class=na>class</span><span class=o>)</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>TransactionPojo</span> <span class=o>{</span>
  <span class=kd>public</span> <span class=kd>final</span> <span class=n>String</span> <span class=n>bank</span><span class=o>;</span>
  <span class=kd>public</span> <span class=kd>final</span> <span class=kt>double</span> <span class=n>purchaseAmount</span><span class=o>;</span>
  <span class=nd>@SchemaCreate</span>
  <span class=kd>public</span> <span class=nf>TransactionPojo</span><span class=o>(</span><span class=n>String</span> <span class=n>bank</span><span class=o>,</span> <span class=kt>double</span> <span class=n>purchaseAmount</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>this</span><span class=o>.</span><span class=na>bank</span> <span class=o>=</span> <span class=n>bank</span><span class=o>.</span>
    <span class=k>this</span><span class=o>.</span><span class=na>purchaseAmount</span> <span class=o>=</span> <span class=n>purchaseAmount</span><span class=o>;</span>
  <span class=o>}</span>
<span class=o>}</span>
<span class=c1>// Beam will automatically infer the correct schema for this PCollection. No coder is needed as a result.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>TransactionPojo</span><span class=o>&gt;</span> <span class=n>pojos</span> <span class=o>=</span> <span class=n>readPojos</span><span class=o>();</span></code></pre></div></div><p>The <code>@SchemaCreate</code> annotation tells Beam that this constructor can be used to create instances of TransactionPojo,
assuming that constructor parameters have the same names as the field names. <code>@SchemaCreate</code> can also be used to annotate
static factory methods on the class, allowing the constructor to remain private. If there is no <code>@SchemaCreate</code>
annotation then all the fields must be non-final and the class must have a zero-argument constructor.</p><p>There are a couple of other useful annotations that affect how Beam infers schemas. By default the schema field names
inferred will match that of the class field names. However <code>@SchemaFieldName</code> can be used to specify a different name to
be used for the schema field. <code>@SchemaIgnore</code> can be used to mark specific class fields as excluded from the inferred
schema. For example, it’s common to have ephemeral fields in a class that should not be included in a schema
(e.g. caching the hash value to prevent expensive recomputation of the hash), and <code>@SchemaIgnore</code> can be used to
exclude these fields. Note that ignored fields will not be included in the encoding of these records.</p><p>In some cases it is not convenient to annotate the POJO class, for example if the POJO is in a different package that is
not owned by the Beam pipeline author. In these cases the schema inference can be triggered programmatically in
pipeline’s main function as follows:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java> <span class=n>pipeline</span><span class=o>.</span><span class=na>getSchemaRegistry</span><span class=o>().</span><span class=na>registerPOJO</span><span class=o>(</span><span class=n>TransactionPOJO</span><span class=o>.</span><span class=na>class</span><span class=o>);</span> </code></pre></div></div><h5 id=java-beans><strong>Java Beans</strong></h5><p>Java Beans are a de-facto standard for creating reusable property classes in Java. While the full
standard has many characteristics, the key ones are that all properties are accessed via getter and setter classes, and
the name format for these getters and setters is standardized. A Java Bean class can be annotated with
<code>@DefaultSchema(JavaBeanSchema.class)</code> and Beam will automatically infer a schema for this class. For example:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@DefaultSchema</span><span class=o>(</span><span class=n>JavaBeanSchema</span><span class=o>.</span><span class=na>class</span><span class=o>)</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>TransactionBean</span> <span class=o>{</span>
  <span class=kd>public</span> <span class=nf>TransactionBean</span><span class=o>()</span> <span class=o>{</span> <span class=err>…</span> <span class=o>}</span> 
  <span class=kd>public</span> <span class=n>String</span> <span class=nf>getBank</span><span class=o>()</span> <span class=o>{</span> <span class=err>…</span> <span class=o>}</span>
  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>setBank</span><span class=o>(</span><span class=n>String</span> <span class=n>bank</span><span class=o>)</span> <span class=o>{</span> <span class=err>…</span> <span class=o>}</span>
  <span class=kd>public</span> <span class=kt>double</span> <span class=nf>getPurchaseAmount</span><span class=o>()</span> <span class=o>{</span> <span class=err>…</span> <span class=o>}</span>
  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>setPurchaseAmount</span><span class=o>(</span><span class=kt>double</span> <span class=n>purchaseAmount</span><span class=o>)</span> <span class=o>{</span> <span class=err>…</span> <span class=o>}</span>
<span class=o>}</span>
<span class=c1>// Beam will automatically infer the correct schema for this PCollection. No coder is needed as a result.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>TransactionBean</span><span class=o>&gt;</span> <span class=n>beans</span> <span class=o>=</span> <span class=n>readBeans</span><span class=o>();</span></code></pre></div></div><p>The <code>@SchemaCreate</code> annotation can be used to specify a constructor or a static factory method, in which case the
setters and zero-argument constructor can be omitted.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@DefaultSchema</span><span class=o>(</span><span class=n>JavaBeanSchema</span><span class=o>.</span><span class=na>class</span><span class=o>)</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>TransactionBean</span> <span class=o>{</span>
  <span class=nd>@SchemaCreate</span>
  <span class=n>Public</span> <span class=nf>TransactionBean</span><span class=o>(</span><span class=n>String</span> <span class=n>bank</span><span class=o>,</span> <span class=kt>double</span> <span class=n>purchaseAmount</span><span class=o>)</span> <span class=o>{</span> <span class=err>…</span> <span class=o>}</span>
  <span class=kd>public</span> <span class=n>String</span> <span class=nf>getBank</span><span class=o>()</span> <span class=o>{</span> <span class=err>…</span> <span class=o>}</span>
  <span class=kd>public</span> <span class=kt>double</span> <span class=nf>getPurchaseAmount</span><span class=o>()</span> <span class=o>{</span> <span class=err>…</span> <span class=o>}</span>
<span class=o>}</span></code></pre></div></div><p><code>@SchemaFieldName</code> and <code>@SchemaIgnore</code> can be used to alter the schema inferred, just like with POJO classes.</p><h5 id=autovalue><strong>AutoValue</strong></h5><p>Java value classes are notoriously difficult to generate correctly. There is a lot of boilerplate you must create in
order to properly implement a value class. AutoValue is a popular library for easily generating such classes by
implementing a simple abstract base class.</p><p>Beam can infer a schema from an AutoValue class. For example:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@DefaultSchema</span><span class=o>(</span><span class=n>AutoValueSchema</span><span class=o>.</span><span class=na>class</span><span class=o>)</span>
<span class=nd>@AutoValue</span>
<span class=kd>public</span> <span class=kd>abstract</span> <span class=kd>class</span> <span class=nc>TransactionValue</span> <span class=o>{</span>
  <span class=kd>public</span> <span class=kd>abstract</span> <span class=n>String</span> <span class=nf>getBank</span><span class=o>();</span> 
  <span class=kd>public</span> <span class=kd>abstract</span> <span class=kt>double</span> <span class=nf>getPurchaseAmount</span><span class=o>();</span>
<span class=o>}</span></code></pre></div></div><p>This is all that’s needed to generate a simple AutoValue class, and the above <code>@DefaultSchema</code> annotation tells Beam to
infer a schema from it. This also allows AutoValue elements to be used inside of <code>PCollection</code>s.</p><p><code>@SchemaFieldName</code> and <code>@SchemaIgnore</code> can be used to alter the schema inferred.</p><h3 id=using-schemas>6.6. Using Schema Transforms</h3><p>A schema on a <code>PCollection</code> enables a rich variety of relational transforms. The fact that each record is composed of
named fields allows for simple and readable aggregations that reference fields by name, similar to the aggregations in
a SQL expression.</p><h4 id=661-field-selection-syntax>6.6.1. Field selection syntax</h4><p>The advantage of schemas is that they allow referencing of element fields by name. Beam provides a selection syntax for
referencing fields, including nested and repeated fields. This syntax is used by all of the schema transforms when
referencing the fields they operate on. The syntax can also be used inside of a DoFn to specify which schema fields to
process.</p><p>Addressing fields by name still retains type safety as Beam will check that schemas match at the time the pipeline graph
is constructed. If a field is specified that does not exist in the schema, the pipeline will fail to launch. In addition,
if a field is specified with a type that does not match the type of that field in the schema, the pipeline will fail to
launch.</p><p>The following characters are not allowed in field names: . * [ ] { }</p><h5 id=top-level-fields><strong>Top-level fields</strong></h5><p>In order to select a field at the top level of a schema, the name of the field is specified. For example, to select just
the user ids from a <code>PCollection</code> of purchases one would write (using the <code>Select</code> transform)</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Select</span><span class=o>.</span><span class=na>fieldNames</span><span class=o>(</span><span class=s>&#34;userId&#34;</span><span class=o>));</span></code></pre></div></div><h5 id=nested-fields><strong>Nested fields</strong></h5><p>Individual nested fields can be specified using the dot operator. For example, to select just the postal code from the
shipping address one would write</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Select</span><span class=o>.</span><span class=na>fieldNames</span><span class=o>(</span><span class=s>&#34;shippingAddress.postCode&#34;</span><span class=o>));</span></code></pre></div></div><h5 id=wildcards><strong>Wildcards</strong></h5><p>The * operator can be specified at any nesting level to represent all fields at that level. For example, to select all
shipping-address fields one would write</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Select</span><span class=o>.</span><span class=na>fieldNames</span><span class=o>(</span><span class=s>&#34;shippingAddress.*&#34;</span><span class=o>));</span></code></pre></div></div><h5 id=arrays><strong>Arrays</strong></h5><p>An array field, where the array element type is a row, can also have subfields of the element type addressed. When
selected, the result is an array of the selected subfield type. For example</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Select</span><span class=o>.</span><span class=na>fieldNames</span><span class=o>(</span><span class=s>&#34;transactions[].bank&#34;</span><span class=o>));</span></code></pre></div></div><p>Will result in a row containing an array field with element-type string, containing the list of banks for each
transaction.</p><p>While the use of [] brackets in the selector is recommended, to make it clear that array elements are being selected,
they can be omitted for brevity. In the future, array slicing will be supported, allowing selection of portions of the
array.</p><h5 id=maps><strong>Maps</strong></h5><p>A map field, where the value type is a row, can also have subfields of the value type addressed. When selected, the
result is a map where the keys are the same as in the original map but the value is the specified type. Similar to
arrays, the use of {} curly brackets in the selector is recommended, to make it clear that map value elements are being
selected, they can be omitted for brevity. In the future, map key selectors will be supported, allowing selection of
specific keys from the map. For example, given the following schema:</p><p><strong>PurchasesByType</strong></p><table><thead><tr class=header><th><b>Field Name</b></th><th><b>Field Type</b></th></tr></thead><tbody><tr><td>purchases</td><td>MAP{STRING, ROW{PURCHASE}</td></tr></tbody></table><br><p>The following</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchasesByType</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Select</span><span class=o>.</span><span class=na>fieldNames</span><span class=o>(</span><span class=s>&#34;purchases{}.userId&#34;</span><span class=o>));</span></code></pre></div></div><p>Will result in a row containing a map field with key-type string and value-type string. The selected map will contain
all of the keys from the original map, and the values will be the userId contained in the purchase record.</p><p>While the use of {} brackets in the selector is recommended, to make it clear that map value elements are being selected,
they can be omitted for brevity. In the future, map slicing will be supported, allowing selection of specific keys from
the map.</p><h4 id=662-schema-transforms>6.6.2. Schema transforms</h4><p>Beam provides a collection of transforms that operate natively on schemas. These transforms are very expressive,
allowing selections and aggregations in terms of named schema fields. Following are some examples of useful
schema transforms.</p><h5 id=selecting-input><strong>Selecting input</strong></h5><p>Often a computation is only interested in a subset of the fields in an input <code>PCollection</code>. The <code>Select</code> transform allows
one to easily project out only the fields of interest. The resulting <code>PCollection</code> has a schema containing each selected
field as a top-level field. Both top-level and nested fields can be selected. For example, in the Purchase schema, one
could select only the userId and streetAddress fields as follows</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Select</span><span class=o>.</span><span class=na>fieldNames</span><span class=o>(</span><span class=s>&#34;userId&#34;</span><span class=o>,</span> <span class=s>&#34;shippingAddress.streetAddress&#34;</span><span class=o>));</span></code></pre></div></div><p>The resulting <code>PCollection</code> will have the following schema</p><table><thead><tr class=header><th><b>Field Name</b></th><th><b>Field Type</b></th></tr></thead><tbody><tr><td>userId</td><td>STRING</td></tr><tr><td>streetAddress</td><td>STRING</td></tr></tbody></table><br><p>The same is true for wildcard selections. The following</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Select</span><span class=o>.</span><span class=na>fieldNames</span><span class=o>(</span><span class=s>&#34;userId&#34;</span><span class=o>,</span> <span class=s>&#34;shippingAddress.*&#34;</span><span class=o>));</span></code></pre></div></div><p>Will result in the following schema</p><table><thead><tr class=header><th><b>Field Name</b></th><th><b>Field Type</b></th></tr></thead><tbody><tr><td>userId</td><td>STRING</td></tr><tr><td>streetAddress</td><td>STRING</td></tr><tr><td>city</td><td>STRING</td></tr><tr><td>state</td><td>nullable STRING</td></tr><tr><td>country</td><td>STRING</td></tr><tr><td>postCode</td><td>STRING</td></tr></tbody></table><br><p>When selecting fields nested inside of an array, the same rule applies that each selected field appears separately as a
top-level field in the resulting row. This means that if multiple fields are selected from the same nested row, each
selected field will appear as its own array field. For example</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Select</span><span class=o>.</span><span class=na>fieldNames</span><span class=o>(</span> <span class=s>&#34;transactions.bank&#34;</span><span class=o>,</span> <span class=s>&#34;transactions.purchaseAmount&#34;</span><span class=o>));</span></code></pre></div></div><p>Will result in the following schema</p><table><thead><tr class=header><th><b>Field Name</b></th><th><b>Field Type</b></th></tr></thead><tbody><tr><td>bank</td><td>ARRAY[STRING]</td></tr><tr><td>purchaseAmount</td><td>ARRAY[DOUBLE]</td></tr></tbody></table><br><p>Wildcard selections are equivalent to separately selecting each field.</p><p>Selecting fields nested inside of maps have the same semantics as arrays. If you select multiple fields from a map
, then each selected field will be expanded to its own map at the top level. This means that the set of map keys will
be copied, once for each selected field.</p><p>Sometimes different nested rows will have fields with the same name. Selecting multiple of these fields would result in
a name conflict, as all selected fields are put in the same row schema. When this situation arises, the
<code>Select.withFieldNameAs</code> builder method can be used to provide an alternate name for the selected field.</p><p>Another use of the Select transform is to flatten a nested schema into a single flat schema. For example</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Select</span><span class=o>.</span><span class=na>flattenedSchema</span><span class=o>());</span></code></pre></div></div><p>Will result in the following schema</p><table><thead><tr class=header><th><b>Field Name</b></th><th><b>Field Type</b></th></tr></thead><tbody><tr><td>userId</td><td>STRING</td></tr><tr><td>itemId</td><td>STRING</td></tr><tr><td>shippingAddress_streetAddress</td><td>STRING</td></tr><tr><td>shippingAddress_city</td><td>nullable STRING</td></tr><tr><td>shippingAddress_state</td><td>STRING</td></tr><tr><td>shippingAddress_country</td><td>STRING</td></tr><tr><td>shippingAddress_postCode</td><td>STRING</td></tr><tr><td>costCents</td><td>INT64</td></tr><tr><td>transactions_bank</td><td>ARRAY[STRING]</td></tr><tr><td>transactions_purchaseAmount</td><td>ARRAY[DOUBLE]</td></tr></tbody></table><br><h5 id=grouping-aggregations><strong>Grouping aggregations</strong></h5><p>The <code>Group</code> transform allows simply grouping data by any number of fields in the input schema, applying aggregations to
those groupings, and storing the result of those aggregations in a new schema field. The output of the <code>Group</code> transform
has a schema with one field corresponding to each aggregation performed.</p><p>The simplest usage of <code>Group</code> specifies no aggregations, in which case all inputs matching the provided set of fields
are grouped together into an <code>ITERABLE</code> field. For example</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Group</span><span class=o>.</span><span class=na>byFieldNames</span><span class=o>(</span><span class=s>&#34;userId&#34;</span><span class=o>,</span> <span class=s>&#34;shippingAddress.streetAddress&#34;</span><span class=o>));</span></code></pre></div></div><p>The output schema of this is:</p><table><thead><tr class=header><th><b>Field Name</b></th><th><b>Field Type</b></th></tr></thead><tbody><tr><td>key</td><td>ROW{userId:STRING, streetAddress:STRING}</td></tr><tr><td>values</td><td>ITERABLE[ROW[Purchase]]</td></tr></tbody></table><br><p>The key field contains the grouping key and the values field contains a list of all the values that matched that key.</p><p>The names of the key and values fields in the output schema can be controlled using this withKeyField and withValueField
builders, as follows:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Group</span><span class=o>.</span><span class=na>byFieldNames</span><span class=o>(</span><span class=s>&#34;userId&#34;</span><span class=o>,</span> <span class=s>&#34;shippingAddress.streetAddress&#34;</span><span class=o>)</span>
    <span class=o>.</span><span class=na>withKeyField</span><span class=o>(</span><span class=s>&#34;userAndStreet&#34;</span><span class=o>)</span>
    <span class=o>.</span><span class=na>withValueField</span><span class=o>(</span><span class=s>&#34;matchingPurchases&#34;</span><span class=o>));</span></code></pre></div></div><p>It is quite common to apply one or more aggregations to the grouped result. Each aggregation can specify one or more fields
to aggregate, an aggregation function, and the name of the resulting field in the output schema. For example, the
following application computes three aggregations grouped by userId, with all aggregations represented in a single
output schema:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Group</span><span class=o>.</span><span class=na>byFieldNames</span><span class=o>(</span><span class=s>&#34;userId&#34;</span><span class=o>)</span>
    <span class=o>.</span><span class=na>aggregateField</span><span class=o>(</span><span class=s>&#34;itemId&#34;</span><span class=o>,</span> <span class=n>Count</span><span class=o>.</span><span class=na>combineFn</span><span class=o>(),</span> <span class=s>&#34;numPurchases&#34;</span><span class=o>)</span>
    <span class=o>.</span><span class=na>aggregateField</span><span class=o>(</span><span class=s>&#34;costCents&#34;</span><span class=o>,</span> <span class=n>Sum</span><span class=o>.</span><span class=na>ofLongs</span><span class=o>(),</span> <span class=s>&#34;totalSpendCents&#34;</span><span class=o>)</span>
    <span class=o>.</span><span class=na>aggregateField</span><span class=o>(</span><span class=s>&#34;costCents&#34;</span><span class=o>,</span> <span class=n>Top</span><span class=o>.&lt;</span><span class=n>Long</span><span class=o>&gt;</span><span class=n>largestLongsFn</span><span class=o>(</span><span class=n>10</span><span class=o>),</span> <span class=s>&#34;topPurchases&#34;</span><span class=o>));</span></code></pre></div></div><p>The result of this aggregation will have the following schema:</p><table><thead><tr class=header><th><b>Field Name</b></th><th><b>Field Type</b></th></tr></thead><tbody><tr><td>key</td><td>ROW{userId:STRING}</td></tr><tr><td>value</td><td>ROW{numPurchases: INT64, totalSpendCents: INT64, topPurchases: ARRAY[INT64]}</td></tr></tbody></table><br><p>Often <code>Selected.flattenedSchema</code> will be use to flatten the result into a non-nested, flat schema.</p><h5 id=joins><strong>Joins</strong></h5><p>Beam supports equijoins on schema <code>PCollections</code> - namely joins where the join condition depends on the equality of a
subset of fields. For example, the following examples uses the Purchases schema to join transactions with the reviews
that are likely associated with that transaction (both the user and product match that in the transaction). This is a
&ldquo;natural join&rdquo; - one in which the same field names are used on both the left-hand and right-hand sides of the join -
and is specified with the <code>using</code> keyword:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Transaction</span><span class=o>&gt;</span> <span class=n>transactions</span> <span class=o>=</span> <span class=n>readTransactions</span><span class=o>();</span>
<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Review</span><span class=o>&gt;</span> <span class=n>reviews</span> <span class=o>=</span> <span class=n>readReviews</span><span class=o>();</span>
<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Row</span><span class=o>&gt;</span> <span class=n>joined</span> <span class=o>=</span> <span class=n>transactions</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
    <span class=n>Join</span><span class=o>.</span><span class=na>innerJoin</span><span class=o>(</span><span class=n>reviews</span><span class=o>).</span><span class=na>using</span><span class=o>(</span><span class=s>&#34;userId&#34;</span><span class=o>,</span> <span class=s>&#34;productId&#34;</span><span class=o>));</span></code></pre></div></div><p>The resulting schema is the following:</p><table><thead><tr class=header><th><b>Field Name</b></th><th><b>Field Type</b></th></tr></thead><tbody><tr><td>lhs</td><td>ROW{Transaction}</td></tr><tr><td>rhs</td><td>ROW{Review}</td></tr></tbody></table><br><p>Each resulting row contains one Review and one Review that matched the join condition.</p><p>If the fields to match in the two schemas have different names, then the on function can be used. For example, if the
Review schema named those fields differently than the Transaction schema, then we could write the following:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Row</span><span class=o>&gt;</span> <span class=n>joined</span> <span class=o>=</span> <span class=n>transactions</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
    <span class=n>Join</span><span class=o>.</span><span class=na>innerJoin</span><span class=o>(</span><span class=n>reviews</span><span class=o>).</span><span class=na>on</span><span class=o>(</span>
      <span class=n>FieldsEqual</span>
         <span class=o>.</span><span class=na>left</span><span class=o>(</span><span class=s>&#34;userId&#34;</span><span class=o>,</span> <span class=s>&#34;productId&#34;</span><span class=o>)</span>
         <span class=o>.</span><span class=na>right</span><span class=o>(</span><span class=s>&#34;reviewUserId&#34;</span><span class=o>,</span> <span class=s>&#34;reviewProductId&#34;</span><span class=o>)));</span></code></pre></div></div><p>In addition to inner joins, the Join transform supports full outer joins, left outer joins, and right outer joins.</p><h5 id=complex-joins><strong>Complex joins</strong></h5><p>While most joins tend to be binary joins - joining two inputs together - sometimes you have more than two input
streams that all need to be joined on a common key. The <code>CoGroup</code> transform allows joining multiple <code>PCollections</code>
together based on equality of schema fields. Each <code>PCollection</code> can be marked as required or optional in the final
join record, providing a generalization of outer joins to joins with greater than two input <code>PCollection</code>s. The output
can optionally be expanded - providing individual joined records, as in the <code>Join</code> transform. The output can also be
processed in unexpanded format - providing the join key along with Iterables of all records from each input that matched
that key.</p><h5 id=filtering-events><strong>Filtering events</strong></h5><p>The <code>Filter</code> transform can be configured with a set of predicates, each one based one specified fields. Only records for
which all predicates return true will pass the filter. For example the following</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Filter</span>
    <span class=o>.</span><span class=na>whereFieldName</span><span class=o>(</span><span class=s>&#34;costCents&#34;</span><span class=o>,</span> <span class=n>c</span> <span class=o>-&gt;</span> <span class=n>c</span> <span class=o>&gt;</span> <span class=n>100</span> <span class=o>*</span> <span class=n>20</span><span class=o>)</span>
    <span class=o>.</span><span class=na>whereFieldName</span><span class=o>(</span><span class=s>&#34;shippingAddress.country&#34;</span><span class=o>,</span> <span class=n>c</span> <span class=o>-&gt;</span> <span class=n>c</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=s>&#34;de&#34;</span><span class=o>));</span></code></pre></div></div><p>Will produce all purchases made from Germany with a purchase price of greater than twenty cents.</p><h5 id=adding-fields-to-a-schema><strong>Adding fields to a schema</strong></h5><p>The AddFields transform can be used to extend a schema with new fields. Input rows will be extended to the new schema by
inserting null values for the new fields, though alternate default values can be specified; if the default null value
is used then the new field type will be marked as nullable. Nested subfields can be added using the field selection
syntax, including nested fields inside arrays or map values.</p><p>For example, the following application</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>AddFields</span><span class=o>.&lt;</span><span class=n>PurchasePojo</span><span class=o>&gt;</span><span class=n>create</span><span class=o>()</span>
    <span class=o>.</span><span class=na>field</span><span class=o>(</span><span class=s>&#34;timeOfDaySeconds&#34;</span><span class=o>,</span> <span class=n>FieldType</span><span class=o>.</span><span class=na>INT32</span><span class=o>)</span>
    <span class=o>.</span><span class=na>field</span><span class=o>(</span><span class=s>&#34;shippingAddress.deliveryNotes&#34;</span><span class=o>,</span> <span class=n>FieldType</span><span class=o>.</span><span class=na>STRING</span><span class=o>)</span>
    <span class=o>.</span><span class=na>field</span><span class=o>(</span><span class=err>&#34;</span><span class=n>transactions</span><span class=o>.</span><span class=na>isFlagged</span><span class=o>,</span> <span class=n>FieldType</span><span class=o>.</span><span class=na>BOOLEAN</span><span class=o>,</span> <span class=kc>false</span><span class=o>));</span></code></pre></div></div><p>Results in a <code>PCollection</code> with an expanded schema. All of the rows and fields of the input, but also with the specified
fields added to the schema. All resulting rows will have null values filled in for the <strong>timeOfDaySeconds</strong> and the
<strong>shippingAddress.deliveryNotes</strong> fields, and a false value filled in for the <strong>transactions.isFlagged</strong> field.</p><h5 id=removing-fields-from-a-schema><strong>Removing fields from a schema</strong></h5><p><code>DropFields</code> allows specific fields to be dropped from a schema. Input rows will have their schemas truncated, and any
values for dropped fields will be removed from the output. Nested fields can also be dropped using the field selection
syntax.</p><p>For example, the following snippet</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>DropFields</span><span class=o>.</span><span class=na>fields</span><span class=o>(</span><span class=s>&#34;userId&#34;</span><span class=o>,</span> <span class=s>&#34;shippingAddress.streetAddress&#34;</span><span class=o>));</span></code></pre></div></div><p>Results in a copy of the input with those two fields and their corresponding values removed.</p><h5 id=renaming-schema-fields><strong>Renaming schema fields</strong></h5><p><code>RenameFields</code> allows specific fields in a schema to be renamed. The field values in input rows are left unchanged, only
the schema is modified. This transform is often used to prepare records for output to a schema-aware sink, such as an
RDBMS, to make sure that the <code>PCollection</code> schema field names match that of the output. It can also be used to rename
fields generated by other transforms to make them more usable (similar to SELECT AS in SQL). Nested fields can also be
renamed using the field-selection syntax.</p><p>For example, the following snippet</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>RenameFields</span><span class=o>.&lt;</span><span class=n>PurchasePojo</span><span class=o>&gt;</span><span class=n>create</span><span class=o>()</span>
  <span class=o>.</span><span class=na>rename</span><span class=o>(</span><span class=s>&#34;userId&#34;</span><span class=o>,</span> <span class=s>&#34;userIdentifier&#34;</span><span class=o>)</span>
  <span class=o>.</span><span class=na>rename</span><span class=o>(</span><span class=s>&#34;shippingAddress.streetAddress&#34;</span><span class=o>,</span> <span class=s>&#34;shippingAddress.street&#34;</span><span class=o>));</span></code></pre></div></div><p>Results in the same set of unmodified input elements, however the schema on the PCollection has been changed to rename
<strong>userId</strong> to <strong>userIdentifier</strong> and <strong>shippingAddress.streetAddress</strong> to <strong>shippingAddress.street</strong>.</p><h5 id=converting-between-types><strong>Converting between types</strong></h5><p>As mentioned, Beam can automatically convert between different Java types, as long as those types have equivalent
schemas. One way to do this is by using the <code>Convert</code> transform, as follows.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>PurchaseBean</span><span class=o>&gt;</span> <span class=n>purchaseBeans</span> <span class=o>=</span> <span class=n>readPurchasesAsBeans</span><span class=o>();</span>
<span class=n>PCollection</span><span class=o>&lt;</span><span class=n>PurchasePojo</span><span class=o>&gt;</span> <span class=n>pojoPurchases</span> <span class=o>=</span> 
    <span class=n>purchaseBeans</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Convert</span><span class=o>.</span><span class=na>to</span><span class=o>(</span><span class=n>PurchasePojo</span><span class=o>.</span><span class=na>class</span><span class=o>));</span></code></pre></div></div><p>Beam will validate that the inferred schema for <code>PurchasePojo</code> matches that of the input <code>PCollection</code>, and will
then cast to a <code>PCollection&lt;PurchasePojo></code>.</p><p>Since the <code>Row</code> class can support any schema, any <code>PCollection</code> with schema can be cast to a <code>PCollection</code> of rows, as
follows.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Row</span><span class=o>&gt;</span> <span class=n>purchaseRows</span> <span class=o>=</span> <span class=n>purchaseBeans</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Convert</span><span class=o>.</span><span class=na>toRows</span><span class=o>());</span></code></pre></div></div><p>If the source type is a single-field schema, Convert will also convert to the type of the field if asked, effectively
unboxing the row. For example, give a schema with a single INT64 field, the following will convert it to a
<code>PCollection&lt;Long></code></p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>&gt;</span> <span class=n>longs</span> <span class=o>=</span> <span class=n>rows</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Convert</span><span class=o>.</span><span class=na>to</span><span class=o>(</span><span class=n>TypeDescriptors</span><span class=o>.</span><span class=na>longs</span><span class=o>()));</span></code></pre></div></div><p>In all cases, type checking is done at pipeline graph construction, and if the types do not match the schema then the
pipeline will fail to launch.</p><h4 id=663-schemas-in-pardo>6.6.3. Schemas in ParDo</h4><p>A <code>PCollection</code> with a schema can apply a <code>ParDo</code>, just like any other <code>PCollection</code>. However the Beam runner is aware
of schemas when applying a <code>ParDo</code>, which enables additional functionality.</p><h5 id=input-conversion><strong>Input conversion</strong></h5><p>Since Beam knows the schema of the source <code>PCollection</code>, it can automatically convert the elements to any Java type for
which a matching schema is known. For example, using the above-mentioned Transaction schema, say we have the following
<code>PCollection</code>:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>PurchasePojo</span><span class=o>&gt;</span> <span class=n>purchases</span> <span class=o>=</span> <span class=n>readPurchases</span><span class=o>();</span></code></pre></div></div><p>If there were no schema, then the applied <code>DoFn</code> would have to accept an element of type <code>TransactionPojo</code>. However
since there is a schema, you could apply the following DoFn:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>appy</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>PurchasePojo</span><span class=o>,</span> <span class=n>PurchasePojo</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>PurchaseBean</span> <span class=n>purchase</span><span class=o>)</span> <span class=o>{</span>
      <span class=o>...</span>
  <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><p>Even though the <code>@Element</code> parameter does not match the Java type of the <code>PCollection</code>, since it has a matching schema
Beam will automatically convert elements. If the schema does not match, Beam will detect this at graph-construction time
and will fail the job with a type error.</p><p>Since every schema can be represented by a Row type, Row can also be used here:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>appy</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>PurchasePojo</span><span class=o>,</span> <span class=n>PurchasePojo</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>Row</span> <span class=n>purchase</span><span class=o>)</span> <span class=o>{</span>
      <span class=o>...</span>
  <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><h5 id=input-selection><strong>Input selection</strong></h5><p>Since the input has a schema, you can also automatically select specific fields to process in the DoFn.</p><p>Given the above purchases <code>PCollection</code>, say you want to process just the userId and the itemId fields. You can do these
using the above-described selection expressions, as follows:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>appy</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>PurchasePojo</span><span class=o>,</span> <span class=n>PurchasePojo</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span>
     <span class=nd>@FieldAccess</span><span class=o>(</span><span class=s>&#34;userId&#34;</span><span class=o>)</span> <span class=n>String</span> <span class=n>userId</span><span class=o>,</span> <span class=nd>@FieldAccess</span><span class=o>(</span><span class=s>&#34;itemId&#34;</span><span class=o>)</span> <span class=kt>long</span> <span class=n>itemId</span><span class=o>)</span> <span class=o>{</span>
      <span class=o>...</span>
  <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><p>You can also select nested fields, as follows.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>purchases</span><span class=o>.</span><span class=na>appy</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>PurchasePojo</span><span class=o>,</span> <span class=n>PurchasePojo</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span>
    <span class=nd>@FieldAccess</span><span class=o>(</span><span class=s>&#34;shippingAddress.street&#34;</span><span class=o>)</span> <span class=n>String</span> <span class=n>street</span><span class=o>)</span> <span class=o>{</span>
      <span class=o>...</span>
  <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><p>For more information, see the section on field-selection expressions. When selecting subschemas, Beam will
automatically convert to any matching schema type, just like when reading the entire row.</p><h2 id=data-encoding-and-type-safety>7. Data encoding and type safety</h2><p>When Beam runners execute your pipeline, they often need to materialize the
intermediate data in your <code>PCollection</code>s, which requires converting elements to
and from byte strings. The Beam SDKs use objects called <code>Coder</code>s to describe how
the elements of a given <code>PCollection</code> may be encoded and decoded.</p><blockquote><p>Note that coders are unrelated to parsing or formatting data when interacting
with external data sources or sinks. Such parsing or formatting should
typically be done explicitly, using transforms such as <code>ParDo</code> or
<code>MapElements</code>.</p></blockquote><p class=language-java>In the Beam SDK for Java, the type <code>Coder</code> provides the methods required for
encoding and decoding data. The SDK for Java provides a number of Coder
subclasses that work with a variety of standard Java types, such as Integer,
Long, Double, StringUtf8 and more. You can find all of the available Coder
subclasses in the <a href=https://github.com/apache/beam/tree/master/sdks/java/core/src/main/java/org/apache/beam/sdk/coders>Coder package</a>.</p><p class=language-py>In the Beam SDK for Python, the type <code>Coder</code> provides the methods required for
encoding and decoding data. The SDK for Python provides a number of Coder
subclasses that work with a variety of standard Python types, such as primitive
types, Tuple, Iterable, StringUtf8 and more. You can find all of the available
Coder subclasses in the
<a href=https://github.com/apache/beam/tree/master/sdks/python/apache_beam/coders>apache_beam.coders</a>
package.</p><blockquote><p>Note that coders do not necessarily have a 1:1 relationship with types. For
example, the Integer type can have multiple valid coders, and input and output
data can use different Integer coders. A transform might have Integer-typed
input data that uses BigEndianIntegerCoder, and Integer-typed output data that
uses VarIntCoder.</p></blockquote><h3 id=specifying-coders>7.1. Specifying coders</h3><p>The Beam SDKs require a coder for every <code>PCollection</code> in your pipeline. In most
cases, the Beam SDK is able to automatically infer a <code>Coder</code> for a <code>PCollection</code>
based on its element type or the transform that produces it, however, in some
cases the pipeline author will need to specify a <code>Coder</code> explicitly, or develop
a <code>Coder</code> for their custom type.</p><p class=language-java>You can explicitly set the coder for an existing <code>PCollection</code> by using the
method <code>PCollection.setCoder</code>. Note that you cannot call <code>setCoder</code> on a
<code>PCollection</code> that has been finalized (e.g. by calling <code>.apply</code> on it).</p><p class=language-java>You can get the coder for an existing <code>PCollection</code> by using the method
<code>getCoder</code>. This method will fail with an <code>IllegalStateException</code> if a coder has
not been set and cannot be inferred for the given <code>PCollection</code>.</p><p>Beam SDKs use a variety of mechanisms when attempting to automatically infer the
<code>Coder</code> for a <code>PCollection</code>.</p><p class=language-java>Each pipeline object has a <code>CoderRegistry</code>. The <code>CoderRegistry</code> represents a
mapping of Java types to the default coders that the pipeline should use for
<code>PCollection</code>s of each type.</p><p class=language-py>The Beam SDK for Python has a <code>CoderRegistry</code> that represents a mapping of
Python types to the default coder that should be used for <code>PCollection</code>s of each
type.</p><p class=language-java>By default, the Beam SDK for Java automatically infers the <code>Coder</code> for the
elements of a <code>PCollection</code> produced by a <code>PTransform</code> using the type parameter
from the transform&rsquo;s function object, such as <code>DoFn</code>. In the case of <code>ParDo</code>,
for example, a <code>DoFn&lt;Integer, String></code> function object accepts an input element
of type <code>Integer</code> and produces an output element of type <code>String</code>. In such a
case, the SDK for Java will automatically infer the default <code>Coder</code> for the
output <code>PCollection&lt;String></code> (in the default pipeline <code>CoderRegistry</code>, this is
<code>StringUtf8Coder</code>).</p><p class=language-py>By default, the Beam SDK for Python automatically infers the <code>Coder</code> for the
elements of an output <code>PCollection</code> using the typehints from the transform&rsquo;s
function object, such as <code>DoFn</code>. In the case of <code>ParDo</code>, for example a <code>DoFn</code>
with the typehints <code>@beam.typehints.with_input_types(int)</code> and
<code>@beam.typehints.with_output_types(str)</code> accepts an input element of type int
and produces an output element of type str. In such a case, the Beam SDK for
Python will automatically infer the default <code>Coder</code> for the output <code>PCollection</code>
(in the default pipeline <code>CoderRegistry</code>, this is <code>BytesCoder</code>).</p><blockquote><p>NOTE: If you create your <code>PCollection</code> from in-memory data by using the
<code>Create</code> transform, you cannot rely on coder inference and default coders.
<code>Create</code> does not have access to any typing information for its arguments, and
may not be able to infer a coder if the argument list contains a value whose
exact run-time class doesn&rsquo;t have a default coder registered.</p></blockquote><p class=language-java>When using <code>Create</code>, the simplest way to ensure that you have the correct coder
is by invoking <code>withCoder</code> when you apply the <code>Create</code> transform.</p><h3 id=default-coders-and-the-coderregistry>7.2. Default coders and the CoderRegistry</h3><p>Each Pipeline object has a <code>CoderRegistry</code> object, which maps language types to
the default coder the pipeline should use for those types. You can use the
<code>CoderRegistry</code> yourself to look up the default coder for a given type, or to
register a new default coder for a given type.</p><p><code>CoderRegistry</code> contains a default mapping of coders to standard
<span class=language-java>Java</span><span class=language-py>Python</span>
types for any pipeline you create using the Beam SDK for
<span class=language-java>Java</span><span class=language-py>Python</span>.
The following table shows the standard mapping:</p><p class=language-java><table><thead><tr class=header><th>Java Type</th><th>Default Coder</th></tr></thead><tbody><tr class=odd><td>Double</td><td>DoubleCoder</td></tr><tr class=even><td>Instant</td><td>InstantCoder</td></tr><tr class=odd><td>Integer</td><td>VarIntCoder</td></tr><tr class=even><td>Iterable</td><td>IterableCoder</td></tr><tr class=odd><td>KV</td><td>KvCoder</td></tr><tr class=even><td>List</td><td>ListCoder</td></tr><tr class=odd><td>Map</td><td>MapCoder</td></tr><tr class=even><td>Long</td><td>VarLongCoder</td></tr><tr class=odd><td>String</td><td>StringUtf8Coder</td></tr><tr class=even><td>TableRow</td><td>TableRowJsonCoder</td></tr><tr class=odd><td>Void</td><td>VoidCoder</td></tr><tr class=even><td>byte[ ]</td><td>ByteArrayCoder</td></tr><tr class=odd><td>TimestampedValue</td><td>TimestampedValueCoder</td></tr></tbody></table></p><p class=language-py><table><thead><tr class=header><th>Python Type</th><th>Default Coder</th></tr></thead><tbody><tr class=odd><td>int</td><td>VarIntCoder</td></tr><tr class=even><td>float</td><td>FloatCoder</td></tr><tr class=odd><td>str</td><td>BytesCoder</td></tr><tr class=even><td>bytes</td><td>StrUtf8Coder</td></tr><tr class=odd><td>Tuple</td><td>TupleCoder</td></tr></tbody></table></p><h4 id=default-coder-lookup>7.2.1. Looking up a default coder</h4><p class=language-java>You can use the method <code>CoderRegistry.getCoder</code> to determine the default
Coder for a Java type. You can access the <code>CoderRegistry</code> for a given pipeline
by using the method <code>Pipeline.getCoderRegistry</code>. This allows you to determine
(or set) the default Coder for a Java type on a per-pipeline basis: i.e. &ldquo;for
this pipeline, verify that Integer values are encoded using
<code>BigEndianIntegerCoder</code>.&rdquo;</p><p class=language-py>You can use the method <code>CoderRegistry.get_coder</code> to determine the default Coder
for a Python type. You can use <code>coders.registry</code> to access the <code>CoderRegistry</code>.
This allows you to determine (or set) the default Coder for a Python type.</p><h4 id=setting-default-coder>7.2.2. Setting the default coder for a type</h4><p>To set the default Coder for a
<span class=language-java>Java</span><span class=language-py>Python</span>
type for a particular pipeline, you obtain and modify the pipeline&rsquo;s
<code>CoderRegistry</code>. You use the method
<span class=language-java><code>Pipeline.getCoderRegistry</code></span>
<span class=language-py><code>coders.registry</code></span>
to get the <code>CoderRegistry</code> object, and then use the method
<span class=language-java><code>CoderRegistry.registerCoder</code></span>
<span class=language-py><code>CoderRegistry.register_coder</code></span>
to register a new <code>Coder</code> for the target type.</p><p>The following example code demonstrates how to set a default Coder, in this case
<code>BigEndianIntegerCoder</code>, for
<span class=language-java>Integer</span><span class=language-py>int</span>
values for a pipeline.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PipelineOptions</span> <span class=n>options</span> <span class=o>=</span> <span class=n>PipelineOptionsFactory</span><span class=o>.</span><span class=na>create</span><span class=o>();</span>
<span class=n>Pipeline</span> <span class=n>p</span> <span class=o>=</span> <span class=n>Pipeline</span><span class=o>.</span><span class=na>create</span><span class=o>(</span><span class=n>options</span><span class=o>);</span>

<span class=n>CoderRegistry</span> <span class=n>cr</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>getCoderRegistry</span><span class=o>();</span>
<span class=n>cr</span><span class=o>.</span><span class=na>registerCoder</span><span class=o>(</span><span class=n>Integer</span><span class=o>.</span><span class=na>class</span><span class=o>,</span> <span class=n>BigEndianIntegerCoder</span><span class=o>.</span><span class=na>class</span><span class=o>);</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>apache_beam</span><span class=o>.</span><span class=n>coders</span><span class=o>.</span><span class=n>registry</span><span class=o>.</span><span class=n>register_coder</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=n>BigEndianIntegerCoder</span><span class=p>)</span></code></pre></div></div><h4 id=annotating-custom-type-default-coder>7.2.3. Annotating a custom data type with a default coder</h4><p class=language-java>If your pipeline program defines a custom data type, you can use the
<code>@DefaultCoder</code> annotation to specify the coder to use with that type. For
example, let&rsquo;s say you have a custom data type for which you want to use
<code>SerializableCoder</code>. You can use the <code>@DefaultCoder</code> annotation as follows:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@DefaultCoder</span><span class=o>(</span><span class=n>AvroCoder</span><span class=o>.</span><span class=na>class</span><span class=o>)</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>MyCustomDataType</span> <span class=o>{</span>
  <span class=o>...</span>
<span class=o>}</span></code></pre></div></div><p class=language-java>If you&rsquo;ve created a custom coder to match your data type, and you want to use
the <code>@DefaultCoder</code> annotation, your coder class must implement a static
<code>Coder.of(Class&lt;T>)</code> factory method.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>MyCustomCoder</span> <span class=kd>implements</span> <span class=n>Coder</span> <span class=o>{</span>
  <span class=kd>public</span> <span class=kd>static</span> <span class=n>Coder</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=nf>of</span><span class=o>(</span><span class=n>Class</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>clazz</span><span class=o>)</span> <span class=o>{...}</span>
  <span class=o>...</span>
<span class=o>}</span>

<span class=nd>@DefaultCoder</span><span class=o>(</span><span class=n>MyCustomCoder</span><span class=o>.</span><span class=na>class</span><span class=o>)</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>MyCustomDataType</span> <span class=o>{</span>
  <span class=o>...</span>
<span class=o>}</span></code></pre></div></div><p class=language-py>The Beam SDK for Python does not support annotating data types with a default
coder. If you would like to set a default coder, use the method described in the
previous section, <em>Setting the default coder for a type</em>.</p><h2 id=windowing>8. Windowing</h2><p>Windowing subdivides a <code>PCollection</code> according to the timestamps of its
individual elements. Transforms that aggregate multiple elements, such as
<code>GroupByKey</code> and <code>Combine</code>, work implicitly on a per-window basis — they process
each <code>PCollection</code> as a succession of multiple, finite windows, though the
entire collection itself may be of unbounded size.</p><p>A related concept, called <strong>triggers</strong>, determines when to emit the results of
aggregation as unbounded data arrives. You can use triggers to refine the
windowing strategy for your <code>PCollection</code>. Triggers allow you to deal with
late-arriving data or to provide early results. See the <a href=#triggers>triggers</a>
section for more information.</p><h3 id=windowing-basics>8.1. Windowing basics</h3><p>Some Beam transforms, such as <code>GroupByKey</code> and <code>Combine</code>, group multiple
elements by a common key. Ordinarily, that grouping operation groups all of the
elements that have the same key within the entire data set. With an unbounded
data set, it is impossible to collect all of the elements, since new elements
are constantly being added and may be infinitely many (e.g. streaming data). If
you are working with unbounded <code>PCollection</code>s, windowing is especially useful.</p><p>In the Beam model, any <code>PCollection</code> (including unbounded <code>PCollection</code>s) can be
subdivided into logical windows. Each element in a <code>PCollection</code> is assigned to
one or more windows according to the <code>PCollection</code>'s windowing function, and
each individual window contains a finite number of elements. Grouping transforms
then consider each <code>PCollection</code>'s elements on a per-window basis. <code>GroupByKey</code>,
for example, implicitly groups the elements of a <code>PCollection</code> by <em>key and
window</em>.</p><p><strong>Caution:</strong> Beam&rsquo;s default windowing behavior is to assign all elements of a
<code>PCollection</code> to a single, global window and discard late data, <em>even for
unbounded <code>PCollection</code>s</em>. Before you use a grouping transform such as
<code>GroupByKey</code> on an unbounded <code>PCollection</code>, you must do at least one of the
following:</p><ul><li>Set a non-global windowing function. See <a href=#setting-your-pcollections-windowing-function>Setting your PCollection&rsquo;s
windowing function</a>.</li><li>Set a non-default <a href=#triggers>trigger</a>. This allows the global window to emit
results under other conditions, since the default windowing behavior (waiting
for all data to arrive) will never occur.</li></ul><p>If you don&rsquo;t set a non-global windowing function or a non-default trigger for
your unbounded <code>PCollection</code> and subsequently use a grouping transform such as
<code>GroupByKey</code> or <code>Combine</code>, your pipeline will generate an error upon
construction and your job will fail.</p><h4 id=windowing-constraints>8.1.1. Windowing constraints</h4><p>After you set the windowing function for a <code>PCollection</code>, the elements&rsquo; windows
are used the next time you apply a grouping transform to that <code>PCollection</code>.
Window grouping occurs on an as-needed basis. If you set a windowing function
using the <code>Window</code> transform, each element is assigned to a window, but the
windows are not considered until <code>GroupByKey</code> or <code>Combine</code> aggregates across a
window and key. This can have different effects on your pipeline. Consider the
example pipeline in the figure below:</p><p><img src=/images/windowing-pipeline-unbounded.svg alt="Diagram of pipeline applying windowing"></p><p><strong>Figure 3:</strong> Pipeline applying windowing</p><p>In the above pipeline, we create an unbounded <code>PCollection</code> by reading a set of
key/value pairs using <code>KafkaIO</code>, and then apply a windowing function to that
collection using the <code>Window</code> transform. We then apply a <code>ParDo</code> to the the
collection, and then later group the result of that <code>ParDo</code> using <code>GroupByKey</code>.
The windowing function has no effect on the <code>ParDo</code> transform, because the
windows are not actually used until they&rsquo;re needed for the <code>GroupByKey</code>.
Subsequent transforms, however, are applied to the result of the <code>GroupByKey</code> &ndash;
data is grouped by both key and window.</p><h4 id=windowing-bounded-collections>8.1.2. Windowing with bounded PCollections</h4><p>You can use windowing with fixed-size data sets in <strong>bounded</strong> <code>PCollection</code>s.
However, note that windowing considers only the implicit timestamps attached to
each element of a <code>PCollection</code>, and data sources that create fixed data sets
(such as <code>TextIO</code>) assign the same timestamp to every element. This means that
all the elements are by default part of a single, global window.</p><p>To use windowing with fixed data sets, you can assign your own timestamps to
each element. To assign timestamps to elements, use a <code>ParDo</code> transform with a
<code>DoFn</code> that outputs each element with a new timestamp (for example, the
<a href=https://beam.apache.org/releases/javadoc/2.22.0/index.html?org/apache/beam/sdk/transforms/WithTimestamps.html>WithTimestamps</a>
transform in the Beam SDK for Java).</p><p>To illustrate how windowing with a bounded <code>PCollection</code> can affect how your
pipeline processes data, consider the following pipeline:</p><p><img src=/images/unwindowed-pipeline-bounded.svg alt="Diagram of GroupByKey and ParDo without windowing, on a bounded collection"></p><p><strong>Figure 4:</strong> <code>GroupByKey</code> and <code>ParDo</code> without windowing, on a bounded collection.</p><p>In the above pipeline, we create a bounded <code>PCollection</code> by reading a set of
key/value pairs using <code>TextIO</code>. We then group the collection using <code>GroupByKey</code>,
and apply a <code>ParDo</code> transform to the grouped <code>PCollection</code>. In this example, the
<code>GroupByKey</code> creates a collection of unique keys, and then <code>ParDo</code> gets applied
exactly once per key.</p><p>Note that even if you don’t set a windowing function, there is still a window &ndash;
all elements in your <code>PCollection</code> are assigned to a single global window.</p><p>Now, consider the same pipeline, but using a windowing function:</p><p><img src=/images/windowing-pipeline-bounded.svg alt="Diagram of GroupByKey and ParDo with windowing, on a bounded collection"></p><p><strong>Figure 5:</strong> <code>GroupByKey</code> and <code>ParDo</code> with windowing, on a bounded collection.</p><p>As before, the pipeline creates a bounded <code>PCollection</code> of key/value pairs. We
then set a <a href=#setting-your-pcollections-windowing-function>windowing function</a>
for that <code>PCollection</code>. The <code>GroupByKey</code> transform groups the elements of the
<code>PCollection</code> by both key and window, based on the windowing function. The
subsequent <code>ParDo</code> transform gets applied multiple times per key, once for each
window.</p><h3 id=provided-windowing-functions>8.2. Provided windowing functions</h3><p>You can define different kinds of windows to divide the elements of your
<code>PCollection</code>. Beam provides several windowing functions, including:</p><ul><li>Fixed Time Windows</li><li>Sliding Time Windows</li><li>Per-Session Windows</li><li>Single Global Window</li><li>Calendar-based Windows (not supported by the Beam SDK for Python)</li></ul><p>You can also define your own <code>WindowFn</code> if you have a more complex need.</p><p>Note that each element can logically belong to more than one window, depending
on the windowing function you use. Sliding time windowing, for example, creates
overlapping windows wherein a single element can be assigned to multiple
windows.</p><h4 id=fixed-time-windows>8.2.1. Fixed time windows</h4><p>The simplest form of windowing is using <strong>fixed time windows</strong>: given a
timestamped <code>PCollection</code> which might be continuously updating, each window
might capture (for example) all elements with timestamps that fall into a 30
second interval.</p><p>A fixed time window represents a consistent duration, non overlapping time
interval in the data stream. Consider windows with a 30 second duration: all
of the elements in your unbounded <code>PCollection</code> with timestamp values from
0:00:00 up to (but not including) 0:00:30 belong to the first window, elements
with timestamp values from 0:00:30 up to (but not including) 0:01:00 belong to
the second window, and so on.</p><p><img src=/images/fixed-time-windows.png alt="Diagram of fixed time windows, 30s in duration"></p><p><strong>Figure 6:</strong> Fixed time windows, 30s in duration.</p><h4 id=sliding-time-windows>8.2.2. Sliding time windows</h4><p>A <strong>sliding time window</strong> also represents time intervals in the data stream;
however, sliding time windows can overlap. For example, each window might
capture 60 seconds worth of data, but a new window starts every 30 seconds.
The frequency with which sliding windows begin is called the <em>period</em>.
Therefore, our example would have a window <em>duration</em> of 60 seconds and a
<em>period</em> of 30 seconds.</p><p>Because multiple windows overlap, most elements in a data set will belong to
more than one window. This kind of windowing is useful for taking running
averages of data; using sliding time windows, you can compute a running average
of the past 60 seconds&rsquo; worth of data, updated every 30 seconds, in our
example.</p><p><img src=/images/sliding-time-windows.png alt="Diagram of sliding time windows, with 1 minute window duration and 30s window period"></p><p><strong>Figure 7:</strong> Sliding time windows, with 1 minute window duration and 30s window
period.</p><h4 id=session-windows>8.2.3. Session windows</h4><p>A <strong>session window</strong> function defines windows that contain elements that are
within a certain gap duration of another element. Session windowing applies on a
per-key basis and is useful for data that is irregularly distributed with
respect to time. For example, a data stream representing user mouse activity may
have long periods of idle time interspersed with high concentrations of clicks.
If data arrives after the minimum specified gap duration time, this initiates
the start of a new window.</p><p><img src=/images/session-windows.png alt="Diagram of session windows with a minimum gap duration"></p><p><strong>Figure 8:</strong> Session windows, with a minimum gap duration. Note how each data key
has different windows, according to its data distribution.</p><h4 id=single-global-window>8.2.4. The single global window</h4><p>By default, all data in a <code>PCollection</code> is assigned to the single global window,
and late data is discarded. If your data set is of a fixed size, you can use the
global window default for your <code>PCollection</code>.</p><p>You can use the single global window if you are working with an unbounded data set
(e.g. from a streaming data source) but use caution when applying aggregating
transforms such as <code>GroupByKey</code> and <code>Combine</code>. The single global window with a
default trigger generally requires the entire data set to be available before
processing, which is not possible with continuously updating data. To perform
aggregations on an unbounded <code>PCollection</code> that uses global windowing, you
should specify a non-default trigger for that <code>PCollection</code>.</p><h3 id=setting-your-pcollections-windowing-function>8.3. Setting your PCollection&rsquo;s windowing function</h3><p>You can set the windowing function for a <code>PCollection</code> by applying the <code>Window</code>
transform. When you apply the <code>Window</code> transform, you must provide a <code>WindowFn</code>.
The <code>WindowFn</code> determines the windowing function your <code>PCollection</code> will use for
subsequent grouping transforms, such as a fixed or sliding time window.</p><p>When you set a windowing function, you may also want to set a trigger for your
<code>PCollection</code>. The trigger determines when each individual window is aggregated
and emitted, and helps refine how the windowing function performs with respect
to late data and computing early results. See the <a href=#triggers>triggers</a> section
for more information.</p><h4 id=using-fixed-time-windows>8.3.1. Fixed-time windows</h4><p>The following example code shows how to apply <code>Window</code> to divide a <code>PCollection</code>
into fixed windows, each 60 seconds in length:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>    <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>items</span> <span class=o>=</span> <span class=o>...;</span>
    <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>fixedWindowedItems</span> <span class=o>=</span> <span class=n>items</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
        <span class=n>Window</span><span class=o>.&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=n>into</span><span class=o>(</span><span class=n>FixedWindows</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardSeconds</span><span class=o>(</span><span class=n>60</span><span class=o>))));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=kn>from</span> <span class=nn>apache_beam</span> <span class=kn>import</span> <span class=n>window</span>
<span class=n>fixed_windowed_items</span> <span class=o>=</span> <span class=p>(</span>
    <span class=n>items</span> <span class=o>|</span> <span class=s1>&#39;window&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>WindowInto</span><span class=p>(</span><span class=n>window</span><span class=o>.</span><span class=n>FixedWindows</span><span class=p>(</span><span class=mi>60</span><span class=p>)))</span></code></pre></div></div><h4 id=using-sliding-time-windows>8.3.2. Sliding time windows</h4><p>The following example code shows how to apply <code>Window</code> to divide a <code>PCollection</code>
into sliding time windows. Each window is 30 seconds in length, and a new window
begins every five seconds:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>    <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>items</span> <span class=o>=</span> <span class=o>...;</span>
    <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>slidingWindowedItems</span> <span class=o>=</span> <span class=n>items</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
        <span class=n>Window</span><span class=o>.&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=n>into</span><span class=o>(</span><span class=n>SlidingWindows</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardSeconds</span><span class=o>(</span><span class=n>30</span><span class=o>)).</span><span class=na>every</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardSeconds</span><span class=o>(</span><span class=n>5</span><span class=o>))));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=kn>from</span> <span class=nn>apache_beam</span> <span class=kn>import</span> <span class=n>window</span>
<span class=n>sliding_windowed_items</span> <span class=o>=</span> <span class=p>(</span>
    <span class=n>items</span> <span class=o>|</span> <span class=s1>&#39;window&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>WindowInto</span><span class=p>(</span><span class=n>window</span><span class=o>.</span><span class=n>SlidingWindows</span><span class=p>(</span><span class=mi>30</span><span class=p>,</span> <span class=mi>5</span><span class=p>)))</span></code></pre></div></div><h4 id=using-session-windows>8.3.3. Session windows</h4><p>The following example code shows how to apply <code>Window</code> to divide a <code>PCollection</code>
into session windows, where each session must be separated by a time gap of at
least 10 minutes (600 seconds):</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>    <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>items</span> <span class=o>=</span> <span class=o>...;</span>
    <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>sessionWindowedItems</span> <span class=o>=</span> <span class=n>items</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
        <span class=n>Window</span><span class=o>.&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=n>into</span><span class=o>(</span><span class=n>Sessions</span><span class=o>.</span><span class=na>withGapDuration</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardSeconds</span><span class=o>(</span><span class=n>600</span><span class=o>))));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=kn>from</span> <span class=nn>apache_beam</span> <span class=kn>import</span> <span class=n>window</span>
<span class=n>session_windowed_items</span> <span class=o>=</span> <span class=p>(</span>
    <span class=n>items</span> <span class=o>|</span> <span class=s1>&#39;window&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>WindowInto</span><span class=p>(</span><span class=n>window</span><span class=o>.</span><span class=n>Sessions</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=mi>60</span><span class=p>)))</span></code></pre></div></div><p>Note that the sessions are per-key — each key in the collection will have its
own session groupings depending on the data distribution.</p><h4 id=using-single-global-window>8.3.4. Single global window</h4><p>If your <code>PCollection</code> is bounded (the size is fixed), you can assign all the
elements to a single global window. The following example code shows how to set
a single global window for a <code>PCollection</code>:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>    <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>items</span> <span class=o>=</span> <span class=o>...;</span>
    <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>batchItems</span> <span class=o>=</span> <span class=n>items</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
        <span class=n>Window</span><span class=o>.&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=n>into</span><span class=o>(</span><span class=k>new</span> <span class=n>GlobalWindows</span><span class=o>()));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=kn>from</span> <span class=nn>apache_beam</span> <span class=kn>import</span> <span class=n>window</span>
<span class=n>session_windowed_items</span> <span class=o>=</span> <span class=p>(</span>
    <span class=n>items</span> <span class=o>|</span> <span class=s1>&#39;window&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>WindowInto</span><span class=p>(</span><span class=n>window</span><span class=o>.</span><span class=n>GlobalWindows</span><span class=p>()))</span></code></pre></div></div><h3 id=watermarks-and-late-data>8.4. Watermarks and late data</h3><p>In any data processing system, there is a certain amount of lag between the time
a data event occurs (the &ldquo;event time&rdquo;, determined by the timestamp on the data
element itself) and the time the actual data element gets processed at any stage
in your pipeline (the &ldquo;processing time&rdquo;, determined by the clock on the system
processing the element). In addition, there are no guarantees that data events
will appear in your pipeline in the same order that they were generated.</p><p>For example, let&rsquo;s say we have a <code>PCollection</code> that&rsquo;s using fixed-time
windowing, with windows that are five minutes long. For each window, Beam must
collect all the data with an <em>event time</em> timestamp in the given window range
(between 0:00 and 4:59 in the first window, for instance). Data with timestamps
outside that range (data from 5:00 or later) belong to a different window.</p><p>However, data isn&rsquo;t always guaranteed to arrive in a pipeline in time order, or
to always arrive at predictable intervals. Beam tracks a <em>watermark</em>, which is
the system&rsquo;s notion of when all data in a certain window can be expected to have
arrived in the pipeline. Once the watermark progresses past the end of a window,
any further element that arrives with a timestamp in that window is considered
<strong>late data</strong>.</p><p>From our example, suppose we have a simple watermark that assumes approximately
30s of lag time between the data timestamps (the event time) and the time the
data appears in the pipeline (the processing time), then Beam would close the
first window at 5:30. If a data record arrives at 5:34, but with a timestamp
that would put it in the 0:00-4:59 window (say, 3:38), then that record is late
data.</p><p>Note: For simplicity, we&rsquo;ve assumed that we&rsquo;re using a very straightforward
watermark that estimates the lag time. In practice, your <code>PCollection</code>'s data
source determines the watermark, and watermarks can be more precise or complex.</p><p>Beam&rsquo;s default windowing configuration tries to determine when all data has
arrived (based on the type of data source) and then advances the watermark past
the end of the window. This default configuration does <em>not</em> allow late data.
<a href=#triggers>Triggers</a> allow you to modify and refine the windowing strategy for
a <code>PCollection</code>. You can use triggers to decide when each individual window
aggregates and reports its results, including how the window emits late
elements.</p><h4 id=managing-late-data>8.4.1. Managing late data</h4><p>You can allow late data by invoking the <code>.withAllowedLateness</code> operation when
you set your <code>PCollection</code>'s windowing strategy. The following code example
demonstrates a windowing strategy that will allow late data up to two days after
the end of a window.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>    <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>items</span> <span class=o>=</span> <span class=o>...;</span>
    <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>fixedWindowedItems</span> <span class=o>=</span> <span class=n>items</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span>
        <span class=n>Window</span><span class=o>.&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=n>into</span><span class=o>(</span><span class=n>FixedWindows</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardMinutes</span><span class=o>(</span><span class=n>1</span><span class=o>)))</span>
              <span class=o>.</span><span class=na>withAllowedLateness</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardDays</span><span class=o>(</span><span class=n>2</span><span class=o>)));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py>   <span class=n>pc</span> <span class=o>=</span> <span class=p>[</span><span class=n>Initial</span> <span class=n>PCollection</span><span class=p>]</span>
   <span class=n>pc</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>WindowInto</span><span class=p>(</span>
              <span class=n>FixedWindows</span><span class=p>(</span><span class=mi>60</span><span class=p>),</span>
              <span class=n>trigger</span><span class=o>=</span><span class=n>trigger_fn</span><span class=p>,</span>
              <span class=n>accumulation_mode</span><span class=o>=</span><span class=n>accumulation_mode</span><span class=p>,</span>
              <span class=n>timestamp_combiner</span><span class=o>=</span><span class=n>timestamp_combiner</span><span class=p>,</span>
              <span class=n>allowed_lateness</span><span class=o>=</span><span class=n>Duration</span><span class=p>(</span><span class=n>seconds</span><span class=o>=</span><span class=mi>2</span><span class=o>*</span><span class=mi>24</span><span class=o>*</span><span class=mi>60</span><span class=o>*</span><span class=mi>60</span><span class=p>))</span> <span class=c1># 2 days</span></code></pre></div></div><p>When you set <code>.withAllowedLateness</code> on a <code>PCollection</code>, that allowed lateness
propagates forward to any subsequent <code>PCollection</code> derived from the first
<code>PCollection</code> you applied allowed lateness to. If you want to change the allowed
lateness later in your pipeline, you must do so explicitly by applying
<code>Window.configure().withAllowedLateness()</code>.</p><h3 id=adding-timestamps-to-a-pcollections-elements>8.5. Adding timestamps to a PCollection&rsquo;s elements</h3><p>An unbounded source provides a timestamp for each element. Depending on your
unbounded source, you may need to configure how the timestamp is extracted from
the raw data stream.</p><p>However, bounded sources (such as a file from <code>TextIO</code>) do not provide
timestamps. If you need timestamps, you must add them to your <code>PCollection</code>’s
elements.</p><p>You can assign new timestamps to the elements of a <code>PCollection</code> by applying a
<a href=#pardo>ParDo</a> transform that outputs new elements with timestamps that you
set.</p><p>An example might be if your pipeline reads log records from an input file, and
each log record includes a timestamp field; since your pipeline reads the
records in from a file, the file source doesn&rsquo;t assign timestamps automatically.
You can parse the timestamp field from each record and use a <code>ParDo</code> transform
with a <code>DoFn</code> to attach the timestamps to each element in your <code>PCollection</code>.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>      <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>LogEntry</span><span class=o>&gt;</span> <span class=n>unstampedLogs</span> <span class=o>=</span> <span class=o>...;</span>
      <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>LogEntry</span><span class=o>&gt;</span> <span class=n>stampedLogs</span> <span class=o>=</span>
          <span class=n>unstampedLogs</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>LogEntry</span><span class=o>,</span> <span class=n>LogEntry</span><span class=o>&gt;()</span> <span class=o>{</span>
            <span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=nd>@Element</span> <span class=n>LogEntry</span> <span class=n>element</span><span class=o>,</span> <span class=n>OutputReceiver</span><span class=o>&lt;</span><span class=n>LogEntry</span><span class=o>&gt;</span> <span class=n>out</span><span class=o>)</span> <span class=o>{</span>
              <span class=c1>// Extract the timestamp from log entry we&#39;re currently processing.
</span><span class=c1></span>              <span class=n>Instant</span> <span class=n>logTimeStamp</span> <span class=o>=</span> <span class=n>extractTimeStampFromLogEntry</span><span class=o>(</span><span class=n>element</span><span class=o>);</span>
              <span class=c1>// Use OutputReceiver.outputWithTimestamp (rather than
</span><span class=c1></span>              <span class=c1>// OutputReceiver.output) to emit the entry with timestamp attached.
</span><span class=c1></span>              <span class=n>out</span><span class=o>.</span><span class=na>outputWithTimestamp</span><span class=o>(</span><span class=n>element</span><span class=o>,</span> <span class=n>logTimeStamp</span><span class=o>);</span>
            <span class=o>}</span>
          <span class=o>}));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=k>class</span> <span class=nc>AddTimestampDoFn</span><span class=p>(</span><span class=n>beam</span><span class=o>.</span><span class=n>DoFn</span><span class=p>):</span>
  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>element</span><span class=p>):</span>
    <span class=c1># Extract the numeric Unix seconds-since-epoch timestamp to be</span>
    <span class=c1># associated with the current log entry.</span>
    <span class=n>unix_timestamp</span> <span class=o>=</span> <span class=n>extract_timestamp_from_log_entry</span><span class=p>(</span><span class=n>element</span><span class=p>)</span>
    <span class=c1># Wrap and emit the current entry and new timestamp in a</span>
    <span class=c1># TimestampedValue.</span>
    <span class=k>yield</span> <span class=n>beam</span><span class=o>.</span><span class=n>window</span><span class=o>.</span><span class=n>TimestampedValue</span><span class=p>(</span><span class=n>element</span><span class=p>,</span> <span class=n>unix_timestamp</span><span class=p>)</span>

<span class=n>timestamped_items</span> <span class=o>=</span> <span class=n>items</span> <span class=o>|</span> <span class=s1>&#39;timestamp&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span><span class=n>AddTimestampDoFn</span><span class=p>())</span></code></pre></div></div><h2 id=triggers>9. Triggers</h2><p>When collecting and grouping data into windows, Beam uses <strong>triggers</strong> to
determine when to emit the aggregated results of each window (referred to as a
<em>pane</em>). If you use Beam&rsquo;s default windowing configuration and <a href=#default-trigger>default
trigger</a>, Beam outputs the aggregated result when it
<a href=#watermarks-and-late-data>estimates all data has arrived</a>, and discards all
subsequent data for that window.</p><p>You can set triggers for your <code>PCollection</code>s to change this default behavior.
Beam provides a number of pre-built triggers that you can set:</p><ul><li><strong>Event time triggers</strong>. These triggers operate on the event time, as
indicated by the timestamp on each data element. Beam&rsquo;s default trigger is
event time-based.</li><li><strong>Processing time triggers</strong>. These triggers operate on the processing time
&ndash; the time when the data element is processed at any given stage in the
pipeline.</li><li><strong>Data-driven triggers</strong>. These triggers operate by examining the data as it
arrives in each window, and firing when that data meets a certain property.
Currently, data-driven triggers only support firing after a certain number
of data elements.</li><li><strong>Composite triggers</strong>. These triggers combine multiple triggers in various
ways.</li></ul><p>At a high level, triggers provide two additional capabilities compared to simply
outputting at the end of a window:</p><ul><li>Triggers allow Beam to emit early results, before all the data in a given
window has arrived. For example, emitting after a certain amount of time
elapses, or after a certain number of elements arrives.</li><li>Triggers allow processing of late data by triggering after the event time
watermark passes the end of the window.</li></ul><p>These capabilities allow you to control the flow of your data and balance
between different factors depending on your use case:</p><ul><li><strong>Completeness:</strong> How important is it to have all of your data before you
compute your result?</li><li><strong>Latency:</strong> How long do you want to wait for data? For example, do you wait
until you think you have all data? Do you process data as it arrives?</li><li><strong>Cost:</strong> How much compute power/money are you willing to spend to lower the
latency?</li></ul><p>For example, a system that requires time-sensitive updates might use a strict
time-based trigger that emits a window every <em>N</em> seconds, valuing promptness
over data completeness. A system that values data completeness more than the
exact timing of results might choose to use Beam&rsquo;s default trigger, which fires
at the end of the window.</p><p>You can also set a trigger for an unbounded <code>PCollection</code> that uses a <a href=#windowing>single
global window for its windowing function</a>. This can be useful when
you want your pipeline to provide periodic updates on an unbounded data set —
for example, a running average of all data provided to the present time, updated
every N seconds or every N elements.</p><h3 id=event-time-triggers>9.1. Event time triggers</h3><p>The <code>AfterWatermark</code> trigger operates on <em>event time</em>. The <code>AfterWatermark</code>
trigger emits the contents of a window after the
<a href=#watermarks-and-late-data>watermark</a> passes the end of the window, based on the
timestamps attached to the data elements. The watermark is a global progress
metric, and is Beam&rsquo;s notion of input completeness within your pipeline at any
given point. <span class=language-java><code>AfterWatermark.pastEndOfWindow()</code></span>
<span class=language-py><code>AfterWatermark</code></span> <em>only</em> fires when the
watermark passes the end of the window.</p><p>In addition, you can configure triggers that fire if your pipeline receives data
before or after the end of the window.</p><p>The following example shows a billing scenario, and uses both early and late
firings:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>  <span class=c1>// Create a bill at the end of the month.
</span><span class=c1></span>  <span class=n>AfterWatermark</span><span class=o>.</span><span class=na>pastEndOfWindow</span><span class=o>()</span>
      <span class=c1>// During the month, get near real-time estimates.
</span><span class=c1></span>      <span class=o>.</span><span class=na>withEarlyFirings</span><span class=o>(</span>
          <span class=n>AfterProcessingTime</span>
              <span class=o>.</span><span class=na>pastFirstElementInPane</span><span class=o>()</span>
              <span class=o>.</span><span class=na>plusDuration</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardMinutes</span><span class=o>(</span><span class=n>1</span><span class=o>))</span>
      <span class=c1>// Fire on any late data so the bill can be corrected.
</span><span class=c1></span>      <span class=o>.</span><span class=na>withLateFirings</span><span class=o>(</span><span class=n>AfterPane</span><span class=o>.</span><span class=na>elementCountAtLeast</span><span class=o>(</span><span class=n>1</span><span class=o>))</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>AfterWatermark</span><span class=p>(</span>
    <span class=n>early</span><span class=o>=</span><span class=n>AfterProcessingTime</span><span class=p>(</span><span class=n>delay</span><span class=o>=</span><span class=mi>1</span> <span class=o>*</span> <span class=mi>60</span><span class=p>),</span> <span class=n>late</span><span class=o>=</span><span class=n>AfterCount</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span></code></pre></div></div><h4 id=default-trigger>9.1.1. Default trigger</h4><p>The default trigger for a <code>PCollection</code> is based on event time, and emits the
results of the window when the Beam&rsquo;s watermark passes the end of the window,
and then fires each time late data arrives.</p><p>However, if you are using both the default windowing configuration and the
default trigger, the default trigger emits exactly once, and late data is
discarded. This is because the default windowing configuration has an allowed
lateness value of 0. See the Handling Late Data section for information about
modifying this behavior.</p><h3 id=processing-time-triggers>9.2. Processing time triggers</h3><p>The <code>AfterProcessingTime</code> trigger operates on <em>processing time</em>. For example,
the <span class=language-java><code>AfterProcessingTime.pastFirstElementInPane()</code></span>
<span class=language-py><code>AfterProcessingTime</code></span> trigger emits a window
after a certain amount of processing time has passed since data was received.
The processing time is determined by the system clock, rather than the data
element&rsquo;s timestamp.</p><p>The <code>AfterProcessingTime</code> trigger is useful for triggering early results from a
window, particularly a window with a large time frame such as a single global
window.</p><h3 id=data-driven-triggers>9.3. Data-driven triggers</h3><p>Beam provides one data-driven trigger,
<span class=language-java><code>AfterPane.elementCountAtLeast()</code></span>
<span class=language-py><code>AfterCount</code></span>. This trigger works on an element
count; it fires after the current pane has collected at least <em>N</em> elements. This
allows a window to emit early results (before all the data has accumulated),
which can be particularly useful if you are using a single global window.</p><p>It is important to note that if, for example, you specify
<span class=language-java><code>.elementCountAtLeast(50)</code></span>
<span class=language-py>AfterCount(50)</span> and only 32 elements arrive,
those 32 elements sit around forever. If the 32 elements are important to you,
consider using <a href=#composite-triggers>composite triggers</a> to combine multiple
conditions. This allows you to specify multiple firing conditions such as &ldquo;fire
either when I receive 50 elements, or every 1 second&rdquo;.</p><h3 id=setting-a-trigger>9.4. Setting a trigger</h3><p>When you set a windowing function for a <code>PCollection</code> by using the
<span class=language-java><code>Window</code></span><span class=language-py><code>WindowInto</code></span>
transform, you can also specify a trigger.</p><p class=language-java>You set the trigger(s) for a <code>PCollection</code> by invoking the method
<code>.triggering()</code> on the result of your <code>Window.into()</code> transform. This code
sample sets a time-based trigger for a <code>PCollection</code>, which emits results one
minute after the first element in that window has been processed. The last line
in the code sample, <code>.discardingFiredPanes()</code>, sets the window&rsquo;s <strong>accumulation
mode</strong>.</p><p class=language-py>You set the trigger(s) for a <code>PCollection</code> by setting the <code>trigger</code> parameter
when you use the <code>WindowInto</code> transform. This code sample sets a time-based
trigger for a <code>PCollection</code>, which emits results one minute after the first
element in that window has been processed. The <code>accumulation_mode</code> parameter
sets the window&rsquo;s <strong>accumulation mode</strong>.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>  <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>pc</span> <span class=o>=</span> <span class=o>...;</span>
  <span class=n>pc</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Window</span><span class=o>.&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=n>into</span><span class=o>(</span><span class=n>FixedWindows</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>MINUTES</span><span class=o>))</span>
                               <span class=o>.</span><span class=na>triggering</span><span class=o>(</span><span class=n>AfterProcessingTime</span><span class=o>.</span><span class=na>pastFirstElementInPane</span><span class=o>()</span>
                                                              <span class=o>.</span><span class=na>plusDelayOf</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardMinutes</span><span class=o>(</span><span class=n>1</span><span class=o>)))</span>
                               <span class=o>.</span><span class=na>discardingFiredPanes</span><span class=o>());</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>pcollection</span> <span class=o>|</span> <span class=n>WindowInto</span><span class=p>(</span>
    <span class=n>FixedWindows</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=mi>60</span><span class=p>),</span>
    <span class=n>trigger</span><span class=o>=</span><span class=n>AfterProcessingTime</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=mi>60</span><span class=p>),</span>
    <span class=n>accumulation_mode</span><span class=o>=</span><span class=n>AccumulationMode</span><span class=o>.</span><span class=n>DISCARDING</span><span class=p>)</span></code></pre></div></div><h4 id=window-accumulation-modes>9.4.1. Window accumulation modes</h4><p>When you specify a trigger, you must also set the the window&rsquo;s <strong>accumulation
mode</strong>. When a trigger fires, it emits the current contents of the window as a
pane. Since a trigger can fire multiple times, the accumulation mode determines
whether the system <em>accumulates</em> the window panes as the trigger fires, or
<em>discards</em> them.</p><p class=language-java>To set a window to accumulate the panes that are produced when the trigger
fires, invoke<code>.accumulatingFiredPanes()</code> when you set the trigger. To set a
window to discard fired panes, invoke <code>.discardingFiredPanes()</code>.</p><p class=language-py>To set a window to accumulate the panes that are produced when the trigger
fires, set the <code>accumulation_mode</code> parameter to <code>ACCUMULATING</code> when you set the
trigger. To set a window to discard fired panes, set <code>accumulation_mode</code> to
<code>DISCARDING</code>.</p><p>Let&rsquo;s look an example that uses a <code>PCollection</code> with fixed-time windowing and a
data-based trigger. This is something you might do if, for example, each window
represented a ten-minute running average, but you wanted to display the current
value of the average in a UI more frequently than every ten minutes. We&rsquo;ll
assume the following conditions:</p><ul><li>The <code>PCollection</code> uses 10-minute fixed-time windows.</li><li>The <code>PCollection</code> has a repeating trigger that fires every time 3 elements
arrive.</li></ul><p>The following diagram shows data events for key X as they arrive in the
PCollection and are assigned to windows. To keep the diagram a bit simpler,
we&rsquo;ll assume that the events all arrive in the pipeline in order.</p><p><img src=/images/trigger-accumulation.png alt="Diagram of data events for acculumating mode example"></p><h5 id=accumulating-mode>9.4.1.1. Accumulating mode</h5><p>If our trigger is set to accumulating mode, the trigger emits the following
values each time it fires. Keep in mind that the trigger fires every time three
elements arrive:</p><pre><code>  First trigger firing:  [5, 8, 3]
  Second trigger firing: [5, 8, 3, 15, 19, 23]
  Third trigger firing:  [5, 8, 3, 15, 19, 23, 9, 13, 10]
</code></pre><h5 id=discarding-mode>9.4.1.2. Discarding mode</h5><p>If our trigger is set to discarding mode, the trigger emits the following values
on each firing:</p><pre><code>  First trigger firing:  [5, 8, 3]
  Second trigger firing:           [15, 19, 23]
  Third trigger firing:                         [9, 13, 10]
</code></pre><h4 id=handling-late-data>9.4.2. Handling late data</h4><p>If you want your pipeline to process data that arrives after the watermark
passes the end of the window, you can apply an <em>allowed lateness</em> when you set
your windowing configuration. This gives your trigger the opportunity to react
to the late data. If allowed lateness is set, the default trigger will emit new
results immediately whenever late data arrives.</p><p>You set the allowed lateness by using <code>.withAllowedLateness()</code> when you set your
windowing function:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>  <span class=n>PCollection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>pc</span> <span class=o>=</span> <span class=o>...;</span>
  <span class=n>pc</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Window</span><span class=o>.&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=n>into</span><span class=o>(</span><span class=n>FixedWindows</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>MINUTES</span><span class=o>))</span>
                              <span class=o>.</span><span class=na>triggering</span><span class=o>(</span><span class=n>AfterProcessingTime</span><span class=o>.</span><span class=na>pastFirstElementInPane</span><span class=o>()</span>
                                                             <span class=o>.</span><span class=na>plusDelayOf</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardMinutes</span><span class=o>(</span><span class=n>1</span><span class=o>)))</span>
                              <span class=o>.</span><span class=na>withAllowedLateness</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardMinutes</span><span class=o>(</span><span class=n>30</span><span class=o>));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py>  <span class=n>pc</span> <span class=o>=</span> <span class=p>[</span><span class=n>Initial</span> <span class=n>PCollection</span><span class=p>]</span>
  <span class=n>pc</span> <span class=o>|</span> <span class=n>beam</span><span class=o>.</span><span class=n>WindowInto</span><span class=p>(</span>
            <span class=n>FixedWindows</span><span class=p>(</span><span class=mi>60</span><span class=p>),</span>
            <span class=n>trigger</span><span class=o>=</span><span class=n>AfterProcessingTime</span><span class=p>(</span><span class=mi>60</span><span class=p>),</span>
            <span class=n>allowed_lateness</span><span class=o>=</span><span class=mi>1800</span><span class=p>)</span> <span class=c1># 30 minutes</span>
     <span class=o>|</span> <span class=o>...</span>
  </code></pre></div></div><p>This allowed lateness propagates to all <code>PCollection</code>s derived as a result of
applying transforms to the original <code>PCollection</code>. If you want to change the
allowed lateness later in your pipeline, you can apply
<code>Window.configure().withAllowedLateness()</code> again, explicitly.</p><h3 id=composite-triggers>9.5. Composite triggers</h3><p>You can combine multiple triggers to form <strong>composite triggers</strong>, and can
specify a trigger to emit results repeatedly, at most once, or under other
custom conditions.</p><h4 id=composite-trigger-types>9.5.1. Composite trigger types</h4><p>Beam includes the following composite triggers:</p><ul><li>You can add additional early firings or late firings to
<code>AfterWatermark.pastEndOfWindow</code> via <code>.withEarlyFirings</code> and
<code>.withLateFirings</code>.</li><li><code>Repeatedly.forever</code> specifies a trigger that executes forever. Any time the
trigger&rsquo;s conditions are met, it causes a window to emit results and then
resets and starts over. It can be useful to combine <code>Repeatedly.forever</code>
with <code>.orFinally</code> to specify a condition that causes the repeating trigger
to stop.</li><li><code>AfterEach.inOrder</code> combines multiple triggers to fire in a specific
sequence. Each time a trigger in the sequence emits a window, the sequence
advances to the next trigger.</li><li><code>AfterFirst</code> takes multiple triggers and emits the first time <em>any</em> of its
argument triggers is satisfied. This is equivalent to a logical OR operation
for multiple triggers.</li><li><code>AfterAll</code> takes multiple triggers and emits when <em>all</em> of its argument
triggers are satisfied. This is equivalent to a logical AND operation for
multiple triggers.</li><li><code>orFinally</code> can serve as a final condition to cause any trigger to fire one
final time and never fire again.</li></ul><h4 id=composite-afterwatermark>9.5.2. Composition with AfterWatermark</h4><p>Some of the most useful composite triggers fire a single time when Beam
estimates that all the data has arrived (i.e. when the watermark passes the end
of the window) combined with either, or both, of the following:</p><ul><li><p>Speculative firings that precede the watermark passing the end of the window
to allow faster processing of partial results.</p></li><li><p>Late firings that happen after the watermark passes the end of the window,
to allow for handling late-arriving data</p></li></ul><p>You can express this pattern using <code>AfterWatermark</code>. For example, the following
example trigger code fires on the following conditions:</p><ul><li><p>On Beam&rsquo;s estimate that all the data has arrived (the watermark passes the
end of the window)</p></li><li><p>Any time late data arrives, after a ten-minute delay</p></li></ul><p class=language-java><ul><li>After two days, we assume no more data of interest will arrive, and the
trigger stops executing</li></ul></p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>  <span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Window</span>
      <span class=o>.</span><span class=na>configure</span><span class=o>()</span>
      <span class=o>.</span><span class=na>triggering</span><span class=o>(</span><span class=n>AfterWatermark</span>
           <span class=o>.</span><span class=na>pastEndOfWindow</span><span class=o>()</span>
           <span class=o>.</span><span class=na>withLateFirings</span><span class=o>(</span><span class=n>AfterProcessingTime</span>
                <span class=o>.</span><span class=na>pastFirstElementInPane</span><span class=o>()</span>
                <span class=o>.</span><span class=na>plusDelayOf</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardMinutes</span><span class=o>(</span><span class=n>10</span><span class=o>))))</span>
      <span class=o>.</span><span class=na>withAllowedLateness</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardDays</span><span class=o>(</span><span class=n>2</span><span class=o>)));</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>pcollection</span> <span class=o>|</span> <span class=n>WindowInto</span><span class=p>(</span>
    <span class=n>FixedWindows</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=mi>60</span><span class=p>),</span>
    <span class=n>trigger</span><span class=o>=</span><span class=n>AfterWatermark</span><span class=p>(</span><span class=n>late</span><span class=o>=</span><span class=n>AfterProcessingTime</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=mi>60</span><span class=p>)),</span>
    <span class=n>allowed_lateness</span><span class=o>=</span><span class=mi>10</span><span class=p>,</span>
    <span class=n>accumulation_mode</span><span class=o>=</span><span class=n>AccumulationMode</span><span class=o>.</span><span class=n>DISCARDING</span><span class=p>)</span></code></pre></div></div><h4 id=other-composite-triggers>9.5.3. Other composite triggers</h4><p>You can also build other sorts of composite triggers. The following example code
shows a simple composite trigger that fires whenever the pane has at least 100
elements, or after a minute.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java>  <span class=n>Repeatedly</span><span class=o>.</span><span class=na>forever</span><span class=o>(</span><span class=n>AfterFirst</span><span class=o>.</span><span class=na>of</span><span class=o>(</span>
      <span class=n>AfterPane</span><span class=o>.</span><span class=na>elementCountAtLeast</span><span class=o>(</span><span class=n>100</span><span class=o>),</span>
      <span class=n>AfterProcessingTime</span><span class=o>.</span><span class=na>pastFirstElementInPane</span><span class=o>().</span><span class=na>plusDelayOf</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardMinutes</span><span class=o>(</span><span class=n>1</span><span class=o>))))</span></code></pre></div></div><div class=language-py><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=n>pcollection</span> <span class=o>|</span> <span class=n>WindowInto</span><span class=p>(</span>
    <span class=n>FixedWindows</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=mi>60</span><span class=p>),</span>
    <span class=n>trigger</span><span class=o>=</span><span class=n>Repeatedly</span><span class=p>(</span>
        <span class=n>AfterAny</span><span class=p>(</span><span class=n>AfterCount</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span> <span class=n>AfterProcessingTime</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=mi>60</span><span class=p>))),</span>
    <span class=n>accumulation_mode</span><span class=o>=</span><span class=n>AccumulationMode</span><span class=o>.</span><span class=n>DISCARDING</span><span class=p>)</span></code></pre></div></div><h2 id=metrics>10. Metrics</h2><p>In the Beam model, metrics provide some insight into the current state of a user pipeline,
potentially while the pipeline is running. There could be different reasons for that, for instance:</p><ul><li>Check the number of errors encountered while running a specific step in the pipeline;</li><li>Monitor the number of RPCs made to backend service;</li><li>Retrieve an accurate count of the number of elements that have been processed;</li><li>&mldr;and so on.</li></ul><h3 id=101-the-main-concepts-of-beam-metrics>10.1 The main concepts of Beam metrics</h3><ul><li><strong>Named</strong>. Each metric has a name which consists of a namespace and an actual name. The
namespace can be used to differentiate between multiple metrics with the same name and also
allows querying for all metrics within a specific namespace.</li><li><strong>Scoped</strong>. Each metric is reported against a specific step in the pipeline, indicating what
code was running when the metric was incremented.</li><li><strong>Dynamically Created</strong>. Metrics may be created during runtime without pre-declaring them, in
much the same way a logger could be created. This makes it easier to produce metrics in utility
code and have them usefully reported.</li><li><strong>Degrade Gracefully</strong>. If a runner doesn’t support some part of reporting metrics, the
fallback behavior is to drop the metric updates rather than failing the pipeline. If a runner
doesn’t support some part of querying metrics, the runner will not return the associated data.</li></ul><p>Reported metrics are implicitly scoped to the transform within the pipeline that reported them.
This allows reporting the same metric name in multiple places and identifying the value each
transform reported, as well as aggregating the metric across the entire pipeline.</p><blockquote><p><strong>Note:</strong> It is runner-dependent whether metrics are accessible during pipeline execution or only
after jobs have completed.</p></blockquote><h3 id=types-of-metrics>10.2 Types of metrics</h3><p>There are three types of metrics that are supported for the moment: <code>Counter</code>, <code>Distribution</code> and
<code>Gauge</code>.</p><p><strong>Counter</strong>: A metric that reports a single long value and can be incremented or decremented.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Counter</span> <span class=n>counter</span> <span class=o>=</span> <span class=n>Metrics</span><span class=o>.</span><span class=na>counter</span><span class=o>(</span> <span class=s>&#34;namespace&#34;</span><span class=o>,</span> <span class=s>&#34;counter1&#34;</span><span class=o>);</span>

<span class=nd>@ProcessElement</span>
<span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=n>ProcessContext</span> <span class=n>context</span><span class=o>)</span> <span class=o>{</span>
  <span class=c1>// count the elements
</span><span class=c1></span>  <span class=n>counter</span><span class=o>.</span><span class=na>inc</span><span class=o>();</span>
  <span class=o>...</span>
<span class=o>}</span></code></pre></div></div><p><strong>Distribution</strong>: A metric that reports information about the distribution of reported values.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Distribution</span> <span class=n>distribution</span> <span class=o>=</span> <span class=n>Metrics</span><span class=o>.</span><span class=na>distribution</span><span class=o>(</span> <span class=s>&#34;namespace&#34;</span><span class=o>,</span> <span class=s>&#34;distribution1&#34;</span><span class=o>);</span>

<span class=nd>@ProcessElement</span>
<span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=n>ProcessContext</span> <span class=n>context</span><span class=o>)</span> <span class=o>{</span>
  <span class=n>Integer</span> <span class=n>element</span> <span class=o>=</span> <span class=n>context</span><span class=o>.</span><span class=na>element</span><span class=o>();</span>
    <span class=c1>// create a distribution (histogram) of the values 
</span><span class=c1></span>    <span class=n>distribution</span><span class=o>.</span><span class=na>update</span><span class=o>(</span><span class=n>element</span><span class=o>);</span>
    <span class=o>...</span>
<span class=o>}</span></code></pre></div></div><p><strong>Gauge</strong>: A metric that reports the latest value out of reported values. Since metrics are
collected from many workers the value may not be the absolute last, but one of the latest values.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Gauge</span> <span class=n>gauge</span> <span class=o>=</span> <span class=n>Metrics</span><span class=o>.</span><span class=na>gauge</span><span class=o>(</span> <span class=s>&#34;namespace&#34;</span><span class=o>,</span> <span class=s>&#34;gauge1&#34;</span><span class=o>);</span>

<span class=nd>@ProcessElement</span>
<span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=n>ProcessContext</span> <span class=n>context</span><span class=o>)</span> <span class=o>{</span>
  <span class=n>Integer</span> <span class=n>element</span> <span class=o>=</span> <span class=n>context</span><span class=o>.</span><span class=na>element</span><span class=o>();</span>
  <span class=c1>// create a gauge (latest value received) of the values 
</span><span class=c1></span>  <span class=n>gauge</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=n>element</span><span class=o>);</span>
  <span class=o>...</span>
<span class=o>}</span></code></pre></div></div><h3 id=querying-metrics>10.3 Querying metrics</h3><p><code>PipelineResult</code> has a method <code>metrics()</code> which returns a <code>MetricResults</code> object that allows
accessing metrics. The main method available in <code>MetricResults</code> allows querying for all metrics
matching a given filter.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>PipelineResult</span> <span class=o>{</span>
  <span class=n>MetricResults</span> <span class=nf>metrics</span><span class=o>();</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kd>abstract</span> <span class=kd>class</span> <span class=nc>MetricResults</span> <span class=o>{</span>
  <span class=kd>public</span> <span class=kd>abstract</span> <span class=n>MetricQueryResults</span> <span class=nf>queryMetrics</span><span class=o>(</span><span class=nd>@Nullable</span> <span class=n>MetricsFilter</span> <span class=n>filter</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kd>interface</span> <span class=nc>MetricQueryResults</span> <span class=o>{</span>
  <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>MetricResult</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>&gt;&gt;</span> <span class=nf>getCounters</span><span class=o>();</span>
  <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>MetricResult</span><span class=o>&lt;</span><span class=n>DistributionResult</span><span class=o>&gt;&gt;</span> <span class=nf>getDistributions</span><span class=o>();</span>
  <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>MetricResult</span><span class=o>&lt;</span><span class=n>GaugeResult</span><span class=o>&gt;&gt;</span> <span class=nf>getGauges</span><span class=o>();</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kd>interface</span> <span class=nc>MetricResult</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
  <span class=n>MetricName</span> <span class=nf>getName</span><span class=o>();</span>
  <span class=n>String</span> <span class=nf>getStep</span><span class=o>();</span>
  <span class=n>T</span> <span class=nf>getCommitted</span><span class=o>();</span>
  <span class=n>T</span> <span class=nf>getAttempted</span><span class=o>();</span>
<span class=o>}</span></code></pre></div></div><h3 id=using-metrics>10.4 Using metrics in pipeline</h3><p>Below, there is a simple example of how to use a <code>Counter</code> metric in a user pipeline.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// creating a pipeline with custom metrics DoFn
</span><span class=c1></span><span class=n>pipeline</span>
    <span class=o>.</span><span class=na>apply</span><span class=o>(...)</span>
    <span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>MyMetricsDoFn</span><span class=o>()));</span>

<span class=n>pipelineResult</span> <span class=o>=</span> <span class=n>pipeline</span><span class=o>.</span><span class=na>run</span><span class=o>().</span><span class=na>waitUntilFinish</span><span class=o>(...);</span>

<span class=c1>// request the metric called &#34;counter1&#34; in namespace called &#34;namespace&#34;
</span><span class=c1></span><span class=n>MetricQueryResults</span> <span class=n>metrics</span> <span class=o>=</span>
    <span class=n>pipelineResult</span>
        <span class=o>.</span><span class=na>metrics</span><span class=o>()</span>
        <span class=o>.</span><span class=na>queryMetrics</span><span class=o>(</span>
            <span class=n>MetricsFilter</span><span class=o>.</span><span class=na>builder</span><span class=o>()</span>
                <span class=o>.</span><span class=na>addNameFilter</span><span class=o>(</span><span class=n>MetricNameFilter</span><span class=o>.</span><span class=na>named</span><span class=o>(</span><span class=s>&#34;namespace&#34;</span><span class=o>,</span> <span class=s>&#34;counter1&#34;</span><span class=o>))</span>
                <span class=o>.</span><span class=na>build</span><span class=o>());</span>

<span class=c1>// print the metric value - there should be only one line because there is only one metric 
</span><span class=c1>// called &#34;counter1&#34; in the namespace called &#34;namespace&#34;
</span><span class=c1></span><span class=k>for</span> <span class=o>(</span><span class=n>MetricResult</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>&gt;</span> <span class=n>counter</span><span class=o>:</span> <span class=n>metrics</span><span class=o>.</span><span class=na>getCounters</span><span class=o>())</span> <span class=o>{</span>
  <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>counter</span><span class=o>.</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;:&#34;</span> <span class=o>+</span> <span class=n>counter</span><span class=o>.</span><span class=na>getAttempted</span><span class=o>());</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kd>class</span> <span class=nc>MyMetricsDoFn</span> <span class=kd>extends</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>
  <span class=kd>private</span> <span class=kd>final</span> <span class=n>Counter</span> <span class=n>counter</span> <span class=o>=</span> <span class=n>Metrics</span><span class=o>.</span><span class=na>counter</span><span class=o>(</span> <span class=s>&#34;namespace&#34;</span><span class=o>,</span> <span class=s>&#34;counter1&#34;</span><span class=o>);</span>

  <span class=nd>@ProcessElement</span>
  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>processElement</span><span class=o>(</span><span class=n>ProcessContext</span> <span class=n>context</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// count the elements
</span><span class=c1></span>    <span class=n>counter</span><span class=o>.</span><span class=na>inc</span><span class=o>();</span>
    <span class=n>context</span><span class=o>.</span><span class=na>output</span><span class=o>(</span><span class=n>context</span><span class=o>.</span><span class=na>element</span><span class=o>());</span>
  <span class=o>}</span>
<span class=o>}</span></code></pre></div></div><h3 id=export-metrics>10.5 Export metrics</h3><p>Beam metrics can be exported to external sinks. If a metrics sink is set up in the configuration, the runner will push metrics to it at a default 5s period.
The configuration is held in the <a href=https://beam.apache.org/releases/javadoc/2.19.0/org/apache/beam/sdk/metrics/MetricsOptions.html>MetricsOptions</a> class.
It contains push period configuration and also sink specific options such as type and URL. As for now only the REST HTTP and the Graphite sinks are supported and only
Flink and Spark runners support metrics export.</p><p>Also Beam metrics are exported to inner Spark and Flink dashboards to be consulted in their respective UI.</p><h2 id=state-and-timers>11. State and Timers</h2><p>Beam&rsquo;s windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input
data based on timestamps. However there are aggregation use cases for which developers may require a higher degree of
control than provided by windows and triggers. Beam provides an API for manually managing per-key state, allowing for
fine-grained control over aggregations.</p><p>Beam&rsquo;s state API models state per key. To use the state API, you start out with a keyed <code>PCollection</code>, which in Java
is modeled as a <code>PCollection&lt;KV&lt;K, V>></code>. A <code>ParDo</code> processing this <code>PCollection</code> can now declare state variables. Inside
the <code>ParDo</code> these state variables can be used to write or update state for the current key or to read previous state
written for that key. State is always fully scoped only to the current processing key.</p><p>Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This
means that the first time a key is seen for a given window any state reads will return empty, and that a runner can
garbage collect state when a window is completed. It&rsquo;s also often useful to use Beam&rsquo;s windowed aggregations prior to
the stateful operator. For example, using a combiner to preaggregate data, and then storing aggregated data inside of
state. Merging windows are not currently supported when using state and timers.</p><p>Sometimes stateful processing is used to implement state-machine style processing inside a <code>DoFn</code>. When doing this,
care must be taken to remember that the elements in input PCollection have no guaranteed order and to ensure that the
program logic is resilient to this. Unit tests written using the DirectRunner will shuffle the order of element
processing, and are recommended to test for correctness.</p><p class=language-java>In Java DoFn declares states to be accessed by creating final <code>StateSpec</code> member variables representing each state. Each
state must be named using the <code>StateId</code> annotation; this name is unique to a ParDo in the graph and has no relation
to other nodes in the graph. A <code>DoFn</code> can declare multiple state variables.</p><p class=language-py>In Python DoFn declares states to be accessed by creating <code>StateSpec</code> class member variables representing each state. Each
<code>StateSpec</code> is initialized with a name, this name is unique to a ParDo in the graph and has no relation
to other nodes in the graph. A <code>DoFn</code> can declare multiple state variables.</p><h3 id=types-of-state>11.1 Types of state</h3><p>Beam provides several types of state:</p><h4 id=valuestate>ValueState</h4><p>A ValueState is a scalar state value. For each key in the input, a ValueState will store a typed value that can be
read and modified inside the DoFn&rsquo;s <code>@ProcessElement</code> or <code>@OnTimer</code> methods. If the type of the ValueState has a coder
registered, then Beam will automatically infer the coder for the state value. Otherwise, a coder can be explicitly
specified when creating the ValueState. For example, the following ParDo creates a single state variable that
accumulates the number of elements seen.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>numElements</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>
  
  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span><span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>state</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// Read the number element seen so far for this user key.
</span><span class=c1></span>    <span class=c1>// state.read() returns null if it was never set. The below code allows us to have a default value of 0.
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>currentValue</span> <span class=o>=</span> <span class=n>MoreObjects</span><span class=o>.</span><span class=na>firstNonNull</span><span class=o>(</span><span class=n>state</span><span class=o>.</span><span class=na>read</span><span class=o>(),</span> <span class=n>0</span><span class=o>);</span>
    <span class=c1>// Update the state.
</span><span class=c1></span>    <span class=n>state</span><span class=o>.</span><span class=na>write</span><span class=o>(</span><span class=n>currentValue</span> <span class=o>+</span> <span class=n>1</span><span class=o>);</span>
  <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><p>Beam also allows explicitly specifying a coder for <code>ValueState</code> values. For example:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>MyType</span><span class=o>&gt;&gt;</span> <span class=n>numElements</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>(</span><span class=k>new</span> <span class=n>MyTypeCoder</span><span class=o>());</span>
                 <span class=o>...</span>
<span class=o>}));</span></code></pre></div></div><h4 id=combiningstate>CombiningState</h4><p><code>CombiningState</code> allows you to create a state object that is updated using a Beam combiner. For example, the previous
<code>ValueState</code> example could be rewritten to use <code>CombiningState</code></p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>CombiningState</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=kt>int</span><span class=o>[],</span> <span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>numElements</span> <span class=o>=</span> 
      <span class=n>StateSpecs</span><span class=o>.</span><span class=na>combining</span><span class=o>(</span><span class=n>Sum</span><span class=o>.</span><span class=na>ofIntegers</span><span class=o>());</span>
  
  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span><span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>state</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>state</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>1</span><span class=o>);</span>
  <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><div class=language-python><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>class</span> <span class=nc>CombiningStateDoFn</span><span class=p>(</span><span class=n>DoFn</span><span class=p>):</span>
  <span class=n>SUM_TOTAL</span> <span class=o>=</span> <span class=n>CombiningValueStateSpec</span><span class=p>(</span><span class=s1>&#39;total&#39;</span><span class=p>,</span> <span class=nb>sum</span><span class=p>)</span>
  
  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>element</span><span class=p>,</span> <span class=n>state</span><span class=o>=</span><span class=n>SoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>SUM_TOTAL</span><span class=p>)):</span>
    <span class=n>state</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
    
<span class=n>_</span> <span class=o>=</span> <span class=p>(</span><span class=n>p</span> <span class=o>|</span> <span class=s1>&#39;Read per user&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>ReadPerUser</span><span class=p>()</span>
       <span class=o>|</span> <span class=s1>&#39;Combine state pardo&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span><span class=n>CombiningStateDofn</span><span class=p>()))</span></code></pre></div></div><h4 id=bagstate>BagState</h4><p>A common use case for state is to accumulate multiple elements. <code>BagState</code> allows for accumulating an unordered set
of elements. This allows for addition of elements to the collection without requiring the reading of the entire
collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual
bags larger than available memory.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>numElements</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>bag</span><span class=o>();</span>
  
  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span>
    <span class=nd>@Element</span> <span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>element</span><span class=o>,</span> 
    <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>state</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// Add the current element to the bag for this key.
</span><span class=c1></span>    <span class=n>state</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>element</span><span class=o>.</span><span class=na>getValue</span><span class=o>());</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>shouldFetch</span><span class=o>())</span> <span class=o>{</span>
      <span class=c1>// Occasionally we fetch and process the values.
</span><span class=c1></span>      <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>values</span> <span class=o>=</span> <span class=n>state</span><span class=o>.</span><span class=na>read</span><span class=o>();</span>
      <span class=n>processValues</span><span class=o>(</span><span class=n>values</span><span class=o>);</span>
      <span class=n>state</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>  <span class=c1>// Clear the state for this key.
</span><span class=c1></span>    <span class=o>}</span>
  <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><div class=language-python><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>class</span> <span class=nc>BagStateDoFn</span><span class=p>(</span><span class=n>DoFn</span><span class=p>):</span>
  <span class=n>ALL_ELEMENTS</span> <span class=o>=</span> <span class=n>BagStateSpec</span><span class=p>(</span><span class=s1>&#39;buffer&#39;</span><span class=p>,</span> <span class=n>coders</span><span class=o>.</span><span class=n>VarIntCoder</span><span class=p>())</span>
  
  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>element_pair</span><span class=p>,</span> <span class=n>state</span><span class=o>=</span><span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>ALL_ELEMENTS</span><span class=p>)):</span>
    <span class=n>state</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>element_pair</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
    <span class=k>if</span> <span class=n>should_fetch</span><span class=p>():</span>
      <span class=n>all_elements</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>state</span><span class=o>.</span><span class=n>read</span><span class=p>())</span>
      <span class=n>process_values</span><span class=p>(</span><span class=n>all_elements</span><span class=p>)</span>
      <span class=n>state</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
    
<span class=n>_</span> <span class=o>=</span> <span class=p>(</span><span class=n>p</span> <span class=o>|</span> <span class=s1>&#39;Read per user&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>ReadPerUser</span><span class=p>()</span>
       <span class=o>|</span> <span class=s1>&#39;Bag state pardo&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span><span class=n>BagStateDoFn</span><span class=p>()))</span></code></pre></div></div><h3 id=deferred-state-reads>11.2 Deferred state reads</h3><p>When a <code>DoFn</code> contains multiple state specifications, reading each one in order can be slow. Calling the <code>read()</code> function
on a state can cause the runner to perform a blocking read. Performing multiple blocking reads in sequence adds latency
to element processing. If you know that a state will always be read, you can annotate it as @AlwaysFetched, and then the
runner can prefetch all of the states necessary. For example:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
   <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state1&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>state1</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>
   <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state2&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;&gt;</span> <span class=n>state2</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>
   <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state3&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>state3</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>bag</span><span class=o>();</span>

  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span>
    <span class=nd>@AlwaysFetched</span> <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state1&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>state1</span><span class=o>,</span>
    <span class=nd>@AlwaysFetched</span> <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state2&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>state2</span><span class=o>,</span>
    <span class=nd>@AlwaysFetched</span> <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state3&#34;</span><span class=o>)</span> <span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>state3</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>state1</span><span class=o>.</span><span class=na>read</span><span class=o>();</span>
    <span class=n>state2</span><span class=o>.</span><span class=na>read</span><span class=o>();</span>
    <span class=n>state3</span><span class=o>.</span><span class=na>read</span><span class=o>();</span>
  <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><p>If however there are code paths in which the states are not fetched, then annotating with @AlwaysFetched will add
unnecessary fetching for those paths. In this case, the readLater method allows the runner to know that the state will
be read in the future, allowing multiple state reads to be batched together.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state1&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>state1</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>
  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state2&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;&gt;</span> <span class=n>state2</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>
  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state3&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>state3</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>bag</span><span class=o>();</span>

  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span>
    <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state1&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>state1</span><span class=o>,</span>
    <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state2&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>state2</span><span class=o>,</span>
    <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state3&#34;</span><span class=o>)</span> <span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>state3</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=cm>/* should read state */</span><span class=o>)</span> <span class=o>{</span>
      <span class=n>state1</span><span class=o>.</span><span class=na>readLater</span><span class=o>();</span>
      <span class=n>state2</span><span class=o>.</span><span class=na>readLater</span><span class=o>();</span>
      <span class=n>state3</span><span class=o>.</span><span class=na>readLater</span><span class=o>();</span>
    <span class=o>}</span>
   
    <span class=c1>// The runner can now batch all three states into a single read, reducing latency.
</span><span class=c1></span>    <span class=n>processState1</span><span class=o>(</span><span class=n>state1</span><span class=o>.</span><span class=na>read</span><span class=o>());</span>
    <span class=n>processState2</span><span class=o>(</span><span class=n>state2</span><span class=o>.</span><span class=na>read</span><span class=o>());</span>
    <span class=n>processState3</span><span class=o>(</span><span class=n>state3</span><span class=o>.</span><span class=na>read</span><span class=o>());</span>
  <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><h3 id=timers>11.3 Timers</h3><p>Beam provides a per-key timer callback API. This allows for delayed processing of data stored using the state API.
Timers can be set to callback at either an event-time or a processing-time timestamp. Every timer is identified with a
TimerId. A given timer for a key can only be set for a single timestamp. Calling set on a timer overwrites the previous
firing time for that key&rsquo;s timer.</p><h4 id=event-time-timers>11.3.1 Event-time timers</h4><p>Event-time timers fire when the input watermark for the DoFn passes the time at which the timer is set, meaning that
the runner believes that there are no more elements to be processed with timestamps before the timer timestamp. This
allows for event-time aggregations.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>state</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>
  <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;timer&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>TimerSpec</span> <span class=n>timer</span> <span class=o>=</span> <span class=n>TimerSpecs</span><span class=o>.</span><span class=na>timer</span><span class=o>(</span><span class=n>TimeDomain</span><span class=o>.</span><span class=na>EVENT_TIME</span><span class=o>);</span>

  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span>
      <span class=nd>@Element</span> <span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>element</span><span class=o>,</span>
      <span class=nd>@Timestamp</span> <span class=n>Instant</span> <span class=n>elementTs</span><span class=o>,</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>state</span><span class=o>,</span> 
      <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;timer&#34;</span><span class=o>)</span> <span class=n>Timer</span> <span class=n>timer</span><span class=o>)</span> <span class=o>{</span>
     <span class=o>...</span>
     <span class=c1>// Set an event-time timer to the element timestamp.
</span><span class=c1></span>     <span class=n>timer</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=n>elementTs</span><span class=o>);</span>
  <span class=o>}</span>
  
   <span class=nd>@OnTimer</span><span class=o>(</span><span class=s>&#34;timer&#34;</span><span class=o>)</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onTimer</span><span class=o>()</span> <span class=o>{</span>
      <span class=c1>//Process timer.
</span><span class=c1></span>   <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><div class=language-python><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>class</span> <span class=nc>EventTimerDoFn</span><span class=p>(</span><span class=n>DoFn</span><span class=p>):</span>
  <span class=n>ALL_ELEMENTS</span> <span class=o>=</span> <span class=n>BagStateSpec</span><span class=p>(</span><span class=s1>&#39;buffer&#39;</span><span class=p>,</span> <span class=n>coders</span><span class=o>.</span><span class=n>VarIntCoder</span><span class=p>())</span>
  <span class=n>TIMER</span> <span class=o>=</span> <span class=n>TimerSpec</span><span class=p>(</span><span class=s1>&#39;timer&#39;</span><span class=p>,</span> <span class=n>TimeDomain</span><span class=o>.</span><span class=n>WATERMARK</span><span class=p>)</span>
  
  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> 
              <span class=n>element_pair</span><span class=p>,</span> 
              <span class=n>t</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>TimestampParam</span><span class=p>,</span>
              <span class=nb>buffer</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>ALL_ELEMENTS</span><span class=p>),</span> 
              <span class=n>timer</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>TimerParam</span><span class=p>(</span><span class=n>TIMER</span><span class=p>)):</span>
    <span class=nb>buffer</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>element_pair</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
    <span class=c1># Set an event-time timer to the element timestamp.</span>
    <span class=n>timer</span><span class=o>.</span><span class=n>set</span><span class=p>(</span><span class=n>t</span><span class=p>)</span>
  
  <span class=nd>@on_timer</span><span class=p>(</span><span class=n>TIMER</span><span class=p>)</span>
  <span class=k>def</span> <span class=nf>expiry_callback</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=nb>buffer</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>ALL_ELEMENTS</span><span class=p>)):</span>
    <span class=n>state</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
    
<span class=n>_</span> <span class=o>=</span> <span class=p>(</span><span class=n>p</span> <span class=o>|</span> <span class=s1>&#39;Read per user&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>ReadPerUser</span><span class=p>()</span>
       <span class=o>|</span> <span class=s1>&#39;EventTime timer pardo&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span><span class=n>EventTimerDoFn</span><span class=p>()))</span></code></pre></div></div><h4 id=processing-time-timers>11.3.2 Processing-time timers</h4><p>Processing-time timers fire when the real wall-clock time passes. This is often used to create larger batches of data
before processing. It can also be used to schedule events that should occur at a specific time. Just like with
event-time timers, processing-time timers are per key - each key has a separate copy of the timer.</p><p>While processing-time timers can be set to an absolute timestamp, it is very common to set them to an offset relative
to the current time. In Java, the <code>Timer.offset</code> and <code>Timer.setRelative</code> methods can be used to accomplish this.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;timer&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>TimerSpec</span> <span class=n>timer</span> <span class=o>=</span> <span class=n>TimerSpecs</span><span class=o>.</span><span class=na>timer</span><span class=o>(</span><span class=n>TimeDomain</span><span class=o>.</span><span class=na>PROCESSING_TIME</span><span class=o>);</span>

  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span><span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;timer&#34;</span><span class=o>)</span> <span class=n>Timer</span> <span class=n>timer</span><span class=o>)</span> <span class=o>{</span>
     <span class=o>...</span>
     <span class=c1>// Set a timer to go off 30 seconds in the future.
</span><span class=c1></span>     <span class=n>timer</span><span class=o>.</span><span class=na>offset</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardSeconds</span><span class=o>(</span><span class=n>30</span><span class=o>)).</span><span class=na>setRelative</span><span class=o>();</span>
  <span class=o>}</span>
  
   <span class=nd>@OnTimer</span><span class=o>(</span><span class=s>&#34;timer&#34;</span><span class=o>)</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onTimer</span><span class=o>()</span> <span class=o>{</span>
      <span class=c1>//Process timer.
</span><span class=c1></span>   <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><div class=language-python><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>class</span> <span class=nc>ProcessingTimerDoFn</span><span class=p>(</span><span class=n>DoFn</span><span class=p>):</span>
  <span class=n>ALL_ELEMENTS</span> <span class=o>=</span> <span class=n>BagStateSpec</span><span class=p>(</span><span class=s1>&#39;buffer&#39;</span><span class=p>,</span> <span class=n>coders</span><span class=o>.</span><span class=n>VarIntCoder</span><span class=p>())</span>
  <span class=n>TIMER</span> <span class=o>=</span> <span class=n>TimerSpec</span><span class=p>(</span><span class=s1>&#39;timer&#39;</span><span class=p>,</span> <span class=n>TimeDomain</span><span class=o>.</span><span class=n>REAL_TIME</span><span class=p>)</span>
  
  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> 
              <span class=n>element_pair</span><span class=p>,</span> 
              <span class=nb>buffer</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>ALL_ELEMENTS</span><span class=p>),</span> 
              <span class=n>timer</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>TimerParam</span><span class=p>(</span><span class=n>TIMER</span><span class=p>)):</span>
    <span class=nb>buffer</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>element_pair</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
    <span class=c1># Set a timer to go off 30 seconds in the future.</span>
    <span class=n>timer</span><span class=o>.</span><span class=n>set</span><span class=p>(</span><span class=n>Timestamp</span><span class=o>.</span><span class=n>now</span><span class=p>()</span> <span class=o>+</span> <span class=n>Duration</span><span class=p>(</span><span class=n>seconds</span><span class=o>=</span><span class=mi>30</span><span class=p>))</span>
  
  <span class=nd>@on_timer</span><span class=p>(</span><span class=n>TIMER</span><span class=p>)</span>
  <span class=k>def</span> <span class=nf>expiry_callback</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=nb>buffer</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>ALL_ELEMENTS</span><span class=p>)):</span>
    <span class=c1># Process timer.</span>
    <span class=n>state</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
    
<span class=n>_</span> <span class=o>=</span> <span class=p>(</span><span class=n>p</span> <span class=o>|</span> <span class=s1>&#39;Read per user&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>ReadPerUser</span><span class=p>()</span>
       <span class=o>|</span> <span class=s1>&#39;ProcessingTime timer pardo&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span><span class=n>ProcessingTimerDoFn</span><span class=p>()))</span></code></pre></div></div><h4 id=dynamic-timer-tags>11.3.3 Dynamic timer tags</h4><p>Beam also supports dynamically setting a timer tag using <code>TimerMap</code>. This allows for setting multiple different timers
in a <code>DoFn</code> and allowing for the timer tags to be dynamically chosen - e.g. based on data in the input elements. A
timer with a specific tag can only be set to a single timestamp, so setting the timer again has the effect of
overwriting the previous expiration time for the timer with that tag. Each <code>TimerMap</code> is identified with a timer family
id, and timers in different timer families are independent.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@TimerFamily</span><span class=o>(</span><span class=s>&#34;actionTimers&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>TimerSpec</span> <span class=n>timer</span> <span class=o>=</span>
    <span class=n>TimerSpecs</span><span class=o>.</span><span class=na>timerMap</span><span class=o>(</span><span class=n>TimeDomain</span><span class=o>.</span><span class=na>EVENT_TIME</span><span class=o>);</span>

  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span>
      <span class=nd>@Element</span> <span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>element</span><span class=o>,</span> 
      <span class=nd>@Timestamp</span> <span class=n>Instant</span> <span class=n>elementTs</span><span class=o>,</span>
      <span class=nd>@TimerFamily</span><span class=o>(</span><span class=s>&#34;actionTimers&#34;</span><span class=o>)</span> <span class=n>TimerMap</span> <span class=n>timers</span><span class=o>)</span> <span class=o>{</span>
     <span class=n>timers</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=n>element</span><span class=o>.</span><span class=na>getValue</span><span class=o>().</span><span class=na>getActionType</span><span class=o>(),</span> <span class=n>elementTs</span><span class=o>);</span>
  <span class=o>}</span>
  
   <span class=nd>@OnTimerFamily</span><span class=o>(</span><span class=s>&#34;actionTimers&#34;</span><span class=o>)</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onTimer</span><span class=o>(</span><span class=nd>@TimerId</span> <span class=n>String</span> <span class=n>timerId</span><span class=o>)</span> <span class=o>{</span>
     <span class=n>LOG</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;Timer fired with id &#34;</span> <span class=o>+</span> <span class=n>timerId</span><span class=o>);</span>
   <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><div class=language-python><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>To</span> <span class=n>be</span> <span class=n>supported</span><span class=p>,</span> <span class=n>See</span> <span class=n>BEAM</span><span class=o>-</span><span class=mi>9602</span></code></pre></div></div><h4 id=timer-output-timestamps>11.3.4 Timer output timestamps</h4><p>By default, event-time timers will hold the output watermark of the <code>ParDo</code> to the timestamp of the timer. This means
that if a timer is set to 12pm, any windowed aggregations or event-time timers later in the pipeline graph that finish<br>after 12pm will not expire. The timestamp of the timer is also the default output timestamp for the timer callback. This
means that any elements output from the onTimer method will have a timestamp equal to the timestamp of the timer firing.
For processing-time timers, the default output timestamp and watermark hold is the value of the input watermark at the
time the timer was set.</p><p>In some cases, a DoFn needs to output timestamps earlier than the timer expiration time, and therefore also needs to
hold its output watermark to those timestamps. For example, consider the following pipeline that temporarily batches
records into state, and sets a timer to drain the state. This code may appear correct, but will not work properly.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;elementBag&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>elementBag</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>bag</span><span class=o>();</span>
  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;timerSet&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;&gt;</span> <span class=n>timerSet</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>
  <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;outputState&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>TimerSpec</span> <span class=n>timer</span> <span class=o>=</span> <span class=n>TimerSpecs</span><span class=o>.</span><span class=na>timer</span><span class=o>(</span><span class=n>TimeDomain</span><span class=o>.</span><span class=na>PROCESSING_TIME</span><span class=o>);</span>
  
  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span>
      <span class=nd>@Element</span> <span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>element</span><span class=o>,</span> 
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;elementBag&#34;</span><span class=o>)</span> <span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>elementBag</span><span class=o>,</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;timerSet&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span> <span class=n>timerSet</span><span class=o>,</span>
      <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;outputState&#34;</span><span class=o>)</span> <span class=n>Timer</span> <span class=n>timer</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// Add the current element to the bag for this key.
</span><span class=c1></span>    <span class=n>elementBag</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>element</span><span class=o>.</span><span class=na>getValue</span><span class=o>());</span>
    <span class=k>if</span> <span class=o>(!</span><span class=n>MoreObjects</span><span class=o>.</span><span class=na>firstNonNull</span><span class=o>(</span><span class=n>timerSet</span><span class=o>.</span><span class=na>read</span><span class=o>(),</span> <span class=kc>false</span><span class=o>))</span> <span class=o>{</span>
      <span class=c1>// If the timer is not current set, then set it to go off in a minute.
</span><span class=c1></span>      <span class=n>timer</span><span class=o>.</span><span class=na>offset</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardMinutes</span><span class=o>(</span><span class=n>1</span><span class=o>)).</span><span class=na>setRelative</span><span class=o>();</span>
      <span class=n>timerSet</span><span class=o>.</span><span class=na>write</span><span class=o>(</span><span class=kc>true</span><span class=o>);</span>
    <span class=o>}</span>
  <span class=o>}</span>
  
  <span class=nd>@OnTimer</span><span class=o>(</span><span class=s>&#34;outputState&#34;</span><span class=o>)</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onTimer</span><span class=o>(</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;elementBag&#34;</span><span class=o>)</span> <span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>elementBag</span><span class=o>,</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;timerSet&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span> <span class=n>timerSet</span><span class=o>,</span>
      <span class=n>OutputReceiver</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>output</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>for</span> <span class=o>(</span><span class=n>ValueT</span> <span class=n>bufferedElement</span> <span class=o>:</span> <span class=n>elementBag</span><span class=o>.</span><span class=na>read</span><span class=o>())</span> <span class=o>{</span>
      <span class=c1>// Output each element.
</span><span class=c1></span>      <span class=n>output</span><span class=o>.</span><span class=na>outputWithTimestamp</span><span class=o>(</span><span class=n>bufferedElement</span><span class=o>,</span> <span class=n>bufferedElement</span><span class=o>.</span><span class=na>timestamp</span><span class=o>());</span>
    <span class=o>}</span>
    <span class=n>elementBag</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>
    <span class=c1>// Note that the timer has now fired.
</span><span class=c1></span>    <span class=n>timerSet</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>
  <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><p>The problem with this code is that the ParDo is buffering elements, however nothing is preventing the watermark
from advancing past the timestamp of those elements, so all those elements might be dropped as late data. In order
to prevent this from happening, an output timestamp needs to be set on the timer to prevent the watermark from advancing
past the timestamp of the minimum element. The following code demonstrates this.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=c1>// The bag of elements accumulated.
</span><span class=c1></span>  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;elementBag&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>elementBag</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>bag</span><span class=o>();</span>
  <span class=c1>// The timestamp of the timer set.
</span><span class=c1></span>  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;timerTimestamp&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>&gt;&gt;</span> <span class=n>timerTimestamp</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>
  <span class=c1>// The minimum timestamp stored in the bag.
</span><span class=c1></span>  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;minTimestampInBag&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>CombiningState</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>,</span> <span class=kt>long</span><span class=o>[],</span> <span class=n>Long</span><span class=o>&gt;&gt;</span> 
     <span class=n>minTimestampInBag</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>combining</span><span class=o>(</span><span class=n>Min</span><span class=o>.</span><span class=na>ofLongs</span><span class=o>());</span>

  <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;outputState&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>TimerSpec</span> <span class=n>timer</span> <span class=o>=</span> <span class=n>TimerSpecs</span><span class=o>.</span><span class=na>timer</span><span class=o>(</span><span class=n>TimeDomain</span><span class=o>.</span><span class=na>PROCESSING_TIME</span><span class=o>);</span>
  
  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span>
      <span class=nd>@Element</span> <span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>element</span><span class=o>,</span> 
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;elementBag&#34;</span><span class=o>)</span> <span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>elementBag</span><span class=o>,</span>
      <span class=nd>@AlwaysFetched</span> <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;timerTimestamp&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>&gt;</span> <span class=n>timerTimestamp</span><span class=o>,</span>
      <span class=nd>@AlwaysFetched</span> <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;minTimestampInBag&#34;</span><span class=o>)</span> <span class=n>CombiningState</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>,</span> <span class=kt>long</span><span class=o>[],</span> <span class=n>Long</span><span class=o>&gt;</span> <span class=n>minTimestamp</span><span class=o>,</span>
      <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;outputState&#34;</span><span class=o>)</span> <span class=n>Timer</span> <span class=n>timer</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// Add the current element to the bag for this key.
</span><span class=c1></span>    <span class=n>elementBag</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>element</span><span class=o>.</span><span class=na>getValue</span><span class=o>());</span>
    <span class=c1>// Keep track of the minimum element timestamp currently stored in the bag.
</span><span class=c1></span>    <span class=n>minTimestamp</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>element</span><span class=o>.</span><span class=na>getValue</span><span class=o>().</span><span class=na>timestamp</span><span class=o>());</span>

    <span class=c1>// If the timer is already set, then reset it at the same time but with an updated output timestamp (otherwise
</span><span class=c1></span>    <span class=c1>// we would keep resetting the timer to the future). If there is no timer set, then set one to expire in a minute.
</span><span class=c1></span>    <span class=n>Long</span> <span class=n>timerTimestampMs</span> <span class=o>=</span> <span class=n>timerTimestamp</span><span class=o>.</span><span class=na>read</span><span class=o>();</span>
    <span class=n>Instant</span> <span class=n>timerToSet</span> <span class=o>=</span> <span class=o>(</span><span class=n>timerTimestamp</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>().</span><span class=na>read</span><span class=o>())</span>
        <span class=o>?</span> <span class=n>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>().</span><span class=na>plus</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardMinutes</span><span class=o>(</span><span class=n>1</span><span class=o>))</span> <span class=o>:</span> <span class=k>new</span> <span class=n>Instant</span><span class=o>(</span><span class=n>timerTimestampMs</span><span class=o>);</span>
    <span class=c1>// Setting the outputTimestamp to the minimum timestamp in the bag holds the watermark to that timestamp until the
</span><span class=c1></span>    <span class=c1>// timer fires. This allows outputting all the elements with their timestamp.
</span><span class=c1></span>    <span class=n>timer</span><span class=o>.</span><span class=na>withOutputTimestamp</span><span class=o>(</span><span class=n>minTimestamp</span><span class=o>.</span><span class=na>read</span><span class=o>()).</span><span class=na>set</span><span class=o>(</span><span class=n>timerToSet</span><span class=o>).</span>
    <span class=n>timerTimestamp</span><span class=o>.</span><span class=na>write</span><span class=o>(</span><span class=n>timerToSet</span><span class=o>.</span><span class=na>getMillis</span><span class=o>());</span>
  <span class=o>}</span>
  
  <span class=nd>@OnTimer</span><span class=o>(</span><span class=s>&#34;outputState&#34;</span><span class=o>)</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onTimer</span><span class=o>(</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;elementBag&#34;</span><span class=o>)</span> <span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>elementBag</span><span class=o>,</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;timerTimestamp&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>&gt;</span> <span class=n>timerTimestamp</span><span class=o>,</span>
      <span class=n>OutputReceiver</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>output</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>for</span> <span class=o>(</span><span class=n>ValueT</span> <span class=n>bufferedElement</span> <span class=o>:</span> <span class=n>elementBag</span><span class=o>.</span><span class=na>read</span><span class=o>())</span> <span class=o>{</span>
      <span class=c1>// Output each element.
</span><span class=c1></span>      <span class=n>output</span><span class=o>.</span><span class=na>outputWithTimestamp</span><span class=o>(</span><span class=n>bufferedElement</span><span class=o>,</span> <span class=n>bufferedElement</span><span class=o>.</span><span class=na>timestamp</span><span class=o>());</span>
    <span class=o>}</span>
    <span class=c1>// Note that the timer has now fired.
</span><span class=c1></span>    <span class=n>timerTimestamp</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>
  <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div><h3 id=garbage-collecting-state>11.4 Garbage collecting state</h3><p>Per-key state needs to be garbage collected, or eventually the increasing size of state may negatively impact
performance. There are two common strategies for garbage collecting state.</p><h5 id=using-windows-for-garbage-collection>11.4.1 <strong>Using windows for garbage collection</strong></h5><p>All state and timers for a key is scoped to the window it is in. This means that depending on the timestamp of the
input element the ParDo will see different values for the state depending on the window that element falls into. In
addition, once the input watermark passes the end of the window, the runner should garbage collect all state for that
window. (note: if allowed lateness is set to a positive value for the window, the runner must wait for the watermark to
pass the end of the window plus the allowed lateness before garbage collecting state). This can be used as a
garbage-collection strategy.</p><p>For example, given the following:</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>Window</span><span class=o>.</span><span class=na>into</span><span class=o>(</span><span class=n>CalendarWindows</span><span class=o>.</span><span class=na>days</span><span class=o>(</span><span class=n>1</span><span class=o>)</span>
   <span class=o>.</span><span class=na>withTimeZone</span><span class=o>(</span><span class=n>DateTimeZone</span><span class=o>.</span><span class=na>forID</span><span class=o>(</span><span class=s>&#34;America/Los_Angeles&#34;</span><span class=o>))));</span>
       <span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
           <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>state</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>
                              <span class=o>...</span>
           <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span><span class=nd>@Timestamp</span> <span class=n>Instant</span> <span class=n>ts</span><span class=o>,</span> <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>state</span><span class=o>)</span> <span class=o>{</span>
              <span class=c1>// The state is scoped to a calendar day window. That means that if the input timestamp ts is after
</span><span class=c1></span>              <span class=c1>// midnight PST, then a new copy of the state will be seen for the next day.
</span><span class=c1></span>           <span class=o>}</span>
         <span class=o>}));</span></code></pre></div></div><div class=language-python><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>class</span> <span class=nc>StateDoFn</span><span class=p>(</span><span class=n>DoFn</span><span class=p>):</span>
  <span class=n>ALL_ELEMENTS</span> <span class=o>=</span> <span class=n>BagStateSpec</span><span class=p>(</span><span class=s1>&#39;buffer&#39;</span><span class=p>,</span> <span class=n>coders</span><span class=o>.</span><span class=n>VarIntCoder</span><span class=p>())</span>
  
  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> 
              <span class=n>element_pair</span><span class=p>,</span> 
              <span class=nb>buffer</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>ALL_ELEMENTS</span><span class=p>)):</span>
    <span class=o>...</span>
    
<span class=n>_</span> <span class=o>=</span> <span class=p>(</span><span class=n>p</span> <span class=o>|</span> <span class=s1>&#39;Read per user&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>ReadPerUser</span><span class=p>()</span>
       <span class=o>|</span> <span class=s1>&#39;Windowing&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>WindowInto</span><span class=p>(</span><span class=n>FixedWindows</span><span class=p>(</span><span class=mi>60</span> <span class=o>*</span> <span class=mi>60</span> <span class=o>*</span> <span class=mi>24</span><span class=p>))</span>
       <span class=o>|</span> <span class=s1>&#39;DoFn&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span><span class=n>StateDoFn</span><span class=p>()))</span></code></pre></div></div><p>This <code>ParDo</code> stores state per day. Once the pipeline is done processing data for a given day, all the state for that
day is garbage collected.</p><h5 id=using-timers-for-garbage-collection>11.4.1 <strong>Using timers For garbage collection</strong></h5><p>In some cases, it is difficult to find a windowing strategy that models the desired garbage-collection strategy. For
example, a common desire is to garbage collect state for a key once no activity has been seen on the key for some time.
This can be done by updating a timer that garbage collects state. For example</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=c1>// The state for the key.
</span><span class=c1></span>  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>state</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>

  <span class=c1>// The maximum element timestamp seen so far.
</span><span class=c1></span>  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;maxTimestampSeen&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>CombiningState</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>,</span> <span class=kt>long</span><span class=o>[],</span> <span class=n>Long</span><span class=o>&gt;&gt;</span> 
     <span class=n>maxTimestamp</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>combining</span><span class=o>(</span><span class=n>Max</span><span class=o>.</span><span class=na>ofLongs</span><span class=o>());</span>

  <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;gcTimer&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>TimerSpec</span> <span class=n>gcTimer</span> <span class=o>=</span> <span class=n>TimerSpecs</span><span class=o>.</span><span class=na>timer</span><span class=o>(</span><span class=n>TimeDomain</span><span class=o>.</span><span class=na>EVENT_TIME</span><span class=o>);</span>

  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span>
      <span class=nd>@Element</span> <span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>element</span><span class=o>,</span>
      <span class=nd>@Timestamp</span> <span class=n>Instant</span> <span class=n>ts</span><span class=o>,</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>state</span><span class=o>,</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;maxTimestampSeen&#34;</span><span class=o>)</span> <span class=n>CombiningState</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>,</span> <span class=kt>long</span><span class=o>[],</span> <span class=n>Long</span><span class=o>&gt;</span> <span class=n>maxTimestamp</span><span class=o>,</span>
      <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;gcTimer&#34;</span><span class=o>)</span> <span class=n>gcTimer</span><span class=o>)</span> <span class=o>{</span> 
    <span class=n>updateState</span><span class=o>(</span><span class=n>state</span><span class=o>,</span> <span class=n>element</span><span class=o>);</span>
    <span class=n>maxTimestamp</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>ts</span><span class=o>.</span><span class=na>getMillis</span><span class=o>());</span>
    
    <span class=c1>// Set the timer to be one hour after the maximum timestamp seen. This will keep overwriting the same timer, so 
</span><span class=c1></span>    <span class=c1>// as long as there is activity on this key the state will stay active. Once the key goes inactive for one hour&#39;s
</span><span class=c1></span>    <span class=c1>// worth of event time (as measured by the watermark), then the gc timer will fire.
</span><span class=c1></span>    <span class=n>Instant</span> <span class=n>expirationTime</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Instant</span><span class=o>(</span><span class=n>maxTimestamp</span><span class=o>.</span><span class=na>read</span><span class=o>()).</span><span class=na>plus</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardHours</span><span class=o>(</span><span class=n>1</span><span class=o>));</span>
    <span class=n>timer</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=n>expirationTime</span><span class=o>);</span>
  <span class=o>}</span>

  <span class=nd>@OnTimer</span><span class=o>(</span><span class=s>&#34;gcTimer&#34;</span><span class=o>)</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onTimer</span><span class=o>(</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>state</span><span class=o>,</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;maxTimestampSeen&#34;</span><span class=o>)</span> <span class=n>CombiningState</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>,</span> <span class=kt>long</span><span class=o>[],</span> <span class=n>Long</span><span class=o>&gt;</span> <span class=n>maxTimestamp</span><span class=o>)</span> <span class=o>{</span>
       <span class=c1>// Clear all state for the key.
</span><span class=c1></span>       <span class=n>state</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>
       <span class=n>maxTimestamp</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>
    <span class=o>}</span>
 <span class=o>}</span></code></pre></div></div><div class=language-python><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>class</span> <span class=nc>UserDoFn</span><span class=p>(</span><span class=n>DoFn</span><span class=p>):</span>
  <span class=n>ALL_ELEMENTS</span> <span class=o>=</span> <span class=n>BagStateSpec</span><span class=p>(</span><span class=s1>&#39;state&#39;</span><span class=p>,</span> <span class=n>coders</span><span class=o>.</span><span class=n>VarIntCoder</span><span class=p>())</span>
  <span class=n>MAX_TIMESTAMP</span> <span class=o>=</span> <span class=n>CombiningValueStateSpec</span><span class=p>(</span><span class=s1>&#39;max_timestamp_seen&#39;</span><span class=p>,</span> <span class=nb>max</span><span class=p>)</span>
  <span class=n>TIMER</span> <span class=o>=</span> <span class=n>TimerSpec</span><span class=p>(</span><span class=s1>&#39;gc-timer&#39;</span><span class=p>,</span> <span class=n>TimeDomain</span><span class=o>.</span><span class=n>WATERMARK</span><span class=p>)</span>
  
  <span class=k>def</span> <span class=nf>process</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> 
              <span class=n>element</span><span class=p>,</span> 
              <span class=n>t</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>TimestampParam</span><span class=p>,</span>
              <span class=n>state</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>ALL_ELEMENTS</span><span class=p>),</span> 
              <span class=n>max_timestamp</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>MAX_TIMESTAMP</span><span class=p>),</span>
              <span class=n>timer</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>TimerParam</span><span class=p>(</span><span class=n>TIMER</span><span class=p>)):</span>
    <span class=n>update_state</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>element</span><span class=p>)</span>
    <span class=n>max_timestamp</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>t</span><span class=o>.</span><span class=n>micros</span><span class=p>)</span>
    
    <span class=c1># Set the timer to be one hour after the maximum timestamp seen. This will keep overwriting the same timer, so </span>
    <span class=c1># as long as there is activity on this key the state will stay active. Once the key goes inactive for one hour&#39;s</span>
    <span class=c1># worth of event time (as measured by the watermark), then the gc timer will fire.</span>
    <span class=n>expiration_time</span> <span class=o>=</span> <span class=n>Timestamp</span><span class=p>(</span><span class=n>micros</span><span class=o>=</span><span class=n>max_timestamp</span><span class=o>.</span><span class=n>read</span><span class=p>())</span> <span class=o>+</span> <span class=n>Duration</span><span class=p>(</span><span class=n>seconds</span><span class=o>=</span><span class=mi>60</span><span class=o>*</span><span class=mi>60</span><span class=p>)</span>
    <span class=n>timer</span><span class=o>.</span><span class=n>set</span><span class=p>(</span><span class=n>expiration_time</span><span class=p>)</span>
  
  <span class=nd>@on_timer</span><span class=p>(</span><span class=n>TIMER</span><span class=p>)</span>
  <span class=k>def</span> <span class=nf>expiry_callback</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> 
                      <span class=n>state</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>ALL_ELEMENTS</span><span class=p>),</span>
                      <span class=n>max_timestamp</span> <span class=o>=</span> <span class=n>DoFn</span><span class=o>.</span><span class=n>StateParam</span><span class=p>(</span><span class=n>MAX_TIMESTAMP</span><span class=p>)):</span>
    <span class=n>state</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
    <span class=n>max_timestamp</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
  
    
<span class=n>_</span> <span class=o>=</span> <span class=p>(</span><span class=n>p</span> <span class=o>|</span> <span class=s1>&#39;Read per user&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>ReadPerUser</span><span class=p>()</span>
       <span class=o>|</span> <span class=s1>&#39;User DoFn&#39;</span> <span class=o>&gt;&gt;</span> <span class=n>beam</span><span class=o>.</span><span class=n>ParDo</span><span class=p>(</span><span class=n>UserDoFn</span><span class=p>()))</span></code></pre></div></div><h3 id=state-timers-examples>11.5 State and timers examples</h3><p>Following are some example uses of state and timers</p><h4 id=joining-clicks-and-views>11.5.1. Joining clicks and views</h4><p>In this example, the pipeline is processing data from an e-commerce site&rsquo;s home page. There are two input streams:
a stream of views, representing suggested product links displayed to the user on the home page, and a stream of
clicks, representing actual user clicks on these links. The goal of the pipeline is to join click events with view
events, outputting a new joined event that contains information from both events. Each link has a unique identifier
that is present in both the view event and the join event.</p><p>Many view events will never be followed up with clicks. This pipeline will wait one hour for a click, after which it
will give up on this join. While every click event should have a view event, some small number of view events may be
lost and never make it to the Beam pipeline; the pipeline will similarly wait one hour after seeing a click event, and
give up if the view event does not arrive in that time. Input events are not ordered - it is possible to see the click
event before the view event. The one hour join timeout should be based on event time, not on processing time.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// Read the event stream and key it by the link id.
</span><span class=c1></span><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Event</span><span class=o>&gt;&gt;</span> <span class=n>eventsPerLinkId</span> <span class=o>=</span> 
    <span class=n>readEvents</span><span class=o>()</span>
    <span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>WithKeys</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>Event</span><span class=o>::</span><span class=n>getLinkId</span><span class=o>).</span><span class=na>withKeyType</span><span class=o>(</span><span class=n>TypeDescriptors</span><span class=o>.</span><span class=na>strings</span><span class=o>()));</span>

<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Event</span><span class=o>&gt;,</span> <span class=n>JoinedEvent</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=c1>// Store the view event.
</span><span class=c1></span>  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;view&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Event</span><span class=o>&gt;&gt;</span> <span class=n>viewState</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>
  <span class=c1>// Store the click event.
</span><span class=c1></span>  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;click&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Event</span><span class=o>&gt;&gt;</span> <span class=n>clickState</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>

  <span class=c1>// The maximum element timestamp seen so far.
</span><span class=c1></span>  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;maxTimestampSeen&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>CombiningState</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>,</span> <span class=kt>long</span><span class=o>[],</span> <span class=n>Long</span><span class=o>&gt;&gt;</span> 
     <span class=n>maxTimestamp</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>combining</span><span class=o>(</span><span class=n>Max</span><span class=o>.</span><span class=na>ofLongs</span><span class=o>());</span>

  <span class=c1>// Timer that fires when an hour goes by with an incomplete join.
</span><span class=c1></span>  <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;gcTimer&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>TimerSpec</span> <span class=n>gcTimer</span> <span class=o>=</span> <span class=n>TimerSpecs</span><span class=o>.</span><span class=na>timer</span><span class=o>(</span><span class=n>TimeDomain</span><span class=o>.</span><span class=na>EVENT_TIME</span><span class=o>);</span>

  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span>
      <span class=nd>@Element</span> <span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Event</span><span class=o>&gt;</span> <span class=n>element</span><span class=o>,</span>
      <span class=nd>@Timestamp</span> <span class=n>Instant</span> <span class=n>ts</span><span class=o>,</span>
      <span class=nd>@AlwaysFetched</span> <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;view&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Event</span><span class=o>&gt;</span> <span class=n>viewState</span><span class=o>,</span>
      <span class=nd>@AlwaysFetched</span> <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;click&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Event</span><span class=o>&gt;</span> <span class=n>clickState</span><span class=o>,</span>
      <span class=nd>@AlwaysFetched</span> <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;maxTimestampSeen&#34;</span><span class=o>)</span> <span class=n>CombiningState</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>,</span> <span class=kt>long</span><span class=o>[],</span> <span class=n>Long</span><span class=o>&gt;</span> <span class=n>maxTimestampState</span><span class=o>,</span>
      <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;gcTimer&#34;</span><span class=o>)</span> <span class=n>gcTimer</span><span class=o>,</span>
      <span class=n>OutputReceiver</span><span class=o>&lt;</span><span class=n>JoinedEvent</span><span class=o>&gt;</span> <span class=n>output</span><span class=o>)</span> <span class=o>{</span> 
    <span class=c1>// Store the event into the correct state variable.
</span><span class=c1></span>    <span class=n>Event</span> <span class=n>event</span> <span class=o>=</span> <span class=n>element</span><span class=o>.</span><span class=na>getValue</span><span class=o>();</span>
    <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Event</span><span class=o>&gt;</span> <span class=n>valueState</span> <span class=o>=</span> <span class=n>event</span><span class=o>.</span><span class=na>getType</span><span class=o>().</span><span class=na>equals</span><span class=o>(</span><span class=n>VIEW</span><span class=o>)</span> <span class=o>?</span> <span class=n>viewState</span> <span class=o>:</span> <span class=n>clickState</span><span class=o>;</span>
    <span class=n>valueState</span><span class=o>.</span><span class=na>write</span><span class=o>(</span><span class=n>event</span><span class=o>);</span>
  
    <span class=n>Event</span> <span class=n>view</span> <span class=o>=</span> <span class=n>viewState</span><span class=o>.</span><span class=na>read</span><span class=o>();</span>
    <span class=n>Event</span> <span class=n>click</span> <span class=o>=</span> <span class=n>clickState</span><span class=o>.</span><span class=na>read</span><span class=o>();</span>
    <span class=o>(</span><span class=k>if</span> <span class=n>view</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>click</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
      <span class=c1>// We&#39;ve seen both a view and a click. Output a joined event and clear state.
</span><span class=c1></span>      <span class=n>output</span><span class=o>.</span><span class=na>output</span><span class=o>(</span><span class=n>JoinedEvent</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>view</span><span class=o>,</span> <span class=n>click</span><span class=o>));</span>
      <span class=n>clearState</span><span class=o>(</span><span class=n>viewState</span><span class=o>,</span> <span class=n>clickState</span><span class=o>,</span> <span class=n>maxTimestampState</span><span class=o>);</span>
    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
       <span class=c1>// We&#39;ve only seen on half of the join.
</span><span class=c1></span>       <span class=c1>// Set the timer to be one hour after the maximum timestamp seen. This will keep overwriting the same timer, so 
</span><span class=c1></span>       <span class=c1>// as long as there is activity on this key the state will stay active. Once the key goes inactive for one hour&#39;s
</span><span class=c1></span>       <span class=c1>// worth of event time (as measured by the watermark), then the gc timer will fire.
</span><span class=c1></span>        <span class=n>maxTimestampState</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>ts</span><span class=o>.</span><span class=na>getMillis</span><span class=o>());</span>
       <span class=n>Instant</span> <span class=n>expirationTime</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Instant</span><span class=o>(</span><span class=n>maxTimestampState</span><span class=o>.</span><span class=na>read</span><span class=o>()).</span><span class=na>plus</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardHours</span><span class=o>(</span><span class=n>1</span><span class=o>));</span>
       <span class=n>gcTimer</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=n>expirationTime</span><span class=o>);</span>
    <span class=o>}</span>
  <span class=o>}</span>

  <span class=nd>@OnTimer</span><span class=o>(</span><span class=s>&#34;gcTimer&#34;</span><span class=o>)</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onTimer</span><span class=o>(</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;view&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Event</span><span class=o>&gt;</span> <span class=n>viewState</span><span class=o>,</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;click&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Event</span><span class=o>&gt;</span> <span class=n>clickState</span><span class=o>,</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;maxTimestampSeen&#34;</span><span class=o>)</span> <span class=n>CombiningState</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>,</span> <span class=kt>long</span><span class=o>[],</span> <span class=n>Long</span><span class=o>&gt;</span> <span class=n>maxTimestampState</span><span class=o>)</span> <span class=o>{</span>
       <span class=c1>// An hour has gone by with an incomplete join. Give up and clear the state.
</span><span class=c1></span>       <span class=n>clearState</span><span class=o>(</span><span class=n>viewState</span><span class=o>,</span> <span class=n>clickState</span><span class=o>,</span> <span class=n>maxTimestampState</span><span class=o>);</span>
    <span class=o>}</span>
   
    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>clearState</span><span class=o>(</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;view&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Event</span><span class=o>&gt;</span> <span class=n>viewState</span><span class=o>,</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;click&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Event</span><span class=o>&gt;</span> <span class=n>clickState</span><span class=o>,</span>
      <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;maxTimestampSeen&#34;</span><span class=o>)</span> <span class=n>CombiningState</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>,</span> <span class=kt>long</span><span class=o>[],</span> <span class=n>Long</span><span class=o>&gt;</span> <span class=n>maxTimestampState</span><span class=o>)</span> <span class=o>{</span>
      <span class=n>viewState</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>
      <span class=n>clickState</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>
      <span class=n>maxTimestampState</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>
    <span class=o>}</span>
 <span class=o>}));</span></code></pre></div></div><h4 id=batching-rpcs>11.5.2 Batching RPCs</h4><p>In this example, input elements are being forwarded to an external RPC service. The RPC accepts batch requests -
multiple events for the same user can be batched in a single RPC call. Since this RPC service also imposes rate limits,
we want to batch ten seconds worth of events together in order to reduce the number of calls.</p><div class=language-java><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PCollection</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>perUser</span> <span class=o>=</span> <span class=n>readPerUser</span><span class=o>();</span>
<span class=n>perUser</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>ParDo</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>DoFn</span><span class=o>&lt;</span><span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;,</span> <span class=n>OutputT</span><span class=o>&gt;()</span> <span class=o>{</span>
  <span class=c1>// Store the elements buffered so far.
</span><span class=c1></span>  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;&gt;</span> <span class=n>elements</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>bag</span><span class=o>();</span>
  <span class=c1>// Keep track of whether a timer is currently set or not.
</span><span class=c1></span>  <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;isTimerSet&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>StateSpec</span><span class=o>&lt;</span><span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;&gt;</span> <span class=n>isTimerSet</span> <span class=o>=</span> <span class=n>StateSpecs</span><span class=o>.</span><span class=na>value</span><span class=o>();</span>
  <span class=c1>// The processing-time timer user to publish the RPC.
</span><span class=c1></span>  <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;outputState&#34;</span><span class=o>)</span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>TimerSpec</span> <span class=n>timer</span> <span class=o>=</span> <span class=n>TimerSpecs</span><span class=o>.</span><span class=na>timer</span><span class=o>(</span><span class=n>TimeDomain</span><span class=o>.</span><span class=na>PROCESSING_TIME</span><span class=o>);</span>
  
  <span class=nd>@ProcessElement</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>process</span><span class=o>(</span>
    <span class=nd>@Element</span> <span class=n>KV</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>element</span><span class=o>,</span> 
    <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>elementsState</span><span class=o>,</span>
    <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;isTimerSet&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span> <span class=n>isTimerSetState</span><span class=o>,</span>
    <span class=nd>@TimerId</span><span class=o>(</span><span class=s>&#34;outputState&#34;</span><span class=o>)</span> <span class=n>Timer</span> <span class=n>timer</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// Add the current element to the bag for this key.
</span><span class=c1></span>    <span class=n>state</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>element</span><span class=o>.</span><span class=na>getValue</span><span class=o>());</span>
    <span class=k>if</span> <span class=o>(!</span><span class=n>MoreObjects</span><span class=o>.</span><span class=na>firstNonNull</span><span class=o>(</span><span class=n>isTimerSetState</span><span class=o>.</span><span class=na>read</span><span class=o>(),</span> <span class=kc>false</span><span class=o>))</span> <span class=o>{</span>
      <span class=c1>// If there is no timer currently set, then set one to go off in 10 seconds.
</span><span class=c1></span>      <span class=n>timer</span><span class=o>.</span><span class=na>offset</span><span class=o>(</span><span class=n>Duration</span><span class=o>.</span><span class=na>standardSeconds</span><span class=o>(</span><span class=n>10</span><span class=o>)).</span><span class=na>setRelative</span><span class=o>();</span>
      <span class=n>isTimerSetState</span><span class=o>.</span><span class=na>write</span><span class=o>(</span><span class=kc>true</span><span class=o>);</span>
   <span class=o>}</span>
  <span class=o>}</span>
 
  <span class=nd>@OnTimer</span><span class=o>(</span><span class=s>&#34;outputState&#34;</span><span class=o>)</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onTimer</span><span class=o>(</span>
    <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;state&#34;</span><span class=o>)</span> <span class=n>BagState</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=n>elementsState</span><span class=o>,</span>
    <span class=nd>@StateId</span><span class=o>(</span><span class=s>&#34;isTimerSet&#34;</span><span class=o>)</span> <span class=n>ValueState</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span> <span class=n>isTimerSetState</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// Send an RPC containing the batched elements and clear state.
</span><span class=c1></span>    <span class=n>sendRPC</span><span class=o>(</span><span class=n>elementsState</span><span class=o>.</span><span class=na>read</span><span class=o>());</span>
    <span class=n>elementsState</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>
    <span class=n>isTimerSetState</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>
  <span class=o>}</span>
<span class=o>}));</span></code></pre></div></div></div></div><footer class=footer><div class=footer__contained><div class=footer__cols><div class=footer__cols__col><div class=footer__cols__col__logo><img src=/images/beam_logo_circle.svg class=footer__logo alt="Beam logo"></div><div class=footer__cols__col__logo><img src=/images/apache_logo_circle.svg class=footer__logo alt="Apache logo"></div></div><div class="footer__cols__col footer__cols__col--md"><div class=footer__cols__col__title>Start</div><div class=footer__cols__col__link><a href=/get-started/beam-overview/>Overview</a></div><div class=footer__cols__col__link><a href=/get-started/quickstart-java/>Quickstart (Java)</a></div><div class=footer__cols__col__link><a href=/get-started/quickstart-py/>Quickstart (Python)</a></div><div class=footer__cols__col__link><a href=/get-started/quickstart-go/>Quickstart (Go)</a></div><div class=footer__cols__col__link><a href=/get-started/downloads/>Downloads</a></div></div><div class="footer__cols__col footer__cols__col--md"><div class=footer__cols__col__title>Docs</div><div class=footer__cols__col__link><a href=/documentation/programming-guide/>Concepts</a></div><div class=footer__cols__col__link><a href=/documentation/pipelines/design-your-pipeline/>Pipelines</a></div><div class=footer__cols__col__link><a href=/documentation/runners/capability-matrix/>Runners</a></div></div><div class="footer__cols__col footer__cols__col--md"><div class=footer__cols__col__title>Community</div><div class=footer__cols__col__link><a href=/contribute/>Contribute</a></div><div class=footer__cols__col__link><a href=https://projects.apache.org/committee.html?beam target=_blank>Team<img src=/images/external-link-icon.png width=14 height=14 alt="External link."></a></div><div class=footer__cols__col__link><a href=/community/presentation-materials/>Media</a></div><div class=footer__cols__col__link><a href=/community/in-person/>Events/Meetups</a></div></div><div class="footer__cols__col footer__cols__col--md"><div class=footer__cols__col__title>Resources</div><div class=footer__cols__col__link><a href=/blog/>Blog</a></div><div class=footer__cols__col__link><a href=/community/contact-us/>Contact Us</a></div><div class=footer__cols__col__link><a href=https://github.com/apache/beam>GitHub</a></div></div></div></div><div class=footer__bottom>&copy;
<a href=http://www.apache.org>The Apache Software Foundation</a>
| <a href=/privacy_policy>Privacy Policy</a>
| <a href=/feed.xml>RSS Feed</a><br><br>Apache Beam, Apache, Beam, the Beam logo, and the Apache feather logo are either registered trademarks or trademarks of The Apache Software Foundation. All other products or name brands are trademarks of their respective holders, including The Apache Software Foundation.</div></footer></body></html>