// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: org/apache/beam/model/pipeline/v1/metrics.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// Protocol Buffers for metrics classes, used in the Fn API, Job API, and by SDKs.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A specification for describing a well known MonitoringInfo.
///
/// All specifications are uniquely identified by the urn.
struct Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Defines the semantic meaning of the metric or monitored state.
  ///
  /// See MonitoringInfoSpecs.Enum for the set of well known metrics/monitored
  /// state.
  var urn: String = String()

  /// Defines the required encoding and aggregation method for the payload.
  ///
  /// See MonitoringInfoTypeUrns.Enum for the set of well known types.
  var type: String = String()

  /// The list of required labels for the specified urn and type.
  var requiredLabels: [String] = []

  /// Extra non functional parts of the spec for descriptive purposes.
  /// i.e. description, units, etc.
  var annotations: [Org_Apache_Beam_Model_Pipeline_V1_Annotation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The key name and value string of MonitoringInfo annotations.
struct Org_Apache_Beam_Model_Pipeline_V1_Annotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A set of well known MonitoringInfo specifications.
struct Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpecs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Enum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Represents an integer counter where values are summed across bundles.
    case userSumInt64 // = 0

    /// Represents a double counter where values are summed across bundles.
    case userSumDouble // = 1

    /// Represents a distribution of an integer value where:
    ///   - count: represents the number of values seen across all bundles
    ///   - sum: represents the total of the value across all bundles
    ///   - min: represents the smallest value seen across all bundles
    ///   - max: represents the largest value seen across all bundles
    case userDistributionInt64 // = 2

    /// Represents a distribution of a double value where:
    ///   - count: represents the number of values seen across all bundles
    ///   - sum: represents the total of the value across all bundles
    ///   - min: represents the smallest value seen across all bundles
    ///   - max: represents the largest value seen across all bundles
    case userDistributionDouble // = 3

    /// Represents the latest seen integer value. The timestamp is used to
    /// provide an "ordering" over multiple values to determine which is the
    /// latest.
    case userLatestInt64 // = 4

    /// Represents the latest seen double value. The timestamp is used to
    /// provide an "ordering" over multiple values to determine which is the
    /// latest.
    case userLatestDouble // = 5

    /// Represents the largest set of integer values seen across bundles.
    case userTopNInt64 // = 6

    /// Represents the largest set of double values seen across bundles.
    case userTopNDouble // = 7

    /// Represents the smallest set of integer values seen across bundles.
    case userBottomNInt64 // = 8

    /// Represents the smallest set of double values seen across bundles.
    case userBottomNDouble // = 9
    case elementCount // = 10
    case sampledByteSize // = 11
    case startBundleMsecs // = 12
    case processBundleMsecs // = 13
    case finishBundleMsecs // = 14
    case totalMsecs // = 15

    /// All values reported across all beam:metric:ptransform_progress:.*:v1
    /// metrics are of the same magnitude.
    case workRemaining // = 16

    /// All values reported across all beam:metric:ptransform_progress:.*:v1
    /// metrics are of the same magnitude.
    case workCompleted // = 17

    /// The (0-based) index of the latest item processed from the data channel.
    /// This gives an indication of the SDKs progress through the data channel,
    /// and is a lower bound on where it is able to split.
    /// For an SDK that processes items sequentially, this is equivalently the
    /// number of items fully processed (or -1 if processing has not yet started).
    case dataChannelReadIndex // = 18
    case apiRequestCount // = 19
    case apiRequestLatencies // = 20
    case UNRECOGNIZED(Int)

    init() {
      self = .userSumInt64
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .userSumInt64
      case 1: self = .userSumDouble
      case 2: self = .userDistributionInt64
      case 3: self = .userDistributionDouble
      case 4: self = .userLatestInt64
      case 5: self = .userLatestDouble
      case 6: self = .userTopNInt64
      case 7: self = .userTopNDouble
      case 8: self = .userBottomNInt64
      case 9: self = .userBottomNDouble
      case 10: self = .elementCount
      case 11: self = .sampledByteSize
      case 12: self = .startBundleMsecs
      case 13: self = .processBundleMsecs
      case 14: self = .finishBundleMsecs
      case 15: self = .totalMsecs
      case 16: self = .workRemaining
      case 17: self = .workCompleted
      case 18: self = .dataChannelReadIndex
      case 19: self = .apiRequestCount
      case 20: self = .apiRequestLatencies
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .userSumInt64: return 0
      case .userSumDouble: return 1
      case .userDistributionInt64: return 2
      case .userDistributionDouble: return 3
      case .userLatestInt64: return 4
      case .userLatestDouble: return 5
      case .userTopNInt64: return 6
      case .userTopNDouble: return 7
      case .userBottomNInt64: return 8
      case .userBottomNDouble: return 9
      case .elementCount: return 10
      case .sampledByteSize: return 11
      case .startBundleMsecs: return 12
      case .processBundleMsecs: return 13
      case .finishBundleMsecs: return 14
      case .totalMsecs: return 15
      case .workRemaining: return 16
      case .workCompleted: return 17
      case .dataChannelReadIndex: return 18
      case .apiRequestCount: return 19
      case .apiRequestLatencies: return 20
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpecs.Enum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpecs.Enum] = [
    .userSumInt64,
    .userSumDouble,
    .userDistributionInt64,
    .userDistributionDouble,
    .userLatestInt64,
    .userLatestDouble,
    .userTopNInt64,
    .userTopNDouble,
    .userBottomNInt64,
    .userBottomNDouble,
    .elementCount,
    .sampledByteSize,
    .startBundleMsecs,
    .processBundleMsecs,
    .finishBundleMsecs,
    .totalMsecs,
    .workRemaining,
    .workCompleted,
    .dataChannelReadIndex,
    .apiRequestCount,
    .apiRequestLatencies,
  ]
}

#endif  // swift(>=4.2)

/// A set of properties for the MonitoringInfoLabel, this is useful to obtain
/// the proper label string for the MonitoringInfoLabel.
struct Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoLabelProps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The label key to use in the MonitoringInfo labels map.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) Defines the semantic meaning of the metric or monitored state.
  ///
  /// See MonitoringInfoSpecs.Enum for the set of well known metrics/monitored
  /// state.
  var urn: String = String()

  /// (Required) Defines the encoding and aggregation method for the payload.
  ///
  /// See MonitoringInfoTypeUrns.Enum for the set of well known types.
  var type: String = String()

  /// (Required) The metric or monitored state encoded as per the specification
  /// defined by the type.
  var payload: Data = Data()

  /// A set of key and value labels which define the scope of the metric. For
  /// well known URNs, the set of required labels is provided by the associated
  /// MonitoringInfoSpec.
  ///
  /// Either a well defined entity id for matching the enum names in
  /// the MonitoringInfoLabels enum or any arbitrary label
  /// set by a custom metric or user metric.
  ///
  /// A monitoring system is expected to be able to aggregate the metrics
  /// together for all updates having the same URN and labels. Some systems such
  /// as Stackdriver will be able to aggregate the metrics using a subset of the
  /// provided labels
  var labels: Dictionary<String,String> = [:]

  /// This indicates the start of the time range over which this value was
  /// measured.
  /// This is needed by some external metric aggregation services
  /// to indicate when the reporter of the metric first began collecting the
  /// cumulative value for the timeseries.
  /// If the SDK Harness restarts, it should reset the start_time, and reset
  /// the collection of cumulative metrics (i.e. start to count again from 0).
  /// HarnessMonitoringInfos should set this start_time once, when the
  /// MonitoringInfo is first reported.
  /// ProcessBundle MonitoringInfos should set a start_time for each bundle.
  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum MonitoringInfoLabels: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The values used for TRANSFORM, PCOLLECTION, WINDOWING_STRATEGY
    /// CODER, ENVIRONMENT, etc. must always match the keys used to
    /// refer to them. For actively processed bundles, these should match the
    /// values within the ProcessBundleDescriptor. For job management APIs,
    /// these should match values within the original pipeline representation.
    case transform // = 0
    case pcollection // = 1
    case windowingStrategy // = 2
    case coder // = 3
    case environment // = 4
    case namespace // = 5
    case name // = 6
    case service // = 7
    case method // = 8
    case resource // = 9
    case status // = 10
    case bigqueryProjectID // = 11
    case bigqueryDataset // = 12
    case bigqueryTable // = 13
    case bigqueryView // = 14
    case bigqueryQueryName // = 15
    case gcsBucket // = 16
    case gcsProjectID // = 17
    case datastoreProject // = 18
    case datastoreNamespace // = 19
    case bigtableProjectID // = 20
    case instanceID // = 21
    case tableID // = 22
    case spannerProjectID // = 23
    case spannerDatabaseID // = 24
    case spannerTableID // = 25
    case spannerInstanceID // = 26
    case spannerQueryName // = 27
    case UNRECOGNIZED(Int)

    init() {
      self = .transform
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .transform
      case 1: self = .pcollection
      case 2: self = .windowingStrategy
      case 3: self = .coder
      case 4: self = .environment
      case 5: self = .namespace
      case 6: self = .name
      case 7: self = .service
      case 8: self = .method
      case 9: self = .resource
      case 10: self = .status
      case 11: self = .bigqueryProjectID
      case 12: self = .bigqueryDataset
      case 13: self = .bigqueryTable
      case 14: self = .bigqueryView
      case 15: self = .bigqueryQueryName
      case 16: self = .gcsBucket
      case 17: self = .gcsProjectID
      case 18: self = .datastoreProject
      case 19: self = .datastoreNamespace
      case 20: self = .bigtableProjectID
      case 21: self = .instanceID
      case 22: self = .tableID
      case 23: self = .spannerProjectID
      case 24: self = .spannerDatabaseID
      case 25: self = .spannerTableID
      case 26: self = .spannerInstanceID
      case 27: self = .spannerQueryName
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .transform: return 0
      case .pcollection: return 1
      case .windowingStrategy: return 2
      case .coder: return 3
      case .environment: return 4
      case .namespace: return 5
      case .name: return 6
      case .service: return 7
      case .method: return 8
      case .resource: return 9
      case .status: return 10
      case .bigqueryProjectID: return 11
      case .bigqueryDataset: return 12
      case .bigqueryTable: return 13
      case .bigqueryView: return 14
      case .bigqueryQueryName: return 15
      case .gcsBucket: return 16
      case .gcsProjectID: return 17
      case .datastoreProject: return 18
      case .datastoreNamespace: return 19
      case .bigtableProjectID: return 20
      case .instanceID: return 21
      case .tableID: return 22
      case .spannerProjectID: return 23
      case .spannerDatabaseID: return 24
      case .spannerTableID: return 25
      case .spannerInstanceID: return 26
      case .spannerQueryName: return 27
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo.MonitoringInfoLabels: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo.MonitoringInfoLabels] = [
    .transform,
    .pcollection,
    .windowingStrategy,
    .coder,
    .environment,
    .namespace,
    .name,
    .service,
    .method,
    .resource,
    .status,
    .bigqueryProjectID,
    .bigqueryDataset,
    .bigqueryTable,
    .bigqueryView,
    .bigqueryQueryName,
    .gcsBucket,
    .gcsProjectID,
    .datastoreProject,
    .datastoreNamespace,
    .bigtableProjectID,
    .instanceID,
    .tableID,
    .spannerProjectID,
    .spannerDatabaseID,
    .spannerTableID,
    .spannerInstanceID,
    .spannerQueryName,
  ]
}

#endif  // swift(>=4.2)

/// A set of well known URNs that specify the encoding and aggregation method.
struct Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoTypeUrns {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Enum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Represents an integer counter where values are summed across bundles.
    ///
    /// Encoding: <value>
    ///   - value: beam:coder:varint:v1
    case sumInt64Type // = 0

    /// Represents a double counter where values are summed across bundles.
    ///
    /// Encoding: <value>
    ///   value: beam:coder:double:v1
    case sumDoubleType // = 1

    /// Represents a distribution of an integer value where:
    ///   - count: represents the number of values seen across all bundles
    ///   - sum: represents the total of the value across all bundles
    ///   - min: represents the smallest value seen across all bundles
    ///   - max: represents the largest value seen across all bundles
    ///
    /// Encoding: <count><sum><min><max>
    ///   - count: beam:coder:varint:v1
    ///   - sum:   beam:coder:varint:v1
    ///   - min:   beam:coder:varint:v1
    ///   - max:   beam:coder:varint:v1
    case distributionInt64Type // = 2

    /// Represents a distribution of a double value where:
    ///   - count: represents the number of values seen across all bundles
    ///   - sum: represents the total of the value across all bundles
    ///   - min: represents the smallest value seen across all bundles
    ///   - max: represents the largest value seen across all bundles
    ///
    /// Encoding: <count><sum><min><max>
    ///   - count: beam:coder:varint:v1
    ///   - sum:   beam:coder:double:v1
    ///   - min:   beam:coder:double:v1
    ///   - max:   beam:coder:double:v1
    case distributionDoubleType // = 3

    /// Represents the latest seen integer value. The timestamp is used to
    /// provide an "ordering" over multiple values to determine which is the
    /// latest.
    ///
    /// Encoding: <timestamp><value>
    ///   - timestamp: beam:coder:varint:v1     (milliseconds since epoch)
    ///   - value:     beam:coder:varint:v1
    case latestInt64Type // = 4

    /// Represents the latest seen double value. The timestamp is used to
    /// provide an "ordering" over multiple values to determine which is the
    /// latest.
    ///
    /// Encoding: <timestamp><value>
    ///   - timestamp: beam:coder:varint:v1     (milliseconds since epoch)
    ///   - value:     beam:coder:double:v1
    case latestDoubleType // = 5

    /// Represents the largest set of integer values seen across bundles.
    ///
    /// Encoding: <iter><value1><value2>...<valueN></iter>
    ///   - iter:   beam:coder:iterable:v1
    ///   - valueX: beam:coder:varint:v1
    case topNInt64Type // = 6

    /// Represents the largest set of double values seen across bundles.
    ///
    /// Encoding: <iter><value1><value2>...<valueN></iter>
    ///   - iter:   beam:coder:iterable:v1
    ///   - valueX: beam:coder<beam:coder:double:v1
    case topNDoubleType // = 7

    /// Represents the smallest set of integer values seen across bundles.
    ///
    /// Encoding: <iter><value1><value2>...<valueN></iter>
    ///   - iter:   beam:coder:iterable:v1
    ///   - valueX: beam:coder:varint:v1
    case bottomNInt64Type // = 8

    /// Represents the smallest set of double values seen across bundles.
    ///
    /// Encoding: <iter><value1><value2>...<valueN></iter>
    ///   - iter:   beam:coder:iterable:v1
    ///   - valueX: beam:coder:double:v1
    case bottomNDoubleType // = 9

    /// Encoding: <iter><value1><value2>...<valueN></iter>
    ///   - iter:   beam:coder:iterable:v1
    ///   - valueX: beam:coder:double:v1
    case progressType // = 10
    case UNRECOGNIZED(Int)

    init() {
      self = .sumInt64Type
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sumInt64Type
      case 1: self = .sumDoubleType
      case 2: self = .distributionInt64Type
      case 3: self = .distributionDoubleType
      case 4: self = .latestInt64Type
      case 5: self = .latestDoubleType
      case 6: self = .topNInt64Type
      case 7: self = .topNDoubleType
      case 8: self = .bottomNInt64Type
      case 9: self = .bottomNDoubleType
      case 10: self = .progressType
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .sumInt64Type: return 0
      case .sumDoubleType: return 1
      case .distributionInt64Type: return 2
      case .distributionDoubleType: return 3
      case .latestInt64Type: return 4
      case .latestDoubleType: return 5
      case .topNInt64Type: return 6
      case .topNDoubleType: return 7
      case .bottomNInt64Type: return 8
      case .bottomNDoubleType: return 9
      case .progressType: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoTypeUrns.Enum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoTypeUrns.Enum] = [
    .sumInt64Type,
    .sumDoubleType,
    .distributionInt64Type,
    .distributionDoubleType,
    .latestInt64Type,
    .latestDoubleType,
    .topNInt64Type,
    .topNDoubleType,
    .bottomNInt64Type,
    .bottomNDoubleType,
    .progressType,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpec: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_Annotation: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpecs: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpecs.Enum: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoLabelProps: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo.MonitoringInfoLabels: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoTypeUrns: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoTypeUrns.Enum: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Extension support defined in metrics.proto.

// MARK: - Extension Properties

// Swift Extensions on the exteneded Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension SwiftProtobuf.Google_Protobuf_EnumValueOptions {

  /// From: commit 0x7970544.
  var Org_Apache_Beam_Model_Pipeline_V1_labelProps: Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoLabelProps {
    get {return getExtensionValue(ext: Org_Apache_Beam_Model_Pipeline_V1_Extensions_label_props) ?? Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoLabelProps()}
    set {setExtensionValue(ext: Org_Apache_Beam_Model_Pipeline_V1_Extensions_label_props, value: newValue)}
  }
  /// Returns true if extension `Org_Apache_Beam_Model_Pipeline_V1_Extensions_label_props`
  /// has been explicitly set.
  var hasOrg_Apache_Beam_Model_Pipeline_V1_labelProps: Bool {
    return hasExtensionValue(ext: Org_Apache_Beam_Model_Pipeline_V1_Extensions_label_props)
  }
  /// Clears the value of extension `Org_Apache_Beam_Model_Pipeline_V1_Extensions_label_props`.
  /// Subsequent reads from it will return its default value.
  mutating func clearOrg_Apache_Beam_Model_Pipeline_V1_labelProps() {
    clearExtensionValue(ext: Org_Apache_Beam_Model_Pipeline_V1_Extensions_label_props)
  }

  /// Enum extension to store the MonitoringInfoSpecs.
  var Org_Apache_Beam_Model_Pipeline_V1_monitoringInfoSpec: Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpec {
    get {return getExtensionValue(ext: Org_Apache_Beam_Model_Pipeline_V1_Extensions_monitoring_info_spec) ?? Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpec()}
    set {setExtensionValue(ext: Org_Apache_Beam_Model_Pipeline_V1_Extensions_monitoring_info_spec, value: newValue)}
  }
  /// Returns true if extension `Org_Apache_Beam_Model_Pipeline_V1_Extensions_monitoring_info_spec`
  /// has been explicitly set.
  var hasOrg_Apache_Beam_Model_Pipeline_V1_monitoringInfoSpec: Bool {
    return hasExtensionValue(ext: Org_Apache_Beam_Model_Pipeline_V1_Extensions_monitoring_info_spec)
  }
  /// Clears the value of extension `Org_Apache_Beam_Model_Pipeline_V1_Extensions_monitoring_info_spec`.
  /// Subsequent reads from it will return its default value.
  mutating func clearOrg_Apache_Beam_Model_Pipeline_V1_monitoringInfoSpec() {
    clearExtensionValue(ext: Org_Apache_Beam_Model_Pipeline_V1_Extensions_monitoring_info_spec)
  }

}

// MARK: - File's ExtensionMap: Org_Apache_Beam_Model_Pipeline_V1_Metrics_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let Org_Apache_Beam_Model_Pipeline_V1_Metrics_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  Org_Apache_Beam_Model_Pipeline_V1_Extensions_label_props,
  Org_Apache_Beam_Model_Pipeline_V1_Extensions_monitoring_info_spec
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

/// From: commit 0x7970544.
let Org_Apache_Beam_Model_Pipeline_V1_Extensions_label_props = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoLabelProps>, SwiftProtobuf.Google_Protobuf_EnumValueOptions>(
  _protobuf_fieldNumber: 127337796,
  fieldName: "org.apache.beam.model.pipeline.v1.label_props"
)

/// Enum extension to store the MonitoringInfoSpecs.
let Org_Apache_Beam_Model_Pipeline_V1_Extensions_monitoring_info_spec = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpec>, SwiftProtobuf.Google_Protobuf_EnumValueOptions>(
  _protobuf_fieldNumber: 207174266,
  fieldName: "org.apache.beam.model.pipeline.v1.monitoring_info_spec"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "org.apache.beam.model.pipeline.v1"

extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MonitoringInfoSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "urn"),
    2: .same(proto: "type"),
    3: .standard(proto: "required_labels"),
    4: .same(proto: "annotations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.urn) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.requiredLabels) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.urn.isEmpty {
      try visitor.visitSingularStringField(value: self.urn, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.requiredLabels.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requiredLabels, fieldNumber: 3)
    }
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpec, rhs: Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpec) -> Bool {
    if lhs.urn != rhs.urn {return false}
    if lhs.type != rhs.type {return false}
    if lhs.requiredLabels != rhs.requiredLabels {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_Annotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Annotation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_Annotation, rhs: Org_Apache_Beam_Model_Pipeline_V1_Annotation) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpecs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MonitoringInfoSpecs"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpecs, rhs: Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpecs) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoSpecs.Enum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER_SUM_INT64"),
    1: .same(proto: "USER_SUM_DOUBLE"),
    2: .same(proto: "USER_DISTRIBUTION_INT64"),
    3: .same(proto: "USER_DISTRIBUTION_DOUBLE"),
    4: .same(proto: "USER_LATEST_INT64"),
    5: .same(proto: "USER_LATEST_DOUBLE"),
    6: .same(proto: "USER_TOP_N_INT64"),
    7: .same(proto: "USER_TOP_N_DOUBLE"),
    8: .same(proto: "USER_BOTTOM_N_INT64"),
    9: .same(proto: "USER_BOTTOM_N_DOUBLE"),
    10: .same(proto: "ELEMENT_COUNT"),
    11: .same(proto: "SAMPLED_BYTE_SIZE"),
    12: .same(proto: "START_BUNDLE_MSECS"),
    13: .same(proto: "PROCESS_BUNDLE_MSECS"),
    14: .same(proto: "FINISH_BUNDLE_MSECS"),
    15: .same(proto: "TOTAL_MSECS"),
    16: .same(proto: "WORK_REMAINING"),
    17: .same(proto: "WORK_COMPLETED"),
    18: .same(proto: "DATA_CHANNEL_READ_INDEX"),
    19: .same(proto: "API_REQUEST_COUNT"),
    20: .same(proto: "API_REQUEST_LATENCIES"),
  ]
}

extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoLabelProps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MonitoringInfoLabelProps"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoLabelProps, rhs: Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoLabelProps) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MonitoringInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "urn"),
    2: .same(proto: "type"),
    3: .same(proto: "payload"),
    4: .same(proto: "labels"),
    5: .standard(proto: "start_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.urn) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.urn.isEmpty {
      try visitor.visitSingularStringField(value: self.urn, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 4)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo, rhs: Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo) -> Bool {
    if lhs.urn != rhs.urn {return false}
    if lhs.type != rhs.type {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo.MonitoringInfoLabels: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSFORM"),
    1: .same(proto: "PCOLLECTION"),
    2: .same(proto: "WINDOWING_STRATEGY"),
    3: .same(proto: "CODER"),
    4: .same(proto: "ENVIRONMENT"),
    5: .same(proto: "NAMESPACE"),
    6: .same(proto: "NAME"),
    7: .same(proto: "SERVICE"),
    8: .same(proto: "METHOD"),
    9: .same(proto: "RESOURCE"),
    10: .same(proto: "STATUS"),
    11: .same(proto: "BIGQUERY_PROJECT_ID"),
    12: .same(proto: "BIGQUERY_DATASET"),
    13: .same(proto: "BIGQUERY_TABLE"),
    14: .same(proto: "BIGQUERY_VIEW"),
    15: .same(proto: "BIGQUERY_QUERY_NAME"),
    16: .same(proto: "GCS_BUCKET"),
    17: .same(proto: "GCS_PROJECT_ID"),
    18: .same(proto: "DATASTORE_PROJECT"),
    19: .same(proto: "DATASTORE_NAMESPACE"),
    20: .same(proto: "BIGTABLE_PROJECT_ID"),
    21: .same(proto: "INSTANCE_ID"),
    22: .same(proto: "TABLE_ID"),
    23: .same(proto: "SPANNER_PROJECT_ID"),
    24: .same(proto: "SPANNER_DATABASE_ID"),
    25: .same(proto: "SPANNER_TABLE_ID"),
    26: .same(proto: "SPANNER_INSTANCE_ID"),
    27: .same(proto: "SPANNER_QUERY_NAME"),
  ]
}

extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoTypeUrns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MonitoringInfoTypeUrns"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoTypeUrns, rhs: Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoTypeUrns) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfoTypeUrns.Enum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUM_INT64_TYPE"),
    1: .same(proto: "SUM_DOUBLE_TYPE"),
    2: .same(proto: "DISTRIBUTION_INT64_TYPE"),
    3: .same(proto: "DISTRIBUTION_DOUBLE_TYPE"),
    4: .same(proto: "LATEST_INT64_TYPE"),
    5: .same(proto: "LATEST_DOUBLE_TYPE"),
    6: .same(proto: "TOP_N_INT64_TYPE"),
    7: .same(proto: "TOP_N_DOUBLE_TYPE"),
    8: .same(proto: "BOTTOM_N_INT64_TYPE"),
    9: .same(proto: "BOTTOM_N_DOUBLE_TYPE"),
    10: .same(proto: "PROGRESS_TYPE"),
  ]
}
