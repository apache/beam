// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: org/apache/beam/model/job_management/v1/beam_job_api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// Protocol Buffers describing the Job API, api for communicating with a runner
// for job submission over GRPC.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Prepare is a synchronous request that returns a preparationId back
/// Throws error GRPC_STATUS_UNAVAILABLE if server is down
/// Throws error ALREADY_EXISTS if the jobName is reused. Runners are permitted to deduplicate based on the name of the job.
/// Throws error UNKNOWN for all other issues
struct Org_Apache_Beam_Model_JobManagement_V1_PrepareJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required)
  var pipeline: Org_Apache_Beam_Model_Pipeline_V1_Pipeline {
    get {return _pipeline ?? Org_Apache_Beam_Model_Pipeline_V1_Pipeline()}
    set {_pipeline = newValue}
  }
  /// Returns true if `pipeline` has been explicitly set.
  var hasPipeline: Bool {return self._pipeline != nil}
  /// Clears the value of `pipeline`. Subsequent reads from it will return its default value.
  mutating func clearPipeline() {self._pipeline = nil}

  /// (required)
  var pipelineOptions: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _pipelineOptions ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_pipelineOptions = newValue}
  }
  /// Returns true if `pipelineOptions` has been explicitly set.
  var hasPipelineOptions: Bool {return self._pipelineOptions != nil}
  /// Clears the value of `pipelineOptions`. Subsequent reads from it will return its default value.
  mutating func clearPipelineOptions() {self._pipelineOptions = nil}

  /// (required)
  var jobName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pipeline: Org_Apache_Beam_Model_Pipeline_V1_Pipeline? = nil
  fileprivate var _pipelineOptions: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

struct Org_Apache_Beam_Model_JobManagement_V1_PrepareJobResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required) The ID used to associate calls made while preparing the job. preparationId is used
  /// to run the job.
  var preparationID: String = String()

  /// An endpoint which exposes the Beam Artifact Staging API. Artifacts used by the job should be
  /// staged to this endpoint, and will be available during job execution.
  var artifactStagingEndpoint: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor {
    get {return _artifactStagingEndpoint ?? Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor()}
    set {_artifactStagingEndpoint = newValue}
  }
  /// Returns true if `artifactStagingEndpoint` has been explicitly set.
  var hasArtifactStagingEndpoint: Bool {return self._artifactStagingEndpoint != nil}
  /// Clears the value of `artifactStagingEndpoint`. Subsequent reads from it will return its default value.
  mutating func clearArtifactStagingEndpoint() {self._artifactStagingEndpoint = nil}

  /// (required) Token for the artifact staging. This token also represent an artifact
  /// staging session with the artifact staging service.
  var stagingSessionToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _artifactStagingEndpoint: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor? = nil
}

/// Run is a synchronous request that returns a jobId back.
/// Throws error GRPC_STATUS_UNAVAILABLE if server is down
/// Throws error NOT_FOUND if the preparation ID does not exist
/// Throws error UNKNOWN for all other issues
struct Org_Apache_Beam_Model_JobManagement_V1_RunJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required) The ID provided by an earlier call to prepare. Runs the job. All prerequisite tasks
  /// must have been completed.
  var preparationID: String = String()

  /// (optional) If any artifacts have been staged for this job, contains the retrieval_token returned
  /// from the CommitManifestResponse.
  var retrievalToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_JobManagement_V1_RunJobResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required) The ID for the executing job
  var jobID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Cancel is a synchronus request that returns a job state back
/// Throws error GRPC_STATUS_UNAVAILABLE if server is down
/// Throws error NOT_FOUND if the jobId is not found
struct Org_Apache_Beam_Model_JobManagement_V1_CancelJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required)
  var jobID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Valid responses include any terminal state or CANCELLING
struct Org_Apache_Beam_Model_JobManagement_V1_CancelJobResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required)
  var state: Org_Apache_Beam_Model_JobManagement_V1_JobState.Enum = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A subset of info provided by ProvisionApi.ProvisionInfo
struct Org_Apache_Beam_Model_JobManagement_V1_JobInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required)
  var jobID: String = String()

  /// (required)
  var jobName: String = String()

  /// (required)
  var pipelineOptions: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _pipelineOptions ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_pipelineOptions = newValue}
  }
  /// Returns true if `pipelineOptions` has been explicitly set.
  var hasPipelineOptions: Bool {return self._pipelineOptions != nil}
  /// Clears the value of `pipelineOptions`. Subsequent reads from it will return its default value.
  mutating func clearPipelineOptions() {self._pipelineOptions = nil}

  /// (required)
  var state: Org_Apache_Beam_Model_JobManagement_V1_JobState.Enum = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pipelineOptions: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// GetJobs is a synchronus request that returns a list of invoked jobs back
/// Throws error GRPC_STATUS_UNAVAILABLE if server is down
struct Org_Apache_Beam_Model_JobManagement_V1_GetJobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_JobManagement_V1_GetJobsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required)
  var jobInfo: [Org_Apache_Beam_Model_JobManagement_V1_JobInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetState is a synchronus request that returns a job state back
/// Throws error GRPC_STATUS_UNAVAILABLE if server is down
/// Throws error NOT_FOUND if the jobId is not found
struct Org_Apache_Beam_Model_JobManagement_V1_GetJobStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required)
  var jobID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_JobManagement_V1_JobStateEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required)
  var state: Org_Apache_Beam_Model_JobManagement_V1_JobState.Enum = .unspecified

  /// (required)
  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// GetPipeline is a synchronus request that returns a pipeline back
/// Throws error GRPC_STATUS_UNAVAILABLE if server is down
/// Throws error NOT_FOUND if the jobId is not found
struct Org_Apache_Beam_Model_JobManagement_V1_GetJobPipelineRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required)
  var jobID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_JobManagement_V1_GetJobPipelineResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required)
  var pipeline: Org_Apache_Beam_Model_Pipeline_V1_Pipeline {
    get {return _pipeline ?? Org_Apache_Beam_Model_Pipeline_V1_Pipeline()}
    set {_pipeline = newValue}
  }
  /// Returns true if `pipeline` has been explicitly set.
  var hasPipeline: Bool {return self._pipeline != nil}
  /// Clears the value of `pipeline`. Subsequent reads from it will return its default value.
  mutating func clearPipeline() {self._pipeline = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pipeline: Org_Apache_Beam_Model_Pipeline_V1_Pipeline? = nil
}

/// GetJobMessages is a streaming api for streaming job messages from the service
/// One request will connect you to the job and you'll get a stream of job state
/// and job messages back; one is used for logging and the other for detecting
/// the job ended.
struct Org_Apache_Beam_Model_JobManagement_V1_JobMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required)
  var jobID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_JobManagement_V1_JobMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageID: String = String()

  var time: String = String()

  var importance: Org_Apache_Beam_Model_JobManagement_V1_JobMessage.MessageImportance = .unspecified

  var messageText: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum MessageImportance: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case jobMessageDebug // = 1
    case jobMessageDetailed // = 2
    case jobMessageBasic // = 3
    case jobMessageWarning // = 4
    case jobMessageError // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .jobMessageDebug
      case 2: self = .jobMessageDetailed
      case 3: self = .jobMessageBasic
      case 4: self = .jobMessageWarning
      case 5: self = .jobMessageError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .jobMessageDebug: return 1
      case .jobMessageDetailed: return 2
      case .jobMessageBasic: return 3
      case .jobMessageWarning: return 4
      case .jobMessageError: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Org_Apache_Beam_Model_JobManagement_V1_JobMessage.MessageImportance: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Org_Apache_Beam_Model_JobManagement_V1_JobMessage.MessageImportance] = [
    .unspecified,
    .jobMessageDebug,
    .jobMessageDetailed,
    .jobMessageBasic,
    .jobMessageWarning,
    .jobMessageError,
  ]
}

#endif  // swift(>=4.2)

struct Org_Apache_Beam_Model_JobManagement_V1_JobMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Org_Apache_Beam_Model_JobManagement_V1_JobMessagesResponse.OneOf_Response? = nil

  var messageResponse: Org_Apache_Beam_Model_JobManagement_V1_JobMessage {
    get {
      if case .messageResponse(let v)? = response {return v}
      return Org_Apache_Beam_Model_JobManagement_V1_JobMessage()
    }
    set {response = .messageResponse(newValue)}
  }

  var stateResponse: Org_Apache_Beam_Model_JobManagement_V1_JobStateEvent {
    get {
      if case .stateResponse(let v)? = response {return v}
      return Org_Apache_Beam_Model_JobManagement_V1_JobStateEvent()
    }
    set {response = .stateResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case messageResponse(Org_Apache_Beam_Model_JobManagement_V1_JobMessage)
    case stateResponse(Org_Apache_Beam_Model_JobManagement_V1_JobStateEvent)

  #if !swift(>=4.1)
    static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_JobMessagesResponse.OneOf_Response, rhs: Org_Apache_Beam_Model_JobManagement_V1_JobMessagesResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.messageResponse, .messageResponse): return {
        guard case .messageResponse(let l) = lhs, case .messageResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stateResponse, .stateResponse): return {
        guard case .stateResponse(let l) = lhs, case .stateResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Enumeration of all JobStates
///
/// The state transition diagram is:
///   STOPPED -> STARTING -> RUNNING -> DONE
///                                  \> FAILED
///                                  \> CANCELLING -> CANCELLED
///                                  \> UPDATING -> UPDATED
///                                  \> DRAINING -> DRAINED
///
/// Transitions are optional such that a job may go from STOPPED to RUNNING
/// without needing to pass through STARTING.
struct Org_Apache_Beam_Model_JobManagement_V1_JobState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Enum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The job state reported by a runner cannot be interpreted by the SDK.
    case unspecified // = 0

    /// The job has not yet started.
    case stopped // = 1

    /// The job is currently running.
    case running // = 2

    /// The job has successfully completed. (terminal)
    case done // = 3

    /// The job has failed. (terminal)
    case failed // = 4

    /// The job has been explicitly cancelled. (terminal)
    case cancelled // = 5

    /// The job has been updated. (terminal)
    case updated // = 6

    /// The job is draining its data. (optional)
    case draining // = 7

    /// The job has completed draining its data. (terminal)
    case drained // = 8

    /// The job is starting up.
    case starting // = 9

    /// The job is cancelling. (optional)
    case cancelling // = 10

    /// The job is in the process of being updated. (optional)
    case updating // = 11
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .stopped
      case 2: self = .running
      case 3: self = .done
      case 4: self = .failed
      case 5: self = .cancelled
      case 6: self = .updated
      case 7: self = .draining
      case 8: self = .drained
      case 9: self = .starting
      case 10: self = .cancelling
      case 11: self = .updating
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .stopped: return 1
      case .running: return 2
      case .done: return 3
      case .failed: return 4
      case .cancelled: return 5
      case .updated: return 6
      case .draining: return 7
      case .drained: return 8
      case .starting: return 9
      case .cancelling: return 10
      case .updating: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Org_Apache_Beam_Model_JobManagement_V1_JobState.Enum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Org_Apache_Beam_Model_JobManagement_V1_JobState.Enum] = [
    .unspecified,
    .stopped,
    .running,
    .done,
    .failed,
    .cancelled,
    .updated,
    .draining,
    .drained,
    .starting,
    .cancelling,
    .updating,
  ]
}

#endif  // swift(>=4.2)

struct Org_Apache_Beam_Model_JobManagement_V1_GetJobMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (required)
  var jobID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_JobManagement_V1_GetJobMetricsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metrics: Org_Apache_Beam_Model_JobManagement_V1_MetricResults {
    get {return _metrics ?? Org_Apache_Beam_Model_JobManagement_V1_MetricResults()}
    set {_metrics = newValue}
  }
  /// Returns true if `metrics` has been explicitly set.
  var hasMetrics: Bool {return self._metrics != nil}
  /// Clears the value of `metrics`. Subsequent reads from it will return its default value.
  mutating func clearMetrics() {self._metrics = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metrics: Org_Apache_Beam_Model_JobManagement_V1_MetricResults? = nil
}

/// All metrics for a given job.  Runners may support one or the other or both.
struct Org_Apache_Beam_Model_JobManagement_V1_MetricResults {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var attempted: [Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo] = []

  var committed: [Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DescribePipelineOptions provides metadata about the options supported by a runner.
/// It will be used by the SDK client to validate the options specified by or
/// list available options to the user.
/// Throws error GRPC_STATUS_UNAVAILABLE if server is down
struct Org_Apache_Beam_Model_JobManagement_V1_DescribePipelineOptionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type for pipeline options.
/// Types mirror those of JSON, since that's how pipeline options are serialized.
struct Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Enum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case string // = 0
    case boolean // = 1

    /// whole numbers, see https://json-schema.org/understanding-json-schema/reference/numeric.html
    case integer // = 2
    case number // = 3
    case array // = 4
    case object // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .string
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .string
      case 1: self = .boolean
      case 2: self = .integer
      case 3: self = .number
      case 4: self = .array
      case 5: self = .object
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .string: return 0
      case .boolean: return 1
      case .integer: return 2
      case .number: return 3
      case .array: return 4
      case .object: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionType.Enum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionType.Enum] = [
    .string,
    .boolean,
    .integer,
    .number,
    .array,
    .object,
  ]
}

#endif  // swift(>=4.2)

/// Metadata for a pipeline option.
struct Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) The option name.
  var name: String = String()

  /// (Required) Type of option.
  var type: Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionType.Enum = .string

  /// (Optional) Description suitable for display / help text.
  var description_p: String = String()

  /// (Optional) Default value.
  var defaultValue: String = String()

  /// (Required) The group this option belongs to.
  var group: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_JobManagement_V1_DescribePipelineOptionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of pipeline option descriptors.
  var options: [Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Org_Apache_Beam_Model_JobManagement_V1_PrepareJobRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_PrepareJobResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_RunJobRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_RunJobResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_CancelJobRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_CancelJobResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_JobInfo: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_GetJobsRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_GetJobsResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_GetJobStateRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_JobStateEvent: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_GetJobPipelineRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_GetJobPipelineResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_JobMessagesRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_JobMessage: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_JobMessage.MessageImportance: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_JobMessagesResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_JobMessagesResponse.OneOf_Response: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_JobState: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_JobState.Enum: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_GetJobMetricsRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_GetJobMetricsResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_MetricResults: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_DescribePipelineOptionsRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionType: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionType.Enum: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionDescriptor: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_DescribePipelineOptionsResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "org.apache.beam.model.job_management.v1"

extension Org_Apache_Beam_Model_JobManagement_V1_PrepareJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrepareJobRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pipeline"),
    2: .standard(proto: "pipeline_options"),
    3: .standard(proto: "job_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pipeline) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pipelineOptions) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.jobName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pipeline {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pipelineOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.jobName.isEmpty {
      try visitor.visitSingularStringField(value: self.jobName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_PrepareJobRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_PrepareJobRequest) -> Bool {
    if lhs._pipeline != rhs._pipeline {return false}
    if lhs._pipelineOptions != rhs._pipelineOptions {return false}
    if lhs.jobName != rhs.jobName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_PrepareJobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrepareJobResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "preparation_id"),
    2: .standard(proto: "artifact_staging_endpoint"),
    3: .standard(proto: "staging_session_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.preparationID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._artifactStagingEndpoint) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.stagingSessionToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.preparationID.isEmpty {
      try visitor.visitSingularStringField(value: self.preparationID, fieldNumber: 1)
    }
    try { if let v = self._artifactStagingEndpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.stagingSessionToken.isEmpty {
      try visitor.visitSingularStringField(value: self.stagingSessionToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_PrepareJobResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_PrepareJobResponse) -> Bool {
    if lhs.preparationID != rhs.preparationID {return false}
    if lhs._artifactStagingEndpoint != rhs._artifactStagingEndpoint {return false}
    if lhs.stagingSessionToken != rhs.stagingSessionToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_RunJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunJobRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "preparation_id"),
    2: .standard(proto: "retrieval_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.preparationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.retrievalToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.preparationID.isEmpty {
      try visitor.visitSingularStringField(value: self.preparationID, fieldNumber: 1)
    }
    if !self.retrievalToken.isEmpty {
      try visitor.visitSingularStringField(value: self.retrievalToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_RunJobRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_RunJobRequest) -> Bool {
    if lhs.preparationID != rhs.preparationID {return false}
    if lhs.retrievalToken != rhs.retrievalToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_RunJobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunJobResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_RunJobResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_RunJobResponse) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_CancelJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelJobRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_CancelJobRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_CancelJobRequest) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_CancelJobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelJobResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_CancelJobResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_CancelJobResponse) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_JobInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JobInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_id"),
    2: .standard(proto: "job_name"),
    3: .standard(proto: "pipeline_options"),
    4: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jobName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pipelineOptions) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    if !self.jobName.isEmpty {
      try visitor.visitSingularStringField(value: self.jobName, fieldNumber: 2)
    }
    try { if let v = self._pipelineOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_JobInfo, rhs: Org_Apache_Beam_Model_JobManagement_V1_JobInfo) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.jobName != rhs.jobName {return false}
    if lhs._pipelineOptions != rhs._pipelineOptions {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_GetJobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetJobsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobsRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_GetJobsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetJobsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.jobInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.jobInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobsResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobsResponse) -> Bool {
    if lhs.jobInfo != rhs.jobInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_GetJobStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetJobStateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobStateRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobStateRequest) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_JobStateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JobStateEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_JobStateEvent, rhs: Org_Apache_Beam_Model_JobManagement_V1_JobStateEvent) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_GetJobPipelineRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetJobPipelineRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobPipelineRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobPipelineRequest) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_GetJobPipelineResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetJobPipelineResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pipeline"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pipeline) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pipeline {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobPipelineResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobPipelineResponse) -> Bool {
    if lhs._pipeline != rhs._pipeline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_JobMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JobMessagesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_JobMessagesRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_JobMessagesRequest) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_JobMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JobMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .same(proto: "time"),
    3: .same(proto: "importance"),
    4: .standard(proto: "message_text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.importance) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.messageText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if !self.time.isEmpty {
      try visitor.visitSingularStringField(value: self.time, fieldNumber: 2)
    }
    if self.importance != .unspecified {
      try visitor.visitSingularEnumField(value: self.importance, fieldNumber: 3)
    }
    if !self.messageText.isEmpty {
      try visitor.visitSingularStringField(value: self.messageText, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_JobMessage, rhs: Org_Apache_Beam_Model_JobManagement_V1_JobMessage) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.time != rhs.time {return false}
    if lhs.importance != rhs.importance {return false}
    if lhs.messageText != rhs.messageText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_JobMessage.MessageImportance: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MESSAGE_IMPORTANCE_UNSPECIFIED"),
    1: .same(proto: "JOB_MESSAGE_DEBUG"),
    2: .same(proto: "JOB_MESSAGE_DETAILED"),
    3: .same(proto: "JOB_MESSAGE_BASIC"),
    4: .same(proto: "JOB_MESSAGE_WARNING"),
    5: .same(proto: "JOB_MESSAGE_ERROR"),
  ]
}

extension Org_Apache_Beam_Model_JobManagement_V1_JobMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JobMessagesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_response"),
    2: .standard(proto: "state_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Org_Apache_Beam_Model_JobManagement_V1_JobMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .messageResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .messageResponse(v)
        }
      }()
      case 2: try {
        var v: Org_Apache_Beam_Model_JobManagement_V1_JobStateEvent?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .stateResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .stateResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .messageResponse?: try {
      guard case .messageResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stateResponse?: try {
      guard case .stateResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_JobMessagesResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_JobMessagesResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_JobState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JobState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_JobState, rhs: Org_Apache_Beam_Model_JobManagement_V1_JobState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_JobState.Enum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "STOPPED"),
    2: .same(proto: "RUNNING"),
    3: .same(proto: "DONE"),
    4: .same(proto: "FAILED"),
    5: .same(proto: "CANCELLED"),
    6: .same(proto: "UPDATED"),
    7: .same(proto: "DRAINING"),
    8: .same(proto: "DRAINED"),
    9: .same(proto: "STARTING"),
    10: .same(proto: "CANCELLING"),
    11: .same(proto: "UPDATING"),
  ]
}

extension Org_Apache_Beam_Model_JobManagement_V1_GetJobMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetJobMetricsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobMetricsRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobMetricsRequest) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_GetJobMetricsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetJobMetricsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metrics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metrics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobMetricsResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_GetJobMetricsResponse) -> Bool {
    if lhs._metrics != rhs._metrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_MetricResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetricResults"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attempted"),
    2: .same(proto: "committed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.attempted) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.committed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attempted.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attempted, fieldNumber: 1)
    }
    if !self.committed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.committed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_MetricResults, rhs: Org_Apache_Beam_Model_JobManagement_V1_MetricResults) -> Bool {
    if lhs.attempted != rhs.attempted {return false}
    if lhs.committed != rhs.committed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_DescribePipelineOptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DescribePipelineOptionsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_DescribePipelineOptionsRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_DescribePipelineOptionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PipelineOptionType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionType, rhs: Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionType.Enum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STRING"),
    1: .same(proto: "BOOLEAN"),
    2: .same(proto: "INTEGER"),
    3: .same(proto: "NUMBER"),
    4: .same(proto: "ARRAY"),
    5: .same(proto: "OBJECT"),
  ]
}

extension Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PipelineOptionDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "description"),
    4: .standard(proto: "default_value"),
    5: .same(proto: "group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.defaultValue) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.group) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .string {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.defaultValue.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultValue, fieldNumber: 4)
    }
    if !self.group.isEmpty {
      try visitor.visitSingularStringField(value: self.group, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionDescriptor, rhs: Org_Apache_Beam_Model_JobManagement_V1_PipelineOptionDescriptor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.group != rhs.group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_DescribePipelineOptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DescribePipelineOptionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_DescribePipelineOptionsResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_DescribePipelineOptionsResponse) -> Bool {
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
