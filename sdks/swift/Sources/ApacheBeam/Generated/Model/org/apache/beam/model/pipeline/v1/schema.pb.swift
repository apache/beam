// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: org/apache/beam/model/pipeline/v1/schema.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Protocol Buffers describing Beam Schemas, a portable representation for
// complex types.
//
// The primary application of Schema is as the payload for the standard coder
// "beam:coder:row:v1", defined in beam_runner_api.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Org_Apache_Beam_Model_Pipeline_V1_AtomicType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case byte // = 1
  case int16 // = 2
  case int32 // = 3
  case int64 // = 4
  case float // = 5
  case double // = 6
  case string // = 7
  case boolean // = 8
  case bytes // = 9
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .byte
    case 2: self = .int16
    case 3: self = .int32
    case 4: self = .int64
    case 5: self = .float
    case 6: self = .double
    case 7: self = .string
    case 8: self = .boolean
    case 9: self = .bytes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .byte: return 1
    case .int16: return 2
    case .int32: return 3
    case .int64: return 4
    case .float: return 5
    case .double: return 6
    case .string: return 7
    case .boolean: return 8
    case .bytes: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Org_Apache_Beam_Model_Pipeline_V1_AtomicType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Org_Apache_Beam_Model_Pipeline_V1_AtomicType] = [
    .unspecified,
    .byte,
    .int16,
    .int32,
    .int64,
    .float,
    .double,
    .string,
    .boolean,
    .bytes,
  ]
}

#endif  // swift(>=4.2)

struct Org_Apache_Beam_Model_Pipeline_V1_Schema {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of fields for this schema. Two fields may not share a name.
  var fields: [Org_Apache_Beam_Model_Pipeline_V1_Field] = []

  /// REQUIRED. An RFC 4122 UUID.
  var id: String = String()

  var options: [Org_Apache_Beam_Model_Pipeline_V1_Option] = []

  /// Indicates that encoding positions have been overridden.
  var encodingPositionsSet: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_Pipeline_V1_Field {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// REQUIRED. Name of this field within the schema.
  var name: String = String()

  /// OPTIONAL. Human readable description of this field, such as the query that generated it.
  var description_p: String = String()

  var type: Org_Apache_Beam_Model_Pipeline_V1_FieldType {
    get {return _type ?? Org_Apache_Beam_Model_Pipeline_V1_FieldType()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var id: Int32 = 0

  /// OPTIONAL. The position of this field's data when encoded, e.g. with beam:coder:row:v1.
  /// Either no fields in a given row are have encoding position populated,
  /// or all of them are. Used to support backwards compatibility with schema
  /// changes.
  /// If no fields have encoding position populated the order of encoding is the same as the order in the Schema.
  /// If this Field is part of a Schema where encoding_positions_set is True then encoding_position must be
  /// defined, otherwise this field is ignored.
  var encodingPosition: Int32 = 0

  var options: [Org_Apache_Beam_Model_Pipeline_V1_Option] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: Org_Apache_Beam_Model_Pipeline_V1_FieldType? = nil
}

struct Org_Apache_Beam_Model_Pipeline_V1_FieldType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nullable: Bool {
    get {return _storage._nullable}
    set {_uniqueStorage()._nullable = newValue}
  }

  var typeInfo: OneOf_TypeInfo? {
    get {return _storage._typeInfo}
    set {_uniqueStorage()._typeInfo = newValue}
  }

  var atomicType: Org_Apache_Beam_Model_Pipeline_V1_AtomicType {
    get {
      if case .atomicType(let v)? = _storage._typeInfo {return v}
      return .unspecified
    }
    set {_uniqueStorage()._typeInfo = .atomicType(newValue)}
  }

  var arrayType: Org_Apache_Beam_Model_Pipeline_V1_ArrayType {
    get {
      if case .arrayType(let v)? = _storage._typeInfo {return v}
      return Org_Apache_Beam_Model_Pipeline_V1_ArrayType()
    }
    set {_uniqueStorage()._typeInfo = .arrayType(newValue)}
  }

  var iterableType: Org_Apache_Beam_Model_Pipeline_V1_IterableType {
    get {
      if case .iterableType(let v)? = _storage._typeInfo {return v}
      return Org_Apache_Beam_Model_Pipeline_V1_IterableType()
    }
    set {_uniqueStorage()._typeInfo = .iterableType(newValue)}
  }

  var mapType: Org_Apache_Beam_Model_Pipeline_V1_MapType {
    get {
      if case .mapType(let v)? = _storage._typeInfo {return v}
      return Org_Apache_Beam_Model_Pipeline_V1_MapType()
    }
    set {_uniqueStorage()._typeInfo = .mapType(newValue)}
  }

  var rowType: Org_Apache_Beam_Model_Pipeline_V1_RowType {
    get {
      if case .rowType(let v)? = _storage._typeInfo {return v}
      return Org_Apache_Beam_Model_Pipeline_V1_RowType()
    }
    set {_uniqueStorage()._typeInfo = .rowType(newValue)}
  }

  var logicalType: Org_Apache_Beam_Model_Pipeline_V1_LogicalType {
    get {
      if case .logicalType(let v)? = _storage._typeInfo {return v}
      return Org_Apache_Beam_Model_Pipeline_V1_LogicalType()
    }
    set {_uniqueStorage()._typeInfo = .logicalType(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_TypeInfo: Equatable {
    case atomicType(Org_Apache_Beam_Model_Pipeline_V1_AtomicType)
    case arrayType(Org_Apache_Beam_Model_Pipeline_V1_ArrayType)
    case iterableType(Org_Apache_Beam_Model_Pipeline_V1_IterableType)
    case mapType(Org_Apache_Beam_Model_Pipeline_V1_MapType)
    case rowType(Org_Apache_Beam_Model_Pipeline_V1_RowType)
    case logicalType(Org_Apache_Beam_Model_Pipeline_V1_LogicalType)

  #if !swift(>=4.1)
    static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_FieldType.OneOf_TypeInfo, rhs: Org_Apache_Beam_Model_Pipeline_V1_FieldType.OneOf_TypeInfo) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.atomicType, .atomicType): return {
        guard case .atomicType(let l) = lhs, case .atomicType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.arrayType, .arrayType): return {
        guard case .arrayType(let l) = lhs, case .arrayType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iterableType, .iterableType): return {
        guard case .iterableType(let l) = lhs, case .iterableType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mapType, .mapType): return {
        guard case .mapType(let l) = lhs, case .mapType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rowType, .rowType): return {
        guard case .rowType(let l) = lhs, case .rowType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logicalType, .logicalType): return {
        guard case .logicalType(let l) = lhs, case .logicalType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Org_Apache_Beam_Model_Pipeline_V1_ArrayType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementType: Org_Apache_Beam_Model_Pipeline_V1_FieldType {
    get {return _storage._elementType ?? Org_Apache_Beam_Model_Pipeline_V1_FieldType()}
    set {_uniqueStorage()._elementType = newValue}
  }
  /// Returns true if `elementType` has been explicitly set.
  var hasElementType: Bool {return _storage._elementType != nil}
  /// Clears the value of `elementType`. Subsequent reads from it will return its default value.
  mutating func clearElementType() {_uniqueStorage()._elementType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Org_Apache_Beam_Model_Pipeline_V1_IterableType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementType: Org_Apache_Beam_Model_Pipeline_V1_FieldType {
    get {return _storage._elementType ?? Org_Apache_Beam_Model_Pipeline_V1_FieldType()}
    set {_uniqueStorage()._elementType = newValue}
  }
  /// Returns true if `elementType` has been explicitly set.
  var hasElementType: Bool {return _storage._elementType != nil}
  /// Clears the value of `elementType`. Subsequent reads from it will return its default value.
  mutating func clearElementType() {_uniqueStorage()._elementType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Org_Apache_Beam_Model_Pipeline_V1_MapType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyType: Org_Apache_Beam_Model_Pipeline_V1_FieldType {
    get {return _storage._keyType ?? Org_Apache_Beam_Model_Pipeline_V1_FieldType()}
    set {_uniqueStorage()._keyType = newValue}
  }
  /// Returns true if `keyType` has been explicitly set.
  var hasKeyType: Bool {return _storage._keyType != nil}
  /// Clears the value of `keyType`. Subsequent reads from it will return its default value.
  mutating func clearKeyType() {_uniqueStorage()._keyType = nil}

  var valueType: Org_Apache_Beam_Model_Pipeline_V1_FieldType {
    get {return _storage._valueType ?? Org_Apache_Beam_Model_Pipeline_V1_FieldType()}
    set {_uniqueStorage()._valueType = newValue}
  }
  /// Returns true if `valueType` has been explicitly set.
  var hasValueType: Bool {return _storage._valueType != nil}
  /// Clears the value of `valueType`. Subsequent reads from it will return its default value.
  mutating func clearValueType() {_uniqueStorage()._valueType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Org_Apache_Beam_Model_Pipeline_V1_RowType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var schema: Org_Apache_Beam_Model_Pipeline_V1_Schema {
    get {return _schema ?? Org_Apache_Beam_Model_Pipeline_V1_Schema()}
    set {_schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  var hasSchema: Bool {return self._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  mutating func clearSchema() {self._schema = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _schema: Org_Apache_Beam_Model_Pipeline_V1_Schema? = nil
}

struct Org_Apache_Beam_Model_Pipeline_V1_LogicalType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var urn: String {
    get {return _storage._urn}
    set {_uniqueStorage()._urn = newValue}
  }

  var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  var representation: Org_Apache_Beam_Model_Pipeline_V1_FieldType {
    get {return _storage._representation ?? Org_Apache_Beam_Model_Pipeline_V1_FieldType()}
    set {_uniqueStorage()._representation = newValue}
  }
  /// Returns true if `representation` has been explicitly set.
  var hasRepresentation: Bool {return _storage._representation != nil}
  /// Clears the value of `representation`. Subsequent reads from it will return its default value.
  mutating func clearRepresentation() {_uniqueStorage()._representation = nil}

  var argumentType: Org_Apache_Beam_Model_Pipeline_V1_FieldType {
    get {return _storage._argumentType ?? Org_Apache_Beam_Model_Pipeline_V1_FieldType()}
    set {_uniqueStorage()._argumentType = newValue}
  }
  /// Returns true if `argumentType` has been explicitly set.
  var hasArgumentType: Bool {return _storage._argumentType != nil}
  /// Clears the value of `argumentType`. Subsequent reads from it will return its default value.
  mutating func clearArgumentType() {_uniqueStorage()._argumentType = nil}

  var argument: Org_Apache_Beam_Model_Pipeline_V1_FieldValue {
    get {return _storage._argument ?? Org_Apache_Beam_Model_Pipeline_V1_FieldValue()}
    set {_uniqueStorage()._argument = newValue}
  }
  /// Returns true if `argument` has been explicitly set.
  var hasArgument: Bool {return _storage._argument != nil}
  /// Clears the value of `argument`. Subsequent reads from it will return its default value.
  mutating func clearArgument() {_uniqueStorage()._argument = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Universally defined Logical types for Row schemas.
/// These logical types are supposed to be understood by all SDKs.
struct Org_Apache_Beam_Model_Pipeline_V1_LogicalTypes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Enum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// A URN for Python Callable logical type
    ///   - Representation type: STRING
    ///   - Language type: In Python SDK, PythonCallableWithSource.
    ///     In any other SDKs, a wrapper object for a string which
    ///     can be evaluated to a Python Callable object.
    case pythonCallable // = 0

    /// A URN for MicrosInstant type
    ///   - Representation type: ROW<seconds: INT64, micros: INT64>
    ///   - A timestamp without a timezone where seconds + micros represents the
    ///     amount of time since the epoch.
    case microsInstant // = 1

    /// A URN for MillisInstant type
    ///   - Representation type: INT64
    ///   - A timestamp without a timezone represented by the number of
    ///     milliseconds since the epoch. The INT64 value is encoded with
    ///     big-endian shifted such that lexicographic ordering of the bytes
    ///     corresponds to chronological order.
    case millisInstant // = 2

    /// A URN for Decimal type
    ///   - Representation type: BYTES
    ///   - A decimal number with variable scale. Its BYTES
    ///     representation consists of an integer (INT32) scale followed by a
    ///     two's complement encoded big integer.
    case decimal // = 3

    /// A URN for FixedLengthBytes type
    ///   - Representation type: BYTES
    ///   - Argument type: INT32.
    ///     A fixed-length bytes with its length as the argument.
    case fixedBytes // = 4

    /// A URN for VariableLengthBytes type
    ///   - Representation type: BYTES
    ///   - Argument type: INT32.
    ///     A variable-length bytes with its maximum length as the argument.
    case varBytes // = 5

    /// A URN for FixedLengthString type
    ///   - Representation type: STRING
    ///   - Argument type: INT32.
    ///     A fixed-length string with its length as the argument.
    case fixedChar // = 6

    /// A URN for VariableLengthString type
    ///   - Representation type: STRING
    ///   - Argument type: INT32.
    ///     A variable-length string with its maximum length as the argument.
    case varChar // = 7
    case UNRECOGNIZED(Int)

    init() {
      self = .pythonCallable
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pythonCallable
      case 1: self = .microsInstant
      case 2: self = .millisInstant
      case 3: self = .decimal
      case 4: self = .fixedBytes
      case 5: self = .varBytes
      case 6: self = .fixedChar
      case 7: self = .varChar
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .pythonCallable: return 0
      case .microsInstant: return 1
      case .millisInstant: return 2
      case .decimal: return 3
      case .fixedBytes: return 4
      case .varBytes: return 5
      case .fixedChar: return 6
      case .varChar: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Org_Apache_Beam_Model_Pipeline_V1_LogicalTypes.Enum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Org_Apache_Beam_Model_Pipeline_V1_LogicalTypes.Enum] = [
    .pythonCallable,
    .microsInstant,
    .millisInstant,
    .decimal,
    .fixedBytes,
    .varBytes,
    .fixedChar,
    .varChar,
  ]
}

#endif  // swift(>=4.2)

struct Org_Apache_Beam_Model_Pipeline_V1_Option {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// REQUIRED. Identifier for the option.
  var name: String = String()

  /// REQUIRED. Type specifier for the structure of value.
  /// Conventionally, options that don't require additional configuration should
  /// use a boolean type, with the value set to true.
  var type: Org_Apache_Beam_Model_Pipeline_V1_FieldType {
    get {return _type ?? Org_Apache_Beam_Model_Pipeline_V1_FieldType()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var value: Org_Apache_Beam_Model_Pipeline_V1_FieldValue {
    get {return _value ?? Org_Apache_Beam_Model_Pipeline_V1_FieldValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: Org_Apache_Beam_Model_Pipeline_V1_FieldType? = nil
  fileprivate var _value: Org_Apache_Beam_Model_Pipeline_V1_FieldValue? = nil
}

struct Org_Apache_Beam_Model_Pipeline_V1_Row {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var values: [Org_Apache_Beam_Model_Pipeline_V1_FieldValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_Pipeline_V1_FieldValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If none of these are set, value is considered null.
  var fieldValue: OneOf_FieldValue? {
    get {return _storage._fieldValue}
    set {_uniqueStorage()._fieldValue = newValue}
  }

  var atomicValue: Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue {
    get {
      if case .atomicValue(let v)? = _storage._fieldValue {return v}
      return Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue()
    }
    set {_uniqueStorage()._fieldValue = .atomicValue(newValue)}
  }

  var arrayValue: Org_Apache_Beam_Model_Pipeline_V1_ArrayTypeValue {
    get {
      if case .arrayValue(let v)? = _storage._fieldValue {return v}
      return Org_Apache_Beam_Model_Pipeline_V1_ArrayTypeValue()
    }
    set {_uniqueStorage()._fieldValue = .arrayValue(newValue)}
  }

  var iterableValue: Org_Apache_Beam_Model_Pipeline_V1_IterableTypeValue {
    get {
      if case .iterableValue(let v)? = _storage._fieldValue {return v}
      return Org_Apache_Beam_Model_Pipeline_V1_IterableTypeValue()
    }
    set {_uniqueStorage()._fieldValue = .iterableValue(newValue)}
  }

  var mapValue: Org_Apache_Beam_Model_Pipeline_V1_MapTypeValue {
    get {
      if case .mapValue(let v)? = _storage._fieldValue {return v}
      return Org_Apache_Beam_Model_Pipeline_V1_MapTypeValue()
    }
    set {_uniqueStorage()._fieldValue = .mapValue(newValue)}
  }

  var rowValue: Org_Apache_Beam_Model_Pipeline_V1_Row {
    get {
      if case .rowValue(let v)? = _storage._fieldValue {return v}
      return Org_Apache_Beam_Model_Pipeline_V1_Row()
    }
    set {_uniqueStorage()._fieldValue = .rowValue(newValue)}
  }

  var logicalTypeValue: Org_Apache_Beam_Model_Pipeline_V1_LogicalTypeValue {
    get {
      if case .logicalTypeValue(let v)? = _storage._fieldValue {return v}
      return Org_Apache_Beam_Model_Pipeline_V1_LogicalTypeValue()
    }
    set {_uniqueStorage()._fieldValue = .logicalTypeValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If none of these are set, value is considered null.
  enum OneOf_FieldValue: Equatable {
    case atomicValue(Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue)
    case arrayValue(Org_Apache_Beam_Model_Pipeline_V1_ArrayTypeValue)
    case iterableValue(Org_Apache_Beam_Model_Pipeline_V1_IterableTypeValue)
    case mapValue(Org_Apache_Beam_Model_Pipeline_V1_MapTypeValue)
    case rowValue(Org_Apache_Beam_Model_Pipeline_V1_Row)
    case logicalTypeValue(Org_Apache_Beam_Model_Pipeline_V1_LogicalTypeValue)

  #if !swift(>=4.1)
    static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_FieldValue.OneOf_FieldValue, rhs: Org_Apache_Beam_Model_Pipeline_V1_FieldValue.OneOf_FieldValue) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.atomicValue, .atomicValue): return {
        guard case .atomicValue(let l) = lhs, case .atomicValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.arrayValue, .arrayValue): return {
        guard case .arrayValue(let l) = lhs, case .arrayValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iterableValue, .iterableValue): return {
        guard case .iterableValue(let l) = lhs, case .iterableValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mapValue, .mapValue): return {
        guard case .mapValue(let l) = lhs, case .mapValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rowValue, .rowValue): return {
        guard case .rowValue(let l) = lhs, case .rowValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logicalTypeValue, .logicalTypeValue): return {
        guard case .logicalTypeValue(let l) = lhs, case .logicalTypeValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue.OneOf_Value? = nil

  var byte: Int32 {
    get {
      if case .byte(let v)? = value {return v}
      return 0
    }
    set {value = .byte(newValue)}
  }

  var int16: Int32 {
    get {
      if case .int16(let v)? = value {return v}
      return 0
    }
    set {value = .int16(newValue)}
  }

  var int32: Int32 {
    get {
      if case .int32(let v)? = value {return v}
      return 0
    }
    set {value = .int32(newValue)}
  }

  var int64: Int64 {
    get {
      if case .int64(let v)? = value {return v}
      return 0
    }
    set {value = .int64(newValue)}
  }

  var float: Float {
    get {
      if case .float(let v)? = value {return v}
      return 0
    }
    set {value = .float(newValue)}
  }

  var double: Double {
    get {
      if case .double(let v)? = value {return v}
      return 0
    }
    set {value = .double(newValue)}
  }

  var string: String {
    get {
      if case .string(let v)? = value {return v}
      return String()
    }
    set {value = .string(newValue)}
  }

  var boolean: Bool {
    get {
      if case .boolean(let v)? = value {return v}
      return false
    }
    set {value = .boolean(newValue)}
  }

  var bytes: Data {
    get {
      if case .bytes(let v)? = value {return v}
      return Data()
    }
    set {value = .bytes(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case byte(Int32)
    case int16(Int32)
    case int32(Int32)
    case int64(Int64)
    case float(Float)
    case double(Double)
    case string(String)
    case boolean(Bool)
    case bytes(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue.OneOf_Value, rhs: Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.byte, .byte): return {
        guard case .byte(let l) = lhs, case .byte(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.int16, .int16): return {
        guard case .int16(let l) = lhs, case .int16(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.int32, .int32): return {
        guard case .int32(let l) = lhs, case .int32(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.int64, .int64): return {
        guard case .int64(let l) = lhs, case .int64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.float, .float): return {
        guard case .float(let l) = lhs, case .float(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.double, .double): return {
        guard case .double(let l) = lhs, case .double(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.boolean, .boolean): return {
        guard case .boolean(let l) = lhs, case .boolean(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bytes, .bytes): return {
        guard case .bytes(let l) = lhs, case .bytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Org_Apache_Beam_Model_Pipeline_V1_ArrayTypeValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var element: [Org_Apache_Beam_Model_Pipeline_V1_FieldValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_Pipeline_V1_IterableTypeValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var element: [Org_Apache_Beam_Model_Pipeline_V1_FieldValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_Pipeline_V1_MapTypeValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [Org_Apache_Beam_Model_Pipeline_V1_MapTypeEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_Pipeline_V1_MapTypeEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: Org_Apache_Beam_Model_Pipeline_V1_FieldValue {
    get {return _key ?? Org_Apache_Beam_Model_Pipeline_V1_FieldValue()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var value: Org_Apache_Beam_Model_Pipeline_V1_FieldValue {
    get {return _value ?? Org_Apache_Beam_Model_Pipeline_V1_FieldValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: Org_Apache_Beam_Model_Pipeline_V1_FieldValue? = nil
  fileprivate var _value: Org_Apache_Beam_Model_Pipeline_V1_FieldValue? = nil
}

struct Org_Apache_Beam_Model_Pipeline_V1_LogicalTypeValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Org_Apache_Beam_Model_Pipeline_V1_FieldValue {
    get {return _storage._value ?? Org_Apache_Beam_Model_Pipeline_V1_FieldValue()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Org_Apache_Beam_Model_Pipeline_V1_AtomicType: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_Schema: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_Field: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_FieldType: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_FieldType.OneOf_TypeInfo: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_ArrayType: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_IterableType: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_MapType: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_RowType: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_LogicalType: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_LogicalTypes: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_LogicalTypes.Enum: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_Option: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_Row: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_FieldValue: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_FieldValue.OneOf_FieldValue: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue.OneOf_Value: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_ArrayTypeValue: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_IterableTypeValue: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_MapTypeValue: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_MapTypeEntry: @unchecked Sendable {}
extension Org_Apache_Beam_Model_Pipeline_V1_LogicalTypeValue: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "org.apache.beam.model.pipeline.v1"

extension Org_Apache_Beam_Model_Pipeline_V1_AtomicType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "BYTE"),
    2: .same(proto: "INT16"),
    3: .same(proto: "INT32"),
    4: .same(proto: "INT64"),
    5: .same(proto: "FLOAT"),
    6: .same(proto: "DOUBLE"),
    7: .same(proto: "STRING"),
    8: .same(proto: "BOOLEAN"),
    9: .same(proto: "BYTES"),
  ]
}

extension Org_Apache_Beam_Model_Pipeline_V1_Schema: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Schema"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fields"),
    2: .same(proto: "id"),
    3: .same(proto: "options"),
    4: .standard(proto: "encoding_positions_set"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.encodingPositionsSet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 3)
    }
    if self.encodingPositionsSet != false {
      try visitor.visitSingularBoolField(value: self.encodingPositionsSet, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_Schema, rhs: Org_Apache_Beam_Model_Pipeline_V1_Schema) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.id != rhs.id {return false}
    if lhs.options != rhs.options {return false}
    if lhs.encodingPositionsSet != rhs.encodingPositionsSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Field"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "type"),
    4: .same(proto: "id"),
    5: .standard(proto: "encoding_position"),
    6: .same(proto: "options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.encodingPosition) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 4)
    }
    if self.encodingPosition != 0 {
      try visitor.visitSingularInt32Field(value: self.encodingPosition, fieldNumber: 5)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_Field, rhs: Org_Apache_Beam_Model_Pipeline_V1_Field) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._type != rhs._type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.encodingPosition != rhs.encodingPosition {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_FieldType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FieldType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nullable"),
    2: .standard(proto: "atomic_type"),
    3: .standard(proto: "array_type"),
    4: .standard(proto: "iterable_type"),
    5: .standard(proto: "map_type"),
    6: .standard(proto: "row_type"),
    7: .standard(proto: "logical_type"),
  ]

  fileprivate class _StorageClass {
    var _nullable: Bool = false
    var _typeInfo: Org_Apache_Beam_Model_Pipeline_V1_FieldType.OneOf_TypeInfo?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nullable = source._nullable
      _typeInfo = source._typeInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._nullable) }()
        case 2: try {
          var v: Org_Apache_Beam_Model_Pipeline_V1_AtomicType?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._typeInfo != nil {try decoder.handleConflictingOneOf()}
            _storage._typeInfo = .atomicType(v)
          }
        }()
        case 3: try {
          var v: Org_Apache_Beam_Model_Pipeline_V1_ArrayType?
          var hadOneofValue = false
          if let current = _storage._typeInfo {
            hadOneofValue = true
            if case .arrayType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._typeInfo = .arrayType(v)
          }
        }()
        case 4: try {
          var v: Org_Apache_Beam_Model_Pipeline_V1_IterableType?
          var hadOneofValue = false
          if let current = _storage._typeInfo {
            hadOneofValue = true
            if case .iterableType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._typeInfo = .iterableType(v)
          }
        }()
        case 5: try {
          var v: Org_Apache_Beam_Model_Pipeline_V1_MapType?
          var hadOneofValue = false
          if let current = _storage._typeInfo {
            hadOneofValue = true
            if case .mapType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._typeInfo = .mapType(v)
          }
        }()
        case 6: try {
          var v: Org_Apache_Beam_Model_Pipeline_V1_RowType?
          var hadOneofValue = false
          if let current = _storage._typeInfo {
            hadOneofValue = true
            if case .rowType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._typeInfo = .rowType(v)
          }
        }()
        case 7: try {
          var v: Org_Apache_Beam_Model_Pipeline_V1_LogicalType?
          var hadOneofValue = false
          if let current = _storage._typeInfo {
            hadOneofValue = true
            if case .logicalType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._typeInfo = .logicalType(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._nullable != false {
        try visitor.visitSingularBoolField(value: _storage._nullable, fieldNumber: 1)
      }
      switch _storage._typeInfo {
      case .atomicType?: try {
        guard case .atomicType(let v)? = _storage._typeInfo else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }()
      case .arrayType?: try {
        guard case .arrayType(let v)? = _storage._typeInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .iterableType?: try {
        guard case .iterableType(let v)? = _storage._typeInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .mapType?: try {
        guard case .mapType(let v)? = _storage._typeInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .rowType?: try {
        guard case .rowType(let v)? = _storage._typeInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .logicalType?: try {
        guard case .logicalType(let v)? = _storage._typeInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_FieldType, rhs: Org_Apache_Beam_Model_Pipeline_V1_FieldType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nullable != rhs_storage._nullable {return false}
        if _storage._typeInfo != rhs_storage._typeInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_ArrayType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArrayType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_type"),
  ]

  fileprivate class _StorageClass {
    var _elementType: Org_Apache_Beam_Model_Pipeline_V1_FieldType? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementType = source._elementType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._elementType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._elementType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_ArrayType, rhs: Org_Apache_Beam_Model_Pipeline_V1_ArrayType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementType != rhs_storage._elementType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_IterableType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IterableType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_type"),
  ]

  fileprivate class _StorageClass {
    var _elementType: Org_Apache_Beam_Model_Pipeline_V1_FieldType? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementType = source._elementType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._elementType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._elementType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_IterableType, rhs: Org_Apache_Beam_Model_Pipeline_V1_IterableType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementType != rhs_storage._elementType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_MapType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_type"),
    2: .standard(proto: "value_type"),
  ]

  fileprivate class _StorageClass {
    var _keyType: Org_Apache_Beam_Model_Pipeline_V1_FieldType? = nil
    var _valueType: Org_Apache_Beam_Model_Pipeline_V1_FieldType? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _keyType = source._keyType
      _valueType = source._valueType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._keyType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._valueType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._keyType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._valueType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_MapType, rhs: Org_Apache_Beam_Model_Pipeline_V1_MapType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keyType != rhs_storage._keyType {return false}
        if _storage._valueType != rhs_storage._valueType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_RowType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RowType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schema"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._schema) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._schema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_RowType, rhs: Org_Apache_Beam_Model_Pipeline_V1_RowType) -> Bool {
    if lhs._schema != rhs._schema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_LogicalType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogicalType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "urn"),
    2: .same(proto: "payload"),
    3: .same(proto: "representation"),
    4: .standard(proto: "argument_type"),
    5: .same(proto: "argument"),
  ]

  fileprivate class _StorageClass {
    var _urn: String = String()
    var _payload: Data = Data()
    var _representation: Org_Apache_Beam_Model_Pipeline_V1_FieldType? = nil
    var _argumentType: Org_Apache_Beam_Model_Pipeline_V1_FieldType? = nil
    var _argument: Org_Apache_Beam_Model_Pipeline_V1_FieldValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _urn = source._urn
      _payload = source._payload
      _representation = source._representation
      _argumentType = source._argumentType
      _argument = source._argument
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._urn) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._payload) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._representation) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._argumentType) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._argument) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._urn.isEmpty {
        try visitor.visitSingularStringField(value: _storage._urn, fieldNumber: 1)
      }
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 2)
      }
      try { if let v = _storage._representation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._argumentType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._argument {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_LogicalType, rhs: Org_Apache_Beam_Model_Pipeline_V1_LogicalType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._urn != rhs_storage._urn {return false}
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._representation != rhs_storage._representation {return false}
        if _storage._argumentType != rhs_storage._argumentType {return false}
        if _storage._argument != rhs_storage._argument {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_LogicalTypes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogicalTypes"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_LogicalTypes, rhs: Org_Apache_Beam_Model_Pipeline_V1_LogicalTypes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_LogicalTypes.Enum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PYTHON_CALLABLE"),
    1: .same(proto: "MICROS_INSTANT"),
    2: .same(proto: "MILLIS_INSTANT"),
    3: .same(proto: "DECIMAL"),
    4: .same(proto: "FIXED_BYTES"),
    5: .same(proto: "VAR_BYTES"),
    6: .same(proto: "FIXED_CHAR"),
    7: .same(proto: "VAR_CHAR"),
  ]
}

extension Org_Apache_Beam_Model_Pipeline_V1_Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Option"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_Option, rhs: Org_Apache_Beam_Model_Pipeline_V1_Option) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._type != rhs._type {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_Row: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Row"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_Row, rhs: Org_Apache_Beam_Model_Pipeline_V1_Row) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_FieldValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FieldValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "atomic_value"),
    2: .standard(proto: "array_value"),
    3: .standard(proto: "iterable_value"),
    4: .standard(proto: "map_value"),
    5: .standard(proto: "row_value"),
    6: .standard(proto: "logical_type_value"),
  ]

  fileprivate class _StorageClass {
    var _fieldValue: Org_Apache_Beam_Model_Pipeline_V1_FieldValue.OneOf_FieldValue?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _fieldValue = source._fieldValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue?
          var hadOneofValue = false
          if let current = _storage._fieldValue {
            hadOneofValue = true
            if case .atomicValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._fieldValue = .atomicValue(v)
          }
        }()
        case 2: try {
          var v: Org_Apache_Beam_Model_Pipeline_V1_ArrayTypeValue?
          var hadOneofValue = false
          if let current = _storage._fieldValue {
            hadOneofValue = true
            if case .arrayValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._fieldValue = .arrayValue(v)
          }
        }()
        case 3: try {
          var v: Org_Apache_Beam_Model_Pipeline_V1_IterableTypeValue?
          var hadOneofValue = false
          if let current = _storage._fieldValue {
            hadOneofValue = true
            if case .iterableValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._fieldValue = .iterableValue(v)
          }
        }()
        case 4: try {
          var v: Org_Apache_Beam_Model_Pipeline_V1_MapTypeValue?
          var hadOneofValue = false
          if let current = _storage._fieldValue {
            hadOneofValue = true
            if case .mapValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._fieldValue = .mapValue(v)
          }
        }()
        case 5: try {
          var v: Org_Apache_Beam_Model_Pipeline_V1_Row?
          var hadOneofValue = false
          if let current = _storage._fieldValue {
            hadOneofValue = true
            if case .rowValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._fieldValue = .rowValue(v)
          }
        }()
        case 6: try {
          var v: Org_Apache_Beam_Model_Pipeline_V1_LogicalTypeValue?
          var hadOneofValue = false
          if let current = _storage._fieldValue {
            hadOneofValue = true
            if case .logicalTypeValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._fieldValue = .logicalTypeValue(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._fieldValue {
      case .atomicValue?: try {
        guard case .atomicValue(let v)? = _storage._fieldValue else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .arrayValue?: try {
        guard case .arrayValue(let v)? = _storage._fieldValue else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .iterableValue?: try {
        guard case .iterableValue(let v)? = _storage._fieldValue else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .mapValue?: try {
        guard case .mapValue(let v)? = _storage._fieldValue else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .rowValue?: try {
        guard case .rowValue(let v)? = _storage._fieldValue else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .logicalTypeValue?: try {
        guard case .logicalTypeValue(let v)? = _storage._fieldValue else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_FieldValue, rhs: Org_Apache_Beam_Model_Pipeline_V1_FieldValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fieldValue != rhs_storage._fieldValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AtomicTypeValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "byte"),
    2: .same(proto: "int16"),
    3: .same(proto: "int32"),
    4: .same(proto: "int64"),
    5: .same(proto: "float"),
    6: .same(proto: "double"),
    7: .same(proto: "string"),
    8: .same(proto: "boolean"),
    9: .same(proto: "bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .byte(v)
        }
      }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .int16(v)
        }
      }()
      case 3: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .int32(v)
        }
      }()
      case 4: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .int64(v)
        }
      }()
      case 5: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .float(v)
        }
      }()
      case 6: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .double(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .string(v)
        }
      }()
      case 8: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .boolean(v)
        }
      }()
      case 9: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .bytes(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .byte?: try {
      guard case .byte(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .int16?: try {
      guard case .int16(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case .int32?: try {
      guard case .int32(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }()
    case .int64?: try {
      guard case .int64(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case .float?: try {
      guard case .float(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }()
    case .double?: try {
      guard case .double(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    }()
    case .string?: try {
      guard case .string(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    case .boolean?: try {
      guard case .boolean(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case .bytes?: try {
      guard case .bytes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue, rhs: Org_Apache_Beam_Model_Pipeline_V1_AtomicTypeValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_ArrayTypeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArrayTypeValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "element"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.element) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.element.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.element, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_ArrayTypeValue, rhs: Org_Apache_Beam_Model_Pipeline_V1_ArrayTypeValue) -> Bool {
    if lhs.element != rhs.element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_IterableTypeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IterableTypeValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "element"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.element) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.element.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.element, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_IterableTypeValue, rhs: Org_Apache_Beam_Model_Pipeline_V1_IterableTypeValue) -> Bool {
    if lhs.element != rhs.element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_MapTypeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapTypeValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_MapTypeValue, rhs: Org_Apache_Beam_Model_Pipeline_V1_MapTypeValue) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_MapTypeEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapTypeEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_MapTypeEntry, rhs: Org_Apache_Beam_Model_Pipeline_V1_MapTypeEntry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_Pipeline_V1_LogicalTypeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogicalTypeValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _value: Org_Apache_Beam_Model_Pipeline_V1_FieldValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_Pipeline_V1_LogicalTypeValue, rhs: Org_Apache_Beam_Model_Pipeline_V1_LogicalTypeValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
