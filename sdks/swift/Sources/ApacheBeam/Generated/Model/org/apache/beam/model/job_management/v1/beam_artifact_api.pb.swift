// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: org/apache/beam/model/job_management/v1/beam_artifact_api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// Protocol Buffers describing the Artifact API, for communicating with a runner
// for artifact staging and retrieval over GRPC.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A request for artifact resolution.
struct Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An (ordered) set of artifacts to (jointly) resolve.
  var artifacts: [Org_Apache_Beam_Model_Pipeline_V1_ArtifactInformation] = []

  /// A set of artifact type urns that are understood by the requester.
  /// An attempt should be made to resolve the artifacts in terms of these URNs,
  /// but other URNs may be used as well with the understanding that they must
  /// be fetch-able as bytes via GetArtifact.
  var preferredUrns: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A response for artifact resolution.
struct Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A full (ordered) set of replacements for the set of requested artifacts,
  /// preferably in terms of the requested type URNs.  If there is no better
  /// resolution, the original list is returned.
  var replacements: [Org_Apache_Beam_Model_Pipeline_V1_ArtifactInformation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A request to get an artifact.
struct Org_Apache_Beam_Model_JobManagement_V1_GetArtifactRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var artifact: Org_Apache_Beam_Model_Pipeline_V1_ArtifactInformation {
    get {return _artifact ?? Org_Apache_Beam_Model_Pipeline_V1_ArtifactInformation()}
    set {_artifact = newValue}
  }
  /// Returns true if `artifact` has been explicitly set.
  var hasArtifact: Bool {return self._artifact != nil}
  /// Clears the value of `artifact`. Subsequent reads from it will return its default value.
  mutating func clearArtifact() {self._artifact = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _artifact: Org_Apache_Beam_Model_Pipeline_V1_ArtifactInformation? = nil
}

/// Part of a response to getting an artifact.
struct Org_Apache_Beam_Model_JobManagement_V1_GetArtifactResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Wraps an ArtifactRetrievalService request for use in ReverseArtifactRetrievalService.
struct Org_Apache_Beam_Model_JobManagement_V1_ArtifactRequestWrapper {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Org_Apache_Beam_Model_JobManagement_V1_ArtifactRequestWrapper.OneOf_Request? = nil

  var resolveArtifact: Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsRequest {
    get {
      if case .resolveArtifact(let v)? = request {return v}
      return Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsRequest()
    }
    set {request = .resolveArtifact(newValue)}
  }

  var getArtifact: Org_Apache_Beam_Model_JobManagement_V1_GetArtifactRequest {
    get {
      if case .getArtifact(let v)? = request {return v}
      return Org_Apache_Beam_Model_JobManagement_V1_GetArtifactRequest()
    }
    set {request = .getArtifact(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case resolveArtifact(Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsRequest)
    case getArtifact(Org_Apache_Beam_Model_JobManagement_V1_GetArtifactRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_ArtifactRequestWrapper.OneOf_Request, rhs: Org_Apache_Beam_Model_JobManagement_V1_ArtifactRequestWrapper.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.resolveArtifact, .resolveArtifact): return {
        guard case .resolveArtifact(let l) = lhs, case .resolveArtifact(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getArtifact, .getArtifact): return {
        guard case .getArtifact(let l) = lhs, case .getArtifact(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Wraps an ArtifactRetrievalService response for use in ReverseArtifactRetrievalService.
struct Org_Apache_Beam_Model_JobManagement_V1_ArtifactResponseWrapper {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A token indicating which job these artifacts are being staged for.
  var stagingToken: String = String()

  /// Whether this is the last response for this request (for those responses that
  /// would typically be terminated by the end of the response stream.)
  var isLast: Bool = false

  /// The response itself.
  var response: Org_Apache_Beam_Model_JobManagement_V1_ArtifactResponseWrapper.OneOf_Response? = nil

  var resolveArtifactResponse: Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsResponse {
    get {
      if case .resolveArtifactResponse(let v)? = response {return v}
      return Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsResponse()
    }
    set {response = .resolveArtifactResponse(newValue)}
  }

  var getArtifactResponse: Org_Apache_Beam_Model_JobManagement_V1_GetArtifactResponse {
    get {
      if case .getArtifactResponse(let v)? = response {return v}
      return Org_Apache_Beam_Model_JobManagement_V1_GetArtifactResponse()
    }
    set {response = .getArtifactResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The response itself.
  enum OneOf_Response: Equatable {
    case resolveArtifactResponse(Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsResponse)
    case getArtifactResponse(Org_Apache_Beam_Model_JobManagement_V1_GetArtifactResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_ArtifactResponseWrapper.OneOf_Response, rhs: Org_Apache_Beam_Model_JobManagement_V1_ArtifactResponseWrapper.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.resolveArtifactResponse, .resolveArtifactResponse): return {
        guard case .resolveArtifactResponse(let l) = lhs, case .resolveArtifactResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getArtifactResponse, .getArtifactResponse): return {
        guard case .getArtifactResponse(let l) = lhs, case .getArtifactResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// An artifact identifier and associated metadata.
struct Org_Apache_Beam_Model_JobManagement_V1_ArtifactMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) The name of the artifact.
  var name: String = String()

  /// (Optional) The Unix-like permissions of the artifact
  var permissions: UInt32 = 0

  /// (Optional) The hex-encoded sha256 checksum of the artifact. Used, among other things, by
  /// harness boot code to validate the integrity of the artifact.
  var sha256: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A collection of artifacts.
struct Org_Apache_Beam_Model_JobManagement_V1_Manifest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var artifact: [Org_Apache_Beam_Model_JobManagement_V1_ArtifactMetadata] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A manifest with location information.
struct Org_Apache_Beam_Model_JobManagement_V1_ProxyManifest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var manifest: Org_Apache_Beam_Model_JobManagement_V1_Manifest {
    get {return _manifest ?? Org_Apache_Beam_Model_JobManagement_V1_Manifest()}
    set {_manifest = newValue}
  }
  /// Returns true if `manifest` has been explicitly set.
  var hasManifest: Bool {return self._manifest != nil}
  /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
  mutating func clearManifest() {self._manifest = nil}

  var location: [Org_Apache_Beam_Model_JobManagement_V1_ProxyManifest.Location] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Location {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var uri: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _manifest: Org_Apache_Beam_Model_JobManagement_V1_Manifest? = nil
}

/// A request to get the manifest of a Job.
struct Org_Apache_Beam_Model_JobManagement_V1_GetManifestRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) An opaque token representing the entirety of the staged artifacts.
  /// Returned in CommitManifestResponse.
  var retrievalToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A response containing a job manifest.
struct Org_Apache_Beam_Model_JobManagement_V1_GetManifestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var manifest: Org_Apache_Beam_Model_JobManagement_V1_Manifest {
    get {return _manifest ?? Org_Apache_Beam_Model_JobManagement_V1_Manifest()}
    set {_manifest = newValue}
  }
  /// Returns true if `manifest` has been explicitly set.
  var hasManifest: Bool {return self._manifest != nil}
  /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
  mutating func clearManifest() {self._manifest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _manifest: Org_Apache_Beam_Model_JobManagement_V1_Manifest? = nil
}

/// A request to get an artifact. The artifact must be present in the manifest for the job.
struct Org_Apache_Beam_Model_JobManagement_V1_LegacyGetArtifactRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) The name of the artifact to retrieve.
  var name: String = String()

  /// (Required) An opaque token representing the entirety of the staged artifacts.
  /// Returned in CommitManifestResponse.
  var retrievalToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Part of an artifact.
struct Org_Apache_Beam_Model_JobManagement_V1_ArtifactChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_JobManagement_V1_PutArtifactMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) A token for artifact staging session. This token can be obtained
  /// from PrepareJob request in JobService
  var stagingSessionToken: String = String()

  /// (Required) The Artifact metadata.
  var metadata: Org_Apache_Beam_Model_JobManagement_V1_ArtifactMetadata {
    get {return _metadata ?? Org_Apache_Beam_Model_JobManagement_V1_ArtifactMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Org_Apache_Beam_Model_JobManagement_V1_ArtifactMetadata? = nil
}

/// A request to stage an artifact.
struct Org_Apache_Beam_Model_JobManagement_V1_PutArtifactRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required)
  var content: Org_Apache_Beam_Model_JobManagement_V1_PutArtifactRequest.OneOf_Content? = nil

  /// The first message in a PutArtifact call must contain this field.
  var metadata: Org_Apache_Beam_Model_JobManagement_V1_PutArtifactMetadata {
    get {
      if case .metadata(let v)? = content {return v}
      return Org_Apache_Beam_Model_JobManagement_V1_PutArtifactMetadata()
    }
    set {content = .metadata(newValue)}
  }

  /// A chunk of the artifact. All messages after the first in a PutArtifact call must contain a
  /// chunk.
  var data: Org_Apache_Beam_Model_JobManagement_V1_ArtifactChunk {
    get {
      if case .data(let v)? = content {return v}
      return Org_Apache_Beam_Model_JobManagement_V1_ArtifactChunk()
    }
    set {content = .data(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// (Required)
  enum OneOf_Content: Equatable {
    /// The first message in a PutArtifact call must contain this field.
    case metadata(Org_Apache_Beam_Model_JobManagement_V1_PutArtifactMetadata)
    /// A chunk of the artifact. All messages after the first in a PutArtifact call must contain a
    /// chunk.
    case data(Org_Apache_Beam_Model_JobManagement_V1_ArtifactChunk)

  #if !swift(>=4.1)
    static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_PutArtifactRequest.OneOf_Content, rhs: Org_Apache_Beam_Model_JobManagement_V1_PutArtifactRequest.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.metadata, .metadata): return {
        guard case .metadata(let l) = lhs, case .metadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Org_Apache_Beam_Model_JobManagement_V1_PutArtifactResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A request to commit the manifest for a Job. All artifacts must have been successfully uploaded
/// before this call is made.
struct Org_Apache_Beam_Model_JobManagement_V1_CommitManifestRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) The manifest to commit.
  var manifest: Org_Apache_Beam_Model_JobManagement_V1_Manifest {
    get {return _manifest ?? Org_Apache_Beam_Model_JobManagement_V1_Manifest()}
    set {_manifest = newValue}
  }
  /// Returns true if `manifest` has been explicitly set.
  var hasManifest: Bool {return self._manifest != nil}
  /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
  mutating func clearManifest() {self._manifest = nil}

  /// (Required) A token for artifact staging session. This token can be obtained
  /// from PrepareJob request in JobService
  var stagingSessionToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _manifest: Org_Apache_Beam_Model_JobManagement_V1_Manifest? = nil
}

/// The result of committing a manifest.
struct Org_Apache_Beam_Model_JobManagement_V1_CommitManifestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) An opaque token representing the entirety of the staged artifacts.
  /// This can be used to retrieve the manifest and artifacts from an associated
  /// LegacyArtifactRetrievalService.
  var retrievalToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Constants: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Token indicating that no artifacts were staged and therefore no retrieval attempt is necessary.
    case noArtifactsStagedToken // = 0
    case UNRECOGNIZED(Int)

    init() {
      self = .noArtifactsStagedToken
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noArtifactsStagedToken
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .noArtifactsStagedToken: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Org_Apache_Beam_Model_JobManagement_V1_CommitManifestResponse.Constants: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Org_Apache_Beam_Model_JobManagement_V1_CommitManifestResponse.Constants] = [
    .noArtifactsStagedToken,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_GetArtifactRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_GetArtifactResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_ArtifactRequestWrapper: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_ArtifactRequestWrapper.OneOf_Request: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_ArtifactResponseWrapper: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_ArtifactResponseWrapper.OneOf_Response: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_ArtifactMetadata: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_Manifest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_ProxyManifest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_ProxyManifest.Location: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_GetManifestRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_GetManifestResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_LegacyGetArtifactRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_ArtifactChunk: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_PutArtifactMetadata: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_PutArtifactRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_PutArtifactRequest.OneOf_Content: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_PutArtifactResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_CommitManifestRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_CommitManifestResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_JobManagement_V1_CommitManifestResponse.Constants: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "org.apache.beam.model.job_management.v1"

extension Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResolveArtifactsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "artifacts"),
    2: .standard(proto: "preferred_urns"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.artifacts) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.preferredUrns) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artifacts, fieldNumber: 1)
    }
    if !self.preferredUrns.isEmpty {
      try visitor.visitRepeatedStringField(value: self.preferredUrns, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsRequest) -> Bool {
    if lhs.artifacts != rhs.artifacts {return false}
    if lhs.preferredUrns != rhs.preferredUrns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResolveArtifactsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replacements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.replacements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.replacements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.replacements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsResponse) -> Bool {
    if lhs.replacements != rhs.replacements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_GetArtifactRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetArtifactRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "artifact"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._artifact) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._artifact {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_GetArtifactRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_GetArtifactRequest) -> Bool {
    if lhs._artifact != rhs._artifact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_GetArtifactResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetArtifactResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_GetArtifactResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_GetArtifactResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_ArtifactRequestWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArtifactRequestWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1000: .standard(proto: "resolve_artifact"),
    1001: .standard(proto: "get_artifact"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1000: try {
        var v: Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .resolveArtifact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .resolveArtifact(v)
        }
      }()
      case 1001: try {
        var v: Org_Apache_Beam_Model_JobManagement_V1_GetArtifactRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getArtifact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getArtifact(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .resolveArtifact?: try {
      guard case .resolveArtifact(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    }()
    case .getArtifact?: try {
      guard case .getArtifact(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_ArtifactRequestWrapper, rhs: Org_Apache_Beam_Model_JobManagement_V1_ArtifactRequestWrapper) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_ArtifactResponseWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArtifactResponseWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staging_token"),
    2: .standard(proto: "is_last"),
    1000: .standard(proto: "resolve_artifact_response"),
    1001: .standard(proto: "get_artifact_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stagingToken) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isLast) }()
      case 1000: try {
        var v: Org_Apache_Beam_Model_JobManagement_V1_ResolveArtifactsResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .resolveArtifactResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .resolveArtifactResponse(v)
        }
      }()
      case 1001: try {
        var v: Org_Apache_Beam_Model_JobManagement_V1_GetArtifactResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getArtifactResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getArtifactResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.stagingToken.isEmpty {
      try visitor.visitSingularStringField(value: self.stagingToken, fieldNumber: 1)
    }
    if self.isLast != false {
      try visitor.visitSingularBoolField(value: self.isLast, fieldNumber: 2)
    }
    switch self.response {
    case .resolveArtifactResponse?: try {
      guard case .resolveArtifactResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    }()
    case .getArtifactResponse?: try {
      guard case .getArtifactResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_ArtifactResponseWrapper, rhs: Org_Apache_Beam_Model_JobManagement_V1_ArtifactResponseWrapper) -> Bool {
    if lhs.stagingToken != rhs.stagingToken {return false}
    if lhs.isLast != rhs.isLast {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_ArtifactMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArtifactMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "permissions"),
    4: .same(proto: "sha256"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.permissions) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sha256) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.permissions != 0 {
      try visitor.visitSingularUInt32Field(value: self.permissions, fieldNumber: 2)
    }
    if !self.sha256.isEmpty {
      try visitor.visitSingularStringField(value: self.sha256, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_ArtifactMetadata, rhs: Org_Apache_Beam_Model_JobManagement_V1_ArtifactMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.sha256 != rhs.sha256 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_Manifest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Manifest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "artifact"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.artifact) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifact.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artifact, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_Manifest, rhs: Org_Apache_Beam_Model_JobManagement_V1_Manifest) -> Bool {
    if lhs.artifact != rhs.artifact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_ProxyManifest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProxyManifest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manifest"),
    2: .same(proto: "location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._manifest) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.location) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._manifest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.location.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.location, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_ProxyManifest, rhs: Org_Apache_Beam_Model_JobManagement_V1_ProxyManifest) -> Bool {
    if lhs._manifest != rhs._manifest {return false}
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_ProxyManifest.Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_JobManagement_V1_ProxyManifest.protoMessageName + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "uri"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_ProxyManifest.Location, rhs: Org_Apache_Beam_Model_JobManagement_V1_ProxyManifest.Location) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_GetManifestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetManifestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "retrieval_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.retrievalToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.retrievalToken.isEmpty {
      try visitor.visitSingularStringField(value: self.retrievalToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_GetManifestRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_GetManifestRequest) -> Bool {
    if lhs.retrievalToken != rhs.retrievalToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_GetManifestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetManifestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manifest"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._manifest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._manifest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_GetManifestResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_GetManifestResponse) -> Bool {
    if lhs._manifest != rhs._manifest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_LegacyGetArtifactRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LegacyGetArtifactRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "retrieval_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.retrievalToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.retrievalToken.isEmpty {
      try visitor.visitSingularStringField(value: self.retrievalToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_LegacyGetArtifactRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_LegacyGetArtifactRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.retrievalToken != rhs.retrievalToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_ArtifactChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArtifactChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_ArtifactChunk, rhs: Org_Apache_Beam_Model_JobManagement_V1_ArtifactChunk) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_PutArtifactMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PutArtifactMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staging_session_token"),
    2: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stagingSessionToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.stagingSessionToken.isEmpty {
      try visitor.visitSingularStringField(value: self.stagingSessionToken, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_PutArtifactMetadata, rhs: Org_Apache_Beam_Model_JobManagement_V1_PutArtifactMetadata) -> Bool {
    if lhs.stagingSessionToken != rhs.stagingSessionToken {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_PutArtifactRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PutArtifactRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Org_Apache_Beam_Model_JobManagement_V1_PutArtifactMetadata?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .metadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .metadata(v)
        }
      }()
      case 2: try {
        var v: Org_Apache_Beam_Model_JobManagement_V1_ArtifactChunk?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .data(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .metadata?: try {
      guard case .metadata(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_PutArtifactRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_PutArtifactRequest) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_PutArtifactResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PutArtifactResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_PutArtifactResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_PutArtifactResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_CommitManifestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitManifestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manifest"),
    2: .standard(proto: "staging_session_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._manifest) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stagingSessionToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._manifest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.stagingSessionToken.isEmpty {
      try visitor.visitSingularStringField(value: self.stagingSessionToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_CommitManifestRequest, rhs: Org_Apache_Beam_Model_JobManagement_V1_CommitManifestRequest) -> Bool {
    if lhs._manifest != rhs._manifest {return false}
    if lhs.stagingSessionToken != rhs.stagingSessionToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_CommitManifestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitManifestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "retrieval_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.retrievalToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.retrievalToken.isEmpty {
      try visitor.visitSingularStringField(value: self.retrievalToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_JobManagement_V1_CommitManifestResponse, rhs: Org_Apache_Beam_Model_JobManagement_V1_CommitManifestResponse) -> Bool {
    if lhs.retrievalToken != rhs.retrievalToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_JobManagement_V1_CommitManifestResponse.Constants: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_ARTIFACTS_STAGED_TOKEN"),
  ]
}
