// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: org/apache/beam/model/fn_execution/v1/beam_fn_api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// Protocol Buffers describing the Fn API and boostrapping.
//
// TODO: Usage of plural names in lists looks awkward in Java
// e.g. getOutputsMap, addCodersBuilder
//
// TODO: gRPC / proto field names conflict with generated code
// e.g. "class" in java, "output" in python

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes transforms necessary to execute Beam over the FnAPI but are
/// implementation details rather than part of the core model.
struct Org_Apache_Beam_Model_FnExecution_V1_FnApiTransforms {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Runner: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// DataSource is a Root Transform, and a source of data for downstream
    /// transforms in the same ProcessBundleDescriptor. 
    /// It represents a stream of values coming in from an external source/over
    /// a data channel, typically from the runner. It's not the PCollection itself
    /// but a description of how to get the portion of the PCollection for a given
    /// bundle.
    ///
    /// The DataSource transform is implemented in each SDK and not explicitly
    /// provided during pipeline construction. A runner inserts the transform
    /// in ProcessBundleDescriptors to indicate where the bundle
    /// can retrieve data for an associated ProcessBundleRequest.
    /// Data for the same request will be retrieved with the matching instruction ID,
    /// and transform ID determined by the runner.
    ///
    /// The DataSource transform will take a stream of bytes from the remote
    /// source for the matching instruction ID and decode them as windowed
    /// values using the provided coder ID, which must be a windowed value coder.
    ///
    /// Payload: RemoteGrpcPort
    case dataSource // = 0

    /// DataSink is a transform that sends PCollection elements to a remote
    /// port using the Data API.
    ///
    /// The DataSink transform is implemented in each SDK and not explicitly
    /// provided during pipeline construction. A runner inserts the transform in
    /// ProcessBundleDescriptors to indicate where the bundle can send
    /// data for each associated ProcessBundleRequest. Data for the same
    /// request will be sent with the matching instruction ID and transform ID.
    /// Each PCollection that exits the ProcessBundleDescriptor subgraph will have
    /// it's own DataSink, keyed by a transform ID determined by the runner.
    ///  
    /// The DataSink will take in a stream of elements for a given instruction ID
    /// and encode them for transmission to the remote sink. The coder ID must be
    /// for a windowed value coder.
    ///
    /// Payload: RemoteGrpcPort
    case dataSink // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .dataSource
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dataSource
      case 1: self = .dataSink
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .dataSource: return 0
      case .dataSink: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Org_Apache_Beam_Model_FnExecution_V1_FnApiTransforms.Runner: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Org_Apache_Beam_Model_FnExecution_V1_FnApiTransforms.Runner] = [
    .dataSource,
    .dataSink,
  ]
}

#endif  // swift(>=4.2)

/// A descriptor for connecting to a remote port using the Beam Fn Data API.
/// Allows for communication between two environments (for example between the
/// runner and the SDK).
/// Stable
struct Org_Apache_Beam_Model_FnExecution_V1_RemoteGrpcPort {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) An API descriptor which describes where to
  /// connect to including any authentication that is required.
  var apiServiceDescriptor: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor {
    get {return _apiServiceDescriptor ?? Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor()}
    set {_apiServiceDescriptor = newValue}
  }
  /// Returns true if `apiServiceDescriptor` has been explicitly set.
  var hasApiServiceDescriptor: Bool {return self._apiServiceDescriptor != nil}
  /// Clears the value of `apiServiceDescriptor`. Subsequent reads from it will return its default value.
  mutating func clearApiServiceDescriptor() {self._apiServiceDescriptor = nil}

  /// (Required) The ID of the Coder that will be used to encode and decode data
  /// sent over this port.
  var coderID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _apiServiceDescriptor: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor? = nil
}

/// Requests the ProcessBundleDescriptor with the given id.
struct Org_Apache_Beam_Model_FnExecution_V1_GetProcessBundleDescriptorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var processBundleDescriptorID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A request sent by a runner which the SDK is asked to fulfill.
/// For any unsupported request type, an error should be returned with a
/// matching instruction id.
/// Stable
struct Org_Apache_Beam_Model_FnExecution_V1_InstructionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) A unique identifier provided by the runner which represents
  /// this requests execution. The InstructionResponse MUST have the matching id.
  var instructionID: String = String()

  /// (Required) A request that the SDK Harness needs to interpret.
  var request: Org_Apache_Beam_Model_FnExecution_V1_InstructionRequest.OneOf_Request? = nil

  var processBundle: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest {
    get {
      if case .processBundle(let v)? = request {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest()
    }
    set {request = .processBundle(newValue)}
  }

  var processBundleProgress: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressRequest {
    get {
      if case .processBundleProgress(let v)? = request {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressRequest()
    }
    set {request = .processBundleProgress(newValue)}
  }

  var processBundleSplit: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest {
    get {
      if case .processBundleSplit(let v)? = request {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest()
    }
    set {request = .processBundleSplit(newValue)}
  }

  var finalizeBundle: Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleRequest {
    get {
      if case .finalizeBundle(let v)? = request {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleRequest()
    }
    set {request = .finalizeBundle(newValue)}
  }

  var monitoringInfos: Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataRequest {
    get {
      if case .monitoringInfos(let v)? = request {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataRequest()
    }
    set {request = .monitoringInfos(newValue)}
  }

  var harnessMonitoringInfos: Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosRequest {
    get {
      if case .harnessMonitoringInfos(let v)? = request {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosRequest()
    }
    set {request = .harnessMonitoringInfos(newValue)}
  }

  var sampleData: Org_Apache_Beam_Model_FnExecution_V1_SampleDataRequest {
    get {
      if case .sampleData(let v)? = request {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_SampleDataRequest()
    }
    set {request = .sampleData(newValue)}
  }

  /// DEPRECATED
  var register: Org_Apache_Beam_Model_FnExecution_V1_RegisterRequest {
    get {
      if case .register(let v)? = request {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_RegisterRequest()
    }
    set {request = .register(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// (Required) A request that the SDK Harness needs to interpret.
  enum OneOf_Request: Equatable {
    case processBundle(Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest)
    case processBundleProgress(Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressRequest)
    case processBundleSplit(Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest)
    case finalizeBundle(Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleRequest)
    case monitoringInfos(Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataRequest)
    case harnessMonitoringInfos(Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosRequest)
    case sampleData(Org_Apache_Beam_Model_FnExecution_V1_SampleDataRequest)
    /// DEPRECATED
    case register(Org_Apache_Beam_Model_FnExecution_V1_RegisterRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_InstructionRequest.OneOf_Request, rhs: Org_Apache_Beam_Model_FnExecution_V1_InstructionRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.processBundle, .processBundle): return {
        guard case .processBundle(let l) = lhs, case .processBundle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.processBundleProgress, .processBundleProgress): return {
        guard case .processBundleProgress(let l) = lhs, case .processBundleProgress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.processBundleSplit, .processBundleSplit): return {
        guard case .processBundleSplit(let l) = lhs, case .processBundleSplit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.finalizeBundle, .finalizeBundle): return {
        guard case .finalizeBundle(let l) = lhs, case .finalizeBundle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.monitoringInfos, .monitoringInfos): return {
        guard case .monitoringInfos(let l) = lhs, case .monitoringInfos(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.harnessMonitoringInfos, .harnessMonitoringInfos): return {
        guard case .harnessMonitoringInfos(let l) = lhs, case .harnessMonitoringInfos(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sampleData, .sampleData): return {
        guard case .sampleData(let l) = lhs, case .sampleData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.register, .register): return {
        guard case .register(let l) = lhs, case .register(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// The response for an associated request the SDK had been asked to fulfill.
/// Stable
struct Org_Apache_Beam_Model_FnExecution_V1_InstructionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) A reference provided by the runner which represents a requests
  /// execution. The InstructionResponse MUST have the matching id when
  /// responding to the runner.
  var instructionID: String = String()

  /// If this is specified, then this instruction has failed.
  /// A human readable string representing the reason as to why processing has
  /// failed.
  var error: String = String()

  /// If the instruction did not fail, it is required to return an equivalent
  /// response type depending on the request this matches.
  var response: Org_Apache_Beam_Model_FnExecution_V1_InstructionResponse.OneOf_Response? = nil

  var processBundle: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleResponse {
    get {
      if case .processBundle(let v)? = response {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleResponse()
    }
    set {response = .processBundle(newValue)}
  }

  var processBundleProgress: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressResponse {
    get {
      if case .processBundleProgress(let v)? = response {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressResponse()
    }
    set {response = .processBundleProgress(newValue)}
  }

  var processBundleSplit: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse {
    get {
      if case .processBundleSplit(let v)? = response {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse()
    }
    set {response = .processBundleSplit(newValue)}
  }

  var finalizeBundle: Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleResponse {
    get {
      if case .finalizeBundle(let v)? = response {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleResponse()
    }
    set {response = .finalizeBundle(newValue)}
  }

  var monitoringInfos: Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataResponse {
    get {
      if case .monitoringInfos(let v)? = response {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataResponse()
    }
    set {response = .monitoringInfos(newValue)}
  }

  var harnessMonitoringInfos: Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosResponse {
    get {
      if case .harnessMonitoringInfos(let v)? = response {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosResponse()
    }
    set {response = .harnessMonitoringInfos(newValue)}
  }

  var sampleData: Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse {
    get {
      if case .sampleData(let v)? = response {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse()
    }
    set {response = .sampleData(newValue)}
  }

  /// DEPRECATED
  var register: Org_Apache_Beam_Model_FnExecution_V1_RegisterResponse {
    get {
      if case .register(let v)? = response {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_RegisterResponse()
    }
    set {response = .register(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If the instruction did not fail, it is required to return an equivalent
  /// response type depending on the request this matches.
  enum OneOf_Response: Equatable {
    case processBundle(Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleResponse)
    case processBundleProgress(Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressResponse)
    case processBundleSplit(Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse)
    case finalizeBundle(Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleResponse)
    case monitoringInfos(Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataResponse)
    case harnessMonitoringInfos(Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosResponse)
    case sampleData(Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse)
    /// DEPRECATED
    case register(Org_Apache_Beam_Model_FnExecution_V1_RegisterResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_InstructionResponse.OneOf_Response, rhs: Org_Apache_Beam_Model_FnExecution_V1_InstructionResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.processBundle, .processBundle): return {
        guard case .processBundle(let l) = lhs, case .processBundle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.processBundleProgress, .processBundleProgress): return {
        guard case .processBundleProgress(let l) = lhs, case .processBundleProgress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.processBundleSplit, .processBundleSplit): return {
        guard case .processBundleSplit(let l) = lhs, case .processBundleSplit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.finalizeBundle, .finalizeBundle): return {
        guard case .finalizeBundle(let l) = lhs, case .finalizeBundle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.monitoringInfos, .monitoringInfos): return {
        guard case .monitoringInfos(let l) = lhs, case .monitoringInfos(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.harnessMonitoringInfos, .harnessMonitoringInfos): return {
        guard case .harnessMonitoringInfos(let l) = lhs, case .harnessMonitoringInfos(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sampleData, .sampleData): return {
        guard case .sampleData(let l) = lhs, case .sampleData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.register, .register): return {
        guard case .register(let l) = lhs, case .register(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// If supported, the `SampleDataRequest` will respond with a
/// `SampleDataResponse`. The SDK being queried must have the
/// "beam:protocol:data_sampling:v1" capability. Samples are taken only from the
/// specified PCollection ids. An empty list will return everything.
struct Org_Apache_Beam_Model_FnExecution_V1_SampleDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Optional) The PCollection ids to filter for.
  var pcollectionIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An element sampled when the SDK is processing a bundle. This is a proto
/// message to allow for additional per-element metadata.
struct Org_Apache_Beam_Model_FnExecution_V1_SampledElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) Sampled raw bytes for an element. This is a
  /// single encoded element in the nested context.
  var element: Data = Data()

  /// (Required) Timestamp of when the sample was taken.
  var sampleTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _sampleTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_sampleTimestamp = newValue}
  }
  /// Returns true if `sampleTimestamp` has been explicitly set.
  var hasSampleTimestamp: Bool {return self._sampleTimestamp != nil}
  /// Clears the value of `sampleTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearSampleTimestamp() {self._sampleTimestamp = nil}

  /// (Optional) This will be set if this element was sampled because of a user
  /// exception.
  var exception: Org_Apache_Beam_Model_FnExecution_V1_SampledElement.Exception {
    get {return _exception ?? Org_Apache_Beam_Model_FnExecution_V1_SampledElement.Exception()}
    set {_exception = newValue}
  }
  /// Returns true if `exception` has been explicitly set.
  var hasException: Bool {return self._exception != nil}
  /// Clears the value of `exception`. Subsequent reads from it will return its default value.
  mutating func clearException() {self._exception = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Exception {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) The instruction ID of the associated ProcessBundleRequest.
    var instructionID: String = String()

    /// (Required) The transform ID of the executing PTransform during the
    /// exception.
    var transformID: String = String()

    /// (Required) The error message to be displayed to the user. Can use the
    /// other fields to query for contextual logs.
    var error: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _sampleTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _exception: Org_Apache_Beam_Model_FnExecution_V1_SampledElement.Exception? = nil
}

/// If supported, the `SampleDataResponse` will contain samples from PCollections
/// based upon the filters specified in the request.
struct Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map from PCollection id to sampled elements.
  var elementSamples: Dictionary<String,Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse.ElementList> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ElementList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The individual elements sampled from a PCollection.
    var elements: [Org_Apache_Beam_Model_FnExecution_V1_SampledElement] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// A request to provide full MonitoringInfo associated with the entire SDK
/// harness process, not specific to a bundle.
///
/// An SDK can report metrics using an identifier that only contains the
/// associated payload. A runner who wants to receive the full metrics
/// information can request all the monitoring metadata via a
/// MonitoringInfosMetadataRequest providing a list of ids as necessary.
///
/// The SDK is allowed to reuse the identifiers
/// for the lifetime of the associated control connection as long
/// as the MonitoringInfo could be reconstructed fully by overwriting its
/// payload field with the bytes specified here.
struct Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An identifier to MonitoringInfo.payload mapping containing
  /// Metrics associated with the SDK harness, not a specific bundle.
  ///
  /// An SDK can report metrics using an identifier that only contains the
  /// associated payload. A runner who wants to receive the full metrics
  /// information can request all the monitoring metadata via a
  /// MonitoringInfosMetadataRequest providing a list of ids as necessary.
  ///
  /// The SDK is allowed to reuse the identifiers
  /// for the lifetime of the associated control connection as long
  /// as the MonitoringInfo could be reconstructed fully by overwriting its
  /// payload field with the bytes specified here.
  var monitoringData: Dictionary<String,Data> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A list of objects which can be referred to by the runner in
/// future requests.
/// Stable
struct Org_Apache_Beam_Model_FnExecution_V1_RegisterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Optional) The set of descriptors used to process bundles.
  var processBundleDescriptor: [Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Stable
struct Org_Apache_Beam_Model_FnExecution_V1_RegisterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Definitions that should be used to construct the bundle processing graph.
struct Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) A pipeline level unique id which can be used as a reference to
  /// refer to this.
  var id: String = String()

  /// (Required) A map from pipeline-scoped id to PTransform.
  var transforms: Dictionary<String,Org_Apache_Beam_Model_Pipeline_V1_PTransform> = [:]

  /// (Required) A map from pipeline-scoped id to PCollection.
  var pcollections: Dictionary<String,Org_Apache_Beam_Model_Pipeline_V1_PCollection> = [:]

  /// (Required) A map from pipeline-scoped id to WindowingStrategy.
  var windowingStrategies: Dictionary<String,Org_Apache_Beam_Model_Pipeline_V1_WindowingStrategy> = [:]

  /// (Required) A map from pipeline-scoped id to Coder.
  var coders: Dictionary<String,Org_Apache_Beam_Model_Pipeline_V1_Coder> = [:]

  /// (Required) A map from pipeline-scoped id to Environment.
  var environments: Dictionary<String,Org_Apache_Beam_Model_Pipeline_V1_Environment> = [:]

  /// A descriptor describing the end point to use for State API
  /// calls. Required if the Runner intends to send remote references over the
  /// data plane or if any of the transforms rely on user state or side inputs.
  var stateApiServiceDescriptor: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor {
    get {return _stateApiServiceDescriptor ?? Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor()}
    set {_stateApiServiceDescriptor = newValue}
  }
  /// Returns true if `stateApiServiceDescriptor` has been explicitly set.
  var hasStateApiServiceDescriptor: Bool {return self._stateApiServiceDescriptor != nil}
  /// Clears the value of `stateApiServiceDescriptor`. Subsequent reads from it will return its default value.
  mutating func clearStateApiServiceDescriptor() {self._stateApiServiceDescriptor = nil}

  /// A descriptor describing the end point to use for Data API for user timers.
  /// Required if the ProcessBundleDescriptor contains any transforms that have user timers.
  var timerApiServiceDescriptor: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor {
    get {return _timerApiServiceDescriptor ?? Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor()}
    set {_timerApiServiceDescriptor = newValue}
  }
  /// Returns true if `timerApiServiceDescriptor` has been explicitly set.
  var hasTimerApiServiceDescriptor: Bool {return self._timerApiServiceDescriptor != nil}
  /// Clears the value of `timerApiServiceDescriptor`. Subsequent reads from it will return its default value.
  mutating func clearTimerApiServiceDescriptor() {self._timerApiServiceDescriptor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stateApiServiceDescriptor: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor? = nil
  fileprivate var _timerApiServiceDescriptor: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor? = nil
}

/// One of the applications specifying the scope of work for a bundle.
/// See
/// https://docs.google.com/document/d/1tUDb45sStdR8u7-jBkGdw3OGFK7aa2-V7eo86zYSE_4/edit#heading=h.9g3g5weg2u9
/// for further details.
struct Org_Apache_Beam_Model_FnExecution_V1_BundleApplication {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) The transform to which to pass the element
  var transformID: String = String()

  /// (Required) Name of the transform's input to which to pass the element.
  var inputID: String = String()

  /// (Required) The encoded element to pass to the transform.
  var element: Data = Data()

  /// The map is keyed by the local output name of the PTransform. Each
  /// value represents a lower bound on the timestamps of elements that
  /// are produced by this PTransform into each of its output PCollections
  /// when invoked with this application.
  ///
  /// If there is no watermark reported from RestrictionTracker, the runner will
  /// use MIN_TIMESTAMP by default.
  var outputWatermarks: Dictionary<String,SwiftProtobuf.Google_Protobuf_Timestamp> = [:]

  /// Whether this application potentially produces an unbounded
  /// amount of data. Note that this should only be set to BOUNDED if and
  /// only if the application is known to produce a finite amount of output.
  var isBounded: Org_Apache_Beam_Model_Pipeline_V1_IsBounded.Enum = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An Application should be scheduled for execution after a delay.
/// Either an absolute timestamp or a relative timestamp can represent a
/// scheduled execution time.
struct Org_Apache_Beam_Model_FnExecution_V1_DelayedBundleApplication {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) The application that should be scheduled.
  var application: Org_Apache_Beam_Model_FnExecution_V1_BundleApplication {
    get {return _application ?? Org_Apache_Beam_Model_FnExecution_V1_BundleApplication()}
    set {_application = newValue}
  }
  /// Returns true if `application` has been explicitly set.
  var hasApplication: Bool {return self._application != nil}
  /// Clears the value of `application`. Subsequent reads from it will return its default value.
  mutating func clearApplication() {self._application = nil}

  /// Recommended time delay at which the application should be scheduled to
  /// execute by the runner. Time delay that equals 0 may be scheduled to execute
  /// immediately. The unit of time delay should be microsecond.
  var requestedTimeDelay: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _requestedTimeDelay ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_requestedTimeDelay = newValue}
  }
  /// Returns true if `requestedTimeDelay` has been explicitly set.
  var hasRequestedTimeDelay: Bool {return self._requestedTimeDelay != nil}
  /// Clears the value of `requestedTimeDelay`. Subsequent reads from it will return its default value.
  mutating func clearRequestedTimeDelay() {self._requestedTimeDelay = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _application: Org_Apache_Beam_Model_FnExecution_V1_BundleApplication? = nil
  fileprivate var _requestedTimeDelay: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// A request to process a given bundle.
/// Stable
struct Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) A reference to the process bundle descriptor that must be
  /// instantiated and executed by the SDK harness.
  var processBundleDescriptorID: String = String()

  /// (Optional) A list of cache tokens that can be used by an SDK to reuse
  /// cached data returned by the State API across multiple bundles.
  ///
  /// Note that SDKs that can efficiently consume this field should declare
  /// the beam:protocol:state_caching:v1 capability enabling runners to reduce
  /// the amount of memory used.
  ///
  /// See https://s.apache.org/beam-fn-state-api-and-bundle-processing#heading=h.7ghoih5aig5m
  /// for additional details on how to use the cache token with the State API
  /// to cache data across bundle boundaries.
  var cacheTokens: [Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken] = []

  /// (Optional) Elements to be processed with the bundle. Either all or
  /// none of the bundle elements should be included in the ProcessBundleRequest.
  /// This embedding is to achieve better efficiency for bundles that contain
  /// only small amounts of data and are cheap to be processed on the SDK harness
  /// side. This field can be set only if the SDK declares that it supports the
  /// beam:protocol:control_request_elements_embedding:v1 capability. See more
  /// at https://s.apache.org/beam-fn-api-control-data-embedding.
  var elements: Org_Apache_Beam_Model_FnExecution_V1_Elements {
    get {return _elements ?? Org_Apache_Beam_Model_FnExecution_V1_Elements()}
    set {_elements = newValue}
  }
  /// Returns true if `elements` has been explicitly set.
  var hasElements: Bool {return self._elements != nil}
  /// Clears the value of `elements`. Subsequent reads from it will return its default value.
  mutating func clearElements() {self._elements = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Contains the cache token and also defines the scope of what the token applies to.
  ///
  /// See https://s.apache.org/beam-fn-state-api-and-bundle-processing#heading=h.7ghoih5aig5m
  /// for additional details on how to use the cache token with the State API
  /// to cache data across bundle boundaries.
  struct CacheToken {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The scope of a cache token.
    var type: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.OneOf_Type? = nil

    var userState: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.UserState {
      get {
        if case .userState(let v)? = type {return v}
        return Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.UserState()
      }
      set {type = .userState(newValue)}
    }

    var sideInput: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.SideInput {
      get {
        if case .sideInput(let v)? = type {return v}
        return Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.SideInput()
      }
      set {type = .sideInput(newValue)}
    }

    /// An opaque token used with the StateKey to create a globally unique
    /// identifier.
    var token: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The scope of a cache token.
    enum OneOf_Type: Equatable {
      case userState(Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.UserState)
      case sideInput(Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.SideInput)

    #if !swift(>=4.1)
      static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.OneOf_Type, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.OneOf_Type) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.userState, .userState): return {
          guard case .userState(let l) = lhs, case .userState(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.sideInput, .sideInput): return {
          guard case .sideInput(let l) = lhs, case .sideInput(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// A flag to indicate a cache token is valid for all user state.
    struct UserState {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    /// A flag to indicate a cache token is valid for a side input.
    struct SideInput {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// (Required) The id of the PTransform containing a side input.
      var transformID: String = String()

      /// (Required) The id of the side input.
      var sideInputID: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _elements: Org_Apache_Beam_Model_FnExecution_V1_Elements? = nil
}

struct Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Optional) Specifies that the bundle has not been completed and the
  /// following applications need to be scheduled and executed in the future.
  /// A runner that does not yet support residual roots MUST still check that
  /// this is empty for correctness.
  ///
  /// Note that these residual roots must not have been returned as part of a
  /// prior split for this bundle.
  var residualRoots: [Org_Apache_Beam_Model_FnExecution_V1_DelayedBundleApplication] = []

  /// DEPRECATED (Required) The list of metrics or other MonitoredState
  /// collected while processing this bundle.
  var monitoringInfos: [Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo] = []

  /// (Optional) Specifies that the runner must callback to this worker
  /// once the output of the bundle is committed. The Runner must send a
  /// FinalizeBundleRequest with the instruction id of the ProcessBundleRequest
  /// that is related to this ProcessBundleResponse.
  var requiresFinalization: Bool = false

  /// An identifier to MonitoringInfo.payload mapping.
  ///
  /// An SDK can report metrics using an identifier that only contains the
  /// associated payload. A runner who wants to receive the full metrics
  /// information can request all the monitoring metadata via a
  /// MonitoringInfosMetadataRequest providing a list of ids as necessary.
  ///
  /// The SDK is allowed to reuse the identifiers across multiple bundles as long
  /// as the MonitoringInfo could be reconstructed fully by overwriting its
  /// payload field with the bytes specified here.
  var monitoringData: Dictionary<String,Data> = [:]

  /// (Optional) Output elements of the processed bundle. Either all or
  /// none of the bundle elements should be included in the ProcessBundleResponse.
  /// This embedding is to achieve better efficiency for bundles that only
  /// contain small amounts of data. his field can be set only if the runner
  /// declares that it supports the
  /// beam:protocol:control_request_elements_embedding:v1 capability. See more at
  /// https://s.apache.org/beam-fn-api-control-data-embedding.
  var elements: Org_Apache_Beam_Model_FnExecution_V1_Elements {
    get {return _elements ?? Org_Apache_Beam_Model_FnExecution_V1_Elements()}
    set {_elements = newValue}
  }
  /// Returns true if `elements` has been explicitly set.
  var hasElements: Bool {return self._elements != nil}
  /// Clears the value of `elements`. Subsequent reads from it will return its default value.
  mutating func clearElements() {self._elements = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _elements: Org_Apache_Beam_Model_FnExecution_V1_Elements? = nil
}

/// A request to report progress information for a given bundle.
/// This is an optional request to be handled and is used to support advanced
/// SDK features such as SplittableDoFn, user level metrics etc.
struct Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) A reference to an active process bundle request with the given
  /// instruction id.
  var instructionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A request to provide full MonitoringInfo for a set of provided ids.
///
/// An SDK can report metrics using an identifier that only contains the
/// associated payload. A runner who wants to receive the full metrics
/// information can request all the monitoring metadata via a
/// MonitoringInfosMetadataRequest providing a list of ids as necessary.
///
/// The SDK is allowed to reuse the identifiers for the lifetime of the
/// associated control connection as long as the MonitoringInfo could be
/// reconstructed fully by overwriting its payload field with the bytes specified
/// here.
struct Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of ids for which the full MonitoringInfo is requested for.
  var monitoringInfoID: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DEPRECATED (Required) The list of metrics or other MonitoredState
  /// collected while processing this bundle.
  var monitoringInfos: [Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo] = []

  /// An identifier to MonitoringInfo.payload mapping.
  ///
  /// An SDK can report metrics using an identifier that only contains the
  /// associated payload. A runner who wants to receive the full metrics
  /// information can request all the monitoring metadata via a
  /// MonitoringInfosMetadataRequest providing a list of ids as necessary.
  ///
  /// The SDK is allowed to reuse the identifiers
  /// for the lifetime of the associated control connection as long
  /// as the MonitoringInfo could be reconstructed fully by overwriting its
  /// payload field with the bytes specified here.
  var monitoringData: Dictionary<String,Data> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A response that contains the full mapping information associated with
/// a specified set of identifiers.
///
/// An SDK can report metrics using an identifier that only contains the
/// associated payload. A runner who wants to receive the full metrics
/// information can request all the monitoring metadata via a
/// MonitoringInfosMetadataRequest providing a list of ids as necessary.
///
/// The SDK is allowed to reuse the identifiers
/// for the lifetime of the associated control connection as long
/// as the MonitoringInfo could be reconstructed fully by overwriting its
/// payload field with the bytes specified here.
struct Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A mapping from an identifier to the full metrics information.
  var monitoringInfo: Dictionary<String,Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a request to the SDK to split a currently active bundle.
struct Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) A reference to an active process bundle request with the given
  /// instruction id.
  var instructionID: String = String()

  /// (Required) Specifies the desired split for each transform.
  ///
  /// Currently only splits at gRPC read operations are supported.
  /// This may, of course, limit the amount of work downstream operations
  /// receive.
  var desiredSplits: Dictionary<String,Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest.DesiredSplit> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A message specifying the desired split for a single transform.
  struct DesiredSplit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) The fraction of known work remaining in this bundle
    /// for this transform that should be kept by the SDK after this split.
    ///
    /// Set to 0 to "checkpoint" as soon as possible (keeping as little work as
    /// possible and returning the remainder).
    var fractionOfRemainder: Double = 0

    /// (Optional) A set of allowed element indices where the SDK may split. When
    /// this is empty, there are no constraints on where to split.
    var allowedSplitPoints: [Int64] = []

    /// (Required for gRPC Read operation transforms) Number of total elements
    /// expected to be sent to this GrpcRead operation, required to correctly
    /// account for unreceived data when determining where to split.
    var estimatedInputElements: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Represents a partition of the bundle: a "primary" and a "residual", with the
/// following properties:
/// - The work in primary and residual doesn't overlap, and combined, adds up
///   to the work in the current bundle if the split hadn't happened.
/// - The current bundle, if it keeps executing, will have done exactly none of
///   the work under residual_roots and none of the elements at and beyond the
///   first_residual_element.
/// - The current bundle, if no further splits happen, will have done exactly
///   the work under primary_roots and all elements up to and including the
///   channel split's last_primary_element.
///
/// This allows the SDK to relinquish ownership of and commit to not process some
/// of the elements that it may have been sent (the residual) while retaining
/// ownership and commitment to finish the other portion (the primary).
///
/// Example with three splits of a single bundle:
/// Let's say the SDK is processing elements [A B C D E]. These elements make
/// up the 0-indexed channel.
///
/// ** First Split **
/// Channel Split = [ A B C D <> E ]
/// Primary Roots = [] (No elements were split)
/// Residual Roots = []
///
/// Say a split request comes in. The SDK could return a response with a channel
/// split representing a last_primary_element of 3 (D) and
/// first_residual_element of 4 (E). The SDK is now responsible for processing A
/// B C D and the runner must process E in the future.
///
/// (A B C D) | (E)
///
/// ** Second Split **
/// Channel Split = [ A < B C > D E ]
/// Primary Roots = [B1 C1]
/// Residual Roots = [B2 C2]
///
/// A future split request could have the SDK split the elements B into B1 and
/// B2 and C into C1 and C2 representing their primary and residual roots. The
///
/// (A B1 C1) | (B2 C2 D)
///
/// SDK would return a response with a channel split representing a
/// last_primary_element of 0 (A) and first_residual_element of 3 (D) with
/// primary_roots (B1, C1) and residual_roots (B2, C2). The SDK is now
/// responsible for processing A B1 C1 and the runner must process B2 C2 D (and
/// E from the prior split) in the future.
///
/// ** Third Split **
/// Channel Split = [ A < B C > D E ]
/// Primary Roots = [B1a]
/// Residual Roots [B1b C1]
/// Yet another future split request could have the SDK could split B1 further
/// into B1a and B1b primary and residuals and return C1 as a residual (assuming
/// C1 was left unprocessed). The SDK would return a response with a channel
/// split representing a last_primary_element of 0 (A) and
/// first_residual_element of 3 (E) with primary_roots (B1a) and residual_roots
/// (B1b, C1). The SDK is now responsible for processing A B1a the runner must
/// process B1b C1 (in addition to C2, D, E from prior splits) in the future.
///
/// (A B1a) | (B1b C1)
///
/// For more rigorous definitions see https://s.apache.org/beam-breaking-fusion
struct Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Optional) Root applications that should replace the current bundle.
  ///
  /// Note that primary roots can only be specified if a channel split's
  /// last_primary_element + 1 < first_residual_element
  ///
  /// Note that there must be a corresponding residual root contained within
  /// residual_roots representing the remainder of processing for the original
  /// element this this primary root represents a fraction of.
  var primaryRoots: [Org_Apache_Beam_Model_FnExecution_V1_BundleApplication] = []

  /// (Optional) Root applications that have been removed from the current bundle and
  /// have to be executed in a separate bundle (e.g. in parallel on a different
  /// worker, or after the current bundle completes, etc.)
  ///
  /// Note that residual roots can only be specified if a channel split's
  /// last_primary_element + 1 < first_residual_element
  ///
  /// Note that there must be a corresponding primary root contained within
  /// primary_roots representing the remainder of processing for the original
  /// element this this residual root represents a fraction of.
  ///
  /// Note that subsequent splits must not return prior residual roots.
  var residualRoots: [Org_Apache_Beam_Model_FnExecution_V1_DelayedBundleApplication] = []

  /// (Required) Partitions of input data channels into primary and residual
  /// elements, if any. Must not include any elements represented in the bundle
  /// applications roots above of the current split or any prior split of the
  /// same bundle.
  var channelSplits: [Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse.ChannelSplit] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents contiguous portions of the data channel that are either
  /// entirely processed or entirely unprocessed and belong to the primary
  /// or residual respectively.
  ///
  /// This affords both a more efficient representation over the FnAPI
  /// (if the bundle is large) and often a more efficient representation
  /// on the runner side (e.g. if the set of elements can be represented
  /// as some range in an underlying dataset).
  ///
  /// Note that for a split the following properties must hold:
  /// - last_primary_element < first_residual_element
  /// - primary roots and residual roots can only be specified if the
  ///   last_primary_element + 1 < first_residual_element
  ///   (typically there is one primary and residual root per element in the
  ///   range (last_primary_element, first_residual_element))
  /// - primary roots and residual roots must represent a disjoint but full
  ///   coverage of work represented by the elements between last_primary_element
  ///   and first_residual_element
  ///
  /// Note that subsequent splits of the same bundle must ensure that:
  /// - the first_residual_element does not increase
  /// - the first_residual_element does not decrease if there were residual
  ///   or primary roots returned in a prior split.
  struct ChannelSplit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) The grpc read transform reading this channel.
    var transformID: String = String()

    /// (Required) The last element of the input channel that should be entirely
    /// considered part of the primary, identified by its absolute zero-based
    /// index in the (ordered) channel.
    var lastPrimaryElement: Int64 = 0

    /// (Required) The first element of the input channel that should be entirely
    /// considered part of the residual, identified by its absolute zero-based
    /// index in the (ordered) channel.
    var firstResidualElement: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) A reference to a completed process bundle request with the given
  /// instruction id.
  var instructionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Empty
struct Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Messages used to represent logical byte streams.
/// Stable
struct Org_Apache_Beam_Model_FnExecution_V1_Elements {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Optional) A list containing parts of logical byte streams.
  var data: [Org_Apache_Beam_Model_FnExecution_V1_Elements.DataMessage] = []

  /// (Optional)  A list of timer byte streams.
  var timers: [Org_Apache_Beam_Model_FnExecution_V1_Elements.Timers] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents multiple encoded elements in nested context for a given named
  /// instruction and transform.
  struct DataMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) A reference to an active instruction request with the given
    /// instruction id.
    var instructionID: String = String()

    /// (Required) A definition representing a consumer or producer of this data.
    /// If received by a harness, this represents the consumer within that
    /// harness that should consume these bytes. If sent by a harness, this
    /// represents the producer of these bytes.
    ///
    /// Note that a single element may span multiple Data messages.
    ///
    /// Note that a sending/receiving pair should share the same identifier.
    var transformID: String = String()

    /// (Optional) Represents a part of a logical byte stream. Elements within
    /// the logical byte stream are encoded in the nested context and
    /// concatenated together.
    var data: Data = Data()

    /// (Optional) Set this bit to indicate the this is the last data block
    /// for the given instruction and transform, ending the stream.
    var isLast: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Represent the encoded user timer for a given instruction, transform and
  /// timer id.
  struct Timers {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) A reference to an active instruction request with the given
    /// instruction id.
    var instructionID: String = String()

    /// (Required) A definition representing a consumer or producer of this data.
    /// If received by a harness, this represents the consumer within that
    /// harness that should consume these timers. If sent by a harness, this
    /// represents the producer of these timers.
    var transformID: String = String()

    /// (Required) The local timer family name used to identify the associated
    /// timer family specification
    var timerFamilyID: String = String()

    /// (Optional) Represents a logical byte stream of timers. Encoded according
    /// to the coder in the timer spec.
    var timers: Data = Data()

    /// (Optional) Set this bit to indicate the this is the last data block
    /// for the given instruction and transform, ending the stream.
    var isLast: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Org_Apache_Beam_Model_FnExecution_V1_StateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) A unique identifier provided by the SDK which represents this
  /// requests execution. The StateResponse corresponding with this request
  /// will have the matching id.
  var id: String = String()

  /// (Required) The associated instruction id of the work that is currently
  /// being processed. This allows for the runner to associate any modifications
  /// to state to be committed with the appropriate work execution.
  var instructionID: String = String()

  /// (Required) The state key this request is for.
  var stateKey: Org_Apache_Beam_Model_FnExecution_V1_StateKey {
    get {return _stateKey ?? Org_Apache_Beam_Model_FnExecution_V1_StateKey()}
    set {_stateKey = newValue}
  }
  /// Returns true if `stateKey` has been explicitly set.
  var hasStateKey: Bool {return self._stateKey != nil}
  /// Clears the value of `stateKey`. Subsequent reads from it will return its default value.
  mutating func clearStateKey() {self._stateKey = nil}

  /// (Required) The action to take on this request.
  var request: Org_Apache_Beam_Model_FnExecution_V1_StateRequest.OneOf_Request? = nil

  /// A request to get state.
  var get: Org_Apache_Beam_Model_FnExecution_V1_StateGetRequest {
    get {
      if case .get(let v)? = request {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateGetRequest()
    }
    set {request = .get(newValue)}
  }

  /// A request to append to state.
  var append: Org_Apache_Beam_Model_FnExecution_V1_StateAppendRequest {
    get {
      if case .append(let v)? = request {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateAppendRequest()
    }
    set {request = .append(newValue)}
  }

  /// A request to clear state.
  var clear: Org_Apache_Beam_Model_FnExecution_V1_StateClearRequest {
    get {
      if case .clear(let v)? = request {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateClearRequest()
    }
    set {request = .clear(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// (Required) The action to take on this request.
  enum OneOf_Request: Equatable {
    /// A request to get state.
    case get(Org_Apache_Beam_Model_FnExecution_V1_StateGetRequest)
    /// A request to append to state.
    case append(Org_Apache_Beam_Model_FnExecution_V1_StateAppendRequest)
    /// A request to clear state.
    case clear(Org_Apache_Beam_Model_FnExecution_V1_StateClearRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateRequest.OneOf_Request, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.get, .get): return {
        guard case .get(let l) = lhs, case .get(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.append, .append): return {
        guard case .append(let l) = lhs, case .append(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clear, .clear): return {
        guard case .clear(let l) = lhs, case .clear(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _stateKey: Org_Apache_Beam_Model_FnExecution_V1_StateKey? = nil
}

struct Org_Apache_Beam_Model_FnExecution_V1_StateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) A reference provided by the SDK which represents a requests
  /// execution. The StateResponse must have the matching id when responding
  /// to the SDK.
  var id: String = String()

  /// (Optional) If this is specified, then the state request has failed.
  /// A human readable string representing the reason as to why the request
  /// failed.
  var error: String = String()

  /// A corresponding response matching the request will be populated.
  var response: Org_Apache_Beam_Model_FnExecution_V1_StateResponse.OneOf_Response? = nil

  /// A response to getting state.
  var get: Org_Apache_Beam_Model_FnExecution_V1_StateGetResponse {
    get {
      if case .get(let v)? = response {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateGetResponse()
    }
    set {response = .get(newValue)}
  }

  /// A response to appending to state.
  var append: Org_Apache_Beam_Model_FnExecution_V1_StateAppendResponse {
    get {
      if case .append(let v)? = response {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateAppendResponse()
    }
    set {response = .append(newValue)}
  }

  /// A response to clearing state.
  var clear: Org_Apache_Beam_Model_FnExecution_V1_StateClearResponse {
    get {
      if case .clear(let v)? = response {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateClearResponse()
    }
    set {response = .clear(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A corresponding response matching the request will be populated.
  enum OneOf_Response: Equatable {
    /// A response to getting state.
    case get(Org_Apache_Beam_Model_FnExecution_V1_StateGetResponse)
    /// A response to appending to state.
    case append(Org_Apache_Beam_Model_FnExecution_V1_StateAppendResponse)
    /// A response to clearing state.
    case clear(Org_Apache_Beam_Model_FnExecution_V1_StateClearResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateResponse.OneOf_Response, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.get, .get): return {
        guard case .get(let l) = lhs, case .get(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.append, .append): return {
        guard case .append(let l) = lhs, case .append(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clear, .clear): return {
        guard case .clear(let l) = lhs, case .clear(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Org_Apache_Beam_Model_FnExecution_V1_StateKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) One of the following state keys must be set.
  var type: Org_Apache_Beam_Model_FnExecution_V1_StateKey.OneOf_Type? = nil

  var runner: Org_Apache_Beam_Model_FnExecution_V1_StateKey.Runner {
    get {
      if case .runner(let v)? = type {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateKey.Runner()
    }
    set {type = .runner(newValue)}
  }

  var multimapSideInput: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapSideInput {
    get {
      if case .multimapSideInput(let v)? = type {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapSideInput()
    }
    set {type = .multimapSideInput(newValue)}
  }

  var bagUserState: Org_Apache_Beam_Model_FnExecution_V1_StateKey.BagUserState {
    get {
      if case .bagUserState(let v)? = type {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateKey.BagUserState()
    }
    set {type = .bagUserState(newValue)}
  }

  var iterableSideInput: Org_Apache_Beam_Model_FnExecution_V1_StateKey.IterableSideInput {
    get {
      if case .iterableSideInput(let v)? = type {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateKey.IterableSideInput()
    }
    set {type = .iterableSideInput(newValue)}
  }

  var multimapKeysSideInput: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysSideInput {
    get {
      if case .multimapKeysSideInput(let v)? = type {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysSideInput()
    }
    set {type = .multimapKeysSideInput(newValue)}
  }

  var multimapKeysUserState: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysUserState {
    get {
      if case .multimapKeysUserState(let v)? = type {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysUserState()
    }
    set {type = .multimapKeysUserState(newValue)}
  }

  var multimapUserState: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapUserState {
    get {
      if case .multimapUserState(let v)? = type {return v}
      return Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapUserState()
    }
    set {type = .multimapUserState(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// (Required) One of the following state keys must be set.
  enum OneOf_Type: Equatable {
    case runner(Org_Apache_Beam_Model_FnExecution_V1_StateKey.Runner)
    case multimapSideInput(Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapSideInput)
    case bagUserState(Org_Apache_Beam_Model_FnExecution_V1_StateKey.BagUserState)
    case iterableSideInput(Org_Apache_Beam_Model_FnExecution_V1_StateKey.IterableSideInput)
    case multimapKeysSideInput(Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysSideInput)
    case multimapKeysUserState(Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysUserState)
    case multimapUserState(Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapUserState)

  #if !swift(>=4.1)
    static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.OneOf_Type, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.runner, .runner): return {
        guard case .runner(let l) = lhs, case .runner(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multimapSideInput, .multimapSideInput): return {
        guard case .multimapSideInput(let l) = lhs, case .multimapSideInput(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bagUserState, .bagUserState): return {
        guard case .bagUserState(let l) = lhs, case .bagUserState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iterableSideInput, .iterableSideInput): return {
        guard case .iterableSideInput(let l) = lhs, case .iterableSideInput(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multimapKeysSideInput, .multimapKeysSideInput): return {
        guard case .multimapKeysSideInput(let l) = lhs, case .multimapKeysSideInput(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multimapKeysUserState, .multimapKeysUserState): return {
        guard case .multimapKeysUserState(let l) = lhs, case .multimapKeysUserState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multimapUserState, .multimapUserState): return {
        guard case .multimapUserState(let l) = lhs, case .multimapUserState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Runner {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) Opaque information supplied by the runner. Used to support
    /// remote references.
    /// https://s.apache.org/beam-fn-api-send-and-receive-data
    ///
    /// Used by state backed iterable. And in this use case, request type can
    /// only be of type get. Details see:
    /// https://s.apache.org/beam-fn-api-state-backed-iterables
    var key: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Represents a request for the values associated with a specified window
  /// in a PCollection. See
  /// https://s.apache.org/beam-fn-state-api-and-bundle-processing for further
  /// details.
  ///
  /// Can only be used to perform StateGetRequests on side inputs of the URN
  /// beam:side_input:iterable:v1.
  ///
  /// For a PCollection<V>, the response data stream will be a concatenation
  /// of all V's. See https://s.apache.org/beam-fn-api-send-and-receive-data
  /// for further details.
  struct IterableSideInput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) The id of the PTransform containing a side input.
    var transformID: String = String()

    /// (Required) The id of the side input.
    var sideInputID: String = String()

    /// (Required) The window (after mapping the currently executing elements
    /// window into the side input windows domain) encoded in a nested context.
    var window: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Represents a request for the values associated with a specified user key
  /// and window in a PCollection. See
  /// https://s.apache.org/beam-fn-state-api-and-bundle-processing for further
  /// details.
  ///
  /// Can only be used to perform StateGetRequests on side inputs of the URN
  /// beam:side_input:multimap:v1.
  ///
  /// For a PCollection<KV<K, V>>, the response data stream will be a
  /// concatenation of all V's associated with the specified key K. See
  /// https://s.apache.org/beam-fn-api-send-and-receive-data for further
  /// details.
  struct MultimapSideInput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) The id of the PTransform containing a side input.
    var transformID: String = String()

    /// (Required) The id of the side input.
    var sideInputID: String = String()

    /// (Required) The window (after mapping the currently executing elements
    /// window into the side input windows domain) encoded in a nested context.
    var window: Data = Data()

    /// (Required) The key encoded in a nested context.
    var key: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Represents a request for the keys associated with a specified window in a PCollection. See
  /// https://s.apache.org/beam-fn-state-api-and-bundle-processing for further
  /// details.
  ///
  /// Can only be used to perform StateGetRequests on side inputs of the URN
  /// beam:side_input:multimap:v1.
  ///
  /// For a PCollection<KV<K, V>>, the response data stream will be a
  /// concatenation of all K's associated with the specified window. See
  /// https://s.apache.org/beam-fn-api-send-and-receive-data for further
  /// details.
  struct MultimapKeysSideInput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) The id of the PTransform containing a side input.
    var transformID: String = String()

    /// (Required) The id of the side input.
    var sideInputID: String = String()

    /// (Required) The window (after mapping the currently executing elements
    /// window into the side input windows domain) encoded in a nested context.
    var window: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Represents a request for an unordered set of values associated with a
  /// specified user key and window for a PTransform. See
  /// https://s.apache.org/beam-fn-state-api-and-bundle-processing for further
  /// details.
  ///
  /// The response data stream will be a concatenation of all V's associated
  /// with the specified user key and window.
  /// See https://s.apache.org/beam-fn-api-send-and-receive-data for further
  /// details.
  struct BagUserState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) The id of the PTransform containing user state.
    var transformID: String = String()

    /// (Required) The id of the user state.
    var userStateID: String = String()

    /// (Required) The window encoded in a nested context.
    var window: Data = Data()

    /// (Required) The key of the currently executing element encoded in a
    /// nested context.
    var key: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Represents a request for the keys of a multimap associated with a specified
  /// user key and window for a PTransform. See
  /// https://s.apache.org/beam-fn-state-api-and-bundle-processing for further
  /// details.
  ///
  /// Can only be used to perform StateGetRequests and StateClearRequests on the
  /// user state.
  ///
  /// The response data stream will be a concatenation of all K's associated
  /// with the specified user key and window.
  /// See https://s.apache.org/beam-fn-api-send-and-receive-data for further
  /// details.
  struct MultimapKeysUserState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) The id of the PTransform containing user state.
    var transformID: String = String()

    /// (Required) The id of the user state.
    var userStateID: String = String()

    /// (Required) The window encoded in a nested context.
    var window: Data = Data()

    /// (Required) The key of the currently executing element encoded in a
    /// nested context.
    var key: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Represents a request for the values of the map key associated with a
  /// specified user key and window for a PTransform. See
  /// https://s.apache.org/beam-fn-state-api-and-bundle-processing for further
  /// details.
  ///
  /// The response data stream will be a concatenation of all V's associated
  /// with the specified map key, user key, and window.
  /// See https://s.apache.org/beam-fn-api-send-and-receive-data for further
  /// details.
  struct MultimapUserState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) The id of the PTransform containing user state.
    var transformID: String = String()

    /// (Required) The id of the user state.
    var userStateID: String = String()

    /// (Required) The window encoded in a nested context.
    var window: Data = Data()

    /// (Required) The key of the currently executing element encoded in a
    /// nested context.
    var key: Data = Data()

    /// (Required) The map key encoded in a nested context.
    var mapKey: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// A request to get state.
struct Org_Apache_Beam_Model_FnExecution_V1_StateGetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Optional) If specified, signals to the runner that the response
  /// should resume from the following continuation token.
  ///
  /// If unspecified, signals to the runner that the response should start
  /// from the beginning of the logical continuable stream.
  var continuationToken: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A response to get state representing a logical byte stream which can be
/// continued using the state API.
struct Org_Apache_Beam_Model_FnExecution_V1_StateGetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Optional) If specified, represents a token which can be used with the
  /// state API to get the next chunk of this logical byte stream. The end of
  /// the logical byte stream is signalled by this field being unset.
  var continuationToken: Data = Data()

  /// Represents a part of a logical byte stream. Elements within
  /// the logical byte stream are encoded in the nested context and
  /// concatenated together.
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A request to append state.
struct Org_Apache_Beam_Model_FnExecution_V1_StateAppendRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Represents a part of a logical byte stream. Elements within
  /// the logical byte stream are encoded in the nested context and
  /// multiple append requests are concatenated together.
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A response to append state.
struct Org_Apache_Beam_Model_FnExecution_V1_StateAppendResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A request to clear state.
struct Org_Apache_Beam_Model_FnExecution_V1_StateClearRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A response to clear state.
struct Org_Apache_Beam_Model_FnExecution_V1_StateClearResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A log entry
struct Org_Apache_Beam_Model_FnExecution_V1_LogEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) The severity of the log statement.
  var severity: Org_Apache_Beam_Model_FnExecution_V1_LogEntry.Severity.Enum = .unspecified

  /// (Required) The time at which this log statement occurred.
  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// (Required) A human readable message.
  var message: String = String()

  /// (Optional) An optional trace of the functions involved. For example, in
  /// Java this can include multiple causes and multiple suppressed exceptions.
  var trace: String = String()

  /// (Optional) A reference to the instruction this log statement is associated
  /// with.
  var instructionID: String = String()

  /// (Optional) A reference to the transform this log statement is
  /// associated with.
  var transformID: String = String()

  /// (Optional) Human-readable name of the function or method being invoked,
  /// with optional context such as the class or package name. The format can
  /// vary by language. For example:
  ///   qual.if.ied.Class.method (Java)
  ///   dir/package.func (Go)
  ///   module.function (Python)
  ///   file.cc:382 (C++)
  var logLocation: String = String()

  /// (Optional) The name of the thread this log statement is associated with.
  var thread: String = String()

  /// (Optional) Additional structured data to log.
  /// Keys are limited to these characters: [a-zA-Z_-]
  var customData: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _customData ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_customData = newValue}
  }
  /// Returns true if `customData` has been explicitly set.
  var hasCustomData: Bool {return self._customData != nil}
  /// Clears the value of `customData`. Subsequent reads from it will return its default value.
  mutating func clearCustomData() {self._customData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A list of log entries, enables buffering and batching of multiple
  /// log messages using the logging API.
  struct List {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (Required) One or or more log messages.
    var logEntries: [Org_Apache_Beam_Model_FnExecution_V1_LogEntry] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// The severity of the event described in a log entry, expressed as one of the
  /// severity levels listed below. For your reference, the levels are
  /// assigned the listed numeric values. The effect of using numeric values
  /// other than those listed is undefined.
  ///
  /// If you are writing log entries, you should map other severity encodings to
  /// one of these standard levels. For example, you might map all of
  /// Java's FINE, FINER, and FINEST levels to `Severity.DEBUG`.
  ///
  /// This list is intentionally not comprehensive; the intent is to provide a
  /// common set of "good enough" severity levels so that logging front ends
  /// can provide filtering and searching across log types. Users of the API are
  /// free not to use all severity levels in their log messages.
  struct Severity {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Enum: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// Unspecified level information. Will be logged at the TRACE level.
      case unspecified // = 0
      case trace // = 1

      /// Debugging information.
      case debug // = 2

      /// Normal events.
      case info // = 3

      /// Normal but significant events, such as start up, shut down, or
      /// configuration.
      case notice // = 4

      /// Warning events might cause problems.
      case warn // = 5

      /// Error events are likely to cause problems.
      case error // = 6

      /// Critical events cause severe problems or brief outages and may
      /// indicate that a person must take action.
      case critical // = 7
      case UNRECOGNIZED(Int)

      init() {
        self = .unspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .trace
        case 2: self = .debug
        case 3: self = .info
        case 4: self = .notice
        case 5: self = .warn
        case 6: self = .error
        case 7: self = .critical
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .trace: return 1
        case .debug: return 2
        case .info: return 3
        case .notice: return 4
        case .warn: return 5
        case .error: return 6
        case .critical: return 7
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _customData: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

#if swift(>=4.2)

extension Org_Apache_Beam_Model_FnExecution_V1_LogEntry.Severity.Enum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Org_Apache_Beam_Model_FnExecution_V1_LogEntry.Severity.Enum] = [
    .unspecified,
    .trace,
    .debug,
    .info,
    .notice,
    .warn,
    .error,
    .critical,
  ]
}

#endif  // swift(>=4.2)

struct Org_Apache_Beam_Model_FnExecution_V1_LogControl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_FnExecution_V1_StartWorkerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var workerID: String = String()

  var controlEndpoint: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor {
    get {return _controlEndpoint ?? Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor()}
    set {_controlEndpoint = newValue}
  }
  /// Returns true if `controlEndpoint` has been explicitly set.
  var hasControlEndpoint: Bool {return self._controlEndpoint != nil}
  /// Clears the value of `controlEndpoint`. Subsequent reads from it will return its default value.
  mutating func clearControlEndpoint() {self._controlEndpoint = nil}

  var loggingEndpoint: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor {
    get {return _loggingEndpoint ?? Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor()}
    set {_loggingEndpoint = newValue}
  }
  /// Returns true if `loggingEndpoint` has been explicitly set.
  var hasLoggingEndpoint: Bool {return self._loggingEndpoint != nil}
  /// Clears the value of `loggingEndpoint`. Subsequent reads from it will return its default value.
  mutating func clearLoggingEndpoint() {self._loggingEndpoint = nil}

  var artifactEndpoint: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor {
    get {return _artifactEndpoint ?? Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor()}
    set {_artifactEndpoint = newValue}
  }
  /// Returns true if `artifactEndpoint` has been explicitly set.
  var hasArtifactEndpoint: Bool {return self._artifactEndpoint != nil}
  /// Clears the value of `artifactEndpoint`. Subsequent reads from it will return its default value.
  mutating func clearArtifactEndpoint() {self._artifactEndpoint = nil}

  var provisionEndpoint: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor {
    get {return _provisionEndpoint ?? Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor()}
    set {_provisionEndpoint = newValue}
  }
  /// Returns true if `provisionEndpoint` has been explicitly set.
  var hasProvisionEndpoint: Bool {return self._provisionEndpoint != nil}
  /// Clears the value of `provisionEndpoint`. Subsequent reads from it will return its default value.
  mutating func clearProvisionEndpoint() {self._provisionEndpoint = nil}

  var params: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _controlEndpoint: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor? = nil
  fileprivate var _loggingEndpoint: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor? = nil
  fileprivate var _artifactEndpoint: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor? = nil
  fileprivate var _provisionEndpoint: Org_Apache_Beam_Model_Pipeline_V1_ApiServiceDescriptor? = nil
}

struct Org_Apache_Beam_Model_FnExecution_V1_StartWorkerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_FnExecution_V1_StopWorkerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var workerID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Org_Apache_Beam_Model_FnExecution_V1_StopWorkerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request from runner to SDK Harness asking for its status. For more details see
/// https://s.apache.org/beam-fn-api-harness-status
struct Org_Apache_Beam_Model_FnExecution_V1_WorkerStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) Unique ID identifying this request.
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response from SDK Harness to runner containing the debug related status info.
struct Org_Apache_Beam_Model_FnExecution_V1_WorkerStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (Required) Unique ID from the original request.
  var id: String = String()

  /// (Optional) Error message if exception encountered generating the status response.
  var error: String = String()

  /// (Optional) Status debugging info reported by SDK harness worker. Content and
  /// format is not strongly enforced but should be print-friendly and
  /// appropriate as an HTTP response body for end user. For details of the preferred
  /// info to include in the message see
  /// https://s.apache.org/beam-fn-api-harness-status
  var statusInfo: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Org_Apache_Beam_Model_FnExecution_V1_FnApiTransforms: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_FnApiTransforms.Runner: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_RemoteGrpcPort: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_GetProcessBundleDescriptorRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_InstructionRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_InstructionRequest.OneOf_Request: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_InstructionResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_InstructionResponse.OneOf_Response: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_SampleDataRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_SampledElement: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_SampledElement.Exception: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse.ElementList: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_RegisterRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_RegisterResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleDescriptor: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_BundleApplication: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_DelayedBundleApplication: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.OneOf_Type: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.UserState: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.SideInput: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest.DesiredSplit: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse.ChannelSplit: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_Elements: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_Elements.DataMessage: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_Elements.Timers: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateRequest.OneOf_Request: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateResponse.OneOf_Response: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateKey: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.OneOf_Type: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.Runner: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.IterableSideInput: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapSideInput: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysSideInput: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.BagUserState: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysUserState: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapUserState: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateGetRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateGetResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateAppendRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateAppendResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateClearRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StateClearResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_LogEntry: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_LogEntry.List: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_LogEntry.Severity: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_LogEntry.Severity.Enum: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_LogControl: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StartWorkerRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StartWorkerResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StopWorkerRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_StopWorkerResponse: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_WorkerStatusRequest: @unchecked Sendable {}
extension Org_Apache_Beam_Model_FnExecution_V1_WorkerStatusResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "org.apache.beam.model.fn_execution.v1"

extension Org_Apache_Beam_Model_FnExecution_V1_FnApiTransforms: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FnApiTransforms"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_FnApiTransforms, rhs: Org_Apache_Beam_Model_FnExecution_V1_FnApiTransforms) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_FnApiTransforms.Runner: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATA_SOURCE"),
    1: .same(proto: "DATA_SINK"),
  ]
}

extension Org_Apache_Beam_Model_FnExecution_V1_RemoteGrpcPort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteGrpcPort"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_service_descriptor"),
    2: .standard(proto: "coder_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._apiServiceDescriptor) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.coderID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._apiServiceDescriptor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.coderID.isEmpty {
      try visitor.visitSingularStringField(value: self.coderID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_RemoteGrpcPort, rhs: Org_Apache_Beam_Model_FnExecution_V1_RemoteGrpcPort) -> Bool {
    if lhs._apiServiceDescriptor != rhs._apiServiceDescriptor {return false}
    if lhs.coderID != rhs.coderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_GetProcessBundleDescriptorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetProcessBundleDescriptorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "process_bundle_descriptor_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.processBundleDescriptorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.processBundleDescriptorID.isEmpty {
      try visitor.visitSingularStringField(value: self.processBundleDescriptorID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_GetProcessBundleDescriptorRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_GetProcessBundleDescriptorRequest) -> Bool {
    if lhs.processBundleDescriptorID != rhs.processBundleDescriptorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_InstructionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstructionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instruction_id"),
    1001: .standard(proto: "process_bundle"),
    1002: .standard(proto: "process_bundle_progress"),
    1003: .standard(proto: "process_bundle_split"),
    1004: .standard(proto: "finalize_bundle"),
    1005: .standard(proto: "monitoring_infos"),
    1006: .standard(proto: "harness_monitoring_infos"),
    1007: .standard(proto: "sample_data"),
    1000: .same(proto: "register"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instructionID) }()
      case 1000: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_RegisterRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .register(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .register(v)
        }
      }()
      case 1001: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .processBundle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .processBundle(v)
        }
      }()
      case 1002: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .processBundleProgress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .processBundleProgress(v)
        }
      }()
      case 1003: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .processBundleSplit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .processBundleSplit(v)
        }
      }()
      case 1004: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .finalizeBundle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .finalizeBundle(v)
        }
      }()
      case 1005: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .monitoringInfos(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .monitoringInfos(v)
        }
      }()
      case 1006: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .harnessMonitoringInfos(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .harnessMonitoringInfos(v)
        }
      }()
      case 1007: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_SampleDataRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .sampleData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .sampleData(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.instructionID.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionID, fieldNumber: 1)
    }
    switch self.request {
    case .register?: try {
      guard case .register(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    }()
    case .processBundle?: try {
      guard case .processBundle(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
    }()
    case .processBundleProgress?: try {
      guard case .processBundleProgress(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1002)
    }()
    case .processBundleSplit?: try {
      guard case .processBundleSplit(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1003)
    }()
    case .finalizeBundle?: try {
      guard case .finalizeBundle(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1004)
    }()
    case .monitoringInfos?: try {
      guard case .monitoringInfos(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1005)
    }()
    case .harnessMonitoringInfos?: try {
      guard case .harnessMonitoringInfos(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1006)
    }()
    case .sampleData?: try {
      guard case .sampleData(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1007)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_InstructionRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_InstructionRequest) -> Bool {
    if lhs.instructionID != rhs.instructionID {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_InstructionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstructionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instruction_id"),
    2: .same(proto: "error"),
    1001: .standard(proto: "process_bundle"),
    1002: .standard(proto: "process_bundle_progress"),
    1003: .standard(proto: "process_bundle_split"),
    1004: .standard(proto: "finalize_bundle"),
    1005: .standard(proto: "monitoring_infos"),
    1006: .standard(proto: "harness_monitoring_infos"),
    1007: .standard(proto: "sample_data"),
    1000: .same(proto: "register"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instructionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 1000: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_RegisterResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .register(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .register(v)
        }
      }()
      case 1001: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .processBundle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .processBundle(v)
        }
      }()
      case 1002: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .processBundleProgress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .processBundleProgress(v)
        }
      }()
      case 1003: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .processBundleSplit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .processBundleSplit(v)
        }
      }()
      case 1004: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .finalizeBundle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .finalizeBundle(v)
        }
      }()
      case 1005: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .monitoringInfos(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .monitoringInfos(v)
        }
      }()
      case 1006: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .harnessMonitoringInfos(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .harnessMonitoringInfos(v)
        }
      }()
      case 1007: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .sampleData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .sampleData(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.instructionID.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionID, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    switch self.response {
    case .register?: try {
      guard case .register(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    }()
    case .processBundle?: try {
      guard case .processBundle(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
    }()
    case .processBundleProgress?: try {
      guard case .processBundleProgress(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1002)
    }()
    case .processBundleSplit?: try {
      guard case .processBundleSplit(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1003)
    }()
    case .finalizeBundle?: try {
      guard case .finalizeBundle(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1004)
    }()
    case .monitoringInfos?: try {
      guard case .monitoringInfos(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1005)
    }()
    case .harnessMonitoringInfos?: try {
      guard case .harnessMonitoringInfos(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1006)
    }()
    case .sampleData?: try {
      guard case .sampleData(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1007)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_InstructionResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_InstructionResponse) -> Bool {
    if lhs.instructionID != rhs.instructionID {return false}
    if lhs.error != rhs.error {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_SampleDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SampleDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pcollection_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.pcollectionIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pcollectionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pcollectionIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_SampleDataRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_SampleDataRequest) -> Bool {
    if lhs.pcollectionIds != rhs.pcollectionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_SampledElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SampledElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "element"),
    2: .standard(proto: "sample_timestamp"),
    3: .same(proto: "exception"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.element) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sampleTimestamp) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._exception) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.element.isEmpty {
      try visitor.visitSingularBytesField(value: self.element, fieldNumber: 1)
    }
    try { if let v = self._sampleTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._exception {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_SampledElement, rhs: Org_Apache_Beam_Model_FnExecution_V1_SampledElement) -> Bool {
    if lhs.element != rhs.element {return false}
    if lhs._sampleTimestamp != rhs._sampleTimestamp {return false}
    if lhs._exception != rhs._exception {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_SampledElement.Exception: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_SampledElement.protoMessageName + ".Exception"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instruction_id"),
    2: .standard(proto: "transform_id"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instructionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instructionID.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionID, fieldNumber: 1)
    }
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_SampledElement.Exception, rhs: Org_Apache_Beam_Model_FnExecution_V1_SampledElement.Exception) -> Bool {
    if lhs.instructionID != rhs.instructionID {return false}
    if lhs.transformID != rhs.transformID {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SampleDataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_samples"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse.ElementList>.self, value: &self.elementSamples) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elementSamples.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse.ElementList>.self, value: self.elementSamples, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse) -> Bool {
    if lhs.elementSamples != rhs.elementSamples {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse.ElementList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse.protoMessageName + ".ElementList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse.ElementList, rhs: Org_Apache_Beam_Model_FnExecution_V1_SampleDataResponse.ElementList) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HarnessMonitoringInfosRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HarnessMonitoringInfosResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "monitoring_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.monitoringData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.monitoringData.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.monitoringData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_HarnessMonitoringInfosResponse) -> Bool {
    if lhs.monitoringData != rhs.monitoringData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_RegisterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "process_bundle_descriptor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.processBundleDescriptor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.processBundleDescriptor.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.processBundleDescriptor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_RegisterRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_RegisterRequest) -> Bool {
    if lhs.processBundleDescriptor != rhs.processBundleDescriptor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_RegisterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_RegisterResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_RegisterResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessBundleDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "transforms"),
    3: .same(proto: "pcollections"),
    4: .standard(proto: "windowing_strategies"),
    5: .same(proto: "coders"),
    6: .same(proto: "environments"),
    7: .standard(proto: "state_api_service_descriptor"),
    8: .standard(proto: "timer_api_service_descriptor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_Pipeline_V1_PTransform>.self, value: &self.transforms) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_Pipeline_V1_PCollection>.self, value: &self.pcollections) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_Pipeline_V1_WindowingStrategy>.self, value: &self.windowingStrategies) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_Pipeline_V1_Coder>.self, value: &self.coders) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_Pipeline_V1_Environment>.self, value: &self.environments) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._stateApiServiceDescriptor) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._timerApiServiceDescriptor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.transforms.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_Pipeline_V1_PTransform>.self, value: self.transforms, fieldNumber: 2)
    }
    if !self.pcollections.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_Pipeline_V1_PCollection>.self, value: self.pcollections, fieldNumber: 3)
    }
    if !self.windowingStrategies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_Pipeline_V1_WindowingStrategy>.self, value: self.windowingStrategies, fieldNumber: 4)
    }
    if !self.coders.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_Pipeline_V1_Coder>.self, value: self.coders, fieldNumber: 5)
    }
    if !self.environments.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_Pipeline_V1_Environment>.self, value: self.environments, fieldNumber: 6)
    }
    try { if let v = self._stateApiServiceDescriptor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._timerApiServiceDescriptor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleDescriptor, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleDescriptor) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.transforms != rhs.transforms {return false}
    if lhs.pcollections != rhs.pcollections {return false}
    if lhs.windowingStrategies != rhs.windowingStrategies {return false}
    if lhs.coders != rhs.coders {return false}
    if lhs.environments != rhs.environments {return false}
    if lhs._stateApiServiceDescriptor != rhs._stateApiServiceDescriptor {return false}
    if lhs._timerApiServiceDescriptor != rhs._timerApiServiceDescriptor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_BundleApplication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BundleApplication"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transform_id"),
    2: .standard(proto: "input_id"),
    3: .same(proto: "element"),
    4: .standard(proto: "output_watermarks"),
    5: .standard(proto: "is_bounded"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.element) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Timestamp>.self, value: &self.outputWatermarks) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.isBounded) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 1)
    }
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 2)
    }
    if !self.element.isEmpty {
      try visitor.visitSingularBytesField(value: self.element, fieldNumber: 3)
    }
    if !self.outputWatermarks.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Timestamp>.self, value: self.outputWatermarks, fieldNumber: 4)
    }
    if self.isBounded != .unspecified {
      try visitor.visitSingularEnumField(value: self.isBounded, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_BundleApplication, rhs: Org_Apache_Beam_Model_FnExecution_V1_BundleApplication) -> Bool {
    if lhs.transformID != rhs.transformID {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.element != rhs.element {return false}
    if lhs.outputWatermarks != rhs.outputWatermarks {return false}
    if lhs.isBounded != rhs.isBounded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_DelayedBundleApplication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelayedBundleApplication"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "application"),
    2: .standard(proto: "requested_time_delay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._application) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._requestedTimeDelay) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._application {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._requestedTimeDelay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_DelayedBundleApplication, rhs: Org_Apache_Beam_Model_FnExecution_V1_DelayedBundleApplication) -> Bool {
    if lhs._application != rhs._application {return false}
    if lhs._requestedTimeDelay != rhs._requestedTimeDelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessBundleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "process_bundle_descriptor_id"),
    2: .standard(proto: "cache_tokens"),
    3: .same(proto: "elements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.processBundleDescriptorID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.cacheTokens) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.processBundleDescriptorID.isEmpty {
      try visitor.visitSingularStringField(value: self.processBundleDescriptorID, fieldNumber: 1)
    }
    if !self.cacheTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cacheTokens, fieldNumber: 2)
    }
    try { if let v = self._elements {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest) -> Bool {
    if lhs.processBundleDescriptorID != rhs.processBundleDescriptorID {return false}
    if lhs.cacheTokens != rhs.cacheTokens {return false}
    if lhs._elements != rhs._elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.protoMessageName + ".CacheToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_state"),
    2: .standard(proto: "side_input"),
    10: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.UserState?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .userState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .userState(v)
        }
      }()
      case 2: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.SideInput?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .sideInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .sideInput(v)
        }
      }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .userState?: try {
      guard case .userState(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sideInput?: try {
      guard case .sideInput(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.token.isEmpty {
      try visitor.visitSingularBytesField(value: self.token, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.UserState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.protoMessageName + ".UserState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.UserState, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.UserState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.SideInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.protoMessageName + ".SideInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transform_id"),
    2: .standard(proto: "side_input_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sideInputID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 1)
    }
    if !self.sideInputID.isEmpty {
      try visitor.visitSingularStringField(value: self.sideInputID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.SideInput, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleRequest.CacheToken.SideInput) -> Bool {
    if lhs.transformID != rhs.transformID {return false}
    if lhs.sideInputID != rhs.sideInputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessBundleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "residual_roots"),
    3: .standard(proto: "monitoring_infos"),
    4: .standard(proto: "requires_finalization"),
    5: .standard(proto: "monitoring_data"),
    6: .same(proto: "elements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.residualRoots) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.monitoringInfos) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.requiresFinalization) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.monitoringData) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.residualRoots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.residualRoots, fieldNumber: 2)
    }
    if !self.monitoringInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.monitoringInfos, fieldNumber: 3)
    }
    if self.requiresFinalization != false {
      try visitor.visitSingularBoolField(value: self.requiresFinalization, fieldNumber: 4)
    }
    if !self.monitoringData.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.monitoringData, fieldNumber: 5)
    }
    try { if let v = self._elements {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleResponse) -> Bool {
    if lhs.residualRoots != rhs.residualRoots {return false}
    if lhs.monitoringInfos != rhs.monitoringInfos {return false}
    if lhs.requiresFinalization != rhs.requiresFinalization {return false}
    if lhs.monitoringData != rhs.monitoringData {return false}
    if lhs._elements != rhs._elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessBundleProgressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instruction_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instructionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instructionID.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressRequest) -> Bool {
    if lhs.instructionID != rhs.instructionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MonitoringInfosMetadataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "monitoring_info_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.monitoringInfoID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.monitoringInfoID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.monitoringInfoID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataRequest) -> Bool {
    if lhs.monitoringInfoID != rhs.monitoringInfoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessBundleProgressResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "monitoring_infos"),
    5: .standard(proto: "monitoring_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.monitoringInfos) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.monitoringData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.monitoringInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.monitoringInfos, fieldNumber: 3)
    }
    if !self.monitoringData.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.monitoringData, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleProgressResponse) -> Bool {
    if lhs.monitoringInfos != rhs.monitoringInfos {return false}
    if lhs.monitoringData != rhs.monitoringData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MonitoringInfosMetadataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "monitoring_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo>.self, value: &self.monitoringInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.monitoringInfo.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_Pipeline_V1_MonitoringInfo>.self, value: self.monitoringInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_MonitoringInfosMetadataResponse) -> Bool {
    if lhs.monitoringInfo != rhs.monitoringInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessBundleSplitRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instruction_id"),
    3: .standard(proto: "desired_splits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instructionID) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest.DesiredSplit>.self, value: &self.desiredSplits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instructionID.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionID, fieldNumber: 1)
    }
    if !self.desiredSplits.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest.DesiredSplit>.self, value: self.desiredSplits, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest) -> Bool {
    if lhs.instructionID != rhs.instructionID {return false}
    if lhs.desiredSplits != rhs.desiredSplits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest.DesiredSplit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest.protoMessageName + ".DesiredSplit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fraction_of_remainder"),
    3: .standard(proto: "allowed_split_points"),
    2: .standard(proto: "estimated_input_elements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.fractionOfRemainder) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.estimatedInputElements) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.allowedSplitPoints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fractionOfRemainder != 0 {
      try visitor.visitSingularDoubleField(value: self.fractionOfRemainder, fieldNumber: 1)
    }
    if self.estimatedInputElements != 0 {
      try visitor.visitSingularInt64Field(value: self.estimatedInputElements, fieldNumber: 2)
    }
    if !self.allowedSplitPoints.isEmpty {
      try visitor.visitPackedInt64Field(value: self.allowedSplitPoints, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest.DesiredSplit, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitRequest.DesiredSplit) -> Bool {
    if lhs.fractionOfRemainder != rhs.fractionOfRemainder {return false}
    if lhs.allowedSplitPoints != rhs.allowedSplitPoints {return false}
    if lhs.estimatedInputElements != rhs.estimatedInputElements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessBundleSplitResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "primary_roots"),
    2: .standard(proto: "residual_roots"),
    3: .standard(proto: "channel_splits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.primaryRoots) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.residualRoots) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.channelSplits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.primaryRoots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.primaryRoots, fieldNumber: 1)
    }
    if !self.residualRoots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.residualRoots, fieldNumber: 2)
    }
    if !self.channelSplits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelSplits, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse) -> Bool {
    if lhs.primaryRoots != rhs.primaryRoots {return false}
    if lhs.residualRoots != rhs.residualRoots {return false}
    if lhs.channelSplits != rhs.channelSplits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse.ChannelSplit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse.protoMessageName + ".ChannelSplit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transform_id"),
    2: .standard(proto: "last_primary_element"),
    3: .standard(proto: "first_residual_element"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.lastPrimaryElement) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.firstResidualElement) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 1)
    }
    if self.lastPrimaryElement != 0 {
      try visitor.visitSingularInt64Field(value: self.lastPrimaryElement, fieldNumber: 2)
    }
    if self.firstResidualElement != 0 {
      try visitor.visitSingularInt64Field(value: self.firstResidualElement, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse.ChannelSplit, rhs: Org_Apache_Beam_Model_FnExecution_V1_ProcessBundleSplitResponse.ChannelSplit) -> Bool {
    if lhs.transformID != rhs.transformID {return false}
    if lhs.lastPrimaryElement != rhs.lastPrimaryElement {return false}
    if lhs.firstResidualElement != rhs.firstResidualElement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizeBundleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instruction_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instructionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instructionID.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleRequest) -> Bool {
    if lhs.instructionID != rhs.instructionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizeBundleResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_FinalizeBundleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_Elements: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Elements"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "timers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.timers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    if !self.timers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_Elements, rhs: Org_Apache_Beam_Model_FnExecution_V1_Elements) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.timers != rhs.timers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_Elements.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_Elements.protoMessageName + ".Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instruction_id"),
    2: .standard(proto: "transform_id"),
    3: .same(proto: "data"),
    4: .standard(proto: "is_last"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instructionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isLast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instructionID.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionID, fieldNumber: 1)
    }
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if self.isLast != false {
      try visitor.visitSingularBoolField(value: self.isLast, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_Elements.DataMessage, rhs: Org_Apache_Beam_Model_FnExecution_V1_Elements.DataMessage) -> Bool {
    if lhs.instructionID != rhs.instructionID {return false}
    if lhs.transformID != rhs.transformID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.isLast != rhs.isLast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_Elements.Timers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_Elements.protoMessageName + ".Timers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instruction_id"),
    2: .standard(proto: "transform_id"),
    3: .standard(proto: "timer_family_id"),
    4: .same(proto: "timers"),
    5: .standard(proto: "is_last"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instructionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.timerFamilyID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.timers) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isLast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instructionID.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionID, fieldNumber: 1)
    }
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 2)
    }
    if !self.timerFamilyID.isEmpty {
      try visitor.visitSingularStringField(value: self.timerFamilyID, fieldNumber: 3)
    }
    if !self.timers.isEmpty {
      try visitor.visitSingularBytesField(value: self.timers, fieldNumber: 4)
    }
    if self.isLast != false {
      try visitor.visitSingularBoolField(value: self.isLast, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_Elements.Timers, rhs: Org_Apache_Beam_Model_FnExecution_V1_Elements.Timers) -> Bool {
    if lhs.instructionID != rhs.instructionID {return false}
    if lhs.transformID != rhs.transformID {return false}
    if lhs.timerFamilyID != rhs.timerFamilyID {return false}
    if lhs.timers != rhs.timers {return false}
    if lhs.isLast != rhs.isLast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "instruction_id"),
    3: .standard(proto: "state_key"),
    1000: .same(proto: "get"),
    1001: .same(proto: "append"),
    1002: .same(proto: "clear"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instructionID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._stateKey) }()
      case 1000: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateGetRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .get(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .get(v)
        }
      }()
      case 1001: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateAppendRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .append(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .append(v)
        }
      }()
      case 1002: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateClearRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .clear(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .clear(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.instructionID.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionID, fieldNumber: 2)
    }
    try { if let v = self._stateKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    switch self.request {
    case .get?: try {
      guard case .get(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    }()
    case .append?: try {
      guard case .append(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
    }()
    case .clear?: try {
      guard case .clear(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1002)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.instructionID != rhs.instructionID {return false}
    if lhs._stateKey != rhs._stateKey {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    1000: .same(proto: "get"),
    1001: .same(proto: "append"),
    1002: .same(proto: "clear"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 1000: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateGetResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .get(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .get(v)
        }
      }()
      case 1001: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateAppendResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .append(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .append(v)
        }
      }()
      case 1002: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateClearResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .clear(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .clear(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    switch self.response {
    case .get?: try {
      guard case .get(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    }()
    case .append?: try {
      guard case .append(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
    }()
    case .clear?: try {
      guard case .clear(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1002)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.error != rhs.error {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StateKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "runner"),
    2: .standard(proto: "multimap_side_input"),
    3: .standard(proto: "bag_user_state"),
    4: .standard(proto: "iterable_side_input"),
    5: .standard(proto: "multimap_keys_side_input"),
    6: .standard(proto: "multimap_keys_user_state"),
    7: .standard(proto: "multimap_user_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateKey.Runner?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .runner(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .runner(v)
        }
      }()
      case 2: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapSideInput?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .multimapSideInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .multimapSideInput(v)
        }
      }()
      case 3: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateKey.BagUserState?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .bagUserState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .bagUserState(v)
        }
      }()
      case 4: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateKey.IterableSideInput?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .iterableSideInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .iterableSideInput(v)
        }
      }()
      case 5: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysSideInput?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .multimapKeysSideInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .multimapKeysSideInput(v)
        }
      }()
      case 6: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysUserState?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .multimapKeysUserState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .multimapKeysUserState(v)
        }
      }()
      case 7: try {
        var v: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapUserState?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .multimapUserState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .multimapUserState(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .runner?: try {
      guard case .runner(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .multimapSideInput?: try {
      guard case .multimapSideInput(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .bagUserState?: try {
      guard case .bagUserState(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .iterableSideInput?: try {
      guard case .iterableSideInput(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .multimapKeysSideInput?: try {
      guard case .multimapKeysSideInput(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .multimapKeysUserState?: try {
      guard case .multimapKeysUserState(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .multimapUserState?: try {
      guard case .multimapUserState(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.Runner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_StateKey.protoMessageName + ".Runner"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.Runner, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.Runner) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.IterableSideInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_StateKey.protoMessageName + ".IterableSideInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transform_id"),
    2: .standard(proto: "side_input_id"),
    3: .same(proto: "window"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sideInputID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.window) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 1)
    }
    if !self.sideInputID.isEmpty {
      try visitor.visitSingularStringField(value: self.sideInputID, fieldNumber: 2)
    }
    if !self.window.isEmpty {
      try visitor.visitSingularBytesField(value: self.window, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.IterableSideInput, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.IterableSideInput) -> Bool {
    if lhs.transformID != rhs.transformID {return false}
    if lhs.sideInputID != rhs.sideInputID {return false}
    if lhs.window != rhs.window {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapSideInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_StateKey.protoMessageName + ".MultimapSideInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transform_id"),
    2: .standard(proto: "side_input_id"),
    3: .same(proto: "window"),
    4: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sideInputID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.window) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 1)
    }
    if !self.sideInputID.isEmpty {
      try visitor.visitSingularStringField(value: self.sideInputID, fieldNumber: 2)
    }
    if !self.window.isEmpty {
      try visitor.visitSingularBytesField(value: self.window, fieldNumber: 3)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapSideInput, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapSideInput) -> Bool {
    if lhs.transformID != rhs.transformID {return false}
    if lhs.sideInputID != rhs.sideInputID {return false}
    if lhs.window != rhs.window {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysSideInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_StateKey.protoMessageName + ".MultimapKeysSideInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transform_id"),
    2: .standard(proto: "side_input_id"),
    3: .same(proto: "window"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sideInputID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.window) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 1)
    }
    if !self.sideInputID.isEmpty {
      try visitor.visitSingularStringField(value: self.sideInputID, fieldNumber: 2)
    }
    if !self.window.isEmpty {
      try visitor.visitSingularBytesField(value: self.window, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysSideInput, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysSideInput) -> Bool {
    if lhs.transformID != rhs.transformID {return false}
    if lhs.sideInputID != rhs.sideInputID {return false}
    if lhs.window != rhs.window {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.BagUserState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_StateKey.protoMessageName + ".BagUserState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transform_id"),
    2: .standard(proto: "user_state_id"),
    3: .same(proto: "window"),
    4: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userStateID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.window) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 1)
    }
    if !self.userStateID.isEmpty {
      try visitor.visitSingularStringField(value: self.userStateID, fieldNumber: 2)
    }
    if !self.window.isEmpty {
      try visitor.visitSingularBytesField(value: self.window, fieldNumber: 3)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.BagUserState, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.BagUserState) -> Bool {
    if lhs.transformID != rhs.transformID {return false}
    if lhs.userStateID != rhs.userStateID {return false}
    if lhs.window != rhs.window {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysUserState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_StateKey.protoMessageName + ".MultimapKeysUserState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transform_id"),
    2: .standard(proto: "user_state_id"),
    3: .same(proto: "window"),
    4: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userStateID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.window) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 1)
    }
    if !self.userStateID.isEmpty {
      try visitor.visitSingularStringField(value: self.userStateID, fieldNumber: 2)
    }
    if !self.window.isEmpty {
      try visitor.visitSingularBytesField(value: self.window, fieldNumber: 3)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysUserState, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapKeysUserState) -> Bool {
    if lhs.transformID != rhs.transformID {return false}
    if lhs.userStateID != rhs.userStateID {return false}
    if lhs.window != rhs.window {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapUserState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_StateKey.protoMessageName + ".MultimapUserState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transform_id"),
    2: .standard(proto: "user_state_id"),
    3: .same(proto: "window"),
    4: .same(proto: "key"),
    5: .standard(proto: "map_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userStateID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.window) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.mapKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 1)
    }
    if !self.userStateID.isEmpty {
      try visitor.visitSingularStringField(value: self.userStateID, fieldNumber: 2)
    }
    if !self.window.isEmpty {
      try visitor.visitSingularBytesField(value: self.window, fieldNumber: 3)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 4)
    }
    if !self.mapKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.mapKey, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapUserState, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateKey.MultimapUserState) -> Bool {
    if lhs.transformID != rhs.transformID {return false}
    if lhs.userStateID != rhs.userStateID {return false}
    if lhs.window != rhs.window {return false}
    if lhs.key != rhs.key {return false}
    if lhs.mapKey != rhs.mapKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateGetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StateGetRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "continuation_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.continuationToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.continuationToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.continuationToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateGetRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateGetRequest) -> Bool {
    if lhs.continuationToken != rhs.continuationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateGetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StateGetResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "continuation_token"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.continuationToken) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.continuationToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.continuationToken, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateGetResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateGetResponse) -> Bool {
    if lhs.continuationToken != rhs.continuationToken {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateAppendRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StateAppendRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateAppendRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateAppendRequest) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateAppendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StateAppendResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateAppendResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateAppendResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateClearRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StateClearRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateClearRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateClearRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StateClearResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StateClearResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StateClearResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_StateClearResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_LogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "severity"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "message"),
    4: .same(proto: "trace"),
    5: .standard(proto: "instruction_id"),
    6: .standard(proto: "transform_id"),
    7: .standard(proto: "log_location"),
    8: .same(proto: "thread"),
    9: .standard(proto: "custom_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.severity) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.trace) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.instructionID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.transformID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.logLocation) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.thread) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._customData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.severity != .unspecified {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 1)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    if !self.trace.isEmpty {
      try visitor.visitSingularStringField(value: self.trace, fieldNumber: 4)
    }
    if !self.instructionID.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionID, fieldNumber: 5)
    }
    if !self.transformID.isEmpty {
      try visitor.visitSingularStringField(value: self.transformID, fieldNumber: 6)
    }
    if !self.logLocation.isEmpty {
      try visitor.visitSingularStringField(value: self.logLocation, fieldNumber: 7)
    }
    if !self.thread.isEmpty {
      try visitor.visitSingularStringField(value: self.thread, fieldNumber: 8)
    }
    try { if let v = self._customData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_LogEntry, rhs: Org_Apache_Beam_Model_FnExecution_V1_LogEntry) -> Bool {
    if lhs.severity != rhs.severity {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.message != rhs.message {return false}
    if lhs.trace != rhs.trace {return false}
    if lhs.instructionID != rhs.instructionID {return false}
    if lhs.transformID != rhs.transformID {return false}
    if lhs.logLocation != rhs.logLocation {return false}
    if lhs.thread != rhs.thread {return false}
    if lhs._customData != rhs._customData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_LogEntry.List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_LogEntry.protoMessageName + ".List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.logEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logEntries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_LogEntry.List, rhs: Org_Apache_Beam_Model_FnExecution_V1_LogEntry.List) -> Bool {
    if lhs.logEntries != rhs.logEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_LogEntry.Severity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Org_Apache_Beam_Model_FnExecution_V1_LogEntry.protoMessageName + ".Severity"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_LogEntry.Severity, rhs: Org_Apache_Beam_Model_FnExecution_V1_LogEntry.Severity) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_LogEntry.Severity.Enum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "TRACE"),
    2: .same(proto: "DEBUG"),
    3: .same(proto: "INFO"),
    4: .same(proto: "NOTICE"),
    5: .same(proto: "WARN"),
    6: .same(proto: "ERROR"),
    7: .same(proto: "CRITICAL"),
  ]
}

extension Org_Apache_Beam_Model_FnExecution_V1_LogControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogControl"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_LogControl, rhs: Org_Apache_Beam_Model_FnExecution_V1_LogControl) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StartWorkerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartWorkerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
    2: .standard(proto: "control_endpoint"),
    3: .standard(proto: "logging_endpoint"),
    4: .standard(proto: "artifact_endpoint"),
    5: .standard(proto: "provision_endpoint"),
    10: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._controlEndpoint) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._loggingEndpoint) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._artifactEndpoint) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._provisionEndpoint) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.workerID.isEmpty {
      try visitor.visitSingularStringField(value: self.workerID, fieldNumber: 1)
    }
    try { if let v = self._controlEndpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._loggingEndpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._artifactEndpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._provisionEndpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.params.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.params, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StartWorkerRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_StartWorkerRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs._controlEndpoint != rhs._controlEndpoint {return false}
    if lhs._loggingEndpoint != rhs._loggingEndpoint {return false}
    if lhs._artifactEndpoint != rhs._artifactEndpoint {return false}
    if lhs._provisionEndpoint != rhs._provisionEndpoint {return false}
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StartWorkerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartWorkerResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StartWorkerResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_StartWorkerResponse) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StopWorkerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopWorkerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workerID.isEmpty {
      try visitor.visitSingularStringField(value: self.workerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StopWorkerRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_StopWorkerRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_StopWorkerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopWorkerResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_StopWorkerResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_StopWorkerResponse) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_WorkerStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorkerStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_WorkerStatusRequest, rhs: Org_Apache_Beam_Model_FnExecution_V1_WorkerStatusRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Apache_Beam_Model_FnExecution_V1_WorkerStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorkerStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    3: .standard(proto: "status_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.statusInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if !self.statusInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.statusInfo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Org_Apache_Beam_Model_FnExecution_V1_WorkerStatusResponse, rhs: Org_Apache_Beam_Model_FnExecution_V1_WorkerStatusResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.error != rhs.error {return false}
    if lhs.statusInfo != rhs.statusInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
