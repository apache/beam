/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.beam.sdk.io;

import static com.google.common.base.Preconditions.checkNotNull;

import com.google.auto.value.AutoValue;
import com.google.common.annotations.VisibleForTesting;
import javax.annotation.Nullable;
import org.apache.beam.sdk.runners.PipelineRunner;
import org.apache.beam.sdk.transforms.PTransform;
import org.apache.beam.sdk.transforms.display.DisplayData;
import org.apache.beam.sdk.values.PBegin;
import org.apache.beam.sdk.values.PCollection;

/** Transforms for reading and writing XML files using JAXB mappers. */
public class XmlIO {
  // CHECKSTYLE.OFF: JavadocStyle
  /**
   * Reads XML files. This source reads one or more XML files and
   * creates a {@link PCollection} of a given type. Please note the example given below.
   *
   * <p>The XML file must be of the following form, where {@code root} and {@code record} are XML
   * element names that are defined by the user:
   *
   * <pre>{@code
   * <root>
   * <record> ... </record>
   * <record> ... </record>
   * <record> ... </record>
   * ...
   * <record> ... </record>
   * </root>
   * }</pre>
   *
   * <p>Basically, the XML document should contain a single root element with an inner list
   * consisting entirely of record elements. The records may contain arbitrary XML content; however,
   * that content <b>must not</b> contain the start {@code <record>} or end {@code </record>} tags.
   * This restriction enables reading from large XML files in parallel from different offsets in the
   * file.
   *
   * <p>Root and/or record elements may additionally contain an arbitrary number of XML attributes.
   * Additionally users must provide a class of a JAXB annotated Java type that can be used convert
   * records into Java objects and vice versa using JAXB marshalling/unmarshalling mechanisms.
   * Reading the source will generate a {@code PCollection} of the given JAXB annotated Java type.
   * Optionally users may provide a minimum size of a bundle that should be created for the source.
   *
   * <p>The following example shows how to use this method in a Beam pipeline:
   *
   * <pre>{@code
   * PCollection<String> output = p.apply(XmlIO.<Record>read()
   *     .from(file.toPath().toString())
   *     .withRootElement("root")
   *     .withRecordElement("record")
   *     .withRecordClass(Record.class));
   * }</pre>
   *
   * <p>Currently, only XML files that use single-byte characters are supported. Using a file that
   * contains multi-byte characters may result in data loss or duplication.
   *
   * <p>To use this method:
   *
   * <ol>
   * <li>Explicitly declare a dependency on org.codehaus.woodstox:stax2-api
   * <li>Include a compatible implementation on the classpath at run-time, such as
   *     org.codehaus.woodstox:woodstox-core-asl
   * </ol>
   *
   * <p>These dependencies have been declared as optional in the sdks/java/core/pom.xml file of
   * Apache Beam.
   *
   * <h3>Permissions</h3>
   * Permission requirements depend on the {@link org.apache.beam.sdk.runners.PipelineRunner
   * PipelineRunner} that is used to execute the Beam pipeline. Please refer to the documentation of
   * corresponding {@link PipelineRunner PipelineRunners} for more details.
   *
   * @param <T> Type of the objects that represent the records of the XML file. The {@code
   *     PCollection} generated by this source will be of this type.
   */
  // CHECKSTYLE.ON: JavadocStyle
  public static <T> Read<T> read() {
    return new AutoValue_XmlIO_Read.Builder<T>()
        .setMinBundleSize(Read.DEFAULT_MIN_BUNDLE_SIZE)
        .setCompressionType(Read.CompressionType.AUTO)
        .build();
  }

  /** Implementation of {@link #read}. */
  @AutoValue
  public abstract static class Read<T> extends PTransform<PBegin, PCollection<T>> {
    private static final int DEFAULT_MIN_BUNDLE_SIZE = 8 * 1024;

    @Nullable
    abstract String getFileOrPatternSpec();

    @Nullable
    abstract String getRootElement();

    @Nullable
    abstract String getRecordElement();

    @Nullable
    abstract Class<T> getRecordClass();

    abstract CompressionType getCompressionType();

    abstract long getMinBundleSize();

    abstract Builder<T> toBuilder();

    @AutoValue.Builder
    abstract static class Builder<T> {
      abstract Builder<T> setFileOrPatternSpec(String fileOrPatternSpec);

      abstract Builder<T> setRootElement(String rootElement);

      abstract Builder<T> setRecordElement(String recordElement);

      abstract Builder<T> setRecordClass(Class<T> recordClass);

      abstract Builder<T> setMinBundleSize(long minBundleSize);

      abstract Builder<T> setCompressionType(CompressionType compressionType);

      abstract Read<T> build();
    }

    /** Strategy for determining the compression type of XML files being read. */
    public enum CompressionType {
      /** Automatically determine the compression type based on filename extension. */
      AUTO(""),
      /** Uncompressed (i.e., may be split). */
      UNCOMPRESSED(""),
      /** GZipped. */
      GZIP(".gz"),
      /** BZipped. */
      BZIP2(".bz2"),
      /** Zipped. */
      ZIP(".zip"),
      /** Deflate compressed. */
      DEFLATE(".deflate");

      private String filenameSuffix;

      CompressionType(String suffix) {
        this.filenameSuffix = suffix;
      }

      /**
       * Determine if a given filename matches a compression type based on its extension.
       * @param filename the filename to match
       * @return true iff the filename ends with the compression type's known extension.
       */
      public boolean matches(String filename) {
        return filename.toLowerCase().endsWith(filenameSuffix.toLowerCase());
      }
    }

    /**
     * Reads a single XML file or a set of XML files defined by a Java "glob"
     * file pattern. Each XML file should be of the form defined in {@link #read}.
     */
    public Read<T> from(String fileOrPatternSpec) {
      return toBuilder().setFileOrPatternSpec(fileOrPatternSpec).build();
    }

    /**
     * Sets name of the root element of the XML document. This will be used to create a valid
     * starting root element when initiating a bundle of records created from an XML document. This
     * is a required parameter.
     */
    public Read<T> withRootElement(String rootElement) {
      return toBuilder().setRootElement(rootElement).build();
    }

    /**
     * Sets name of the record element of the XML document. This will be used to determine offset of
     * the first record of a bundle created from the XML document. This is a required parameter.
     */
    public Read<T> withRecordElement(String recordElement) {
      return toBuilder().setRecordElement(recordElement).build();
    }

    /**
     * Sets a JAXB annotated class that can be populated using a record of the provided XML file.
     * This will be used when unmarshalling record objects from the XML file. This is a required
     * parameter.
     */
    public Read<T> withRecordClass(Class<T> recordClass) {
      return toBuilder().setRecordClass(recordClass).build();
    }

    /**
     * Sets a parameter {@code minBundleSize} for the minimum bundle size of the source. Please
     * refer to {@link OffsetBasedSource} for the definition of minBundleSize. This is an optional
     * parameter.
     */
    public Read<T> withMinBundleSize(long minBundleSize) {
      return toBuilder().setMinBundleSize(minBundleSize).build();
    }

    /**
     * Decompresses all input files using the specified compression type.
     *
     * <p>If no compression type is specified, the default is {@link CompressionType#AUTO}.
     * In this mode, the compression type of the file is determined by its extension.
     * Supports .gz, .bz2, .zip and .deflate compression.
     */
    public Read<T> withCompressionType(CompressionType compressionType) {
      return toBuilder().setCompressionType(compressionType).build();
    }

    @Override
    public void validate(PBegin input) {
      checkNotNull(
          getRootElement(),
          "rootElement is null. Use builder method withRootElement() to set this.");
      checkNotNull(
          getRecordElement(),
          "recordElement is null. Use builder method withRecordElement() to set this.");
      checkNotNull(
          getRecordClass(),
          "recordClass is null. Use builder method withRecordClass() to set this.");
    }

    @Override
    public void populateDisplayData(DisplayData.Builder builder) {
      builder
          .addIfNotDefault(
              DisplayData.item("minBundleSize", getMinBundleSize())
                  .withLabel("Minimum Bundle Size"),
              1L)
          .add(DisplayData.item("filePattern", getFileOrPatternSpec()).withLabel("File Pattern"))
          .addIfNotNull(
              DisplayData.item("rootElement", getRootElement()).withLabel("XML Root Element"))
          .addIfNotNull(
              DisplayData.item("recordElement", getRecordElement()).withLabel("XML Record Element"))
          .addIfNotNull(
              DisplayData.item("recordClass", getRecordClass()).withLabel("XML Record Class"));
    }

    @VisibleForTesting
    BoundedSource<T> createSource() {
      XmlSource<T> source = new XmlSource<>(this);
      switch (getCompressionType()) {
        case UNCOMPRESSED:
          return source;
        case AUTO:
          return CompressedSource.from(source);
        case BZIP2:
          return CompressedSource.from(source)
              .withDecompression(CompressedSource.CompressionMode.BZIP2);
        case GZIP:
          return CompressedSource.from(source)
              .withDecompression(CompressedSource.CompressionMode.GZIP);
        case ZIP:
          return CompressedSource.from(source)
              .withDecompression(CompressedSource.CompressionMode.ZIP);
        case DEFLATE:
          return CompressedSource.from(source)
              .withDecompression(CompressedSource.CompressionMode.DEFLATE);
        default:
          throw new IllegalArgumentException("Unknown compression type: " + getCompressionType());
      }
    }

    @Override
    public PCollection<T> expand(PBegin input) {
      return input.apply(org.apache.beam.sdk.io.Read.from(createSource()));
    }
  }
}
