#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

"""Code for generating test files with 'from __future__ import annotations'.

Intended for internal use only, no backward-compatibility guarantees."""
import os
from pathlib import Path

from apache_beam.typehints import decorators_test
from apache_beam.typehints import typehints_test

_THIS_FILE_NAME = Path(__file__).name


def _get_futureannotations_header(source_file_name):
  """Generate the header for a future annotations test file."""
  # pylint: disable=line-too-long
  return (
      f"""# File generated by {_THIS_FILE_NAME}, do not edit manually.
# Copy of {source_file_name} with 'from __future__ import annotations' added.
from __future__ import annotations

# pylint: disable-all
""")  # yapf: disable


def generate_futureannotations_test(source_file_path):
  """Generate a test file with future annotations from a source file.

    Args:
        source_file_path: Path to the source test file

    Returns:
        Path to the generated file.
    """
  source_path = Path(source_file_path)

  target_file_path = get_target_filename(source_file_path)

  with open(source_path, 'r') as f:
    orig_contents = f.read()

  header = _get_futureannotations_header(source_path.name)
  new_contents = header + orig_contents

  with open(target_file_path, 'w') as f:
    f.write(new_contents)

  return target_file_path


def get_target_filename(source_file_path):
  """Get the target filename for the generated file."""
  source_path = Path(source_file_path)
  base_name = source_path.stem.replace("_test", "")
  extension = source_path.suffix
  target_name = f"{base_name}_with_futureannotations_test{extension}"
  return source_path.parent / target_name


def check_generated_file(source_file_path):
  """Check that the generated file is up to date."""
  target_file_path = get_target_filename(source_file_path)

  generated_file = Path(target_file_path)
  source_path = Path(source_file_path)

  assert os.path.exists(generated_file), (
      f"Generated file {generated_file} does not exist.")

  with open(generated_file, 'r') as f:
    existing_contents = f.read()

  with open(source_path, 'r') as f:
    orig_contents = f.read()

  header = _get_futureannotations_header(source_path.name)
  expected_contents = header + orig_contents

  err_msg = (
      f"Generated file {generated_file} is out of date. Please run "
      f"`python3 -m "
      "apache_beam.typehints.testing.futureannotations_test_generator "
      f"to regenerate it.")

  assert existing_contents == expected_contents, err_msg


if __name__ == "__main__":
  source_files = [typehints_test.__file__, decorators_test.__file__]
  for source_file in source_files:
    target_file = generate_futureannotations_test(source_file)
    print(f"Generated file {target_file}")
