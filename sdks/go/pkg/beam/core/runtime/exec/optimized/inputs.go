// File generated by specialize. Do not edit.

// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package optimized

import (
	"fmt"
	"io"
	"reflect"

	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec"
	"github.com/apache/beam/sdks/go/pkg/beam/core/typex"
)

func init() {
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte) bool)(nil)).Elem(), iterMakerByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte) bool)(nil)).Elem(), iterMakerETByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *[]byte) bool)(nil)).Elem(), iterMakerByteSliceByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *[]byte) bool)(nil)).Elem(), iterMakerETByteSliceByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *bool) bool)(nil)).Elem(), iterMakerByteSliceBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *bool) bool)(nil)).Elem(), iterMakerETByteSliceBool)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *string) bool)(nil)).Elem(), iterMakerByteSliceString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *string) bool)(nil)).Elem(), iterMakerETByteSliceString)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *int) bool)(nil)).Elem(), iterMakerByteSliceInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *int) bool)(nil)).Elem(), iterMakerETByteSliceInt)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *int8) bool)(nil)).Elem(), iterMakerByteSliceInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *int8) bool)(nil)).Elem(), iterMakerETByteSliceInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *int16) bool)(nil)).Elem(), iterMakerByteSliceInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *int16) bool)(nil)).Elem(), iterMakerETByteSliceInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *int32) bool)(nil)).Elem(), iterMakerByteSliceInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *int32) bool)(nil)).Elem(), iterMakerETByteSliceInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *int64) bool)(nil)).Elem(), iterMakerByteSliceInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *int64) bool)(nil)).Elem(), iterMakerETByteSliceInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *uint) bool)(nil)).Elem(), iterMakerByteSliceUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *uint) bool)(nil)).Elem(), iterMakerETByteSliceUint)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *uint8) bool)(nil)).Elem(), iterMakerByteSliceUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *uint8) bool)(nil)).Elem(), iterMakerETByteSliceUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *uint16) bool)(nil)).Elem(), iterMakerByteSliceUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *uint16) bool)(nil)).Elem(), iterMakerETByteSliceUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *uint32) bool)(nil)).Elem(), iterMakerByteSliceUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *uint32) bool)(nil)).Elem(), iterMakerETByteSliceUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *uint64) bool)(nil)).Elem(), iterMakerByteSliceUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *uint64) bool)(nil)).Elem(), iterMakerETByteSliceUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *float32) bool)(nil)).Elem(), iterMakerByteSliceFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *float32) bool)(nil)).Elem(), iterMakerETByteSliceFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *float64) bool)(nil)).Elem(), iterMakerByteSliceFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *float64) bool)(nil)).Elem(), iterMakerETByteSliceFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.T) bool)(nil)).Elem(), iterMakerByteSliceTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *typex.T) bool)(nil)).Elem(), iterMakerETByteSliceTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.U) bool)(nil)).Elem(), iterMakerByteSliceTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *typex.U) bool)(nil)).Elem(), iterMakerETByteSliceTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.V) bool)(nil)).Elem(), iterMakerByteSliceTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *typex.V) bool)(nil)).Elem(), iterMakerETByteSliceTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.W) bool)(nil)).Elem(), iterMakerByteSliceTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *typex.W) bool)(nil)).Elem(), iterMakerETByteSliceTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.X) bool)(nil)).Elem(), iterMakerByteSliceTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *typex.X) bool)(nil)).Elem(), iterMakerETByteSliceTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.Y) bool)(nil)).Elem(), iterMakerByteSliceTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *typex.Y) bool)(nil)).Elem(), iterMakerETByteSliceTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.Z) bool)(nil)).Elem(), iterMakerByteSliceTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *[]byte, *typex.Z) bool)(nil)).Elem(), iterMakerETByteSliceTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*bool) bool)(nil)).Elem(), iterMakerBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool) bool)(nil)).Elem(), iterMakerETBool)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *[]byte) bool)(nil)).Elem(), iterMakerBoolByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *[]byte) bool)(nil)).Elem(), iterMakerETBoolByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *bool) bool)(nil)).Elem(), iterMakerBoolBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *bool) bool)(nil)).Elem(), iterMakerETBoolBool)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *string) bool)(nil)).Elem(), iterMakerBoolString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *string) bool)(nil)).Elem(), iterMakerETBoolString)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *int) bool)(nil)).Elem(), iterMakerBoolInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *int) bool)(nil)).Elem(), iterMakerETBoolInt)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *int8) bool)(nil)).Elem(), iterMakerBoolInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *int8) bool)(nil)).Elem(), iterMakerETBoolInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *int16) bool)(nil)).Elem(), iterMakerBoolInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *int16) bool)(nil)).Elem(), iterMakerETBoolInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *int32) bool)(nil)).Elem(), iterMakerBoolInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *int32) bool)(nil)).Elem(), iterMakerETBoolInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *int64) bool)(nil)).Elem(), iterMakerBoolInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *int64) bool)(nil)).Elem(), iterMakerETBoolInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *uint) bool)(nil)).Elem(), iterMakerBoolUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *uint) bool)(nil)).Elem(), iterMakerETBoolUint)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *uint8) bool)(nil)).Elem(), iterMakerBoolUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *uint8) bool)(nil)).Elem(), iterMakerETBoolUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *uint16) bool)(nil)).Elem(), iterMakerBoolUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *uint16) bool)(nil)).Elem(), iterMakerETBoolUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *uint32) bool)(nil)).Elem(), iterMakerBoolUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *uint32) bool)(nil)).Elem(), iterMakerETBoolUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *uint64) bool)(nil)).Elem(), iterMakerBoolUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *uint64) bool)(nil)).Elem(), iterMakerETBoolUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *float32) bool)(nil)).Elem(), iterMakerBoolFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *float32) bool)(nil)).Elem(), iterMakerETBoolFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *float64) bool)(nil)).Elem(), iterMakerBoolFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *float64) bool)(nil)).Elem(), iterMakerETBoolFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.T) bool)(nil)).Elem(), iterMakerBoolTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *typex.T) bool)(nil)).Elem(), iterMakerETBoolTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.U) bool)(nil)).Elem(), iterMakerBoolTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *typex.U) bool)(nil)).Elem(), iterMakerETBoolTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.V) bool)(nil)).Elem(), iterMakerBoolTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *typex.V) bool)(nil)).Elem(), iterMakerETBoolTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.W) bool)(nil)).Elem(), iterMakerBoolTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *typex.W) bool)(nil)).Elem(), iterMakerETBoolTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.X) bool)(nil)).Elem(), iterMakerBoolTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *typex.X) bool)(nil)).Elem(), iterMakerETBoolTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.Y) bool)(nil)).Elem(), iterMakerBoolTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *typex.Y) bool)(nil)).Elem(), iterMakerETBoolTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.Z) bool)(nil)).Elem(), iterMakerBoolTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *bool, *typex.Z) bool)(nil)).Elem(), iterMakerETBoolTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*string) bool)(nil)).Elem(), iterMakerString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string) bool)(nil)).Elem(), iterMakerETString)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *[]byte) bool)(nil)).Elem(), iterMakerStringByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *[]byte) bool)(nil)).Elem(), iterMakerETStringByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *bool) bool)(nil)).Elem(), iterMakerStringBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *bool) bool)(nil)).Elem(), iterMakerETStringBool)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *string) bool)(nil)).Elem(), iterMakerStringString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *string) bool)(nil)).Elem(), iterMakerETStringString)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *int) bool)(nil)).Elem(), iterMakerStringInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *int) bool)(nil)).Elem(), iterMakerETStringInt)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *int8) bool)(nil)).Elem(), iterMakerStringInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *int8) bool)(nil)).Elem(), iterMakerETStringInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *int16) bool)(nil)).Elem(), iterMakerStringInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *int16) bool)(nil)).Elem(), iterMakerETStringInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *int32) bool)(nil)).Elem(), iterMakerStringInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *int32) bool)(nil)).Elem(), iterMakerETStringInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *int64) bool)(nil)).Elem(), iterMakerStringInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *int64) bool)(nil)).Elem(), iterMakerETStringInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *uint) bool)(nil)).Elem(), iterMakerStringUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *uint) bool)(nil)).Elem(), iterMakerETStringUint)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *uint8) bool)(nil)).Elem(), iterMakerStringUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *uint8) bool)(nil)).Elem(), iterMakerETStringUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *uint16) bool)(nil)).Elem(), iterMakerStringUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *uint16) bool)(nil)).Elem(), iterMakerETStringUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *uint32) bool)(nil)).Elem(), iterMakerStringUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *uint32) bool)(nil)).Elem(), iterMakerETStringUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *uint64) bool)(nil)).Elem(), iterMakerStringUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *uint64) bool)(nil)).Elem(), iterMakerETStringUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *float32) bool)(nil)).Elem(), iterMakerStringFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *float32) bool)(nil)).Elem(), iterMakerETStringFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *float64) bool)(nil)).Elem(), iterMakerStringFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *float64) bool)(nil)).Elem(), iterMakerETStringFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.T) bool)(nil)).Elem(), iterMakerStringTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *typex.T) bool)(nil)).Elem(), iterMakerETStringTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.U) bool)(nil)).Elem(), iterMakerStringTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *typex.U) bool)(nil)).Elem(), iterMakerETStringTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.V) bool)(nil)).Elem(), iterMakerStringTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *typex.V) bool)(nil)).Elem(), iterMakerETStringTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.W) bool)(nil)).Elem(), iterMakerStringTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *typex.W) bool)(nil)).Elem(), iterMakerETStringTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.X) bool)(nil)).Elem(), iterMakerStringTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *typex.X) bool)(nil)).Elem(), iterMakerETStringTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.Y) bool)(nil)).Elem(), iterMakerStringTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *typex.Y) bool)(nil)).Elem(), iterMakerETStringTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.Z) bool)(nil)).Elem(), iterMakerStringTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *string, *typex.Z) bool)(nil)).Elem(), iterMakerETStringTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*int) bool)(nil)).Elem(), iterMakerInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int) bool)(nil)).Elem(), iterMakerETInt)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *[]byte) bool)(nil)).Elem(), iterMakerIntByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *[]byte) bool)(nil)).Elem(), iterMakerETIntByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *bool) bool)(nil)).Elem(), iterMakerIntBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *bool) bool)(nil)).Elem(), iterMakerETIntBool)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *string) bool)(nil)).Elem(), iterMakerIntString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *string) bool)(nil)).Elem(), iterMakerETIntString)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *int) bool)(nil)).Elem(), iterMakerIntInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *int) bool)(nil)).Elem(), iterMakerETIntInt)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *int8) bool)(nil)).Elem(), iterMakerIntInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *int8) bool)(nil)).Elem(), iterMakerETIntInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *int16) bool)(nil)).Elem(), iterMakerIntInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *int16) bool)(nil)).Elem(), iterMakerETIntInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *int32) bool)(nil)).Elem(), iterMakerIntInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *int32) bool)(nil)).Elem(), iterMakerETIntInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *int64) bool)(nil)).Elem(), iterMakerIntInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *int64) bool)(nil)).Elem(), iterMakerETIntInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *uint) bool)(nil)).Elem(), iterMakerIntUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *uint) bool)(nil)).Elem(), iterMakerETIntUint)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *uint8) bool)(nil)).Elem(), iterMakerIntUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *uint8) bool)(nil)).Elem(), iterMakerETIntUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *uint16) bool)(nil)).Elem(), iterMakerIntUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *uint16) bool)(nil)).Elem(), iterMakerETIntUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *uint32) bool)(nil)).Elem(), iterMakerIntUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *uint32) bool)(nil)).Elem(), iterMakerETIntUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *uint64) bool)(nil)).Elem(), iterMakerIntUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *uint64) bool)(nil)).Elem(), iterMakerETIntUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *float32) bool)(nil)).Elem(), iterMakerIntFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *float32) bool)(nil)).Elem(), iterMakerETIntFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *float64) bool)(nil)).Elem(), iterMakerIntFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *float64) bool)(nil)).Elem(), iterMakerETIntFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.T) bool)(nil)).Elem(), iterMakerIntTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *typex.T) bool)(nil)).Elem(), iterMakerETIntTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.U) bool)(nil)).Elem(), iterMakerIntTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *typex.U) bool)(nil)).Elem(), iterMakerETIntTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.V) bool)(nil)).Elem(), iterMakerIntTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *typex.V) bool)(nil)).Elem(), iterMakerETIntTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.W) bool)(nil)).Elem(), iterMakerIntTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *typex.W) bool)(nil)).Elem(), iterMakerETIntTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.X) bool)(nil)).Elem(), iterMakerIntTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *typex.X) bool)(nil)).Elem(), iterMakerETIntTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.Y) bool)(nil)).Elem(), iterMakerIntTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *typex.Y) bool)(nil)).Elem(), iterMakerETIntTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.Z) bool)(nil)).Elem(), iterMakerIntTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int, *typex.Z) bool)(nil)).Elem(), iterMakerETIntTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*int8) bool)(nil)).Elem(), iterMakerInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8) bool)(nil)).Elem(), iterMakerETInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *[]byte) bool)(nil)).Elem(), iterMakerInt8ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *[]byte) bool)(nil)).Elem(), iterMakerETInt8ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *bool) bool)(nil)).Elem(), iterMakerInt8Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *bool) bool)(nil)).Elem(), iterMakerETInt8Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *string) bool)(nil)).Elem(), iterMakerInt8String)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *string) bool)(nil)).Elem(), iterMakerETInt8String)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *int) bool)(nil)).Elem(), iterMakerInt8Int)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *int) bool)(nil)).Elem(), iterMakerETInt8Int)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *int8) bool)(nil)).Elem(), iterMakerInt8Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *int8) bool)(nil)).Elem(), iterMakerETInt8Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *int16) bool)(nil)).Elem(), iterMakerInt8Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *int16) bool)(nil)).Elem(), iterMakerETInt8Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *int32) bool)(nil)).Elem(), iterMakerInt8Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *int32) bool)(nil)).Elem(), iterMakerETInt8Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *int64) bool)(nil)).Elem(), iterMakerInt8Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *int64) bool)(nil)).Elem(), iterMakerETInt8Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *uint) bool)(nil)).Elem(), iterMakerInt8Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *uint) bool)(nil)).Elem(), iterMakerETInt8Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *uint8) bool)(nil)).Elem(), iterMakerInt8Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *uint8) bool)(nil)).Elem(), iterMakerETInt8Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *uint16) bool)(nil)).Elem(), iterMakerInt8Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *uint16) bool)(nil)).Elem(), iterMakerETInt8Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *uint32) bool)(nil)).Elem(), iterMakerInt8Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *uint32) bool)(nil)).Elem(), iterMakerETInt8Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *uint64) bool)(nil)).Elem(), iterMakerInt8Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *uint64) bool)(nil)).Elem(), iterMakerETInt8Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *float32) bool)(nil)).Elem(), iterMakerInt8Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *float32) bool)(nil)).Elem(), iterMakerETInt8Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *float64) bool)(nil)).Elem(), iterMakerInt8Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *float64) bool)(nil)).Elem(), iterMakerETInt8Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.T) bool)(nil)).Elem(), iterMakerInt8Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *typex.T) bool)(nil)).Elem(), iterMakerETInt8Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.U) bool)(nil)).Elem(), iterMakerInt8Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *typex.U) bool)(nil)).Elem(), iterMakerETInt8Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.V) bool)(nil)).Elem(), iterMakerInt8Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *typex.V) bool)(nil)).Elem(), iterMakerETInt8Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.W) bool)(nil)).Elem(), iterMakerInt8Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *typex.W) bool)(nil)).Elem(), iterMakerETInt8Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.X) bool)(nil)).Elem(), iterMakerInt8Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *typex.X) bool)(nil)).Elem(), iterMakerETInt8Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.Y) bool)(nil)).Elem(), iterMakerInt8Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *typex.Y) bool)(nil)).Elem(), iterMakerETInt8Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.Z) bool)(nil)).Elem(), iterMakerInt8Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int8, *typex.Z) bool)(nil)).Elem(), iterMakerETInt8Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*int16) bool)(nil)).Elem(), iterMakerInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16) bool)(nil)).Elem(), iterMakerETInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *[]byte) bool)(nil)).Elem(), iterMakerInt16ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *[]byte) bool)(nil)).Elem(), iterMakerETInt16ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *bool) bool)(nil)).Elem(), iterMakerInt16Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *bool) bool)(nil)).Elem(), iterMakerETInt16Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *string) bool)(nil)).Elem(), iterMakerInt16String)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *string) bool)(nil)).Elem(), iterMakerETInt16String)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *int) bool)(nil)).Elem(), iterMakerInt16Int)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *int) bool)(nil)).Elem(), iterMakerETInt16Int)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *int8) bool)(nil)).Elem(), iterMakerInt16Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *int8) bool)(nil)).Elem(), iterMakerETInt16Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *int16) bool)(nil)).Elem(), iterMakerInt16Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *int16) bool)(nil)).Elem(), iterMakerETInt16Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *int32) bool)(nil)).Elem(), iterMakerInt16Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *int32) bool)(nil)).Elem(), iterMakerETInt16Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *int64) bool)(nil)).Elem(), iterMakerInt16Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *int64) bool)(nil)).Elem(), iterMakerETInt16Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *uint) bool)(nil)).Elem(), iterMakerInt16Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *uint) bool)(nil)).Elem(), iterMakerETInt16Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *uint8) bool)(nil)).Elem(), iterMakerInt16Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *uint8) bool)(nil)).Elem(), iterMakerETInt16Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *uint16) bool)(nil)).Elem(), iterMakerInt16Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *uint16) bool)(nil)).Elem(), iterMakerETInt16Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *uint32) bool)(nil)).Elem(), iterMakerInt16Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *uint32) bool)(nil)).Elem(), iterMakerETInt16Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *uint64) bool)(nil)).Elem(), iterMakerInt16Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *uint64) bool)(nil)).Elem(), iterMakerETInt16Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *float32) bool)(nil)).Elem(), iterMakerInt16Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *float32) bool)(nil)).Elem(), iterMakerETInt16Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *float64) bool)(nil)).Elem(), iterMakerInt16Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *float64) bool)(nil)).Elem(), iterMakerETInt16Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.T) bool)(nil)).Elem(), iterMakerInt16Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *typex.T) bool)(nil)).Elem(), iterMakerETInt16Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.U) bool)(nil)).Elem(), iterMakerInt16Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *typex.U) bool)(nil)).Elem(), iterMakerETInt16Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.V) bool)(nil)).Elem(), iterMakerInt16Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *typex.V) bool)(nil)).Elem(), iterMakerETInt16Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.W) bool)(nil)).Elem(), iterMakerInt16Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *typex.W) bool)(nil)).Elem(), iterMakerETInt16Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.X) bool)(nil)).Elem(), iterMakerInt16Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *typex.X) bool)(nil)).Elem(), iterMakerETInt16Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.Y) bool)(nil)).Elem(), iterMakerInt16Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *typex.Y) bool)(nil)).Elem(), iterMakerETInt16Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.Z) bool)(nil)).Elem(), iterMakerInt16Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int16, *typex.Z) bool)(nil)).Elem(), iterMakerETInt16Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*int32) bool)(nil)).Elem(), iterMakerInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32) bool)(nil)).Elem(), iterMakerETInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *[]byte) bool)(nil)).Elem(), iterMakerInt32ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *[]byte) bool)(nil)).Elem(), iterMakerETInt32ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *bool) bool)(nil)).Elem(), iterMakerInt32Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *bool) bool)(nil)).Elem(), iterMakerETInt32Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *string) bool)(nil)).Elem(), iterMakerInt32String)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *string) bool)(nil)).Elem(), iterMakerETInt32String)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *int) bool)(nil)).Elem(), iterMakerInt32Int)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *int) bool)(nil)).Elem(), iterMakerETInt32Int)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *int8) bool)(nil)).Elem(), iterMakerInt32Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *int8) bool)(nil)).Elem(), iterMakerETInt32Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *int16) bool)(nil)).Elem(), iterMakerInt32Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *int16) bool)(nil)).Elem(), iterMakerETInt32Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *int32) bool)(nil)).Elem(), iterMakerInt32Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *int32) bool)(nil)).Elem(), iterMakerETInt32Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *int64) bool)(nil)).Elem(), iterMakerInt32Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *int64) bool)(nil)).Elem(), iterMakerETInt32Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *uint) bool)(nil)).Elem(), iterMakerInt32Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *uint) bool)(nil)).Elem(), iterMakerETInt32Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *uint8) bool)(nil)).Elem(), iterMakerInt32Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *uint8) bool)(nil)).Elem(), iterMakerETInt32Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *uint16) bool)(nil)).Elem(), iterMakerInt32Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *uint16) bool)(nil)).Elem(), iterMakerETInt32Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *uint32) bool)(nil)).Elem(), iterMakerInt32Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *uint32) bool)(nil)).Elem(), iterMakerETInt32Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *uint64) bool)(nil)).Elem(), iterMakerInt32Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *uint64) bool)(nil)).Elem(), iterMakerETInt32Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *float32) bool)(nil)).Elem(), iterMakerInt32Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *float32) bool)(nil)).Elem(), iterMakerETInt32Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *float64) bool)(nil)).Elem(), iterMakerInt32Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *float64) bool)(nil)).Elem(), iterMakerETInt32Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.T) bool)(nil)).Elem(), iterMakerInt32Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *typex.T) bool)(nil)).Elem(), iterMakerETInt32Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.U) bool)(nil)).Elem(), iterMakerInt32Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *typex.U) bool)(nil)).Elem(), iterMakerETInt32Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.V) bool)(nil)).Elem(), iterMakerInt32Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *typex.V) bool)(nil)).Elem(), iterMakerETInt32Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.W) bool)(nil)).Elem(), iterMakerInt32Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *typex.W) bool)(nil)).Elem(), iterMakerETInt32Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.X) bool)(nil)).Elem(), iterMakerInt32Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *typex.X) bool)(nil)).Elem(), iterMakerETInt32Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.Y) bool)(nil)).Elem(), iterMakerInt32Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *typex.Y) bool)(nil)).Elem(), iterMakerETInt32Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.Z) bool)(nil)).Elem(), iterMakerInt32Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int32, *typex.Z) bool)(nil)).Elem(), iterMakerETInt32Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*int64) bool)(nil)).Elem(), iterMakerInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64) bool)(nil)).Elem(), iterMakerETInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *[]byte) bool)(nil)).Elem(), iterMakerInt64ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *[]byte) bool)(nil)).Elem(), iterMakerETInt64ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *bool) bool)(nil)).Elem(), iterMakerInt64Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *bool) bool)(nil)).Elem(), iterMakerETInt64Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *string) bool)(nil)).Elem(), iterMakerInt64String)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *string) bool)(nil)).Elem(), iterMakerETInt64String)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *int) bool)(nil)).Elem(), iterMakerInt64Int)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *int) bool)(nil)).Elem(), iterMakerETInt64Int)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *int8) bool)(nil)).Elem(), iterMakerInt64Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *int8) bool)(nil)).Elem(), iterMakerETInt64Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *int16) bool)(nil)).Elem(), iterMakerInt64Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *int16) bool)(nil)).Elem(), iterMakerETInt64Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *int32) bool)(nil)).Elem(), iterMakerInt64Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *int32) bool)(nil)).Elem(), iterMakerETInt64Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *int64) bool)(nil)).Elem(), iterMakerInt64Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *int64) bool)(nil)).Elem(), iterMakerETInt64Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *uint) bool)(nil)).Elem(), iterMakerInt64Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *uint) bool)(nil)).Elem(), iterMakerETInt64Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *uint8) bool)(nil)).Elem(), iterMakerInt64Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *uint8) bool)(nil)).Elem(), iterMakerETInt64Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *uint16) bool)(nil)).Elem(), iterMakerInt64Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *uint16) bool)(nil)).Elem(), iterMakerETInt64Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *uint32) bool)(nil)).Elem(), iterMakerInt64Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *uint32) bool)(nil)).Elem(), iterMakerETInt64Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *uint64) bool)(nil)).Elem(), iterMakerInt64Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *uint64) bool)(nil)).Elem(), iterMakerETInt64Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *float32) bool)(nil)).Elem(), iterMakerInt64Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *float32) bool)(nil)).Elem(), iterMakerETInt64Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *float64) bool)(nil)).Elem(), iterMakerInt64Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *float64) bool)(nil)).Elem(), iterMakerETInt64Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.T) bool)(nil)).Elem(), iterMakerInt64Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *typex.T) bool)(nil)).Elem(), iterMakerETInt64Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.U) bool)(nil)).Elem(), iterMakerInt64Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *typex.U) bool)(nil)).Elem(), iterMakerETInt64Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.V) bool)(nil)).Elem(), iterMakerInt64Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *typex.V) bool)(nil)).Elem(), iterMakerETInt64Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.W) bool)(nil)).Elem(), iterMakerInt64Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *typex.W) bool)(nil)).Elem(), iterMakerETInt64Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.X) bool)(nil)).Elem(), iterMakerInt64Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *typex.X) bool)(nil)).Elem(), iterMakerETInt64Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.Y) bool)(nil)).Elem(), iterMakerInt64Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *typex.Y) bool)(nil)).Elem(), iterMakerETInt64Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.Z) bool)(nil)).Elem(), iterMakerInt64Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *int64, *typex.Z) bool)(nil)).Elem(), iterMakerETInt64Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*uint) bool)(nil)).Elem(), iterMakerUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint) bool)(nil)).Elem(), iterMakerETUint)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *[]byte) bool)(nil)).Elem(), iterMakerUintByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *[]byte) bool)(nil)).Elem(), iterMakerETUintByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *bool) bool)(nil)).Elem(), iterMakerUintBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *bool) bool)(nil)).Elem(), iterMakerETUintBool)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *string) bool)(nil)).Elem(), iterMakerUintString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *string) bool)(nil)).Elem(), iterMakerETUintString)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *int) bool)(nil)).Elem(), iterMakerUintInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *int) bool)(nil)).Elem(), iterMakerETUintInt)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *int8) bool)(nil)).Elem(), iterMakerUintInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *int8) bool)(nil)).Elem(), iterMakerETUintInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *int16) bool)(nil)).Elem(), iterMakerUintInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *int16) bool)(nil)).Elem(), iterMakerETUintInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *int32) bool)(nil)).Elem(), iterMakerUintInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *int32) bool)(nil)).Elem(), iterMakerETUintInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *int64) bool)(nil)).Elem(), iterMakerUintInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *int64) bool)(nil)).Elem(), iterMakerETUintInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *uint) bool)(nil)).Elem(), iterMakerUintUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *uint) bool)(nil)).Elem(), iterMakerETUintUint)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *uint8) bool)(nil)).Elem(), iterMakerUintUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *uint8) bool)(nil)).Elem(), iterMakerETUintUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *uint16) bool)(nil)).Elem(), iterMakerUintUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *uint16) bool)(nil)).Elem(), iterMakerETUintUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *uint32) bool)(nil)).Elem(), iterMakerUintUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *uint32) bool)(nil)).Elem(), iterMakerETUintUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *uint64) bool)(nil)).Elem(), iterMakerUintUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *uint64) bool)(nil)).Elem(), iterMakerETUintUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *float32) bool)(nil)).Elem(), iterMakerUintFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *float32) bool)(nil)).Elem(), iterMakerETUintFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *float64) bool)(nil)).Elem(), iterMakerUintFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *float64) bool)(nil)).Elem(), iterMakerETUintFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.T) bool)(nil)).Elem(), iterMakerUintTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *typex.T) bool)(nil)).Elem(), iterMakerETUintTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.U) bool)(nil)).Elem(), iterMakerUintTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *typex.U) bool)(nil)).Elem(), iterMakerETUintTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.V) bool)(nil)).Elem(), iterMakerUintTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *typex.V) bool)(nil)).Elem(), iterMakerETUintTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.W) bool)(nil)).Elem(), iterMakerUintTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *typex.W) bool)(nil)).Elem(), iterMakerETUintTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.X) bool)(nil)).Elem(), iterMakerUintTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *typex.X) bool)(nil)).Elem(), iterMakerETUintTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.Y) bool)(nil)).Elem(), iterMakerUintTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *typex.Y) bool)(nil)).Elem(), iterMakerETUintTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.Z) bool)(nil)).Elem(), iterMakerUintTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint, *typex.Z) bool)(nil)).Elem(), iterMakerETUintTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8) bool)(nil)).Elem(), iterMakerUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8) bool)(nil)).Elem(), iterMakerETUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *[]byte) bool)(nil)).Elem(), iterMakerUint8ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *[]byte) bool)(nil)).Elem(), iterMakerETUint8ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *bool) bool)(nil)).Elem(), iterMakerUint8Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *bool) bool)(nil)).Elem(), iterMakerETUint8Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *string) bool)(nil)).Elem(), iterMakerUint8String)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *string) bool)(nil)).Elem(), iterMakerETUint8String)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *int) bool)(nil)).Elem(), iterMakerUint8Int)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *int) bool)(nil)).Elem(), iterMakerETUint8Int)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *int8) bool)(nil)).Elem(), iterMakerUint8Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *int8) bool)(nil)).Elem(), iterMakerETUint8Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *int16) bool)(nil)).Elem(), iterMakerUint8Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *int16) bool)(nil)).Elem(), iterMakerETUint8Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *int32) bool)(nil)).Elem(), iterMakerUint8Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *int32) bool)(nil)).Elem(), iterMakerETUint8Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *int64) bool)(nil)).Elem(), iterMakerUint8Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *int64) bool)(nil)).Elem(), iterMakerETUint8Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *uint) bool)(nil)).Elem(), iterMakerUint8Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *uint) bool)(nil)).Elem(), iterMakerETUint8Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *uint8) bool)(nil)).Elem(), iterMakerUint8Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *uint8) bool)(nil)).Elem(), iterMakerETUint8Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *uint16) bool)(nil)).Elem(), iterMakerUint8Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *uint16) bool)(nil)).Elem(), iterMakerETUint8Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *uint32) bool)(nil)).Elem(), iterMakerUint8Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *uint32) bool)(nil)).Elem(), iterMakerETUint8Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *uint64) bool)(nil)).Elem(), iterMakerUint8Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *uint64) bool)(nil)).Elem(), iterMakerETUint8Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *float32) bool)(nil)).Elem(), iterMakerUint8Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *float32) bool)(nil)).Elem(), iterMakerETUint8Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *float64) bool)(nil)).Elem(), iterMakerUint8Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *float64) bool)(nil)).Elem(), iterMakerETUint8Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.T) bool)(nil)).Elem(), iterMakerUint8Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *typex.T) bool)(nil)).Elem(), iterMakerETUint8Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.U) bool)(nil)).Elem(), iterMakerUint8Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *typex.U) bool)(nil)).Elem(), iterMakerETUint8Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.V) bool)(nil)).Elem(), iterMakerUint8Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *typex.V) bool)(nil)).Elem(), iterMakerETUint8Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.W) bool)(nil)).Elem(), iterMakerUint8Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *typex.W) bool)(nil)).Elem(), iterMakerETUint8Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.X) bool)(nil)).Elem(), iterMakerUint8Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *typex.X) bool)(nil)).Elem(), iterMakerETUint8Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.Y) bool)(nil)).Elem(), iterMakerUint8Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *typex.Y) bool)(nil)).Elem(), iterMakerETUint8Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.Z) bool)(nil)).Elem(), iterMakerUint8Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint8, *typex.Z) bool)(nil)).Elem(), iterMakerETUint8Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16) bool)(nil)).Elem(), iterMakerUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16) bool)(nil)).Elem(), iterMakerETUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *[]byte) bool)(nil)).Elem(), iterMakerUint16ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *[]byte) bool)(nil)).Elem(), iterMakerETUint16ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *bool) bool)(nil)).Elem(), iterMakerUint16Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *bool) bool)(nil)).Elem(), iterMakerETUint16Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *string) bool)(nil)).Elem(), iterMakerUint16String)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *string) bool)(nil)).Elem(), iterMakerETUint16String)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *int) bool)(nil)).Elem(), iterMakerUint16Int)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *int) bool)(nil)).Elem(), iterMakerETUint16Int)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *int8) bool)(nil)).Elem(), iterMakerUint16Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *int8) bool)(nil)).Elem(), iterMakerETUint16Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *int16) bool)(nil)).Elem(), iterMakerUint16Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *int16) bool)(nil)).Elem(), iterMakerETUint16Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *int32) bool)(nil)).Elem(), iterMakerUint16Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *int32) bool)(nil)).Elem(), iterMakerETUint16Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *int64) bool)(nil)).Elem(), iterMakerUint16Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *int64) bool)(nil)).Elem(), iterMakerETUint16Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *uint) bool)(nil)).Elem(), iterMakerUint16Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *uint) bool)(nil)).Elem(), iterMakerETUint16Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *uint8) bool)(nil)).Elem(), iterMakerUint16Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *uint8) bool)(nil)).Elem(), iterMakerETUint16Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *uint16) bool)(nil)).Elem(), iterMakerUint16Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *uint16) bool)(nil)).Elem(), iterMakerETUint16Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *uint32) bool)(nil)).Elem(), iterMakerUint16Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *uint32) bool)(nil)).Elem(), iterMakerETUint16Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *uint64) bool)(nil)).Elem(), iterMakerUint16Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *uint64) bool)(nil)).Elem(), iterMakerETUint16Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *float32) bool)(nil)).Elem(), iterMakerUint16Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *float32) bool)(nil)).Elem(), iterMakerETUint16Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *float64) bool)(nil)).Elem(), iterMakerUint16Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *float64) bool)(nil)).Elem(), iterMakerETUint16Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.T) bool)(nil)).Elem(), iterMakerUint16Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *typex.T) bool)(nil)).Elem(), iterMakerETUint16Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.U) bool)(nil)).Elem(), iterMakerUint16Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *typex.U) bool)(nil)).Elem(), iterMakerETUint16Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.V) bool)(nil)).Elem(), iterMakerUint16Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *typex.V) bool)(nil)).Elem(), iterMakerETUint16Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.W) bool)(nil)).Elem(), iterMakerUint16Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *typex.W) bool)(nil)).Elem(), iterMakerETUint16Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.X) bool)(nil)).Elem(), iterMakerUint16Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *typex.X) bool)(nil)).Elem(), iterMakerETUint16Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.Y) bool)(nil)).Elem(), iterMakerUint16Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *typex.Y) bool)(nil)).Elem(), iterMakerETUint16Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.Z) bool)(nil)).Elem(), iterMakerUint16Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint16, *typex.Z) bool)(nil)).Elem(), iterMakerETUint16Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32) bool)(nil)).Elem(), iterMakerUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32) bool)(nil)).Elem(), iterMakerETUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *[]byte) bool)(nil)).Elem(), iterMakerUint32ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *[]byte) bool)(nil)).Elem(), iterMakerETUint32ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *bool) bool)(nil)).Elem(), iterMakerUint32Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *bool) bool)(nil)).Elem(), iterMakerETUint32Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *string) bool)(nil)).Elem(), iterMakerUint32String)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *string) bool)(nil)).Elem(), iterMakerETUint32String)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *int) bool)(nil)).Elem(), iterMakerUint32Int)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *int) bool)(nil)).Elem(), iterMakerETUint32Int)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *int8) bool)(nil)).Elem(), iterMakerUint32Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *int8) bool)(nil)).Elem(), iterMakerETUint32Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *int16) bool)(nil)).Elem(), iterMakerUint32Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *int16) bool)(nil)).Elem(), iterMakerETUint32Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *int32) bool)(nil)).Elem(), iterMakerUint32Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *int32) bool)(nil)).Elem(), iterMakerETUint32Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *int64) bool)(nil)).Elem(), iterMakerUint32Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *int64) bool)(nil)).Elem(), iterMakerETUint32Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *uint) bool)(nil)).Elem(), iterMakerUint32Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *uint) bool)(nil)).Elem(), iterMakerETUint32Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *uint8) bool)(nil)).Elem(), iterMakerUint32Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *uint8) bool)(nil)).Elem(), iterMakerETUint32Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *uint16) bool)(nil)).Elem(), iterMakerUint32Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *uint16) bool)(nil)).Elem(), iterMakerETUint32Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *uint32) bool)(nil)).Elem(), iterMakerUint32Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *uint32) bool)(nil)).Elem(), iterMakerETUint32Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *uint64) bool)(nil)).Elem(), iterMakerUint32Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *uint64) bool)(nil)).Elem(), iterMakerETUint32Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *float32) bool)(nil)).Elem(), iterMakerUint32Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *float32) bool)(nil)).Elem(), iterMakerETUint32Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *float64) bool)(nil)).Elem(), iterMakerUint32Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *float64) bool)(nil)).Elem(), iterMakerETUint32Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.T) bool)(nil)).Elem(), iterMakerUint32Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *typex.T) bool)(nil)).Elem(), iterMakerETUint32Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.U) bool)(nil)).Elem(), iterMakerUint32Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *typex.U) bool)(nil)).Elem(), iterMakerETUint32Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.V) bool)(nil)).Elem(), iterMakerUint32Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *typex.V) bool)(nil)).Elem(), iterMakerETUint32Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.W) bool)(nil)).Elem(), iterMakerUint32Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *typex.W) bool)(nil)).Elem(), iterMakerETUint32Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.X) bool)(nil)).Elem(), iterMakerUint32Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *typex.X) bool)(nil)).Elem(), iterMakerETUint32Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.Y) bool)(nil)).Elem(), iterMakerUint32Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *typex.Y) bool)(nil)).Elem(), iterMakerETUint32Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.Z) bool)(nil)).Elem(), iterMakerUint32Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint32, *typex.Z) bool)(nil)).Elem(), iterMakerETUint32Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64) bool)(nil)).Elem(), iterMakerUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64) bool)(nil)).Elem(), iterMakerETUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *[]byte) bool)(nil)).Elem(), iterMakerUint64ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *[]byte) bool)(nil)).Elem(), iterMakerETUint64ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *bool) bool)(nil)).Elem(), iterMakerUint64Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *bool) bool)(nil)).Elem(), iterMakerETUint64Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *string) bool)(nil)).Elem(), iterMakerUint64String)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *string) bool)(nil)).Elem(), iterMakerETUint64String)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *int) bool)(nil)).Elem(), iterMakerUint64Int)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *int) bool)(nil)).Elem(), iterMakerETUint64Int)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *int8) bool)(nil)).Elem(), iterMakerUint64Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *int8) bool)(nil)).Elem(), iterMakerETUint64Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *int16) bool)(nil)).Elem(), iterMakerUint64Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *int16) bool)(nil)).Elem(), iterMakerETUint64Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *int32) bool)(nil)).Elem(), iterMakerUint64Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *int32) bool)(nil)).Elem(), iterMakerETUint64Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *int64) bool)(nil)).Elem(), iterMakerUint64Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *int64) bool)(nil)).Elem(), iterMakerETUint64Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *uint) bool)(nil)).Elem(), iterMakerUint64Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *uint) bool)(nil)).Elem(), iterMakerETUint64Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *uint8) bool)(nil)).Elem(), iterMakerUint64Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *uint8) bool)(nil)).Elem(), iterMakerETUint64Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *uint16) bool)(nil)).Elem(), iterMakerUint64Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *uint16) bool)(nil)).Elem(), iterMakerETUint64Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *uint32) bool)(nil)).Elem(), iterMakerUint64Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *uint32) bool)(nil)).Elem(), iterMakerETUint64Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *uint64) bool)(nil)).Elem(), iterMakerUint64Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *uint64) bool)(nil)).Elem(), iterMakerETUint64Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *float32) bool)(nil)).Elem(), iterMakerUint64Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *float32) bool)(nil)).Elem(), iterMakerETUint64Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *float64) bool)(nil)).Elem(), iterMakerUint64Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *float64) bool)(nil)).Elem(), iterMakerETUint64Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.T) bool)(nil)).Elem(), iterMakerUint64Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *typex.T) bool)(nil)).Elem(), iterMakerETUint64Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.U) bool)(nil)).Elem(), iterMakerUint64Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *typex.U) bool)(nil)).Elem(), iterMakerETUint64Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.V) bool)(nil)).Elem(), iterMakerUint64Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *typex.V) bool)(nil)).Elem(), iterMakerETUint64Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.W) bool)(nil)).Elem(), iterMakerUint64Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *typex.W) bool)(nil)).Elem(), iterMakerETUint64Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.X) bool)(nil)).Elem(), iterMakerUint64Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *typex.X) bool)(nil)).Elem(), iterMakerETUint64Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.Y) bool)(nil)).Elem(), iterMakerUint64Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *typex.Y) bool)(nil)).Elem(), iterMakerETUint64Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.Z) bool)(nil)).Elem(), iterMakerUint64Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *uint64, *typex.Z) bool)(nil)).Elem(), iterMakerETUint64Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*float32) bool)(nil)).Elem(), iterMakerFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32) bool)(nil)).Elem(), iterMakerETFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *[]byte) bool)(nil)).Elem(), iterMakerFloat32ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *[]byte) bool)(nil)).Elem(), iterMakerETFloat32ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *bool) bool)(nil)).Elem(), iterMakerFloat32Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *bool) bool)(nil)).Elem(), iterMakerETFloat32Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *string) bool)(nil)).Elem(), iterMakerFloat32String)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *string) bool)(nil)).Elem(), iterMakerETFloat32String)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *int) bool)(nil)).Elem(), iterMakerFloat32Int)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *int) bool)(nil)).Elem(), iterMakerETFloat32Int)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *int8) bool)(nil)).Elem(), iterMakerFloat32Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *int8) bool)(nil)).Elem(), iterMakerETFloat32Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *int16) bool)(nil)).Elem(), iterMakerFloat32Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *int16) bool)(nil)).Elem(), iterMakerETFloat32Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *int32) bool)(nil)).Elem(), iterMakerFloat32Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *int32) bool)(nil)).Elem(), iterMakerETFloat32Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *int64) bool)(nil)).Elem(), iterMakerFloat32Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *int64) bool)(nil)).Elem(), iterMakerETFloat32Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *uint) bool)(nil)).Elem(), iterMakerFloat32Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *uint) bool)(nil)).Elem(), iterMakerETFloat32Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *uint8) bool)(nil)).Elem(), iterMakerFloat32Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *uint8) bool)(nil)).Elem(), iterMakerETFloat32Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *uint16) bool)(nil)).Elem(), iterMakerFloat32Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *uint16) bool)(nil)).Elem(), iterMakerETFloat32Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *uint32) bool)(nil)).Elem(), iterMakerFloat32Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *uint32) bool)(nil)).Elem(), iterMakerETFloat32Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *uint64) bool)(nil)).Elem(), iterMakerFloat32Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *uint64) bool)(nil)).Elem(), iterMakerETFloat32Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *float32) bool)(nil)).Elem(), iterMakerFloat32Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *float32) bool)(nil)).Elem(), iterMakerETFloat32Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *float64) bool)(nil)).Elem(), iterMakerFloat32Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *float64) bool)(nil)).Elem(), iterMakerETFloat32Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.T) bool)(nil)).Elem(), iterMakerFloat32Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *typex.T) bool)(nil)).Elem(), iterMakerETFloat32Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.U) bool)(nil)).Elem(), iterMakerFloat32Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *typex.U) bool)(nil)).Elem(), iterMakerETFloat32Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.V) bool)(nil)).Elem(), iterMakerFloat32Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *typex.V) bool)(nil)).Elem(), iterMakerETFloat32Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.W) bool)(nil)).Elem(), iterMakerFloat32Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *typex.W) bool)(nil)).Elem(), iterMakerETFloat32Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.X) bool)(nil)).Elem(), iterMakerFloat32Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *typex.X) bool)(nil)).Elem(), iterMakerETFloat32Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.Y) bool)(nil)).Elem(), iterMakerFloat32Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *typex.Y) bool)(nil)).Elem(), iterMakerETFloat32Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.Z) bool)(nil)).Elem(), iterMakerFloat32Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float32, *typex.Z) bool)(nil)).Elem(), iterMakerETFloat32Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*float64) bool)(nil)).Elem(), iterMakerFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64) bool)(nil)).Elem(), iterMakerETFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *[]byte) bool)(nil)).Elem(), iterMakerFloat64ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *[]byte) bool)(nil)).Elem(), iterMakerETFloat64ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *bool) bool)(nil)).Elem(), iterMakerFloat64Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *bool) bool)(nil)).Elem(), iterMakerETFloat64Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *string) bool)(nil)).Elem(), iterMakerFloat64String)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *string) bool)(nil)).Elem(), iterMakerETFloat64String)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *int) bool)(nil)).Elem(), iterMakerFloat64Int)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *int) bool)(nil)).Elem(), iterMakerETFloat64Int)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *int8) bool)(nil)).Elem(), iterMakerFloat64Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *int8) bool)(nil)).Elem(), iterMakerETFloat64Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *int16) bool)(nil)).Elem(), iterMakerFloat64Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *int16) bool)(nil)).Elem(), iterMakerETFloat64Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *int32) bool)(nil)).Elem(), iterMakerFloat64Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *int32) bool)(nil)).Elem(), iterMakerETFloat64Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *int64) bool)(nil)).Elem(), iterMakerFloat64Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *int64) bool)(nil)).Elem(), iterMakerETFloat64Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *uint) bool)(nil)).Elem(), iterMakerFloat64Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *uint) bool)(nil)).Elem(), iterMakerETFloat64Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *uint8) bool)(nil)).Elem(), iterMakerFloat64Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *uint8) bool)(nil)).Elem(), iterMakerETFloat64Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *uint16) bool)(nil)).Elem(), iterMakerFloat64Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *uint16) bool)(nil)).Elem(), iterMakerETFloat64Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *uint32) bool)(nil)).Elem(), iterMakerFloat64Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *uint32) bool)(nil)).Elem(), iterMakerETFloat64Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *uint64) bool)(nil)).Elem(), iterMakerFloat64Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *uint64) bool)(nil)).Elem(), iterMakerETFloat64Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *float32) bool)(nil)).Elem(), iterMakerFloat64Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *float32) bool)(nil)).Elem(), iterMakerETFloat64Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *float64) bool)(nil)).Elem(), iterMakerFloat64Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *float64) bool)(nil)).Elem(), iterMakerETFloat64Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.T) bool)(nil)).Elem(), iterMakerFloat64Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *typex.T) bool)(nil)).Elem(), iterMakerETFloat64Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.U) bool)(nil)).Elem(), iterMakerFloat64Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *typex.U) bool)(nil)).Elem(), iterMakerETFloat64Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.V) bool)(nil)).Elem(), iterMakerFloat64Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *typex.V) bool)(nil)).Elem(), iterMakerETFloat64Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.W) bool)(nil)).Elem(), iterMakerFloat64Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *typex.W) bool)(nil)).Elem(), iterMakerETFloat64Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.X) bool)(nil)).Elem(), iterMakerFloat64Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *typex.X) bool)(nil)).Elem(), iterMakerETFloat64Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.Y) bool)(nil)).Elem(), iterMakerFloat64Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *typex.Y) bool)(nil)).Elem(), iterMakerETFloat64Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.Z) bool)(nil)).Elem(), iterMakerFloat64Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *float64, *typex.Z) bool)(nil)).Elem(), iterMakerETFloat64Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T) bool)(nil)).Elem(), iterMakerTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T) bool)(nil)).Elem(), iterMakerETTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *[]byte) bool)(nil)).Elem(), iterMakerTypex_TByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *[]byte) bool)(nil)).Elem(), iterMakerETTypex_TByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *bool) bool)(nil)).Elem(), iterMakerTypex_TBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *bool) bool)(nil)).Elem(), iterMakerETTypex_TBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *string) bool)(nil)).Elem(), iterMakerTypex_TString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *string) bool)(nil)).Elem(), iterMakerETTypex_TString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *int) bool)(nil)).Elem(), iterMakerTypex_TInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *int) bool)(nil)).Elem(), iterMakerETTypex_TInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *int8) bool)(nil)).Elem(), iterMakerTypex_TInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *int8) bool)(nil)).Elem(), iterMakerETTypex_TInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *int16) bool)(nil)).Elem(), iterMakerTypex_TInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *int16) bool)(nil)).Elem(), iterMakerETTypex_TInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *int32) bool)(nil)).Elem(), iterMakerTypex_TInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *int32) bool)(nil)).Elem(), iterMakerETTypex_TInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *int64) bool)(nil)).Elem(), iterMakerTypex_TInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *int64) bool)(nil)).Elem(), iterMakerETTypex_TInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *uint) bool)(nil)).Elem(), iterMakerTypex_TUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *uint) bool)(nil)).Elem(), iterMakerETTypex_TUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *uint8) bool)(nil)).Elem(), iterMakerTypex_TUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *uint8) bool)(nil)).Elem(), iterMakerETTypex_TUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *uint16) bool)(nil)).Elem(), iterMakerTypex_TUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *uint16) bool)(nil)).Elem(), iterMakerETTypex_TUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *uint32) bool)(nil)).Elem(), iterMakerTypex_TUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *uint32) bool)(nil)).Elem(), iterMakerETTypex_TUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *uint64) bool)(nil)).Elem(), iterMakerTypex_TUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *uint64) bool)(nil)).Elem(), iterMakerETTypex_TUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *float32) bool)(nil)).Elem(), iterMakerTypex_TFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *float32) bool)(nil)).Elem(), iterMakerETTypex_TFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *float64) bool)(nil)).Elem(), iterMakerTypex_TFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *float64) bool)(nil)).Elem(), iterMakerETTypex_TFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.T) bool)(nil)).Elem(), iterMakerTypex_TTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *typex.T) bool)(nil)).Elem(), iterMakerETTypex_TTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.U) bool)(nil)).Elem(), iterMakerTypex_TTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *typex.U) bool)(nil)).Elem(), iterMakerETTypex_TTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.V) bool)(nil)).Elem(), iterMakerTypex_TTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *typex.V) bool)(nil)).Elem(), iterMakerETTypex_TTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.W) bool)(nil)).Elem(), iterMakerTypex_TTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *typex.W) bool)(nil)).Elem(), iterMakerETTypex_TTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.X) bool)(nil)).Elem(), iterMakerTypex_TTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *typex.X) bool)(nil)).Elem(), iterMakerETTypex_TTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_TTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *typex.Y) bool)(nil)).Elem(), iterMakerETTypex_TTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_TTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.T, *typex.Z) bool)(nil)).Elem(), iterMakerETTypex_TTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U) bool)(nil)).Elem(), iterMakerTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U) bool)(nil)).Elem(), iterMakerETTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *[]byte) bool)(nil)).Elem(), iterMakerTypex_UByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *[]byte) bool)(nil)).Elem(), iterMakerETTypex_UByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *bool) bool)(nil)).Elem(), iterMakerTypex_UBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *bool) bool)(nil)).Elem(), iterMakerETTypex_UBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *string) bool)(nil)).Elem(), iterMakerTypex_UString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *string) bool)(nil)).Elem(), iterMakerETTypex_UString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *int) bool)(nil)).Elem(), iterMakerTypex_UInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *int) bool)(nil)).Elem(), iterMakerETTypex_UInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *int8) bool)(nil)).Elem(), iterMakerTypex_UInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *int8) bool)(nil)).Elem(), iterMakerETTypex_UInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *int16) bool)(nil)).Elem(), iterMakerTypex_UInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *int16) bool)(nil)).Elem(), iterMakerETTypex_UInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *int32) bool)(nil)).Elem(), iterMakerTypex_UInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *int32) bool)(nil)).Elem(), iterMakerETTypex_UInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *int64) bool)(nil)).Elem(), iterMakerTypex_UInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *int64) bool)(nil)).Elem(), iterMakerETTypex_UInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *uint) bool)(nil)).Elem(), iterMakerTypex_UUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *uint) bool)(nil)).Elem(), iterMakerETTypex_UUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *uint8) bool)(nil)).Elem(), iterMakerTypex_UUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *uint8) bool)(nil)).Elem(), iterMakerETTypex_UUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *uint16) bool)(nil)).Elem(), iterMakerTypex_UUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *uint16) bool)(nil)).Elem(), iterMakerETTypex_UUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *uint32) bool)(nil)).Elem(), iterMakerTypex_UUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *uint32) bool)(nil)).Elem(), iterMakerETTypex_UUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *uint64) bool)(nil)).Elem(), iterMakerTypex_UUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *uint64) bool)(nil)).Elem(), iterMakerETTypex_UUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *float32) bool)(nil)).Elem(), iterMakerTypex_UFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *float32) bool)(nil)).Elem(), iterMakerETTypex_UFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *float64) bool)(nil)).Elem(), iterMakerTypex_UFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *float64) bool)(nil)).Elem(), iterMakerETTypex_UFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.T) bool)(nil)).Elem(), iterMakerTypex_UTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *typex.T) bool)(nil)).Elem(), iterMakerETTypex_UTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.U) bool)(nil)).Elem(), iterMakerTypex_UTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *typex.U) bool)(nil)).Elem(), iterMakerETTypex_UTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.V) bool)(nil)).Elem(), iterMakerTypex_UTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *typex.V) bool)(nil)).Elem(), iterMakerETTypex_UTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.W) bool)(nil)).Elem(), iterMakerTypex_UTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *typex.W) bool)(nil)).Elem(), iterMakerETTypex_UTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.X) bool)(nil)).Elem(), iterMakerTypex_UTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *typex.X) bool)(nil)).Elem(), iterMakerETTypex_UTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_UTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *typex.Y) bool)(nil)).Elem(), iterMakerETTypex_UTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_UTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.U, *typex.Z) bool)(nil)).Elem(), iterMakerETTypex_UTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V) bool)(nil)).Elem(), iterMakerTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V) bool)(nil)).Elem(), iterMakerETTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *[]byte) bool)(nil)).Elem(), iterMakerTypex_VByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *[]byte) bool)(nil)).Elem(), iterMakerETTypex_VByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *bool) bool)(nil)).Elem(), iterMakerTypex_VBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *bool) bool)(nil)).Elem(), iterMakerETTypex_VBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *string) bool)(nil)).Elem(), iterMakerTypex_VString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *string) bool)(nil)).Elem(), iterMakerETTypex_VString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *int) bool)(nil)).Elem(), iterMakerTypex_VInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *int) bool)(nil)).Elem(), iterMakerETTypex_VInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *int8) bool)(nil)).Elem(), iterMakerTypex_VInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *int8) bool)(nil)).Elem(), iterMakerETTypex_VInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *int16) bool)(nil)).Elem(), iterMakerTypex_VInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *int16) bool)(nil)).Elem(), iterMakerETTypex_VInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *int32) bool)(nil)).Elem(), iterMakerTypex_VInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *int32) bool)(nil)).Elem(), iterMakerETTypex_VInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *int64) bool)(nil)).Elem(), iterMakerTypex_VInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *int64) bool)(nil)).Elem(), iterMakerETTypex_VInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *uint) bool)(nil)).Elem(), iterMakerTypex_VUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *uint) bool)(nil)).Elem(), iterMakerETTypex_VUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *uint8) bool)(nil)).Elem(), iterMakerTypex_VUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *uint8) bool)(nil)).Elem(), iterMakerETTypex_VUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *uint16) bool)(nil)).Elem(), iterMakerTypex_VUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *uint16) bool)(nil)).Elem(), iterMakerETTypex_VUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *uint32) bool)(nil)).Elem(), iterMakerTypex_VUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *uint32) bool)(nil)).Elem(), iterMakerETTypex_VUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *uint64) bool)(nil)).Elem(), iterMakerTypex_VUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *uint64) bool)(nil)).Elem(), iterMakerETTypex_VUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *float32) bool)(nil)).Elem(), iterMakerTypex_VFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *float32) bool)(nil)).Elem(), iterMakerETTypex_VFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *float64) bool)(nil)).Elem(), iterMakerTypex_VFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *float64) bool)(nil)).Elem(), iterMakerETTypex_VFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.T) bool)(nil)).Elem(), iterMakerTypex_VTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *typex.T) bool)(nil)).Elem(), iterMakerETTypex_VTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.U) bool)(nil)).Elem(), iterMakerTypex_VTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *typex.U) bool)(nil)).Elem(), iterMakerETTypex_VTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.V) bool)(nil)).Elem(), iterMakerTypex_VTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *typex.V) bool)(nil)).Elem(), iterMakerETTypex_VTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.W) bool)(nil)).Elem(), iterMakerTypex_VTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *typex.W) bool)(nil)).Elem(), iterMakerETTypex_VTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.X) bool)(nil)).Elem(), iterMakerTypex_VTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *typex.X) bool)(nil)).Elem(), iterMakerETTypex_VTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_VTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *typex.Y) bool)(nil)).Elem(), iterMakerETTypex_VTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_VTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.V, *typex.Z) bool)(nil)).Elem(), iterMakerETTypex_VTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W) bool)(nil)).Elem(), iterMakerTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W) bool)(nil)).Elem(), iterMakerETTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *[]byte) bool)(nil)).Elem(), iterMakerTypex_WByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *[]byte) bool)(nil)).Elem(), iterMakerETTypex_WByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *bool) bool)(nil)).Elem(), iterMakerTypex_WBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *bool) bool)(nil)).Elem(), iterMakerETTypex_WBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *string) bool)(nil)).Elem(), iterMakerTypex_WString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *string) bool)(nil)).Elem(), iterMakerETTypex_WString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *int) bool)(nil)).Elem(), iterMakerTypex_WInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *int) bool)(nil)).Elem(), iterMakerETTypex_WInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *int8) bool)(nil)).Elem(), iterMakerTypex_WInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *int8) bool)(nil)).Elem(), iterMakerETTypex_WInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *int16) bool)(nil)).Elem(), iterMakerTypex_WInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *int16) bool)(nil)).Elem(), iterMakerETTypex_WInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *int32) bool)(nil)).Elem(), iterMakerTypex_WInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *int32) bool)(nil)).Elem(), iterMakerETTypex_WInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *int64) bool)(nil)).Elem(), iterMakerTypex_WInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *int64) bool)(nil)).Elem(), iterMakerETTypex_WInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *uint) bool)(nil)).Elem(), iterMakerTypex_WUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *uint) bool)(nil)).Elem(), iterMakerETTypex_WUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *uint8) bool)(nil)).Elem(), iterMakerTypex_WUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *uint8) bool)(nil)).Elem(), iterMakerETTypex_WUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *uint16) bool)(nil)).Elem(), iterMakerTypex_WUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *uint16) bool)(nil)).Elem(), iterMakerETTypex_WUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *uint32) bool)(nil)).Elem(), iterMakerTypex_WUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *uint32) bool)(nil)).Elem(), iterMakerETTypex_WUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *uint64) bool)(nil)).Elem(), iterMakerTypex_WUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *uint64) bool)(nil)).Elem(), iterMakerETTypex_WUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *float32) bool)(nil)).Elem(), iterMakerTypex_WFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *float32) bool)(nil)).Elem(), iterMakerETTypex_WFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *float64) bool)(nil)).Elem(), iterMakerTypex_WFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *float64) bool)(nil)).Elem(), iterMakerETTypex_WFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.T) bool)(nil)).Elem(), iterMakerTypex_WTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *typex.T) bool)(nil)).Elem(), iterMakerETTypex_WTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.U) bool)(nil)).Elem(), iterMakerTypex_WTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *typex.U) bool)(nil)).Elem(), iterMakerETTypex_WTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.V) bool)(nil)).Elem(), iterMakerTypex_WTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *typex.V) bool)(nil)).Elem(), iterMakerETTypex_WTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.W) bool)(nil)).Elem(), iterMakerTypex_WTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *typex.W) bool)(nil)).Elem(), iterMakerETTypex_WTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.X) bool)(nil)).Elem(), iterMakerTypex_WTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *typex.X) bool)(nil)).Elem(), iterMakerETTypex_WTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_WTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *typex.Y) bool)(nil)).Elem(), iterMakerETTypex_WTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_WTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.W, *typex.Z) bool)(nil)).Elem(), iterMakerETTypex_WTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X) bool)(nil)).Elem(), iterMakerTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X) bool)(nil)).Elem(), iterMakerETTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *[]byte) bool)(nil)).Elem(), iterMakerTypex_XByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *[]byte) bool)(nil)).Elem(), iterMakerETTypex_XByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *bool) bool)(nil)).Elem(), iterMakerTypex_XBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *bool) bool)(nil)).Elem(), iterMakerETTypex_XBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *string) bool)(nil)).Elem(), iterMakerTypex_XString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *string) bool)(nil)).Elem(), iterMakerETTypex_XString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *int) bool)(nil)).Elem(), iterMakerTypex_XInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *int) bool)(nil)).Elem(), iterMakerETTypex_XInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *int8) bool)(nil)).Elem(), iterMakerTypex_XInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *int8) bool)(nil)).Elem(), iterMakerETTypex_XInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *int16) bool)(nil)).Elem(), iterMakerTypex_XInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *int16) bool)(nil)).Elem(), iterMakerETTypex_XInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *int32) bool)(nil)).Elem(), iterMakerTypex_XInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *int32) bool)(nil)).Elem(), iterMakerETTypex_XInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *int64) bool)(nil)).Elem(), iterMakerTypex_XInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *int64) bool)(nil)).Elem(), iterMakerETTypex_XInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *uint) bool)(nil)).Elem(), iterMakerTypex_XUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *uint) bool)(nil)).Elem(), iterMakerETTypex_XUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *uint8) bool)(nil)).Elem(), iterMakerTypex_XUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *uint8) bool)(nil)).Elem(), iterMakerETTypex_XUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *uint16) bool)(nil)).Elem(), iterMakerTypex_XUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *uint16) bool)(nil)).Elem(), iterMakerETTypex_XUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *uint32) bool)(nil)).Elem(), iterMakerTypex_XUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *uint32) bool)(nil)).Elem(), iterMakerETTypex_XUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *uint64) bool)(nil)).Elem(), iterMakerTypex_XUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *uint64) bool)(nil)).Elem(), iterMakerETTypex_XUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *float32) bool)(nil)).Elem(), iterMakerTypex_XFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *float32) bool)(nil)).Elem(), iterMakerETTypex_XFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *float64) bool)(nil)).Elem(), iterMakerTypex_XFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *float64) bool)(nil)).Elem(), iterMakerETTypex_XFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.T) bool)(nil)).Elem(), iterMakerTypex_XTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *typex.T) bool)(nil)).Elem(), iterMakerETTypex_XTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.U) bool)(nil)).Elem(), iterMakerTypex_XTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *typex.U) bool)(nil)).Elem(), iterMakerETTypex_XTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.V) bool)(nil)).Elem(), iterMakerTypex_XTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *typex.V) bool)(nil)).Elem(), iterMakerETTypex_XTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.W) bool)(nil)).Elem(), iterMakerTypex_XTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *typex.W) bool)(nil)).Elem(), iterMakerETTypex_XTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.X) bool)(nil)).Elem(), iterMakerTypex_XTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *typex.X) bool)(nil)).Elem(), iterMakerETTypex_XTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_XTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *typex.Y) bool)(nil)).Elem(), iterMakerETTypex_XTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_XTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.X, *typex.Z) bool)(nil)).Elem(), iterMakerETTypex_XTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y) bool)(nil)).Elem(), iterMakerTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y) bool)(nil)).Elem(), iterMakerETTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *[]byte) bool)(nil)).Elem(), iterMakerTypex_YByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *[]byte) bool)(nil)).Elem(), iterMakerETTypex_YByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *bool) bool)(nil)).Elem(), iterMakerTypex_YBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *bool) bool)(nil)).Elem(), iterMakerETTypex_YBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *string) bool)(nil)).Elem(), iterMakerTypex_YString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *string) bool)(nil)).Elem(), iterMakerETTypex_YString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *int) bool)(nil)).Elem(), iterMakerTypex_YInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *int) bool)(nil)).Elem(), iterMakerETTypex_YInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *int8) bool)(nil)).Elem(), iterMakerTypex_YInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *int8) bool)(nil)).Elem(), iterMakerETTypex_YInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *int16) bool)(nil)).Elem(), iterMakerTypex_YInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *int16) bool)(nil)).Elem(), iterMakerETTypex_YInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *int32) bool)(nil)).Elem(), iterMakerTypex_YInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *int32) bool)(nil)).Elem(), iterMakerETTypex_YInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *int64) bool)(nil)).Elem(), iterMakerTypex_YInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *int64) bool)(nil)).Elem(), iterMakerETTypex_YInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *uint) bool)(nil)).Elem(), iterMakerTypex_YUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *uint) bool)(nil)).Elem(), iterMakerETTypex_YUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *uint8) bool)(nil)).Elem(), iterMakerTypex_YUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *uint8) bool)(nil)).Elem(), iterMakerETTypex_YUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *uint16) bool)(nil)).Elem(), iterMakerTypex_YUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *uint16) bool)(nil)).Elem(), iterMakerETTypex_YUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *uint32) bool)(nil)).Elem(), iterMakerTypex_YUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *uint32) bool)(nil)).Elem(), iterMakerETTypex_YUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *uint64) bool)(nil)).Elem(), iterMakerTypex_YUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *uint64) bool)(nil)).Elem(), iterMakerETTypex_YUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *float32) bool)(nil)).Elem(), iterMakerTypex_YFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *float32) bool)(nil)).Elem(), iterMakerETTypex_YFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *float64) bool)(nil)).Elem(), iterMakerTypex_YFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *float64) bool)(nil)).Elem(), iterMakerETTypex_YFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.T) bool)(nil)).Elem(), iterMakerTypex_YTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *typex.T) bool)(nil)).Elem(), iterMakerETTypex_YTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.U) bool)(nil)).Elem(), iterMakerTypex_YTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *typex.U) bool)(nil)).Elem(), iterMakerETTypex_YTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.V) bool)(nil)).Elem(), iterMakerTypex_YTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *typex.V) bool)(nil)).Elem(), iterMakerETTypex_YTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.W) bool)(nil)).Elem(), iterMakerTypex_YTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *typex.W) bool)(nil)).Elem(), iterMakerETTypex_YTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.X) bool)(nil)).Elem(), iterMakerTypex_YTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *typex.X) bool)(nil)).Elem(), iterMakerETTypex_YTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_YTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *typex.Y) bool)(nil)).Elem(), iterMakerETTypex_YTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_YTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Y, *typex.Z) bool)(nil)).Elem(), iterMakerETTypex_YTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z) bool)(nil)).Elem(), iterMakerTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z) bool)(nil)).Elem(), iterMakerETTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *[]byte) bool)(nil)).Elem(), iterMakerTypex_ZByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *[]byte) bool)(nil)).Elem(), iterMakerETTypex_ZByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *bool) bool)(nil)).Elem(), iterMakerTypex_ZBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *bool) bool)(nil)).Elem(), iterMakerETTypex_ZBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *string) bool)(nil)).Elem(), iterMakerTypex_ZString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *string) bool)(nil)).Elem(), iterMakerETTypex_ZString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *int) bool)(nil)).Elem(), iterMakerTypex_ZInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *int) bool)(nil)).Elem(), iterMakerETTypex_ZInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *int8) bool)(nil)).Elem(), iterMakerTypex_ZInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *int8) bool)(nil)).Elem(), iterMakerETTypex_ZInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *int16) bool)(nil)).Elem(), iterMakerTypex_ZInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *int16) bool)(nil)).Elem(), iterMakerETTypex_ZInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *int32) bool)(nil)).Elem(), iterMakerTypex_ZInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *int32) bool)(nil)).Elem(), iterMakerETTypex_ZInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *int64) bool)(nil)).Elem(), iterMakerTypex_ZInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *int64) bool)(nil)).Elem(), iterMakerETTypex_ZInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *uint) bool)(nil)).Elem(), iterMakerTypex_ZUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *uint) bool)(nil)).Elem(), iterMakerETTypex_ZUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *uint8) bool)(nil)).Elem(), iterMakerTypex_ZUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *uint8) bool)(nil)).Elem(), iterMakerETTypex_ZUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *uint16) bool)(nil)).Elem(), iterMakerTypex_ZUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *uint16) bool)(nil)).Elem(), iterMakerETTypex_ZUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *uint32) bool)(nil)).Elem(), iterMakerTypex_ZUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *uint32) bool)(nil)).Elem(), iterMakerETTypex_ZUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *uint64) bool)(nil)).Elem(), iterMakerTypex_ZUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *uint64) bool)(nil)).Elem(), iterMakerETTypex_ZUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *float32) bool)(nil)).Elem(), iterMakerTypex_ZFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *float32) bool)(nil)).Elem(), iterMakerETTypex_ZFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *float64) bool)(nil)).Elem(), iterMakerTypex_ZFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *float64) bool)(nil)).Elem(), iterMakerETTypex_ZFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.T) bool)(nil)).Elem(), iterMakerTypex_ZTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *typex.T) bool)(nil)).Elem(), iterMakerETTypex_ZTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.U) bool)(nil)).Elem(), iterMakerTypex_ZTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *typex.U) bool)(nil)).Elem(), iterMakerETTypex_ZTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.V) bool)(nil)).Elem(), iterMakerTypex_ZTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *typex.V) bool)(nil)).Elem(), iterMakerETTypex_ZTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.W) bool)(nil)).Elem(), iterMakerTypex_ZTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *typex.W) bool)(nil)).Elem(), iterMakerETTypex_ZTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.X) bool)(nil)).Elem(), iterMakerTypex_ZTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *typex.X) bool)(nil)).Elem(), iterMakerETTypex_ZTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_ZTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *typex.Y) bool)(nil)).Elem(), iterMakerETTypex_ZTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_ZTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.EventTime, *typex.Z, *typex.Z) bool)(nil)).Elem(), iterMakerETTypex_ZTypex_Z)
}

type iterNative struct {
	s  exec.ReStream
	fn interface{}

	// cur is the "current" stream, if any.
	cur exec.Stream
}

func (v *iterNative) Init() error {
	v.cur = v.s.Open()
	return nil
}

func (v *iterNative) Value() interface{} {
	return v.fn
}

func convToString(v interface{}) string {
	switch v.(type) {
	case []byte:
		return string(v.([]byte))
	default:
		return v.(string)
	}
}

func (v *iterNative) Reset() error {
	if err := v.cur.Close(); err != nil {
		return err
	}
	v.cur = nil
	return nil
}

func (v *iterNative) readByteSlice(val *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.([]byte)
	return true
}

func iterMakerByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSlice
	return ret
}

func (v *iterNative) readETByteSlice(et *typex.EventTime, val *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.([]byte)
	return true
}

func iterMakerETByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSlice
	return ret
}

func (v *iterNative) readByteSliceByteSlice(key *[]byte, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerByteSliceByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceByteSlice
	return ret
}

func (v *iterNative) readETByteSliceByteSlice(et *typex.EventTime, key *[]byte, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETByteSliceByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceByteSlice
	return ret
}

func (v *iterNative) readByteSliceBool(key *[]byte, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerByteSliceBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceBool
	return ret
}

func (v *iterNative) readETByteSliceBool(et *typex.EventTime, key *[]byte, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETByteSliceBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceBool
	return ret
}

func (v *iterNative) readByteSliceString(key *[]byte, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerByteSliceString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceString
	return ret
}

func (v *iterNative) readETByteSliceString(et *typex.EventTime, key *[]byte, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETByteSliceString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceString
	return ret
}

func (v *iterNative) readByteSliceInt(key *[]byte, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerByteSliceInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceInt
	return ret
}

func (v *iterNative) readETByteSliceInt(et *typex.EventTime, key *[]byte, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETByteSliceInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceInt
	return ret
}

func (v *iterNative) readByteSliceInt8(key *[]byte, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerByteSliceInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceInt8
	return ret
}

func (v *iterNative) readETByteSliceInt8(et *typex.EventTime, key *[]byte, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETByteSliceInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceInt8
	return ret
}

func (v *iterNative) readByteSliceInt16(key *[]byte, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerByteSliceInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceInt16
	return ret
}

func (v *iterNative) readETByteSliceInt16(et *typex.EventTime, key *[]byte, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETByteSliceInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceInt16
	return ret
}

func (v *iterNative) readByteSliceInt32(key *[]byte, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerByteSliceInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceInt32
	return ret
}

func (v *iterNative) readETByteSliceInt32(et *typex.EventTime, key *[]byte, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETByteSliceInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceInt32
	return ret
}

func (v *iterNative) readByteSliceInt64(key *[]byte, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerByteSliceInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceInt64
	return ret
}

func (v *iterNative) readETByteSliceInt64(et *typex.EventTime, key *[]byte, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETByteSliceInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceInt64
	return ret
}

func (v *iterNative) readByteSliceUint(key *[]byte, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerByteSliceUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceUint
	return ret
}

func (v *iterNative) readETByteSliceUint(et *typex.EventTime, key *[]byte, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETByteSliceUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceUint
	return ret
}

func (v *iterNative) readByteSliceUint8(key *[]byte, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerByteSliceUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceUint8
	return ret
}

func (v *iterNative) readETByteSliceUint8(et *typex.EventTime, key *[]byte, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETByteSliceUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceUint8
	return ret
}

func (v *iterNative) readByteSliceUint16(key *[]byte, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerByteSliceUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceUint16
	return ret
}

func (v *iterNative) readETByteSliceUint16(et *typex.EventTime, key *[]byte, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETByteSliceUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceUint16
	return ret
}

func (v *iterNative) readByteSliceUint32(key *[]byte, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerByteSliceUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceUint32
	return ret
}

func (v *iterNative) readETByteSliceUint32(et *typex.EventTime, key *[]byte, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETByteSliceUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceUint32
	return ret
}

func (v *iterNative) readByteSliceUint64(key *[]byte, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerByteSliceUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceUint64
	return ret
}

func (v *iterNative) readETByteSliceUint64(et *typex.EventTime, key *[]byte, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETByteSliceUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceUint64
	return ret
}

func (v *iterNative) readByteSliceFloat32(key *[]byte, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerByteSliceFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceFloat32
	return ret
}

func (v *iterNative) readETByteSliceFloat32(et *typex.EventTime, key *[]byte, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETByteSliceFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceFloat32
	return ret
}

func (v *iterNative) readByteSliceFloat64(key *[]byte, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerByteSliceFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceFloat64
	return ret
}

func (v *iterNative) readETByteSliceFloat64(et *typex.EventTime, key *[]byte, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETByteSliceFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceFloat64
	return ret
}

func (v *iterNative) readByteSliceTypex_T(key *[]byte, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerByteSliceTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_T
	return ret
}

func (v *iterNative) readETByteSliceTypex_T(et *typex.EventTime, key *[]byte, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETByteSliceTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceTypex_T
	return ret
}

func (v *iterNative) readByteSliceTypex_U(key *[]byte, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerByteSliceTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_U
	return ret
}

func (v *iterNative) readETByteSliceTypex_U(et *typex.EventTime, key *[]byte, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETByteSliceTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceTypex_U
	return ret
}

func (v *iterNative) readByteSliceTypex_V(key *[]byte, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerByteSliceTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_V
	return ret
}

func (v *iterNative) readETByteSliceTypex_V(et *typex.EventTime, key *[]byte, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETByteSliceTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceTypex_V
	return ret
}

func (v *iterNative) readByteSliceTypex_W(key *[]byte, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerByteSliceTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_W
	return ret
}

func (v *iterNative) readETByteSliceTypex_W(et *typex.EventTime, key *[]byte, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETByteSliceTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceTypex_W
	return ret
}

func (v *iterNative) readByteSliceTypex_X(key *[]byte, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerByteSliceTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_X
	return ret
}

func (v *iterNative) readETByteSliceTypex_X(et *typex.EventTime, key *[]byte, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETByteSliceTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceTypex_X
	return ret
}

func (v *iterNative) readByteSliceTypex_Y(key *[]byte, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerByteSliceTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_Y
	return ret
}

func (v *iterNative) readETByteSliceTypex_Y(et *typex.EventTime, key *[]byte, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETByteSliceTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceTypex_Y
	return ret
}

func (v *iterNative) readByteSliceTypex_Z(key *[]byte, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerByteSliceTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_Z
	return ret
}

func (v *iterNative) readETByteSliceTypex_Z(et *typex.EventTime, key *[]byte, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETByteSliceTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETByteSliceTypex_Z
	return ret
}

func (v *iterNative) readBool(val *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(bool)
	return true
}

func iterMakerBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBool
	return ret
}

func (v *iterNative) readETBool(et *typex.EventTime, val *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(bool)
	return true
}

func iterMakerETBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBool
	return ret
}

func (v *iterNative) readBoolByteSlice(key *bool, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerBoolByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolByteSlice
	return ret
}

func (v *iterNative) readETBoolByteSlice(et *typex.EventTime, key *bool, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETBoolByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolByteSlice
	return ret
}

func (v *iterNative) readBoolBool(key *bool, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerBoolBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolBool
	return ret
}

func (v *iterNative) readETBoolBool(et *typex.EventTime, key *bool, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETBoolBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolBool
	return ret
}

func (v *iterNative) readBoolString(key *bool, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerBoolString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolString
	return ret
}

func (v *iterNative) readETBoolString(et *typex.EventTime, key *bool, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETBoolString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolString
	return ret
}

func (v *iterNative) readBoolInt(key *bool, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerBoolInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolInt
	return ret
}

func (v *iterNative) readETBoolInt(et *typex.EventTime, key *bool, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETBoolInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolInt
	return ret
}

func (v *iterNative) readBoolInt8(key *bool, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerBoolInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolInt8
	return ret
}

func (v *iterNative) readETBoolInt8(et *typex.EventTime, key *bool, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETBoolInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolInt8
	return ret
}

func (v *iterNative) readBoolInt16(key *bool, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerBoolInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolInt16
	return ret
}

func (v *iterNative) readETBoolInt16(et *typex.EventTime, key *bool, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETBoolInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolInt16
	return ret
}

func (v *iterNative) readBoolInt32(key *bool, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerBoolInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolInt32
	return ret
}

func (v *iterNative) readETBoolInt32(et *typex.EventTime, key *bool, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETBoolInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolInt32
	return ret
}

func (v *iterNative) readBoolInt64(key *bool, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerBoolInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolInt64
	return ret
}

func (v *iterNative) readETBoolInt64(et *typex.EventTime, key *bool, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETBoolInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolInt64
	return ret
}

func (v *iterNative) readBoolUint(key *bool, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerBoolUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolUint
	return ret
}

func (v *iterNative) readETBoolUint(et *typex.EventTime, key *bool, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETBoolUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolUint
	return ret
}

func (v *iterNative) readBoolUint8(key *bool, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerBoolUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolUint8
	return ret
}

func (v *iterNative) readETBoolUint8(et *typex.EventTime, key *bool, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETBoolUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolUint8
	return ret
}

func (v *iterNative) readBoolUint16(key *bool, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerBoolUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolUint16
	return ret
}

func (v *iterNative) readETBoolUint16(et *typex.EventTime, key *bool, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETBoolUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolUint16
	return ret
}

func (v *iterNative) readBoolUint32(key *bool, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerBoolUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolUint32
	return ret
}

func (v *iterNative) readETBoolUint32(et *typex.EventTime, key *bool, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETBoolUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolUint32
	return ret
}

func (v *iterNative) readBoolUint64(key *bool, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerBoolUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolUint64
	return ret
}

func (v *iterNative) readETBoolUint64(et *typex.EventTime, key *bool, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETBoolUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolUint64
	return ret
}

func (v *iterNative) readBoolFloat32(key *bool, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerBoolFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolFloat32
	return ret
}

func (v *iterNative) readETBoolFloat32(et *typex.EventTime, key *bool, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETBoolFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolFloat32
	return ret
}

func (v *iterNative) readBoolFloat64(key *bool, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerBoolFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolFloat64
	return ret
}

func (v *iterNative) readETBoolFloat64(et *typex.EventTime, key *bool, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETBoolFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolFloat64
	return ret
}

func (v *iterNative) readBoolTypex_T(key *bool, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerBoolTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_T
	return ret
}

func (v *iterNative) readETBoolTypex_T(et *typex.EventTime, key *bool, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETBoolTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolTypex_T
	return ret
}

func (v *iterNative) readBoolTypex_U(key *bool, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerBoolTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_U
	return ret
}

func (v *iterNative) readETBoolTypex_U(et *typex.EventTime, key *bool, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETBoolTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolTypex_U
	return ret
}

func (v *iterNative) readBoolTypex_V(key *bool, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerBoolTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_V
	return ret
}

func (v *iterNative) readETBoolTypex_V(et *typex.EventTime, key *bool, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETBoolTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolTypex_V
	return ret
}

func (v *iterNative) readBoolTypex_W(key *bool, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerBoolTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_W
	return ret
}

func (v *iterNative) readETBoolTypex_W(et *typex.EventTime, key *bool, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETBoolTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolTypex_W
	return ret
}

func (v *iterNative) readBoolTypex_X(key *bool, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerBoolTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_X
	return ret
}

func (v *iterNative) readETBoolTypex_X(et *typex.EventTime, key *bool, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETBoolTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolTypex_X
	return ret
}

func (v *iterNative) readBoolTypex_Y(key *bool, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerBoolTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_Y
	return ret
}

func (v *iterNative) readETBoolTypex_Y(et *typex.EventTime, key *bool, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETBoolTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolTypex_Y
	return ret
}

func (v *iterNative) readBoolTypex_Z(key *bool, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerBoolTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_Z
	return ret
}

func (v *iterNative) readETBoolTypex_Z(et *typex.EventTime, key *bool, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETBoolTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETBoolTypex_Z
	return ret
}

func (v *iterNative) readString(val *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = convToString(elm.Elm)
	return true
}

func iterMakerString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readString
	return ret
}

func (v *iterNative) readETString(et *typex.EventTime, val *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = convToString(elm.Elm)
	return true
}

func iterMakerETString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETString
	return ret
}

func (v *iterNative) readStringByteSlice(key *string, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerStringByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringByteSlice
	return ret
}

func (v *iterNative) readETStringByteSlice(et *typex.EventTime, key *string, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETStringByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringByteSlice
	return ret
}

func (v *iterNative) readStringBool(key *string, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerStringBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringBool
	return ret
}

func (v *iterNative) readETStringBool(et *typex.EventTime, key *string, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETStringBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringBool
	return ret
}

func (v *iterNative) readStringString(key *string, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerStringString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringString
	return ret
}

func (v *iterNative) readETStringString(et *typex.EventTime, key *string, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETStringString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringString
	return ret
}

func (v *iterNative) readStringInt(key *string, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerStringInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringInt
	return ret
}

func (v *iterNative) readETStringInt(et *typex.EventTime, key *string, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETStringInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringInt
	return ret
}

func (v *iterNative) readStringInt8(key *string, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerStringInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringInt8
	return ret
}

func (v *iterNative) readETStringInt8(et *typex.EventTime, key *string, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETStringInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringInt8
	return ret
}

func (v *iterNative) readStringInt16(key *string, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerStringInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringInt16
	return ret
}

func (v *iterNative) readETStringInt16(et *typex.EventTime, key *string, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETStringInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringInt16
	return ret
}

func (v *iterNative) readStringInt32(key *string, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerStringInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringInt32
	return ret
}

func (v *iterNative) readETStringInt32(et *typex.EventTime, key *string, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETStringInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringInt32
	return ret
}

func (v *iterNative) readStringInt64(key *string, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerStringInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringInt64
	return ret
}

func (v *iterNative) readETStringInt64(et *typex.EventTime, key *string, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETStringInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringInt64
	return ret
}

func (v *iterNative) readStringUint(key *string, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerStringUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringUint
	return ret
}

func (v *iterNative) readETStringUint(et *typex.EventTime, key *string, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETStringUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringUint
	return ret
}

func (v *iterNative) readStringUint8(key *string, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerStringUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringUint8
	return ret
}

func (v *iterNative) readETStringUint8(et *typex.EventTime, key *string, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETStringUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringUint8
	return ret
}

func (v *iterNative) readStringUint16(key *string, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerStringUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringUint16
	return ret
}

func (v *iterNative) readETStringUint16(et *typex.EventTime, key *string, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETStringUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringUint16
	return ret
}

func (v *iterNative) readStringUint32(key *string, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerStringUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringUint32
	return ret
}

func (v *iterNative) readETStringUint32(et *typex.EventTime, key *string, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETStringUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringUint32
	return ret
}

func (v *iterNative) readStringUint64(key *string, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerStringUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringUint64
	return ret
}

func (v *iterNative) readETStringUint64(et *typex.EventTime, key *string, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETStringUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringUint64
	return ret
}

func (v *iterNative) readStringFloat32(key *string, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerStringFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringFloat32
	return ret
}

func (v *iterNative) readETStringFloat32(et *typex.EventTime, key *string, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETStringFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringFloat32
	return ret
}

func (v *iterNative) readStringFloat64(key *string, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerStringFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringFloat64
	return ret
}

func (v *iterNative) readETStringFloat64(et *typex.EventTime, key *string, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETStringFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringFloat64
	return ret
}

func (v *iterNative) readStringTypex_T(key *string, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerStringTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_T
	return ret
}

func (v *iterNative) readETStringTypex_T(et *typex.EventTime, key *string, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETStringTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringTypex_T
	return ret
}

func (v *iterNative) readStringTypex_U(key *string, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerStringTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_U
	return ret
}

func (v *iterNative) readETStringTypex_U(et *typex.EventTime, key *string, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETStringTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringTypex_U
	return ret
}

func (v *iterNative) readStringTypex_V(key *string, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerStringTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_V
	return ret
}

func (v *iterNative) readETStringTypex_V(et *typex.EventTime, key *string, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETStringTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringTypex_V
	return ret
}

func (v *iterNative) readStringTypex_W(key *string, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerStringTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_W
	return ret
}

func (v *iterNative) readETStringTypex_W(et *typex.EventTime, key *string, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETStringTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringTypex_W
	return ret
}

func (v *iterNative) readStringTypex_X(key *string, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerStringTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_X
	return ret
}

func (v *iterNative) readETStringTypex_X(et *typex.EventTime, key *string, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETStringTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringTypex_X
	return ret
}

func (v *iterNative) readStringTypex_Y(key *string, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerStringTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_Y
	return ret
}

func (v *iterNative) readETStringTypex_Y(et *typex.EventTime, key *string, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETStringTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringTypex_Y
	return ret
}

func (v *iterNative) readStringTypex_Z(key *string, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerStringTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_Z
	return ret
}

func (v *iterNative) readETStringTypex_Z(et *typex.EventTime, key *string, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = convToString(elm.Elm)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETStringTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETStringTypex_Z
	return ret
}

func (v *iterNative) readInt(val *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(int)
	return true
}

func iterMakerInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt
	return ret
}

func (v *iterNative) readETInt(et *typex.EventTime, val *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(int)
	return true
}

func iterMakerETInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt
	return ret
}

func (v *iterNative) readIntByteSlice(key *int, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerIntByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntByteSlice
	return ret
}

func (v *iterNative) readETIntByteSlice(et *typex.EventTime, key *int, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETIntByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntByteSlice
	return ret
}

func (v *iterNative) readIntBool(key *int, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerIntBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntBool
	return ret
}

func (v *iterNative) readETIntBool(et *typex.EventTime, key *int, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETIntBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntBool
	return ret
}

func (v *iterNative) readIntString(key *int, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerIntString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntString
	return ret
}

func (v *iterNative) readETIntString(et *typex.EventTime, key *int, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETIntString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntString
	return ret
}

func (v *iterNative) readIntInt(key *int, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerIntInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntInt
	return ret
}

func (v *iterNative) readETIntInt(et *typex.EventTime, key *int, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETIntInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntInt
	return ret
}

func (v *iterNative) readIntInt8(key *int, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerIntInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntInt8
	return ret
}

func (v *iterNative) readETIntInt8(et *typex.EventTime, key *int, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETIntInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntInt8
	return ret
}

func (v *iterNative) readIntInt16(key *int, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerIntInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntInt16
	return ret
}

func (v *iterNative) readETIntInt16(et *typex.EventTime, key *int, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETIntInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntInt16
	return ret
}

func (v *iterNative) readIntInt32(key *int, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerIntInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntInt32
	return ret
}

func (v *iterNative) readETIntInt32(et *typex.EventTime, key *int, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETIntInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntInt32
	return ret
}

func (v *iterNative) readIntInt64(key *int, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerIntInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntInt64
	return ret
}

func (v *iterNative) readETIntInt64(et *typex.EventTime, key *int, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETIntInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntInt64
	return ret
}

func (v *iterNative) readIntUint(key *int, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerIntUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntUint
	return ret
}

func (v *iterNative) readETIntUint(et *typex.EventTime, key *int, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETIntUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntUint
	return ret
}

func (v *iterNative) readIntUint8(key *int, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerIntUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntUint8
	return ret
}

func (v *iterNative) readETIntUint8(et *typex.EventTime, key *int, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETIntUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntUint8
	return ret
}

func (v *iterNative) readIntUint16(key *int, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerIntUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntUint16
	return ret
}

func (v *iterNative) readETIntUint16(et *typex.EventTime, key *int, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETIntUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntUint16
	return ret
}

func (v *iterNative) readIntUint32(key *int, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerIntUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntUint32
	return ret
}

func (v *iterNative) readETIntUint32(et *typex.EventTime, key *int, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETIntUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntUint32
	return ret
}

func (v *iterNative) readIntUint64(key *int, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerIntUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntUint64
	return ret
}

func (v *iterNative) readETIntUint64(et *typex.EventTime, key *int, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETIntUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntUint64
	return ret
}

func (v *iterNative) readIntFloat32(key *int, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerIntFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntFloat32
	return ret
}

func (v *iterNative) readETIntFloat32(et *typex.EventTime, key *int, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETIntFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntFloat32
	return ret
}

func (v *iterNative) readIntFloat64(key *int, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerIntFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntFloat64
	return ret
}

func (v *iterNative) readETIntFloat64(et *typex.EventTime, key *int, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETIntFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntFloat64
	return ret
}

func (v *iterNative) readIntTypex_T(key *int, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerIntTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_T
	return ret
}

func (v *iterNative) readETIntTypex_T(et *typex.EventTime, key *int, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETIntTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntTypex_T
	return ret
}

func (v *iterNative) readIntTypex_U(key *int, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerIntTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_U
	return ret
}

func (v *iterNative) readETIntTypex_U(et *typex.EventTime, key *int, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETIntTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntTypex_U
	return ret
}

func (v *iterNative) readIntTypex_V(key *int, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerIntTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_V
	return ret
}

func (v *iterNative) readETIntTypex_V(et *typex.EventTime, key *int, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETIntTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntTypex_V
	return ret
}

func (v *iterNative) readIntTypex_W(key *int, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerIntTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_W
	return ret
}

func (v *iterNative) readETIntTypex_W(et *typex.EventTime, key *int, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETIntTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntTypex_W
	return ret
}

func (v *iterNative) readIntTypex_X(key *int, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerIntTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_X
	return ret
}

func (v *iterNative) readETIntTypex_X(et *typex.EventTime, key *int, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETIntTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntTypex_X
	return ret
}

func (v *iterNative) readIntTypex_Y(key *int, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerIntTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_Y
	return ret
}

func (v *iterNative) readETIntTypex_Y(et *typex.EventTime, key *int, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETIntTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntTypex_Y
	return ret
}

func (v *iterNative) readIntTypex_Z(key *int, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerIntTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_Z
	return ret
}

func (v *iterNative) readETIntTypex_Z(et *typex.EventTime, key *int, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETIntTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETIntTypex_Z
	return ret
}

func (v *iterNative) readInt8(val *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(int8)
	return true
}

func iterMakerInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8
	return ret
}

func (v *iterNative) readETInt8(et *typex.EventTime, val *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(int8)
	return true
}

func iterMakerETInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8
	return ret
}

func (v *iterNative) readInt8ByteSlice(key *int8, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerInt8ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8ByteSlice
	return ret
}

func (v *iterNative) readETInt8ByteSlice(et *typex.EventTime, key *int8, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETInt8ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8ByteSlice
	return ret
}

func (v *iterNative) readInt8Bool(key *int8, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerInt8Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Bool
	return ret
}

func (v *iterNative) readETInt8Bool(et *typex.EventTime, key *int8, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETInt8Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Bool
	return ret
}

func (v *iterNative) readInt8String(key *int8, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerInt8String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8String
	return ret
}

func (v *iterNative) readETInt8String(et *typex.EventTime, key *int8, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETInt8String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8String
	return ret
}

func (v *iterNative) readInt8Int(key *int8, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerInt8Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Int
	return ret
}

func (v *iterNative) readETInt8Int(et *typex.EventTime, key *int8, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETInt8Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Int
	return ret
}

func (v *iterNative) readInt8Int8(key *int8, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerInt8Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Int8
	return ret
}

func (v *iterNative) readETInt8Int8(et *typex.EventTime, key *int8, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETInt8Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Int8
	return ret
}

func (v *iterNative) readInt8Int16(key *int8, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerInt8Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Int16
	return ret
}

func (v *iterNative) readETInt8Int16(et *typex.EventTime, key *int8, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETInt8Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Int16
	return ret
}

func (v *iterNative) readInt8Int32(key *int8, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerInt8Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Int32
	return ret
}

func (v *iterNative) readETInt8Int32(et *typex.EventTime, key *int8, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETInt8Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Int32
	return ret
}

func (v *iterNative) readInt8Int64(key *int8, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerInt8Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Int64
	return ret
}

func (v *iterNative) readETInt8Int64(et *typex.EventTime, key *int8, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETInt8Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Int64
	return ret
}

func (v *iterNative) readInt8Uint(key *int8, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerInt8Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Uint
	return ret
}

func (v *iterNative) readETInt8Uint(et *typex.EventTime, key *int8, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETInt8Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Uint
	return ret
}

func (v *iterNative) readInt8Uint8(key *int8, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerInt8Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Uint8
	return ret
}

func (v *iterNative) readETInt8Uint8(et *typex.EventTime, key *int8, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETInt8Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Uint8
	return ret
}

func (v *iterNative) readInt8Uint16(key *int8, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerInt8Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Uint16
	return ret
}

func (v *iterNative) readETInt8Uint16(et *typex.EventTime, key *int8, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETInt8Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Uint16
	return ret
}

func (v *iterNative) readInt8Uint32(key *int8, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerInt8Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Uint32
	return ret
}

func (v *iterNative) readETInt8Uint32(et *typex.EventTime, key *int8, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETInt8Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Uint32
	return ret
}

func (v *iterNative) readInt8Uint64(key *int8, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerInt8Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Uint64
	return ret
}

func (v *iterNative) readETInt8Uint64(et *typex.EventTime, key *int8, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETInt8Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Uint64
	return ret
}

func (v *iterNative) readInt8Float32(key *int8, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerInt8Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Float32
	return ret
}

func (v *iterNative) readETInt8Float32(et *typex.EventTime, key *int8, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETInt8Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Float32
	return ret
}

func (v *iterNative) readInt8Float64(key *int8, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerInt8Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Float64
	return ret
}

func (v *iterNative) readETInt8Float64(et *typex.EventTime, key *int8, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETInt8Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Float64
	return ret
}

func (v *iterNative) readInt8Typex_T(key *int8, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerInt8Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_T
	return ret
}

func (v *iterNative) readETInt8Typex_T(et *typex.EventTime, key *int8, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETInt8Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Typex_T
	return ret
}

func (v *iterNative) readInt8Typex_U(key *int8, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerInt8Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_U
	return ret
}

func (v *iterNative) readETInt8Typex_U(et *typex.EventTime, key *int8, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETInt8Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Typex_U
	return ret
}

func (v *iterNative) readInt8Typex_V(key *int8, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerInt8Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_V
	return ret
}

func (v *iterNative) readETInt8Typex_V(et *typex.EventTime, key *int8, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETInt8Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Typex_V
	return ret
}

func (v *iterNative) readInt8Typex_W(key *int8, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerInt8Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_W
	return ret
}

func (v *iterNative) readETInt8Typex_W(et *typex.EventTime, key *int8, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETInt8Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Typex_W
	return ret
}

func (v *iterNative) readInt8Typex_X(key *int8, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerInt8Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_X
	return ret
}

func (v *iterNative) readETInt8Typex_X(et *typex.EventTime, key *int8, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETInt8Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Typex_X
	return ret
}

func (v *iterNative) readInt8Typex_Y(key *int8, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerInt8Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_Y
	return ret
}

func (v *iterNative) readETInt8Typex_Y(et *typex.EventTime, key *int8, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETInt8Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Typex_Y
	return ret
}

func (v *iterNative) readInt8Typex_Z(key *int8, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerInt8Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_Z
	return ret
}

func (v *iterNative) readETInt8Typex_Z(et *typex.EventTime, key *int8, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETInt8Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt8Typex_Z
	return ret
}

func (v *iterNative) readInt16(val *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(int16)
	return true
}

func iterMakerInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16
	return ret
}

func (v *iterNative) readETInt16(et *typex.EventTime, val *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(int16)
	return true
}

func iterMakerETInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16
	return ret
}

func (v *iterNative) readInt16ByteSlice(key *int16, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerInt16ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16ByteSlice
	return ret
}

func (v *iterNative) readETInt16ByteSlice(et *typex.EventTime, key *int16, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETInt16ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16ByteSlice
	return ret
}

func (v *iterNative) readInt16Bool(key *int16, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerInt16Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Bool
	return ret
}

func (v *iterNative) readETInt16Bool(et *typex.EventTime, key *int16, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETInt16Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Bool
	return ret
}

func (v *iterNative) readInt16String(key *int16, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerInt16String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16String
	return ret
}

func (v *iterNative) readETInt16String(et *typex.EventTime, key *int16, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETInt16String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16String
	return ret
}

func (v *iterNative) readInt16Int(key *int16, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerInt16Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Int
	return ret
}

func (v *iterNative) readETInt16Int(et *typex.EventTime, key *int16, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETInt16Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Int
	return ret
}

func (v *iterNative) readInt16Int8(key *int16, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerInt16Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Int8
	return ret
}

func (v *iterNative) readETInt16Int8(et *typex.EventTime, key *int16, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETInt16Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Int8
	return ret
}

func (v *iterNative) readInt16Int16(key *int16, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerInt16Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Int16
	return ret
}

func (v *iterNative) readETInt16Int16(et *typex.EventTime, key *int16, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETInt16Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Int16
	return ret
}

func (v *iterNative) readInt16Int32(key *int16, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerInt16Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Int32
	return ret
}

func (v *iterNative) readETInt16Int32(et *typex.EventTime, key *int16, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETInt16Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Int32
	return ret
}

func (v *iterNative) readInt16Int64(key *int16, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerInt16Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Int64
	return ret
}

func (v *iterNative) readETInt16Int64(et *typex.EventTime, key *int16, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETInt16Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Int64
	return ret
}

func (v *iterNative) readInt16Uint(key *int16, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerInt16Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Uint
	return ret
}

func (v *iterNative) readETInt16Uint(et *typex.EventTime, key *int16, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETInt16Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Uint
	return ret
}

func (v *iterNative) readInt16Uint8(key *int16, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerInt16Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Uint8
	return ret
}

func (v *iterNative) readETInt16Uint8(et *typex.EventTime, key *int16, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETInt16Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Uint8
	return ret
}

func (v *iterNative) readInt16Uint16(key *int16, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerInt16Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Uint16
	return ret
}

func (v *iterNative) readETInt16Uint16(et *typex.EventTime, key *int16, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETInt16Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Uint16
	return ret
}

func (v *iterNative) readInt16Uint32(key *int16, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerInt16Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Uint32
	return ret
}

func (v *iterNative) readETInt16Uint32(et *typex.EventTime, key *int16, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETInt16Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Uint32
	return ret
}

func (v *iterNative) readInt16Uint64(key *int16, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerInt16Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Uint64
	return ret
}

func (v *iterNative) readETInt16Uint64(et *typex.EventTime, key *int16, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETInt16Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Uint64
	return ret
}

func (v *iterNative) readInt16Float32(key *int16, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerInt16Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Float32
	return ret
}

func (v *iterNative) readETInt16Float32(et *typex.EventTime, key *int16, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETInt16Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Float32
	return ret
}

func (v *iterNative) readInt16Float64(key *int16, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerInt16Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Float64
	return ret
}

func (v *iterNative) readETInt16Float64(et *typex.EventTime, key *int16, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETInt16Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Float64
	return ret
}

func (v *iterNative) readInt16Typex_T(key *int16, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerInt16Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_T
	return ret
}

func (v *iterNative) readETInt16Typex_T(et *typex.EventTime, key *int16, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETInt16Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Typex_T
	return ret
}

func (v *iterNative) readInt16Typex_U(key *int16, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerInt16Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_U
	return ret
}

func (v *iterNative) readETInt16Typex_U(et *typex.EventTime, key *int16, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETInt16Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Typex_U
	return ret
}

func (v *iterNative) readInt16Typex_V(key *int16, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerInt16Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_V
	return ret
}

func (v *iterNative) readETInt16Typex_V(et *typex.EventTime, key *int16, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETInt16Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Typex_V
	return ret
}

func (v *iterNative) readInt16Typex_W(key *int16, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerInt16Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_W
	return ret
}

func (v *iterNative) readETInt16Typex_W(et *typex.EventTime, key *int16, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETInt16Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Typex_W
	return ret
}

func (v *iterNative) readInt16Typex_X(key *int16, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerInt16Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_X
	return ret
}

func (v *iterNative) readETInt16Typex_X(et *typex.EventTime, key *int16, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETInt16Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Typex_X
	return ret
}

func (v *iterNative) readInt16Typex_Y(key *int16, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerInt16Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_Y
	return ret
}

func (v *iterNative) readETInt16Typex_Y(et *typex.EventTime, key *int16, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETInt16Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Typex_Y
	return ret
}

func (v *iterNative) readInt16Typex_Z(key *int16, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerInt16Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_Z
	return ret
}

func (v *iterNative) readETInt16Typex_Z(et *typex.EventTime, key *int16, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETInt16Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt16Typex_Z
	return ret
}

func (v *iterNative) readInt32(val *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(int32)
	return true
}

func iterMakerInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32
	return ret
}

func (v *iterNative) readETInt32(et *typex.EventTime, val *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(int32)
	return true
}

func iterMakerETInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32
	return ret
}

func (v *iterNative) readInt32ByteSlice(key *int32, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerInt32ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32ByteSlice
	return ret
}

func (v *iterNative) readETInt32ByteSlice(et *typex.EventTime, key *int32, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETInt32ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32ByteSlice
	return ret
}

func (v *iterNative) readInt32Bool(key *int32, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerInt32Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Bool
	return ret
}

func (v *iterNative) readETInt32Bool(et *typex.EventTime, key *int32, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETInt32Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Bool
	return ret
}

func (v *iterNative) readInt32String(key *int32, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerInt32String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32String
	return ret
}

func (v *iterNative) readETInt32String(et *typex.EventTime, key *int32, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETInt32String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32String
	return ret
}

func (v *iterNative) readInt32Int(key *int32, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerInt32Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Int
	return ret
}

func (v *iterNative) readETInt32Int(et *typex.EventTime, key *int32, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETInt32Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Int
	return ret
}

func (v *iterNative) readInt32Int8(key *int32, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerInt32Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Int8
	return ret
}

func (v *iterNative) readETInt32Int8(et *typex.EventTime, key *int32, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETInt32Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Int8
	return ret
}

func (v *iterNative) readInt32Int16(key *int32, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerInt32Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Int16
	return ret
}

func (v *iterNative) readETInt32Int16(et *typex.EventTime, key *int32, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETInt32Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Int16
	return ret
}

func (v *iterNative) readInt32Int32(key *int32, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerInt32Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Int32
	return ret
}

func (v *iterNative) readETInt32Int32(et *typex.EventTime, key *int32, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETInt32Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Int32
	return ret
}

func (v *iterNative) readInt32Int64(key *int32, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerInt32Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Int64
	return ret
}

func (v *iterNative) readETInt32Int64(et *typex.EventTime, key *int32, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETInt32Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Int64
	return ret
}

func (v *iterNative) readInt32Uint(key *int32, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerInt32Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Uint
	return ret
}

func (v *iterNative) readETInt32Uint(et *typex.EventTime, key *int32, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETInt32Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Uint
	return ret
}

func (v *iterNative) readInt32Uint8(key *int32, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerInt32Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Uint8
	return ret
}

func (v *iterNative) readETInt32Uint8(et *typex.EventTime, key *int32, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETInt32Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Uint8
	return ret
}

func (v *iterNative) readInt32Uint16(key *int32, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerInt32Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Uint16
	return ret
}

func (v *iterNative) readETInt32Uint16(et *typex.EventTime, key *int32, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETInt32Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Uint16
	return ret
}

func (v *iterNative) readInt32Uint32(key *int32, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerInt32Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Uint32
	return ret
}

func (v *iterNative) readETInt32Uint32(et *typex.EventTime, key *int32, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETInt32Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Uint32
	return ret
}

func (v *iterNative) readInt32Uint64(key *int32, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerInt32Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Uint64
	return ret
}

func (v *iterNative) readETInt32Uint64(et *typex.EventTime, key *int32, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETInt32Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Uint64
	return ret
}

func (v *iterNative) readInt32Float32(key *int32, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerInt32Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Float32
	return ret
}

func (v *iterNative) readETInt32Float32(et *typex.EventTime, key *int32, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETInt32Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Float32
	return ret
}

func (v *iterNative) readInt32Float64(key *int32, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerInt32Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Float64
	return ret
}

func (v *iterNative) readETInt32Float64(et *typex.EventTime, key *int32, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETInt32Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Float64
	return ret
}

func (v *iterNative) readInt32Typex_T(key *int32, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerInt32Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_T
	return ret
}

func (v *iterNative) readETInt32Typex_T(et *typex.EventTime, key *int32, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETInt32Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Typex_T
	return ret
}

func (v *iterNative) readInt32Typex_U(key *int32, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerInt32Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_U
	return ret
}

func (v *iterNative) readETInt32Typex_U(et *typex.EventTime, key *int32, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETInt32Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Typex_U
	return ret
}

func (v *iterNative) readInt32Typex_V(key *int32, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerInt32Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_V
	return ret
}

func (v *iterNative) readETInt32Typex_V(et *typex.EventTime, key *int32, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETInt32Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Typex_V
	return ret
}

func (v *iterNative) readInt32Typex_W(key *int32, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerInt32Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_W
	return ret
}

func (v *iterNative) readETInt32Typex_W(et *typex.EventTime, key *int32, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETInt32Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Typex_W
	return ret
}

func (v *iterNative) readInt32Typex_X(key *int32, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerInt32Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_X
	return ret
}

func (v *iterNative) readETInt32Typex_X(et *typex.EventTime, key *int32, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETInt32Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Typex_X
	return ret
}

func (v *iterNative) readInt32Typex_Y(key *int32, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerInt32Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_Y
	return ret
}

func (v *iterNative) readETInt32Typex_Y(et *typex.EventTime, key *int32, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETInt32Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Typex_Y
	return ret
}

func (v *iterNative) readInt32Typex_Z(key *int32, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerInt32Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_Z
	return ret
}

func (v *iterNative) readETInt32Typex_Z(et *typex.EventTime, key *int32, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETInt32Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt32Typex_Z
	return ret
}

func (v *iterNative) readInt64(val *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(int64)
	return true
}

func iterMakerInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64
	return ret
}

func (v *iterNative) readETInt64(et *typex.EventTime, val *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(int64)
	return true
}

func iterMakerETInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64
	return ret
}

func (v *iterNative) readInt64ByteSlice(key *int64, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerInt64ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64ByteSlice
	return ret
}

func (v *iterNative) readETInt64ByteSlice(et *typex.EventTime, key *int64, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETInt64ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64ByteSlice
	return ret
}

func (v *iterNative) readInt64Bool(key *int64, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerInt64Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Bool
	return ret
}

func (v *iterNative) readETInt64Bool(et *typex.EventTime, key *int64, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETInt64Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Bool
	return ret
}

func (v *iterNative) readInt64String(key *int64, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerInt64String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64String
	return ret
}

func (v *iterNative) readETInt64String(et *typex.EventTime, key *int64, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETInt64String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64String
	return ret
}

func (v *iterNative) readInt64Int(key *int64, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerInt64Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Int
	return ret
}

func (v *iterNative) readETInt64Int(et *typex.EventTime, key *int64, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETInt64Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Int
	return ret
}

func (v *iterNative) readInt64Int8(key *int64, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerInt64Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Int8
	return ret
}

func (v *iterNative) readETInt64Int8(et *typex.EventTime, key *int64, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETInt64Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Int8
	return ret
}

func (v *iterNative) readInt64Int16(key *int64, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerInt64Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Int16
	return ret
}

func (v *iterNative) readETInt64Int16(et *typex.EventTime, key *int64, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETInt64Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Int16
	return ret
}

func (v *iterNative) readInt64Int32(key *int64, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerInt64Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Int32
	return ret
}

func (v *iterNative) readETInt64Int32(et *typex.EventTime, key *int64, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETInt64Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Int32
	return ret
}

func (v *iterNative) readInt64Int64(key *int64, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerInt64Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Int64
	return ret
}

func (v *iterNative) readETInt64Int64(et *typex.EventTime, key *int64, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETInt64Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Int64
	return ret
}

func (v *iterNative) readInt64Uint(key *int64, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerInt64Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Uint
	return ret
}

func (v *iterNative) readETInt64Uint(et *typex.EventTime, key *int64, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETInt64Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Uint
	return ret
}

func (v *iterNative) readInt64Uint8(key *int64, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerInt64Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Uint8
	return ret
}

func (v *iterNative) readETInt64Uint8(et *typex.EventTime, key *int64, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETInt64Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Uint8
	return ret
}

func (v *iterNative) readInt64Uint16(key *int64, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerInt64Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Uint16
	return ret
}

func (v *iterNative) readETInt64Uint16(et *typex.EventTime, key *int64, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETInt64Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Uint16
	return ret
}

func (v *iterNative) readInt64Uint32(key *int64, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerInt64Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Uint32
	return ret
}

func (v *iterNative) readETInt64Uint32(et *typex.EventTime, key *int64, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETInt64Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Uint32
	return ret
}

func (v *iterNative) readInt64Uint64(key *int64, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerInt64Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Uint64
	return ret
}

func (v *iterNative) readETInt64Uint64(et *typex.EventTime, key *int64, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETInt64Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Uint64
	return ret
}

func (v *iterNative) readInt64Float32(key *int64, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerInt64Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Float32
	return ret
}

func (v *iterNative) readETInt64Float32(et *typex.EventTime, key *int64, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETInt64Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Float32
	return ret
}

func (v *iterNative) readInt64Float64(key *int64, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerInt64Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Float64
	return ret
}

func (v *iterNative) readETInt64Float64(et *typex.EventTime, key *int64, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETInt64Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Float64
	return ret
}

func (v *iterNative) readInt64Typex_T(key *int64, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerInt64Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_T
	return ret
}

func (v *iterNative) readETInt64Typex_T(et *typex.EventTime, key *int64, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETInt64Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Typex_T
	return ret
}

func (v *iterNative) readInt64Typex_U(key *int64, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerInt64Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_U
	return ret
}

func (v *iterNative) readETInt64Typex_U(et *typex.EventTime, key *int64, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETInt64Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Typex_U
	return ret
}

func (v *iterNative) readInt64Typex_V(key *int64, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerInt64Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_V
	return ret
}

func (v *iterNative) readETInt64Typex_V(et *typex.EventTime, key *int64, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETInt64Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Typex_V
	return ret
}

func (v *iterNative) readInt64Typex_W(key *int64, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerInt64Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_W
	return ret
}

func (v *iterNative) readETInt64Typex_W(et *typex.EventTime, key *int64, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETInt64Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Typex_W
	return ret
}

func (v *iterNative) readInt64Typex_X(key *int64, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerInt64Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_X
	return ret
}

func (v *iterNative) readETInt64Typex_X(et *typex.EventTime, key *int64, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETInt64Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Typex_X
	return ret
}

func (v *iterNative) readInt64Typex_Y(key *int64, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerInt64Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_Y
	return ret
}

func (v *iterNative) readETInt64Typex_Y(et *typex.EventTime, key *int64, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETInt64Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Typex_Y
	return ret
}

func (v *iterNative) readInt64Typex_Z(key *int64, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerInt64Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_Z
	return ret
}

func (v *iterNative) readETInt64Typex_Z(et *typex.EventTime, key *int64, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETInt64Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETInt64Typex_Z
	return ret
}

func (v *iterNative) readUint(val *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(uint)
	return true
}

func iterMakerUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint
	return ret
}

func (v *iterNative) readETUint(et *typex.EventTime, val *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(uint)
	return true
}

func iterMakerETUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint
	return ret
}

func (v *iterNative) readUintByteSlice(key *uint, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerUintByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintByteSlice
	return ret
}

func (v *iterNative) readETUintByteSlice(et *typex.EventTime, key *uint, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETUintByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintByteSlice
	return ret
}

func (v *iterNative) readUintBool(key *uint, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerUintBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintBool
	return ret
}

func (v *iterNative) readETUintBool(et *typex.EventTime, key *uint, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETUintBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintBool
	return ret
}

func (v *iterNative) readUintString(key *uint, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerUintString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintString
	return ret
}

func (v *iterNative) readETUintString(et *typex.EventTime, key *uint, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETUintString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintString
	return ret
}

func (v *iterNative) readUintInt(key *uint, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerUintInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintInt
	return ret
}

func (v *iterNative) readETUintInt(et *typex.EventTime, key *uint, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETUintInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintInt
	return ret
}

func (v *iterNative) readUintInt8(key *uint, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerUintInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintInt8
	return ret
}

func (v *iterNative) readETUintInt8(et *typex.EventTime, key *uint, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETUintInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintInt8
	return ret
}

func (v *iterNative) readUintInt16(key *uint, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerUintInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintInt16
	return ret
}

func (v *iterNative) readETUintInt16(et *typex.EventTime, key *uint, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETUintInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintInt16
	return ret
}

func (v *iterNative) readUintInt32(key *uint, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerUintInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintInt32
	return ret
}

func (v *iterNative) readETUintInt32(et *typex.EventTime, key *uint, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETUintInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintInt32
	return ret
}

func (v *iterNative) readUintInt64(key *uint, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerUintInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintInt64
	return ret
}

func (v *iterNative) readETUintInt64(et *typex.EventTime, key *uint, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETUintInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintInt64
	return ret
}

func (v *iterNative) readUintUint(key *uint, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerUintUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintUint
	return ret
}

func (v *iterNative) readETUintUint(et *typex.EventTime, key *uint, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETUintUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintUint
	return ret
}

func (v *iterNative) readUintUint8(key *uint, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerUintUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintUint8
	return ret
}

func (v *iterNative) readETUintUint8(et *typex.EventTime, key *uint, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETUintUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintUint8
	return ret
}

func (v *iterNative) readUintUint16(key *uint, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerUintUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintUint16
	return ret
}

func (v *iterNative) readETUintUint16(et *typex.EventTime, key *uint, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETUintUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintUint16
	return ret
}

func (v *iterNative) readUintUint32(key *uint, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerUintUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintUint32
	return ret
}

func (v *iterNative) readETUintUint32(et *typex.EventTime, key *uint, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETUintUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintUint32
	return ret
}

func (v *iterNative) readUintUint64(key *uint, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerUintUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintUint64
	return ret
}

func (v *iterNative) readETUintUint64(et *typex.EventTime, key *uint, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETUintUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintUint64
	return ret
}

func (v *iterNative) readUintFloat32(key *uint, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerUintFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintFloat32
	return ret
}

func (v *iterNative) readETUintFloat32(et *typex.EventTime, key *uint, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETUintFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintFloat32
	return ret
}

func (v *iterNative) readUintFloat64(key *uint, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerUintFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintFloat64
	return ret
}

func (v *iterNative) readETUintFloat64(et *typex.EventTime, key *uint, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETUintFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintFloat64
	return ret
}

func (v *iterNative) readUintTypex_T(key *uint, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerUintTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_T
	return ret
}

func (v *iterNative) readETUintTypex_T(et *typex.EventTime, key *uint, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETUintTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintTypex_T
	return ret
}

func (v *iterNative) readUintTypex_U(key *uint, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerUintTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_U
	return ret
}

func (v *iterNative) readETUintTypex_U(et *typex.EventTime, key *uint, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETUintTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintTypex_U
	return ret
}

func (v *iterNative) readUintTypex_V(key *uint, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerUintTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_V
	return ret
}

func (v *iterNative) readETUintTypex_V(et *typex.EventTime, key *uint, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETUintTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintTypex_V
	return ret
}

func (v *iterNative) readUintTypex_W(key *uint, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerUintTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_W
	return ret
}

func (v *iterNative) readETUintTypex_W(et *typex.EventTime, key *uint, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETUintTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintTypex_W
	return ret
}

func (v *iterNative) readUintTypex_X(key *uint, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerUintTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_X
	return ret
}

func (v *iterNative) readETUintTypex_X(et *typex.EventTime, key *uint, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETUintTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintTypex_X
	return ret
}

func (v *iterNative) readUintTypex_Y(key *uint, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerUintTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_Y
	return ret
}

func (v *iterNative) readETUintTypex_Y(et *typex.EventTime, key *uint, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETUintTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintTypex_Y
	return ret
}

func (v *iterNative) readUintTypex_Z(key *uint, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerUintTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_Z
	return ret
}

func (v *iterNative) readETUintTypex_Z(et *typex.EventTime, key *uint, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETUintTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUintTypex_Z
	return ret
}

func (v *iterNative) readUint8(val *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(uint8)
	return true
}

func iterMakerUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8
	return ret
}

func (v *iterNative) readETUint8(et *typex.EventTime, val *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(uint8)
	return true
}

func iterMakerETUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8
	return ret
}

func (v *iterNative) readUint8ByteSlice(key *uint8, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerUint8ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8ByteSlice
	return ret
}

func (v *iterNative) readETUint8ByteSlice(et *typex.EventTime, key *uint8, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETUint8ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8ByteSlice
	return ret
}

func (v *iterNative) readUint8Bool(key *uint8, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerUint8Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Bool
	return ret
}

func (v *iterNative) readETUint8Bool(et *typex.EventTime, key *uint8, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETUint8Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Bool
	return ret
}

func (v *iterNative) readUint8String(key *uint8, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerUint8String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8String
	return ret
}

func (v *iterNative) readETUint8String(et *typex.EventTime, key *uint8, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETUint8String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8String
	return ret
}

func (v *iterNative) readUint8Int(key *uint8, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerUint8Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Int
	return ret
}

func (v *iterNative) readETUint8Int(et *typex.EventTime, key *uint8, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETUint8Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Int
	return ret
}

func (v *iterNative) readUint8Int8(key *uint8, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerUint8Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Int8
	return ret
}

func (v *iterNative) readETUint8Int8(et *typex.EventTime, key *uint8, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETUint8Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Int8
	return ret
}

func (v *iterNative) readUint8Int16(key *uint8, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerUint8Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Int16
	return ret
}

func (v *iterNative) readETUint8Int16(et *typex.EventTime, key *uint8, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETUint8Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Int16
	return ret
}

func (v *iterNative) readUint8Int32(key *uint8, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerUint8Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Int32
	return ret
}

func (v *iterNative) readETUint8Int32(et *typex.EventTime, key *uint8, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETUint8Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Int32
	return ret
}

func (v *iterNative) readUint8Int64(key *uint8, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerUint8Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Int64
	return ret
}

func (v *iterNative) readETUint8Int64(et *typex.EventTime, key *uint8, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETUint8Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Int64
	return ret
}

func (v *iterNative) readUint8Uint(key *uint8, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerUint8Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Uint
	return ret
}

func (v *iterNative) readETUint8Uint(et *typex.EventTime, key *uint8, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETUint8Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Uint
	return ret
}

func (v *iterNative) readUint8Uint8(key *uint8, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerUint8Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Uint8
	return ret
}

func (v *iterNative) readETUint8Uint8(et *typex.EventTime, key *uint8, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETUint8Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Uint8
	return ret
}

func (v *iterNative) readUint8Uint16(key *uint8, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerUint8Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Uint16
	return ret
}

func (v *iterNative) readETUint8Uint16(et *typex.EventTime, key *uint8, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETUint8Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Uint16
	return ret
}

func (v *iterNative) readUint8Uint32(key *uint8, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerUint8Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Uint32
	return ret
}

func (v *iterNative) readETUint8Uint32(et *typex.EventTime, key *uint8, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETUint8Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Uint32
	return ret
}

func (v *iterNative) readUint8Uint64(key *uint8, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerUint8Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Uint64
	return ret
}

func (v *iterNative) readETUint8Uint64(et *typex.EventTime, key *uint8, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETUint8Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Uint64
	return ret
}

func (v *iterNative) readUint8Float32(key *uint8, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerUint8Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Float32
	return ret
}

func (v *iterNative) readETUint8Float32(et *typex.EventTime, key *uint8, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETUint8Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Float32
	return ret
}

func (v *iterNative) readUint8Float64(key *uint8, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerUint8Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Float64
	return ret
}

func (v *iterNative) readETUint8Float64(et *typex.EventTime, key *uint8, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETUint8Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Float64
	return ret
}

func (v *iterNative) readUint8Typex_T(key *uint8, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerUint8Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_T
	return ret
}

func (v *iterNative) readETUint8Typex_T(et *typex.EventTime, key *uint8, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETUint8Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Typex_T
	return ret
}

func (v *iterNative) readUint8Typex_U(key *uint8, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerUint8Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_U
	return ret
}

func (v *iterNative) readETUint8Typex_U(et *typex.EventTime, key *uint8, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETUint8Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Typex_U
	return ret
}

func (v *iterNative) readUint8Typex_V(key *uint8, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerUint8Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_V
	return ret
}

func (v *iterNative) readETUint8Typex_V(et *typex.EventTime, key *uint8, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETUint8Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Typex_V
	return ret
}

func (v *iterNative) readUint8Typex_W(key *uint8, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerUint8Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_W
	return ret
}

func (v *iterNative) readETUint8Typex_W(et *typex.EventTime, key *uint8, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETUint8Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Typex_W
	return ret
}

func (v *iterNative) readUint8Typex_X(key *uint8, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerUint8Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_X
	return ret
}

func (v *iterNative) readETUint8Typex_X(et *typex.EventTime, key *uint8, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETUint8Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Typex_X
	return ret
}

func (v *iterNative) readUint8Typex_Y(key *uint8, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerUint8Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_Y
	return ret
}

func (v *iterNative) readETUint8Typex_Y(et *typex.EventTime, key *uint8, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETUint8Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Typex_Y
	return ret
}

func (v *iterNative) readUint8Typex_Z(key *uint8, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerUint8Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_Z
	return ret
}

func (v *iterNative) readETUint8Typex_Z(et *typex.EventTime, key *uint8, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETUint8Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint8Typex_Z
	return ret
}

func (v *iterNative) readUint16(val *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(uint16)
	return true
}

func iterMakerUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16
	return ret
}

func (v *iterNative) readETUint16(et *typex.EventTime, val *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(uint16)
	return true
}

func iterMakerETUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16
	return ret
}

func (v *iterNative) readUint16ByteSlice(key *uint16, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerUint16ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16ByteSlice
	return ret
}

func (v *iterNative) readETUint16ByteSlice(et *typex.EventTime, key *uint16, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETUint16ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16ByteSlice
	return ret
}

func (v *iterNative) readUint16Bool(key *uint16, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerUint16Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Bool
	return ret
}

func (v *iterNative) readETUint16Bool(et *typex.EventTime, key *uint16, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETUint16Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Bool
	return ret
}

func (v *iterNative) readUint16String(key *uint16, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerUint16String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16String
	return ret
}

func (v *iterNative) readETUint16String(et *typex.EventTime, key *uint16, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETUint16String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16String
	return ret
}

func (v *iterNative) readUint16Int(key *uint16, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerUint16Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Int
	return ret
}

func (v *iterNative) readETUint16Int(et *typex.EventTime, key *uint16, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETUint16Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Int
	return ret
}

func (v *iterNative) readUint16Int8(key *uint16, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerUint16Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Int8
	return ret
}

func (v *iterNative) readETUint16Int8(et *typex.EventTime, key *uint16, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETUint16Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Int8
	return ret
}

func (v *iterNative) readUint16Int16(key *uint16, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerUint16Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Int16
	return ret
}

func (v *iterNative) readETUint16Int16(et *typex.EventTime, key *uint16, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETUint16Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Int16
	return ret
}

func (v *iterNative) readUint16Int32(key *uint16, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerUint16Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Int32
	return ret
}

func (v *iterNative) readETUint16Int32(et *typex.EventTime, key *uint16, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETUint16Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Int32
	return ret
}

func (v *iterNative) readUint16Int64(key *uint16, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerUint16Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Int64
	return ret
}

func (v *iterNative) readETUint16Int64(et *typex.EventTime, key *uint16, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETUint16Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Int64
	return ret
}

func (v *iterNative) readUint16Uint(key *uint16, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerUint16Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Uint
	return ret
}

func (v *iterNative) readETUint16Uint(et *typex.EventTime, key *uint16, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETUint16Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Uint
	return ret
}

func (v *iterNative) readUint16Uint8(key *uint16, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerUint16Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Uint8
	return ret
}

func (v *iterNative) readETUint16Uint8(et *typex.EventTime, key *uint16, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETUint16Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Uint8
	return ret
}

func (v *iterNative) readUint16Uint16(key *uint16, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerUint16Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Uint16
	return ret
}

func (v *iterNative) readETUint16Uint16(et *typex.EventTime, key *uint16, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETUint16Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Uint16
	return ret
}

func (v *iterNative) readUint16Uint32(key *uint16, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerUint16Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Uint32
	return ret
}

func (v *iterNative) readETUint16Uint32(et *typex.EventTime, key *uint16, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETUint16Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Uint32
	return ret
}

func (v *iterNative) readUint16Uint64(key *uint16, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerUint16Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Uint64
	return ret
}

func (v *iterNative) readETUint16Uint64(et *typex.EventTime, key *uint16, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETUint16Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Uint64
	return ret
}

func (v *iterNative) readUint16Float32(key *uint16, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerUint16Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Float32
	return ret
}

func (v *iterNative) readETUint16Float32(et *typex.EventTime, key *uint16, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETUint16Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Float32
	return ret
}

func (v *iterNative) readUint16Float64(key *uint16, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerUint16Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Float64
	return ret
}

func (v *iterNative) readETUint16Float64(et *typex.EventTime, key *uint16, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETUint16Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Float64
	return ret
}

func (v *iterNative) readUint16Typex_T(key *uint16, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerUint16Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_T
	return ret
}

func (v *iterNative) readETUint16Typex_T(et *typex.EventTime, key *uint16, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETUint16Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Typex_T
	return ret
}

func (v *iterNative) readUint16Typex_U(key *uint16, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerUint16Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_U
	return ret
}

func (v *iterNative) readETUint16Typex_U(et *typex.EventTime, key *uint16, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETUint16Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Typex_U
	return ret
}

func (v *iterNative) readUint16Typex_V(key *uint16, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerUint16Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_V
	return ret
}

func (v *iterNative) readETUint16Typex_V(et *typex.EventTime, key *uint16, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETUint16Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Typex_V
	return ret
}

func (v *iterNative) readUint16Typex_W(key *uint16, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerUint16Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_W
	return ret
}

func (v *iterNative) readETUint16Typex_W(et *typex.EventTime, key *uint16, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETUint16Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Typex_W
	return ret
}

func (v *iterNative) readUint16Typex_X(key *uint16, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerUint16Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_X
	return ret
}

func (v *iterNative) readETUint16Typex_X(et *typex.EventTime, key *uint16, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETUint16Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Typex_X
	return ret
}

func (v *iterNative) readUint16Typex_Y(key *uint16, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerUint16Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_Y
	return ret
}

func (v *iterNative) readETUint16Typex_Y(et *typex.EventTime, key *uint16, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETUint16Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Typex_Y
	return ret
}

func (v *iterNative) readUint16Typex_Z(key *uint16, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerUint16Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_Z
	return ret
}

func (v *iterNative) readETUint16Typex_Z(et *typex.EventTime, key *uint16, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETUint16Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint16Typex_Z
	return ret
}

func (v *iterNative) readUint32(val *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(uint32)
	return true
}

func iterMakerUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32
	return ret
}

func (v *iterNative) readETUint32(et *typex.EventTime, val *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(uint32)
	return true
}

func iterMakerETUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32
	return ret
}

func (v *iterNative) readUint32ByteSlice(key *uint32, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerUint32ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32ByteSlice
	return ret
}

func (v *iterNative) readETUint32ByteSlice(et *typex.EventTime, key *uint32, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETUint32ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32ByteSlice
	return ret
}

func (v *iterNative) readUint32Bool(key *uint32, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerUint32Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Bool
	return ret
}

func (v *iterNative) readETUint32Bool(et *typex.EventTime, key *uint32, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETUint32Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Bool
	return ret
}

func (v *iterNative) readUint32String(key *uint32, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerUint32String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32String
	return ret
}

func (v *iterNative) readETUint32String(et *typex.EventTime, key *uint32, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETUint32String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32String
	return ret
}

func (v *iterNative) readUint32Int(key *uint32, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerUint32Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Int
	return ret
}

func (v *iterNative) readETUint32Int(et *typex.EventTime, key *uint32, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETUint32Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Int
	return ret
}

func (v *iterNative) readUint32Int8(key *uint32, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerUint32Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Int8
	return ret
}

func (v *iterNative) readETUint32Int8(et *typex.EventTime, key *uint32, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETUint32Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Int8
	return ret
}

func (v *iterNative) readUint32Int16(key *uint32, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerUint32Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Int16
	return ret
}

func (v *iterNative) readETUint32Int16(et *typex.EventTime, key *uint32, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETUint32Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Int16
	return ret
}

func (v *iterNative) readUint32Int32(key *uint32, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerUint32Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Int32
	return ret
}

func (v *iterNative) readETUint32Int32(et *typex.EventTime, key *uint32, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETUint32Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Int32
	return ret
}

func (v *iterNative) readUint32Int64(key *uint32, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerUint32Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Int64
	return ret
}

func (v *iterNative) readETUint32Int64(et *typex.EventTime, key *uint32, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETUint32Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Int64
	return ret
}

func (v *iterNative) readUint32Uint(key *uint32, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerUint32Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Uint
	return ret
}

func (v *iterNative) readETUint32Uint(et *typex.EventTime, key *uint32, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETUint32Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Uint
	return ret
}

func (v *iterNative) readUint32Uint8(key *uint32, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerUint32Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Uint8
	return ret
}

func (v *iterNative) readETUint32Uint8(et *typex.EventTime, key *uint32, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETUint32Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Uint8
	return ret
}

func (v *iterNative) readUint32Uint16(key *uint32, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerUint32Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Uint16
	return ret
}

func (v *iterNative) readETUint32Uint16(et *typex.EventTime, key *uint32, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETUint32Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Uint16
	return ret
}

func (v *iterNative) readUint32Uint32(key *uint32, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerUint32Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Uint32
	return ret
}

func (v *iterNative) readETUint32Uint32(et *typex.EventTime, key *uint32, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETUint32Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Uint32
	return ret
}

func (v *iterNative) readUint32Uint64(key *uint32, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerUint32Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Uint64
	return ret
}

func (v *iterNative) readETUint32Uint64(et *typex.EventTime, key *uint32, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETUint32Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Uint64
	return ret
}

func (v *iterNative) readUint32Float32(key *uint32, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerUint32Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Float32
	return ret
}

func (v *iterNative) readETUint32Float32(et *typex.EventTime, key *uint32, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETUint32Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Float32
	return ret
}

func (v *iterNative) readUint32Float64(key *uint32, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerUint32Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Float64
	return ret
}

func (v *iterNative) readETUint32Float64(et *typex.EventTime, key *uint32, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETUint32Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Float64
	return ret
}

func (v *iterNative) readUint32Typex_T(key *uint32, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerUint32Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_T
	return ret
}

func (v *iterNative) readETUint32Typex_T(et *typex.EventTime, key *uint32, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETUint32Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Typex_T
	return ret
}

func (v *iterNative) readUint32Typex_U(key *uint32, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerUint32Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_U
	return ret
}

func (v *iterNative) readETUint32Typex_U(et *typex.EventTime, key *uint32, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETUint32Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Typex_U
	return ret
}

func (v *iterNative) readUint32Typex_V(key *uint32, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerUint32Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_V
	return ret
}

func (v *iterNative) readETUint32Typex_V(et *typex.EventTime, key *uint32, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETUint32Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Typex_V
	return ret
}

func (v *iterNative) readUint32Typex_W(key *uint32, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerUint32Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_W
	return ret
}

func (v *iterNative) readETUint32Typex_W(et *typex.EventTime, key *uint32, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETUint32Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Typex_W
	return ret
}

func (v *iterNative) readUint32Typex_X(key *uint32, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerUint32Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_X
	return ret
}

func (v *iterNative) readETUint32Typex_X(et *typex.EventTime, key *uint32, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETUint32Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Typex_X
	return ret
}

func (v *iterNative) readUint32Typex_Y(key *uint32, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerUint32Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_Y
	return ret
}

func (v *iterNative) readETUint32Typex_Y(et *typex.EventTime, key *uint32, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETUint32Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Typex_Y
	return ret
}

func (v *iterNative) readUint32Typex_Z(key *uint32, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerUint32Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_Z
	return ret
}

func (v *iterNative) readETUint32Typex_Z(et *typex.EventTime, key *uint32, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETUint32Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint32Typex_Z
	return ret
}

func (v *iterNative) readUint64(val *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(uint64)
	return true
}

func iterMakerUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64
	return ret
}

func (v *iterNative) readETUint64(et *typex.EventTime, val *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(uint64)
	return true
}

func iterMakerETUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64
	return ret
}

func (v *iterNative) readUint64ByteSlice(key *uint64, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerUint64ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64ByteSlice
	return ret
}

func (v *iterNative) readETUint64ByteSlice(et *typex.EventTime, key *uint64, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETUint64ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64ByteSlice
	return ret
}

func (v *iterNative) readUint64Bool(key *uint64, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerUint64Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Bool
	return ret
}

func (v *iterNative) readETUint64Bool(et *typex.EventTime, key *uint64, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETUint64Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Bool
	return ret
}

func (v *iterNative) readUint64String(key *uint64, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerUint64String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64String
	return ret
}

func (v *iterNative) readETUint64String(et *typex.EventTime, key *uint64, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETUint64String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64String
	return ret
}

func (v *iterNative) readUint64Int(key *uint64, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerUint64Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Int
	return ret
}

func (v *iterNative) readETUint64Int(et *typex.EventTime, key *uint64, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETUint64Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Int
	return ret
}

func (v *iterNative) readUint64Int8(key *uint64, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerUint64Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Int8
	return ret
}

func (v *iterNative) readETUint64Int8(et *typex.EventTime, key *uint64, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETUint64Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Int8
	return ret
}

func (v *iterNative) readUint64Int16(key *uint64, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerUint64Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Int16
	return ret
}

func (v *iterNative) readETUint64Int16(et *typex.EventTime, key *uint64, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETUint64Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Int16
	return ret
}

func (v *iterNative) readUint64Int32(key *uint64, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerUint64Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Int32
	return ret
}

func (v *iterNative) readETUint64Int32(et *typex.EventTime, key *uint64, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETUint64Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Int32
	return ret
}

func (v *iterNative) readUint64Int64(key *uint64, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerUint64Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Int64
	return ret
}

func (v *iterNative) readETUint64Int64(et *typex.EventTime, key *uint64, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETUint64Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Int64
	return ret
}

func (v *iterNative) readUint64Uint(key *uint64, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerUint64Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Uint
	return ret
}

func (v *iterNative) readETUint64Uint(et *typex.EventTime, key *uint64, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETUint64Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Uint
	return ret
}

func (v *iterNative) readUint64Uint8(key *uint64, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerUint64Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Uint8
	return ret
}

func (v *iterNative) readETUint64Uint8(et *typex.EventTime, key *uint64, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETUint64Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Uint8
	return ret
}

func (v *iterNative) readUint64Uint16(key *uint64, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerUint64Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Uint16
	return ret
}

func (v *iterNative) readETUint64Uint16(et *typex.EventTime, key *uint64, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETUint64Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Uint16
	return ret
}

func (v *iterNative) readUint64Uint32(key *uint64, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerUint64Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Uint32
	return ret
}

func (v *iterNative) readETUint64Uint32(et *typex.EventTime, key *uint64, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETUint64Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Uint32
	return ret
}

func (v *iterNative) readUint64Uint64(key *uint64, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerUint64Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Uint64
	return ret
}

func (v *iterNative) readETUint64Uint64(et *typex.EventTime, key *uint64, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETUint64Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Uint64
	return ret
}

func (v *iterNative) readUint64Float32(key *uint64, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerUint64Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Float32
	return ret
}

func (v *iterNative) readETUint64Float32(et *typex.EventTime, key *uint64, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETUint64Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Float32
	return ret
}

func (v *iterNative) readUint64Float64(key *uint64, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerUint64Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Float64
	return ret
}

func (v *iterNative) readETUint64Float64(et *typex.EventTime, key *uint64, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETUint64Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Float64
	return ret
}

func (v *iterNative) readUint64Typex_T(key *uint64, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerUint64Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_T
	return ret
}

func (v *iterNative) readETUint64Typex_T(et *typex.EventTime, key *uint64, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETUint64Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Typex_T
	return ret
}

func (v *iterNative) readUint64Typex_U(key *uint64, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerUint64Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_U
	return ret
}

func (v *iterNative) readETUint64Typex_U(et *typex.EventTime, key *uint64, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETUint64Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Typex_U
	return ret
}

func (v *iterNative) readUint64Typex_V(key *uint64, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerUint64Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_V
	return ret
}

func (v *iterNative) readETUint64Typex_V(et *typex.EventTime, key *uint64, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETUint64Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Typex_V
	return ret
}

func (v *iterNative) readUint64Typex_W(key *uint64, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerUint64Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_W
	return ret
}

func (v *iterNative) readETUint64Typex_W(et *typex.EventTime, key *uint64, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETUint64Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Typex_W
	return ret
}

func (v *iterNative) readUint64Typex_X(key *uint64, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerUint64Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_X
	return ret
}

func (v *iterNative) readETUint64Typex_X(et *typex.EventTime, key *uint64, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETUint64Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Typex_X
	return ret
}

func (v *iterNative) readUint64Typex_Y(key *uint64, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerUint64Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_Y
	return ret
}

func (v *iterNative) readETUint64Typex_Y(et *typex.EventTime, key *uint64, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETUint64Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Typex_Y
	return ret
}

func (v *iterNative) readUint64Typex_Z(key *uint64, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerUint64Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_Z
	return ret
}

func (v *iterNative) readETUint64Typex_Z(et *typex.EventTime, key *uint64, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETUint64Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETUint64Typex_Z
	return ret
}

func (v *iterNative) readFloat32(val *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(float32)
	return true
}

func iterMakerFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32
	return ret
}

func (v *iterNative) readETFloat32(et *typex.EventTime, val *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(float32)
	return true
}

func iterMakerETFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32
	return ret
}

func (v *iterNative) readFloat32ByteSlice(key *float32, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerFloat32ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32ByteSlice
	return ret
}

func (v *iterNative) readETFloat32ByteSlice(et *typex.EventTime, key *float32, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETFloat32ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32ByteSlice
	return ret
}

func (v *iterNative) readFloat32Bool(key *float32, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerFloat32Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Bool
	return ret
}

func (v *iterNative) readETFloat32Bool(et *typex.EventTime, key *float32, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETFloat32Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Bool
	return ret
}

func (v *iterNative) readFloat32String(key *float32, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerFloat32String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32String
	return ret
}

func (v *iterNative) readETFloat32String(et *typex.EventTime, key *float32, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETFloat32String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32String
	return ret
}

func (v *iterNative) readFloat32Int(key *float32, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerFloat32Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Int
	return ret
}

func (v *iterNative) readETFloat32Int(et *typex.EventTime, key *float32, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETFloat32Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Int
	return ret
}

func (v *iterNative) readFloat32Int8(key *float32, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerFloat32Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Int8
	return ret
}

func (v *iterNative) readETFloat32Int8(et *typex.EventTime, key *float32, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETFloat32Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Int8
	return ret
}

func (v *iterNative) readFloat32Int16(key *float32, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerFloat32Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Int16
	return ret
}

func (v *iterNative) readETFloat32Int16(et *typex.EventTime, key *float32, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETFloat32Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Int16
	return ret
}

func (v *iterNative) readFloat32Int32(key *float32, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerFloat32Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Int32
	return ret
}

func (v *iterNative) readETFloat32Int32(et *typex.EventTime, key *float32, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETFloat32Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Int32
	return ret
}

func (v *iterNative) readFloat32Int64(key *float32, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerFloat32Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Int64
	return ret
}

func (v *iterNative) readETFloat32Int64(et *typex.EventTime, key *float32, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETFloat32Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Int64
	return ret
}

func (v *iterNative) readFloat32Uint(key *float32, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerFloat32Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Uint
	return ret
}

func (v *iterNative) readETFloat32Uint(et *typex.EventTime, key *float32, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETFloat32Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Uint
	return ret
}

func (v *iterNative) readFloat32Uint8(key *float32, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerFloat32Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Uint8
	return ret
}

func (v *iterNative) readETFloat32Uint8(et *typex.EventTime, key *float32, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETFloat32Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Uint8
	return ret
}

func (v *iterNative) readFloat32Uint16(key *float32, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerFloat32Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Uint16
	return ret
}

func (v *iterNative) readETFloat32Uint16(et *typex.EventTime, key *float32, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETFloat32Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Uint16
	return ret
}

func (v *iterNative) readFloat32Uint32(key *float32, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerFloat32Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Uint32
	return ret
}

func (v *iterNative) readETFloat32Uint32(et *typex.EventTime, key *float32, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETFloat32Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Uint32
	return ret
}

func (v *iterNative) readFloat32Uint64(key *float32, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerFloat32Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Uint64
	return ret
}

func (v *iterNative) readETFloat32Uint64(et *typex.EventTime, key *float32, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETFloat32Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Uint64
	return ret
}

func (v *iterNative) readFloat32Float32(key *float32, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerFloat32Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Float32
	return ret
}

func (v *iterNative) readETFloat32Float32(et *typex.EventTime, key *float32, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETFloat32Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Float32
	return ret
}

func (v *iterNative) readFloat32Float64(key *float32, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerFloat32Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Float64
	return ret
}

func (v *iterNative) readETFloat32Float64(et *typex.EventTime, key *float32, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETFloat32Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Float64
	return ret
}

func (v *iterNative) readFloat32Typex_T(key *float32, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerFloat32Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_T
	return ret
}

func (v *iterNative) readETFloat32Typex_T(et *typex.EventTime, key *float32, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETFloat32Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Typex_T
	return ret
}

func (v *iterNative) readFloat32Typex_U(key *float32, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerFloat32Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_U
	return ret
}

func (v *iterNative) readETFloat32Typex_U(et *typex.EventTime, key *float32, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETFloat32Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Typex_U
	return ret
}

func (v *iterNative) readFloat32Typex_V(key *float32, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerFloat32Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_V
	return ret
}

func (v *iterNative) readETFloat32Typex_V(et *typex.EventTime, key *float32, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETFloat32Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Typex_V
	return ret
}

func (v *iterNative) readFloat32Typex_W(key *float32, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerFloat32Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_W
	return ret
}

func (v *iterNative) readETFloat32Typex_W(et *typex.EventTime, key *float32, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETFloat32Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Typex_W
	return ret
}

func (v *iterNative) readFloat32Typex_X(key *float32, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerFloat32Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_X
	return ret
}

func (v *iterNative) readETFloat32Typex_X(et *typex.EventTime, key *float32, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETFloat32Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Typex_X
	return ret
}

func (v *iterNative) readFloat32Typex_Y(key *float32, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerFloat32Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_Y
	return ret
}

func (v *iterNative) readETFloat32Typex_Y(et *typex.EventTime, key *float32, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETFloat32Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Typex_Y
	return ret
}

func (v *iterNative) readFloat32Typex_Z(key *float32, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerFloat32Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_Z
	return ret
}

func (v *iterNative) readETFloat32Typex_Z(et *typex.EventTime, key *float32, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETFloat32Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat32Typex_Z
	return ret
}

func (v *iterNative) readFloat64(val *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(float64)
	return true
}

func iterMakerFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64
	return ret
}

func (v *iterNative) readETFloat64(et *typex.EventTime, val *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(float64)
	return true
}

func iterMakerETFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64
	return ret
}

func (v *iterNative) readFloat64ByteSlice(key *float64, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerFloat64ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64ByteSlice
	return ret
}

func (v *iterNative) readETFloat64ByteSlice(et *typex.EventTime, key *float64, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETFloat64ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64ByteSlice
	return ret
}

func (v *iterNative) readFloat64Bool(key *float64, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerFloat64Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Bool
	return ret
}

func (v *iterNative) readETFloat64Bool(et *typex.EventTime, key *float64, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETFloat64Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Bool
	return ret
}

func (v *iterNative) readFloat64String(key *float64, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerFloat64String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64String
	return ret
}

func (v *iterNative) readETFloat64String(et *typex.EventTime, key *float64, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETFloat64String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64String
	return ret
}

func (v *iterNative) readFloat64Int(key *float64, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerFloat64Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Int
	return ret
}

func (v *iterNative) readETFloat64Int(et *typex.EventTime, key *float64, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETFloat64Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Int
	return ret
}

func (v *iterNative) readFloat64Int8(key *float64, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerFloat64Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Int8
	return ret
}

func (v *iterNative) readETFloat64Int8(et *typex.EventTime, key *float64, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETFloat64Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Int8
	return ret
}

func (v *iterNative) readFloat64Int16(key *float64, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerFloat64Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Int16
	return ret
}

func (v *iterNative) readETFloat64Int16(et *typex.EventTime, key *float64, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETFloat64Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Int16
	return ret
}

func (v *iterNative) readFloat64Int32(key *float64, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerFloat64Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Int32
	return ret
}

func (v *iterNative) readETFloat64Int32(et *typex.EventTime, key *float64, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETFloat64Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Int32
	return ret
}

func (v *iterNative) readFloat64Int64(key *float64, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerFloat64Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Int64
	return ret
}

func (v *iterNative) readETFloat64Int64(et *typex.EventTime, key *float64, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETFloat64Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Int64
	return ret
}

func (v *iterNative) readFloat64Uint(key *float64, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerFloat64Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Uint
	return ret
}

func (v *iterNative) readETFloat64Uint(et *typex.EventTime, key *float64, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETFloat64Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Uint
	return ret
}

func (v *iterNative) readFloat64Uint8(key *float64, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerFloat64Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Uint8
	return ret
}

func (v *iterNative) readETFloat64Uint8(et *typex.EventTime, key *float64, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETFloat64Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Uint8
	return ret
}

func (v *iterNative) readFloat64Uint16(key *float64, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerFloat64Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Uint16
	return ret
}

func (v *iterNative) readETFloat64Uint16(et *typex.EventTime, key *float64, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETFloat64Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Uint16
	return ret
}

func (v *iterNative) readFloat64Uint32(key *float64, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerFloat64Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Uint32
	return ret
}

func (v *iterNative) readETFloat64Uint32(et *typex.EventTime, key *float64, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETFloat64Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Uint32
	return ret
}

func (v *iterNative) readFloat64Uint64(key *float64, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerFloat64Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Uint64
	return ret
}

func (v *iterNative) readETFloat64Uint64(et *typex.EventTime, key *float64, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETFloat64Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Uint64
	return ret
}

func (v *iterNative) readFloat64Float32(key *float64, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerFloat64Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Float32
	return ret
}

func (v *iterNative) readETFloat64Float32(et *typex.EventTime, key *float64, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETFloat64Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Float32
	return ret
}

func (v *iterNative) readFloat64Float64(key *float64, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerFloat64Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Float64
	return ret
}

func (v *iterNative) readETFloat64Float64(et *typex.EventTime, key *float64, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETFloat64Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Float64
	return ret
}

func (v *iterNative) readFloat64Typex_T(key *float64, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerFloat64Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_T
	return ret
}

func (v *iterNative) readETFloat64Typex_T(et *typex.EventTime, key *float64, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETFloat64Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Typex_T
	return ret
}

func (v *iterNative) readFloat64Typex_U(key *float64, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerFloat64Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_U
	return ret
}

func (v *iterNative) readETFloat64Typex_U(et *typex.EventTime, key *float64, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETFloat64Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Typex_U
	return ret
}

func (v *iterNative) readFloat64Typex_V(key *float64, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerFloat64Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_V
	return ret
}

func (v *iterNative) readETFloat64Typex_V(et *typex.EventTime, key *float64, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETFloat64Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Typex_V
	return ret
}

func (v *iterNative) readFloat64Typex_W(key *float64, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerFloat64Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_W
	return ret
}

func (v *iterNative) readETFloat64Typex_W(et *typex.EventTime, key *float64, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETFloat64Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Typex_W
	return ret
}

func (v *iterNative) readFloat64Typex_X(key *float64, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerFloat64Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_X
	return ret
}

func (v *iterNative) readETFloat64Typex_X(et *typex.EventTime, key *float64, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETFloat64Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Typex_X
	return ret
}

func (v *iterNative) readFloat64Typex_Y(key *float64, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerFloat64Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_Y
	return ret
}

func (v *iterNative) readETFloat64Typex_Y(et *typex.EventTime, key *float64, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETFloat64Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Typex_Y
	return ret
}

func (v *iterNative) readFloat64Typex_Z(key *float64, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerFloat64Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_Z
	return ret
}

func (v *iterNative) readETFloat64Typex_Z(et *typex.EventTime, key *float64, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETFloat64Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETFloat64Typex_Z
	return ret
}

func (v *iterNative) readTypex_T(val *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.T)
	return true
}

func iterMakerTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_T
	return ret
}

func (v *iterNative) readETTypex_T(et *typex.EventTime, val *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(typex.T)
	return true
}

func iterMakerETTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_T
	return ret
}

func (v *iterNative) readTypex_TByteSlice(key *typex.T, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_TByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TByteSlice
	return ret
}

func (v *iterNative) readETTypex_TByteSlice(et *typex.EventTime, key *typex.T, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETTypex_TByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TByteSlice
	return ret
}

func (v *iterNative) readTypex_TBool(key *typex.T, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_TBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TBool
	return ret
}

func (v *iterNative) readETTypex_TBool(et *typex.EventTime, key *typex.T, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETTypex_TBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TBool
	return ret
}

func (v *iterNative) readTypex_TString(key *typex.T, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerTypex_TString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TString
	return ret
}

func (v *iterNative) readETTypex_TString(et *typex.EventTime, key *typex.T, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETTypex_TString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TString
	return ret
}

func (v *iterNative) readTypex_TInt(key *typex.T, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_TInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TInt
	return ret
}

func (v *iterNative) readETTypex_TInt(et *typex.EventTime, key *typex.T, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETTypex_TInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TInt
	return ret
}

func (v *iterNative) readTypex_TInt8(key *typex.T, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_TInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TInt8
	return ret
}

func (v *iterNative) readETTypex_TInt8(et *typex.EventTime, key *typex.T, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETTypex_TInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TInt8
	return ret
}

func (v *iterNative) readTypex_TInt16(key *typex.T, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_TInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TInt16
	return ret
}

func (v *iterNative) readETTypex_TInt16(et *typex.EventTime, key *typex.T, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETTypex_TInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TInt16
	return ret
}

func (v *iterNative) readTypex_TInt32(key *typex.T, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_TInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TInt32
	return ret
}

func (v *iterNative) readETTypex_TInt32(et *typex.EventTime, key *typex.T, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETTypex_TInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TInt32
	return ret
}

func (v *iterNative) readTypex_TInt64(key *typex.T, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_TInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TInt64
	return ret
}

func (v *iterNative) readETTypex_TInt64(et *typex.EventTime, key *typex.T, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETTypex_TInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TInt64
	return ret
}

func (v *iterNative) readTypex_TUint(key *typex.T, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_TUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TUint
	return ret
}

func (v *iterNative) readETTypex_TUint(et *typex.EventTime, key *typex.T, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETTypex_TUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TUint
	return ret
}

func (v *iterNative) readTypex_TUint8(key *typex.T, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_TUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TUint8
	return ret
}

func (v *iterNative) readETTypex_TUint8(et *typex.EventTime, key *typex.T, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETTypex_TUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TUint8
	return ret
}

func (v *iterNative) readTypex_TUint16(key *typex.T, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_TUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TUint16
	return ret
}

func (v *iterNative) readETTypex_TUint16(et *typex.EventTime, key *typex.T, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETTypex_TUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TUint16
	return ret
}

func (v *iterNative) readTypex_TUint32(key *typex.T, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_TUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TUint32
	return ret
}

func (v *iterNative) readETTypex_TUint32(et *typex.EventTime, key *typex.T, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETTypex_TUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TUint32
	return ret
}

func (v *iterNative) readTypex_TUint64(key *typex.T, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_TUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TUint64
	return ret
}

func (v *iterNative) readETTypex_TUint64(et *typex.EventTime, key *typex.T, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETTypex_TUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TUint64
	return ret
}

func (v *iterNative) readTypex_TFloat32(key *typex.T, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_TFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TFloat32
	return ret
}

func (v *iterNative) readETTypex_TFloat32(et *typex.EventTime, key *typex.T, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETTypex_TFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TFloat32
	return ret
}

func (v *iterNative) readTypex_TFloat64(key *typex.T, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_TFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TFloat64
	return ret
}

func (v *iterNative) readETTypex_TFloat64(et *typex.EventTime, key *typex.T, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETTypex_TFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TFloat64
	return ret
}

func (v *iterNative) readTypex_TTypex_T(key *typex.T, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_TTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_T
	return ret
}

func (v *iterNative) readETTypex_TTypex_T(et *typex.EventTime, key *typex.T, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETTypex_TTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TTypex_T
	return ret
}

func (v *iterNative) readTypex_TTypex_U(key *typex.T, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_TTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_U
	return ret
}

func (v *iterNative) readETTypex_TTypex_U(et *typex.EventTime, key *typex.T, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETTypex_TTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TTypex_U
	return ret
}

func (v *iterNative) readTypex_TTypex_V(key *typex.T, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_TTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_V
	return ret
}

func (v *iterNative) readETTypex_TTypex_V(et *typex.EventTime, key *typex.T, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETTypex_TTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TTypex_V
	return ret
}

func (v *iterNative) readTypex_TTypex_W(key *typex.T, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_TTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_W
	return ret
}

func (v *iterNative) readETTypex_TTypex_W(et *typex.EventTime, key *typex.T, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETTypex_TTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TTypex_W
	return ret
}

func (v *iterNative) readTypex_TTypex_X(key *typex.T, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_TTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_X
	return ret
}

func (v *iterNative) readETTypex_TTypex_X(et *typex.EventTime, key *typex.T, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETTypex_TTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TTypex_X
	return ret
}

func (v *iterNative) readTypex_TTypex_Y(key *typex.T, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_TTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_Y
	return ret
}

func (v *iterNative) readETTypex_TTypex_Y(et *typex.EventTime, key *typex.T, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETTypex_TTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TTypex_Y
	return ret
}

func (v *iterNative) readTypex_TTypex_Z(key *typex.T, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_TTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_Z
	return ret
}

func (v *iterNative) readETTypex_TTypex_Z(et *typex.EventTime, key *typex.T, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETTypex_TTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_TTypex_Z
	return ret
}

func (v *iterNative) readTypex_U(val *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.U)
	return true
}

func iterMakerTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_U
	return ret
}

func (v *iterNative) readETTypex_U(et *typex.EventTime, val *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(typex.U)
	return true
}

func iterMakerETTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_U
	return ret
}

func (v *iterNative) readTypex_UByteSlice(key *typex.U, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_UByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UByteSlice
	return ret
}

func (v *iterNative) readETTypex_UByteSlice(et *typex.EventTime, key *typex.U, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETTypex_UByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UByteSlice
	return ret
}

func (v *iterNative) readTypex_UBool(key *typex.U, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_UBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UBool
	return ret
}

func (v *iterNative) readETTypex_UBool(et *typex.EventTime, key *typex.U, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETTypex_UBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UBool
	return ret
}

func (v *iterNative) readTypex_UString(key *typex.U, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerTypex_UString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UString
	return ret
}

func (v *iterNative) readETTypex_UString(et *typex.EventTime, key *typex.U, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETTypex_UString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UString
	return ret
}

func (v *iterNative) readTypex_UInt(key *typex.U, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_UInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UInt
	return ret
}

func (v *iterNative) readETTypex_UInt(et *typex.EventTime, key *typex.U, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETTypex_UInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UInt
	return ret
}

func (v *iterNative) readTypex_UInt8(key *typex.U, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_UInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UInt8
	return ret
}

func (v *iterNative) readETTypex_UInt8(et *typex.EventTime, key *typex.U, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETTypex_UInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UInt8
	return ret
}

func (v *iterNative) readTypex_UInt16(key *typex.U, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_UInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UInt16
	return ret
}

func (v *iterNative) readETTypex_UInt16(et *typex.EventTime, key *typex.U, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETTypex_UInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UInt16
	return ret
}

func (v *iterNative) readTypex_UInt32(key *typex.U, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_UInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UInt32
	return ret
}

func (v *iterNative) readETTypex_UInt32(et *typex.EventTime, key *typex.U, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETTypex_UInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UInt32
	return ret
}

func (v *iterNative) readTypex_UInt64(key *typex.U, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_UInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UInt64
	return ret
}

func (v *iterNative) readETTypex_UInt64(et *typex.EventTime, key *typex.U, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETTypex_UInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UInt64
	return ret
}

func (v *iterNative) readTypex_UUint(key *typex.U, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_UUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UUint
	return ret
}

func (v *iterNative) readETTypex_UUint(et *typex.EventTime, key *typex.U, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETTypex_UUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UUint
	return ret
}

func (v *iterNative) readTypex_UUint8(key *typex.U, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_UUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UUint8
	return ret
}

func (v *iterNative) readETTypex_UUint8(et *typex.EventTime, key *typex.U, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETTypex_UUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UUint8
	return ret
}

func (v *iterNative) readTypex_UUint16(key *typex.U, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_UUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UUint16
	return ret
}

func (v *iterNative) readETTypex_UUint16(et *typex.EventTime, key *typex.U, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETTypex_UUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UUint16
	return ret
}

func (v *iterNative) readTypex_UUint32(key *typex.U, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_UUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UUint32
	return ret
}

func (v *iterNative) readETTypex_UUint32(et *typex.EventTime, key *typex.U, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETTypex_UUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UUint32
	return ret
}

func (v *iterNative) readTypex_UUint64(key *typex.U, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_UUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UUint64
	return ret
}

func (v *iterNative) readETTypex_UUint64(et *typex.EventTime, key *typex.U, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETTypex_UUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UUint64
	return ret
}

func (v *iterNative) readTypex_UFloat32(key *typex.U, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_UFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UFloat32
	return ret
}

func (v *iterNative) readETTypex_UFloat32(et *typex.EventTime, key *typex.U, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETTypex_UFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UFloat32
	return ret
}

func (v *iterNative) readTypex_UFloat64(key *typex.U, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_UFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UFloat64
	return ret
}

func (v *iterNative) readETTypex_UFloat64(et *typex.EventTime, key *typex.U, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETTypex_UFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UFloat64
	return ret
}

func (v *iterNative) readTypex_UTypex_T(key *typex.U, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_UTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_T
	return ret
}

func (v *iterNative) readETTypex_UTypex_T(et *typex.EventTime, key *typex.U, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETTypex_UTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UTypex_T
	return ret
}

func (v *iterNative) readTypex_UTypex_U(key *typex.U, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_UTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_U
	return ret
}

func (v *iterNative) readETTypex_UTypex_U(et *typex.EventTime, key *typex.U, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETTypex_UTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UTypex_U
	return ret
}

func (v *iterNative) readTypex_UTypex_V(key *typex.U, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_UTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_V
	return ret
}

func (v *iterNative) readETTypex_UTypex_V(et *typex.EventTime, key *typex.U, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETTypex_UTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UTypex_V
	return ret
}

func (v *iterNative) readTypex_UTypex_W(key *typex.U, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_UTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_W
	return ret
}

func (v *iterNative) readETTypex_UTypex_W(et *typex.EventTime, key *typex.U, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETTypex_UTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UTypex_W
	return ret
}

func (v *iterNative) readTypex_UTypex_X(key *typex.U, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_UTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_X
	return ret
}

func (v *iterNative) readETTypex_UTypex_X(et *typex.EventTime, key *typex.U, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETTypex_UTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UTypex_X
	return ret
}

func (v *iterNative) readTypex_UTypex_Y(key *typex.U, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_UTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_Y
	return ret
}

func (v *iterNative) readETTypex_UTypex_Y(et *typex.EventTime, key *typex.U, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETTypex_UTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UTypex_Y
	return ret
}

func (v *iterNative) readTypex_UTypex_Z(key *typex.U, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_UTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_Z
	return ret
}

func (v *iterNative) readETTypex_UTypex_Z(et *typex.EventTime, key *typex.U, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETTypex_UTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_UTypex_Z
	return ret
}

func (v *iterNative) readTypex_V(val *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.V)
	return true
}

func iterMakerTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_V
	return ret
}

func (v *iterNative) readETTypex_V(et *typex.EventTime, val *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(typex.V)
	return true
}

func iterMakerETTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_V
	return ret
}

func (v *iterNative) readTypex_VByteSlice(key *typex.V, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_VByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VByteSlice
	return ret
}

func (v *iterNative) readETTypex_VByteSlice(et *typex.EventTime, key *typex.V, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETTypex_VByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VByteSlice
	return ret
}

func (v *iterNative) readTypex_VBool(key *typex.V, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_VBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VBool
	return ret
}

func (v *iterNative) readETTypex_VBool(et *typex.EventTime, key *typex.V, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETTypex_VBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VBool
	return ret
}

func (v *iterNative) readTypex_VString(key *typex.V, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerTypex_VString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VString
	return ret
}

func (v *iterNative) readETTypex_VString(et *typex.EventTime, key *typex.V, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETTypex_VString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VString
	return ret
}

func (v *iterNative) readTypex_VInt(key *typex.V, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_VInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VInt
	return ret
}

func (v *iterNative) readETTypex_VInt(et *typex.EventTime, key *typex.V, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETTypex_VInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VInt
	return ret
}

func (v *iterNative) readTypex_VInt8(key *typex.V, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_VInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VInt8
	return ret
}

func (v *iterNative) readETTypex_VInt8(et *typex.EventTime, key *typex.V, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETTypex_VInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VInt8
	return ret
}

func (v *iterNative) readTypex_VInt16(key *typex.V, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_VInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VInt16
	return ret
}

func (v *iterNative) readETTypex_VInt16(et *typex.EventTime, key *typex.V, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETTypex_VInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VInt16
	return ret
}

func (v *iterNative) readTypex_VInt32(key *typex.V, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_VInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VInt32
	return ret
}

func (v *iterNative) readETTypex_VInt32(et *typex.EventTime, key *typex.V, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETTypex_VInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VInt32
	return ret
}

func (v *iterNative) readTypex_VInt64(key *typex.V, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_VInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VInt64
	return ret
}

func (v *iterNative) readETTypex_VInt64(et *typex.EventTime, key *typex.V, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETTypex_VInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VInt64
	return ret
}

func (v *iterNative) readTypex_VUint(key *typex.V, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_VUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VUint
	return ret
}

func (v *iterNative) readETTypex_VUint(et *typex.EventTime, key *typex.V, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETTypex_VUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VUint
	return ret
}

func (v *iterNative) readTypex_VUint8(key *typex.V, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_VUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VUint8
	return ret
}

func (v *iterNative) readETTypex_VUint8(et *typex.EventTime, key *typex.V, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETTypex_VUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VUint8
	return ret
}

func (v *iterNative) readTypex_VUint16(key *typex.V, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_VUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VUint16
	return ret
}

func (v *iterNative) readETTypex_VUint16(et *typex.EventTime, key *typex.V, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETTypex_VUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VUint16
	return ret
}

func (v *iterNative) readTypex_VUint32(key *typex.V, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_VUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VUint32
	return ret
}

func (v *iterNative) readETTypex_VUint32(et *typex.EventTime, key *typex.V, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETTypex_VUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VUint32
	return ret
}

func (v *iterNative) readTypex_VUint64(key *typex.V, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_VUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VUint64
	return ret
}

func (v *iterNative) readETTypex_VUint64(et *typex.EventTime, key *typex.V, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETTypex_VUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VUint64
	return ret
}

func (v *iterNative) readTypex_VFloat32(key *typex.V, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_VFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VFloat32
	return ret
}

func (v *iterNative) readETTypex_VFloat32(et *typex.EventTime, key *typex.V, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETTypex_VFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VFloat32
	return ret
}

func (v *iterNative) readTypex_VFloat64(key *typex.V, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_VFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VFloat64
	return ret
}

func (v *iterNative) readETTypex_VFloat64(et *typex.EventTime, key *typex.V, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETTypex_VFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VFloat64
	return ret
}

func (v *iterNative) readTypex_VTypex_T(key *typex.V, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_VTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_T
	return ret
}

func (v *iterNative) readETTypex_VTypex_T(et *typex.EventTime, key *typex.V, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETTypex_VTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VTypex_T
	return ret
}

func (v *iterNative) readTypex_VTypex_U(key *typex.V, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_VTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_U
	return ret
}

func (v *iterNative) readETTypex_VTypex_U(et *typex.EventTime, key *typex.V, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETTypex_VTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VTypex_U
	return ret
}

func (v *iterNative) readTypex_VTypex_V(key *typex.V, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_VTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_V
	return ret
}

func (v *iterNative) readETTypex_VTypex_V(et *typex.EventTime, key *typex.V, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETTypex_VTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VTypex_V
	return ret
}

func (v *iterNative) readTypex_VTypex_W(key *typex.V, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_VTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_W
	return ret
}

func (v *iterNative) readETTypex_VTypex_W(et *typex.EventTime, key *typex.V, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETTypex_VTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VTypex_W
	return ret
}

func (v *iterNative) readTypex_VTypex_X(key *typex.V, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_VTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_X
	return ret
}

func (v *iterNative) readETTypex_VTypex_X(et *typex.EventTime, key *typex.V, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETTypex_VTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VTypex_X
	return ret
}

func (v *iterNative) readTypex_VTypex_Y(key *typex.V, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_VTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_Y
	return ret
}

func (v *iterNative) readETTypex_VTypex_Y(et *typex.EventTime, key *typex.V, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETTypex_VTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VTypex_Y
	return ret
}

func (v *iterNative) readTypex_VTypex_Z(key *typex.V, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_VTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_Z
	return ret
}

func (v *iterNative) readETTypex_VTypex_Z(et *typex.EventTime, key *typex.V, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETTypex_VTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_VTypex_Z
	return ret
}

func (v *iterNative) readTypex_W(val *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.W)
	return true
}

func iterMakerTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_W
	return ret
}

func (v *iterNative) readETTypex_W(et *typex.EventTime, val *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(typex.W)
	return true
}

func iterMakerETTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_W
	return ret
}

func (v *iterNative) readTypex_WByteSlice(key *typex.W, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_WByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WByteSlice
	return ret
}

func (v *iterNative) readETTypex_WByteSlice(et *typex.EventTime, key *typex.W, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETTypex_WByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WByteSlice
	return ret
}

func (v *iterNative) readTypex_WBool(key *typex.W, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_WBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WBool
	return ret
}

func (v *iterNative) readETTypex_WBool(et *typex.EventTime, key *typex.W, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETTypex_WBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WBool
	return ret
}

func (v *iterNative) readTypex_WString(key *typex.W, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerTypex_WString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WString
	return ret
}

func (v *iterNative) readETTypex_WString(et *typex.EventTime, key *typex.W, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETTypex_WString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WString
	return ret
}

func (v *iterNative) readTypex_WInt(key *typex.W, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_WInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WInt
	return ret
}

func (v *iterNative) readETTypex_WInt(et *typex.EventTime, key *typex.W, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETTypex_WInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WInt
	return ret
}

func (v *iterNative) readTypex_WInt8(key *typex.W, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_WInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WInt8
	return ret
}

func (v *iterNative) readETTypex_WInt8(et *typex.EventTime, key *typex.W, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETTypex_WInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WInt8
	return ret
}

func (v *iterNative) readTypex_WInt16(key *typex.W, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_WInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WInt16
	return ret
}

func (v *iterNative) readETTypex_WInt16(et *typex.EventTime, key *typex.W, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETTypex_WInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WInt16
	return ret
}

func (v *iterNative) readTypex_WInt32(key *typex.W, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_WInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WInt32
	return ret
}

func (v *iterNative) readETTypex_WInt32(et *typex.EventTime, key *typex.W, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETTypex_WInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WInt32
	return ret
}

func (v *iterNative) readTypex_WInt64(key *typex.W, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_WInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WInt64
	return ret
}

func (v *iterNative) readETTypex_WInt64(et *typex.EventTime, key *typex.W, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETTypex_WInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WInt64
	return ret
}

func (v *iterNative) readTypex_WUint(key *typex.W, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_WUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WUint
	return ret
}

func (v *iterNative) readETTypex_WUint(et *typex.EventTime, key *typex.W, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETTypex_WUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WUint
	return ret
}

func (v *iterNative) readTypex_WUint8(key *typex.W, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_WUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WUint8
	return ret
}

func (v *iterNative) readETTypex_WUint8(et *typex.EventTime, key *typex.W, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETTypex_WUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WUint8
	return ret
}

func (v *iterNative) readTypex_WUint16(key *typex.W, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_WUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WUint16
	return ret
}

func (v *iterNative) readETTypex_WUint16(et *typex.EventTime, key *typex.W, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETTypex_WUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WUint16
	return ret
}

func (v *iterNative) readTypex_WUint32(key *typex.W, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_WUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WUint32
	return ret
}

func (v *iterNative) readETTypex_WUint32(et *typex.EventTime, key *typex.W, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETTypex_WUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WUint32
	return ret
}

func (v *iterNative) readTypex_WUint64(key *typex.W, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_WUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WUint64
	return ret
}

func (v *iterNative) readETTypex_WUint64(et *typex.EventTime, key *typex.W, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETTypex_WUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WUint64
	return ret
}

func (v *iterNative) readTypex_WFloat32(key *typex.W, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_WFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WFloat32
	return ret
}

func (v *iterNative) readETTypex_WFloat32(et *typex.EventTime, key *typex.W, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETTypex_WFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WFloat32
	return ret
}

func (v *iterNative) readTypex_WFloat64(key *typex.W, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_WFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WFloat64
	return ret
}

func (v *iterNative) readETTypex_WFloat64(et *typex.EventTime, key *typex.W, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETTypex_WFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WFloat64
	return ret
}

func (v *iterNative) readTypex_WTypex_T(key *typex.W, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_WTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_T
	return ret
}

func (v *iterNative) readETTypex_WTypex_T(et *typex.EventTime, key *typex.W, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETTypex_WTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WTypex_T
	return ret
}

func (v *iterNative) readTypex_WTypex_U(key *typex.W, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_WTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_U
	return ret
}

func (v *iterNative) readETTypex_WTypex_U(et *typex.EventTime, key *typex.W, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETTypex_WTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WTypex_U
	return ret
}

func (v *iterNative) readTypex_WTypex_V(key *typex.W, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_WTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_V
	return ret
}

func (v *iterNative) readETTypex_WTypex_V(et *typex.EventTime, key *typex.W, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETTypex_WTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WTypex_V
	return ret
}

func (v *iterNative) readTypex_WTypex_W(key *typex.W, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_WTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_W
	return ret
}

func (v *iterNative) readETTypex_WTypex_W(et *typex.EventTime, key *typex.W, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETTypex_WTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WTypex_W
	return ret
}

func (v *iterNative) readTypex_WTypex_X(key *typex.W, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_WTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_X
	return ret
}

func (v *iterNative) readETTypex_WTypex_X(et *typex.EventTime, key *typex.W, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETTypex_WTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WTypex_X
	return ret
}

func (v *iterNative) readTypex_WTypex_Y(key *typex.W, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_WTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_Y
	return ret
}

func (v *iterNative) readETTypex_WTypex_Y(et *typex.EventTime, key *typex.W, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETTypex_WTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WTypex_Y
	return ret
}

func (v *iterNative) readTypex_WTypex_Z(key *typex.W, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_WTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_Z
	return ret
}

func (v *iterNative) readETTypex_WTypex_Z(et *typex.EventTime, key *typex.W, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETTypex_WTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_WTypex_Z
	return ret
}

func (v *iterNative) readTypex_X(val *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.X)
	return true
}

func iterMakerTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_X
	return ret
}

func (v *iterNative) readETTypex_X(et *typex.EventTime, val *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(typex.X)
	return true
}

func iterMakerETTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_X
	return ret
}

func (v *iterNative) readTypex_XByteSlice(key *typex.X, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_XByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XByteSlice
	return ret
}

func (v *iterNative) readETTypex_XByteSlice(et *typex.EventTime, key *typex.X, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETTypex_XByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XByteSlice
	return ret
}

func (v *iterNative) readTypex_XBool(key *typex.X, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_XBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XBool
	return ret
}

func (v *iterNative) readETTypex_XBool(et *typex.EventTime, key *typex.X, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETTypex_XBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XBool
	return ret
}

func (v *iterNative) readTypex_XString(key *typex.X, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerTypex_XString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XString
	return ret
}

func (v *iterNative) readETTypex_XString(et *typex.EventTime, key *typex.X, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETTypex_XString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XString
	return ret
}

func (v *iterNative) readTypex_XInt(key *typex.X, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_XInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XInt
	return ret
}

func (v *iterNative) readETTypex_XInt(et *typex.EventTime, key *typex.X, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETTypex_XInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XInt
	return ret
}

func (v *iterNative) readTypex_XInt8(key *typex.X, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_XInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XInt8
	return ret
}

func (v *iterNative) readETTypex_XInt8(et *typex.EventTime, key *typex.X, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETTypex_XInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XInt8
	return ret
}

func (v *iterNative) readTypex_XInt16(key *typex.X, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_XInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XInt16
	return ret
}

func (v *iterNative) readETTypex_XInt16(et *typex.EventTime, key *typex.X, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETTypex_XInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XInt16
	return ret
}

func (v *iterNative) readTypex_XInt32(key *typex.X, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_XInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XInt32
	return ret
}

func (v *iterNative) readETTypex_XInt32(et *typex.EventTime, key *typex.X, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETTypex_XInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XInt32
	return ret
}

func (v *iterNative) readTypex_XInt64(key *typex.X, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_XInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XInt64
	return ret
}

func (v *iterNative) readETTypex_XInt64(et *typex.EventTime, key *typex.X, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETTypex_XInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XInt64
	return ret
}

func (v *iterNative) readTypex_XUint(key *typex.X, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_XUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XUint
	return ret
}

func (v *iterNative) readETTypex_XUint(et *typex.EventTime, key *typex.X, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETTypex_XUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XUint
	return ret
}

func (v *iterNative) readTypex_XUint8(key *typex.X, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_XUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XUint8
	return ret
}

func (v *iterNative) readETTypex_XUint8(et *typex.EventTime, key *typex.X, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETTypex_XUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XUint8
	return ret
}

func (v *iterNative) readTypex_XUint16(key *typex.X, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_XUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XUint16
	return ret
}

func (v *iterNative) readETTypex_XUint16(et *typex.EventTime, key *typex.X, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETTypex_XUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XUint16
	return ret
}

func (v *iterNative) readTypex_XUint32(key *typex.X, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_XUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XUint32
	return ret
}

func (v *iterNative) readETTypex_XUint32(et *typex.EventTime, key *typex.X, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETTypex_XUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XUint32
	return ret
}

func (v *iterNative) readTypex_XUint64(key *typex.X, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_XUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XUint64
	return ret
}

func (v *iterNative) readETTypex_XUint64(et *typex.EventTime, key *typex.X, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETTypex_XUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XUint64
	return ret
}

func (v *iterNative) readTypex_XFloat32(key *typex.X, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_XFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XFloat32
	return ret
}

func (v *iterNative) readETTypex_XFloat32(et *typex.EventTime, key *typex.X, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETTypex_XFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XFloat32
	return ret
}

func (v *iterNative) readTypex_XFloat64(key *typex.X, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_XFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XFloat64
	return ret
}

func (v *iterNative) readETTypex_XFloat64(et *typex.EventTime, key *typex.X, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETTypex_XFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XFloat64
	return ret
}

func (v *iterNative) readTypex_XTypex_T(key *typex.X, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_XTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_T
	return ret
}

func (v *iterNative) readETTypex_XTypex_T(et *typex.EventTime, key *typex.X, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETTypex_XTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XTypex_T
	return ret
}

func (v *iterNative) readTypex_XTypex_U(key *typex.X, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_XTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_U
	return ret
}

func (v *iterNative) readETTypex_XTypex_U(et *typex.EventTime, key *typex.X, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETTypex_XTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XTypex_U
	return ret
}

func (v *iterNative) readTypex_XTypex_V(key *typex.X, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_XTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_V
	return ret
}

func (v *iterNative) readETTypex_XTypex_V(et *typex.EventTime, key *typex.X, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETTypex_XTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XTypex_V
	return ret
}

func (v *iterNative) readTypex_XTypex_W(key *typex.X, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_XTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_W
	return ret
}

func (v *iterNative) readETTypex_XTypex_W(et *typex.EventTime, key *typex.X, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETTypex_XTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XTypex_W
	return ret
}

func (v *iterNative) readTypex_XTypex_X(key *typex.X, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_XTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_X
	return ret
}

func (v *iterNative) readETTypex_XTypex_X(et *typex.EventTime, key *typex.X, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETTypex_XTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XTypex_X
	return ret
}

func (v *iterNative) readTypex_XTypex_Y(key *typex.X, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_XTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_Y
	return ret
}

func (v *iterNative) readETTypex_XTypex_Y(et *typex.EventTime, key *typex.X, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETTypex_XTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XTypex_Y
	return ret
}

func (v *iterNative) readTypex_XTypex_Z(key *typex.X, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_XTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_Z
	return ret
}

func (v *iterNative) readETTypex_XTypex_Z(et *typex.EventTime, key *typex.X, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETTypex_XTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_XTypex_Z
	return ret
}

func (v *iterNative) readTypex_Y(val *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.Y)
	return true
}

func iterMakerTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_Y
	return ret
}

func (v *iterNative) readETTypex_Y(et *typex.EventTime, val *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(typex.Y)
	return true
}

func iterMakerETTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_Y
	return ret
}

func (v *iterNative) readTypex_YByteSlice(key *typex.Y, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_YByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YByteSlice
	return ret
}

func (v *iterNative) readETTypex_YByteSlice(et *typex.EventTime, key *typex.Y, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETTypex_YByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YByteSlice
	return ret
}

func (v *iterNative) readTypex_YBool(key *typex.Y, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_YBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YBool
	return ret
}

func (v *iterNative) readETTypex_YBool(et *typex.EventTime, key *typex.Y, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETTypex_YBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YBool
	return ret
}

func (v *iterNative) readTypex_YString(key *typex.Y, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerTypex_YString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YString
	return ret
}

func (v *iterNative) readETTypex_YString(et *typex.EventTime, key *typex.Y, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETTypex_YString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YString
	return ret
}

func (v *iterNative) readTypex_YInt(key *typex.Y, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_YInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YInt
	return ret
}

func (v *iterNative) readETTypex_YInt(et *typex.EventTime, key *typex.Y, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETTypex_YInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YInt
	return ret
}

func (v *iterNative) readTypex_YInt8(key *typex.Y, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_YInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YInt8
	return ret
}

func (v *iterNative) readETTypex_YInt8(et *typex.EventTime, key *typex.Y, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETTypex_YInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YInt8
	return ret
}

func (v *iterNative) readTypex_YInt16(key *typex.Y, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_YInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YInt16
	return ret
}

func (v *iterNative) readETTypex_YInt16(et *typex.EventTime, key *typex.Y, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETTypex_YInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YInt16
	return ret
}

func (v *iterNative) readTypex_YInt32(key *typex.Y, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_YInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YInt32
	return ret
}

func (v *iterNative) readETTypex_YInt32(et *typex.EventTime, key *typex.Y, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETTypex_YInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YInt32
	return ret
}

func (v *iterNative) readTypex_YInt64(key *typex.Y, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_YInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YInt64
	return ret
}

func (v *iterNative) readETTypex_YInt64(et *typex.EventTime, key *typex.Y, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETTypex_YInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YInt64
	return ret
}

func (v *iterNative) readTypex_YUint(key *typex.Y, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_YUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YUint
	return ret
}

func (v *iterNative) readETTypex_YUint(et *typex.EventTime, key *typex.Y, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETTypex_YUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YUint
	return ret
}

func (v *iterNative) readTypex_YUint8(key *typex.Y, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_YUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YUint8
	return ret
}

func (v *iterNative) readETTypex_YUint8(et *typex.EventTime, key *typex.Y, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETTypex_YUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YUint8
	return ret
}

func (v *iterNative) readTypex_YUint16(key *typex.Y, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_YUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YUint16
	return ret
}

func (v *iterNative) readETTypex_YUint16(et *typex.EventTime, key *typex.Y, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETTypex_YUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YUint16
	return ret
}

func (v *iterNative) readTypex_YUint32(key *typex.Y, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_YUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YUint32
	return ret
}

func (v *iterNative) readETTypex_YUint32(et *typex.EventTime, key *typex.Y, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETTypex_YUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YUint32
	return ret
}

func (v *iterNative) readTypex_YUint64(key *typex.Y, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_YUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YUint64
	return ret
}

func (v *iterNative) readETTypex_YUint64(et *typex.EventTime, key *typex.Y, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETTypex_YUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YUint64
	return ret
}

func (v *iterNative) readTypex_YFloat32(key *typex.Y, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_YFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YFloat32
	return ret
}

func (v *iterNative) readETTypex_YFloat32(et *typex.EventTime, key *typex.Y, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETTypex_YFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YFloat32
	return ret
}

func (v *iterNative) readTypex_YFloat64(key *typex.Y, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_YFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YFloat64
	return ret
}

func (v *iterNative) readETTypex_YFloat64(et *typex.EventTime, key *typex.Y, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETTypex_YFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YFloat64
	return ret
}

func (v *iterNative) readTypex_YTypex_T(key *typex.Y, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_YTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_T
	return ret
}

func (v *iterNative) readETTypex_YTypex_T(et *typex.EventTime, key *typex.Y, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETTypex_YTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YTypex_T
	return ret
}

func (v *iterNative) readTypex_YTypex_U(key *typex.Y, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_YTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_U
	return ret
}

func (v *iterNative) readETTypex_YTypex_U(et *typex.EventTime, key *typex.Y, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETTypex_YTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YTypex_U
	return ret
}

func (v *iterNative) readTypex_YTypex_V(key *typex.Y, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_YTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_V
	return ret
}

func (v *iterNative) readETTypex_YTypex_V(et *typex.EventTime, key *typex.Y, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETTypex_YTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YTypex_V
	return ret
}

func (v *iterNative) readTypex_YTypex_W(key *typex.Y, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_YTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_W
	return ret
}

func (v *iterNative) readETTypex_YTypex_W(et *typex.EventTime, key *typex.Y, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETTypex_YTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YTypex_W
	return ret
}

func (v *iterNative) readTypex_YTypex_X(key *typex.Y, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_YTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_X
	return ret
}

func (v *iterNative) readETTypex_YTypex_X(et *typex.EventTime, key *typex.Y, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETTypex_YTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YTypex_X
	return ret
}

func (v *iterNative) readTypex_YTypex_Y(key *typex.Y, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_YTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_Y
	return ret
}

func (v *iterNative) readETTypex_YTypex_Y(et *typex.EventTime, key *typex.Y, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETTypex_YTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YTypex_Y
	return ret
}

func (v *iterNative) readTypex_YTypex_Z(key *typex.Y, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_YTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_Z
	return ret
}

func (v *iterNative) readETTypex_YTypex_Z(et *typex.EventTime, key *typex.Y, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETTypex_YTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_YTypex_Z
	return ret
}

func (v *iterNative) readTypex_Z(val *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.Z)
	return true
}

func iterMakerTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_Z
	return ret
}

func (v *iterNative) readETTypex_Z(et *typex.EventTime, val *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*val = elm.Elm.(typex.Z)
	return true
}

func iterMakerETTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_Z
	return ret
}

func (v *iterNative) readTypex_ZByteSlice(key *typex.Z, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_ZByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZByteSlice
	return ret
}

func (v *iterNative) readETTypex_ZByteSlice(et *typex.EventTime, key *typex.Z, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerETTypex_ZByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZByteSlice
	return ret
}

func (v *iterNative) readTypex_ZBool(key *typex.Z, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_ZBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZBool
	return ret
}

func (v *iterNative) readETTypex_ZBool(et *typex.EventTime, key *typex.Z, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerETTypex_ZBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZBool
	return ret
}

func (v *iterNative) readTypex_ZString(key *typex.Z, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerTypex_ZString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZString
	return ret
}

func (v *iterNative) readETTypex_ZString(et *typex.EventTime, key *typex.Z, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = convToString(elm.Elm2)
	return true
}

func iterMakerETTypex_ZString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZString
	return ret
}

func (v *iterNative) readTypex_ZInt(key *typex.Z, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_ZInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZInt
	return ret
}

func (v *iterNative) readETTypex_ZInt(et *typex.EventTime, key *typex.Z, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerETTypex_ZInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZInt
	return ret
}

func (v *iterNative) readTypex_ZInt8(key *typex.Z, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_ZInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZInt8
	return ret
}

func (v *iterNative) readETTypex_ZInt8(et *typex.EventTime, key *typex.Z, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerETTypex_ZInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZInt8
	return ret
}

func (v *iterNative) readTypex_ZInt16(key *typex.Z, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_ZInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZInt16
	return ret
}

func (v *iterNative) readETTypex_ZInt16(et *typex.EventTime, key *typex.Z, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerETTypex_ZInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZInt16
	return ret
}

func (v *iterNative) readTypex_ZInt32(key *typex.Z, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_ZInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZInt32
	return ret
}

func (v *iterNative) readETTypex_ZInt32(et *typex.EventTime, key *typex.Z, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerETTypex_ZInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZInt32
	return ret
}

func (v *iterNative) readTypex_ZInt64(key *typex.Z, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_ZInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZInt64
	return ret
}

func (v *iterNative) readETTypex_ZInt64(et *typex.EventTime, key *typex.Z, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerETTypex_ZInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZInt64
	return ret
}

func (v *iterNative) readTypex_ZUint(key *typex.Z, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_ZUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZUint
	return ret
}

func (v *iterNative) readETTypex_ZUint(et *typex.EventTime, key *typex.Z, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerETTypex_ZUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZUint
	return ret
}

func (v *iterNative) readTypex_ZUint8(key *typex.Z, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_ZUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZUint8
	return ret
}

func (v *iterNative) readETTypex_ZUint8(et *typex.EventTime, key *typex.Z, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerETTypex_ZUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZUint8
	return ret
}

func (v *iterNative) readTypex_ZUint16(key *typex.Z, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_ZUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZUint16
	return ret
}

func (v *iterNative) readETTypex_ZUint16(et *typex.EventTime, key *typex.Z, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerETTypex_ZUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZUint16
	return ret
}

func (v *iterNative) readTypex_ZUint32(key *typex.Z, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_ZUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZUint32
	return ret
}

func (v *iterNative) readETTypex_ZUint32(et *typex.EventTime, key *typex.Z, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerETTypex_ZUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZUint32
	return ret
}

func (v *iterNative) readTypex_ZUint64(key *typex.Z, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_ZUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZUint64
	return ret
}

func (v *iterNative) readETTypex_ZUint64(et *typex.EventTime, key *typex.Z, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerETTypex_ZUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZUint64
	return ret
}

func (v *iterNative) readTypex_ZFloat32(key *typex.Z, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_ZFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZFloat32
	return ret
}

func (v *iterNative) readETTypex_ZFloat32(et *typex.EventTime, key *typex.Z, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerETTypex_ZFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZFloat32
	return ret
}

func (v *iterNative) readTypex_ZFloat64(key *typex.Z, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_ZFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZFloat64
	return ret
}

func (v *iterNative) readETTypex_ZFloat64(et *typex.EventTime, key *typex.Z, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerETTypex_ZFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZFloat64
	return ret
}

func (v *iterNative) readTypex_ZTypex_T(key *typex.Z, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_ZTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_T
	return ret
}

func (v *iterNative) readETTypex_ZTypex_T(et *typex.EventTime, key *typex.Z, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerETTypex_ZTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZTypex_T
	return ret
}

func (v *iterNative) readTypex_ZTypex_U(key *typex.Z, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_ZTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_U
	return ret
}

func (v *iterNative) readETTypex_ZTypex_U(et *typex.EventTime, key *typex.Z, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerETTypex_ZTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZTypex_U
	return ret
}

func (v *iterNative) readTypex_ZTypex_V(key *typex.Z, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_ZTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_V
	return ret
}

func (v *iterNative) readETTypex_ZTypex_V(et *typex.EventTime, key *typex.Z, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerETTypex_ZTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZTypex_V
	return ret
}

func (v *iterNative) readTypex_ZTypex_W(key *typex.Z, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_ZTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_W
	return ret
}

func (v *iterNative) readETTypex_ZTypex_W(et *typex.EventTime, key *typex.Z, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerETTypex_ZTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZTypex_W
	return ret
}

func (v *iterNative) readTypex_ZTypex_X(key *typex.Z, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_ZTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_X
	return ret
}

func (v *iterNative) readETTypex_ZTypex_X(et *typex.EventTime, key *typex.Z, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerETTypex_ZTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZTypex_X
	return ret
}

func (v *iterNative) readTypex_ZTypex_Y(key *typex.Z, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_ZTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_Y
	return ret
}

func (v *iterNative) readETTypex_ZTypex_Y(et *typex.EventTime, key *typex.Z, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerETTypex_ZTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZTypex_Y
	return ret
}

func (v *iterNative) readTypex_ZTypex_Z(key *typex.Z, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_ZTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_Z
	return ret
}

func (v *iterNative) readETTypex_ZTypex_Z(et *typex.EventTime, key *typex.Z, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}

	*et = elm.Timestamp
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerETTypex_ZTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readETTypex_ZTypex_Z
	return ret
}
