// File generated by specialize. Do not edit.

// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package optimized

import (
	"fmt"
	"io"
	"reflect"

	"github.com/apache/beam/sdks/v2/go/pkg/beam/core/runtime/exec"
	"github.com/apache/beam/sdks/v2/go/pkg/beam/core/typex"
)

func init() {
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte) bool)(nil)).Elem(), iterMakerByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *[]byte) bool)(nil)).Elem(), iterMakerByteSliceByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *bool) bool)(nil)).Elem(), iterMakerByteSliceBool)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *string) bool)(nil)).Elem(), iterMakerByteSliceString)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *int) bool)(nil)).Elem(), iterMakerByteSliceInt)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *int8) bool)(nil)).Elem(), iterMakerByteSliceInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *int16) bool)(nil)).Elem(), iterMakerByteSliceInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *int32) bool)(nil)).Elem(), iterMakerByteSliceInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *int64) bool)(nil)).Elem(), iterMakerByteSliceInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *uint) bool)(nil)).Elem(), iterMakerByteSliceUint)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *uint8) bool)(nil)).Elem(), iterMakerByteSliceUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *uint16) bool)(nil)).Elem(), iterMakerByteSliceUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *uint32) bool)(nil)).Elem(), iterMakerByteSliceUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *uint64) bool)(nil)).Elem(), iterMakerByteSliceUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *float32) bool)(nil)).Elem(), iterMakerByteSliceFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *float64) bool)(nil)).Elem(), iterMakerByteSliceFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.T) bool)(nil)).Elem(), iterMakerByteSliceTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.U) bool)(nil)).Elem(), iterMakerByteSliceTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.V) bool)(nil)).Elem(), iterMakerByteSliceTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.W) bool)(nil)).Elem(), iterMakerByteSliceTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.X) bool)(nil)).Elem(), iterMakerByteSliceTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.Y) bool)(nil)).Elem(), iterMakerByteSliceTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*[]byte, *typex.Z) bool)(nil)).Elem(), iterMakerByteSliceTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*bool) bool)(nil)).Elem(), iterMakerBool)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *[]byte) bool)(nil)).Elem(), iterMakerBoolByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *bool) bool)(nil)).Elem(), iterMakerBoolBool)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *string) bool)(nil)).Elem(), iterMakerBoolString)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *int) bool)(nil)).Elem(), iterMakerBoolInt)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *int8) bool)(nil)).Elem(), iterMakerBoolInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *int16) bool)(nil)).Elem(), iterMakerBoolInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *int32) bool)(nil)).Elem(), iterMakerBoolInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *int64) bool)(nil)).Elem(), iterMakerBoolInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *uint) bool)(nil)).Elem(), iterMakerBoolUint)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *uint8) bool)(nil)).Elem(), iterMakerBoolUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *uint16) bool)(nil)).Elem(), iterMakerBoolUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *uint32) bool)(nil)).Elem(), iterMakerBoolUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *uint64) bool)(nil)).Elem(), iterMakerBoolUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *float32) bool)(nil)).Elem(), iterMakerBoolFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *float64) bool)(nil)).Elem(), iterMakerBoolFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.T) bool)(nil)).Elem(), iterMakerBoolTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.U) bool)(nil)).Elem(), iterMakerBoolTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.V) bool)(nil)).Elem(), iterMakerBoolTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.W) bool)(nil)).Elem(), iterMakerBoolTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.X) bool)(nil)).Elem(), iterMakerBoolTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.Y) bool)(nil)).Elem(), iterMakerBoolTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*bool, *typex.Z) bool)(nil)).Elem(), iterMakerBoolTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*string) bool)(nil)).Elem(), iterMakerString)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *[]byte) bool)(nil)).Elem(), iterMakerStringByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *bool) bool)(nil)).Elem(), iterMakerStringBool)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *string) bool)(nil)).Elem(), iterMakerStringString)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *int) bool)(nil)).Elem(), iterMakerStringInt)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *int8) bool)(nil)).Elem(), iterMakerStringInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *int16) bool)(nil)).Elem(), iterMakerStringInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *int32) bool)(nil)).Elem(), iterMakerStringInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *int64) bool)(nil)).Elem(), iterMakerStringInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *uint) bool)(nil)).Elem(), iterMakerStringUint)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *uint8) bool)(nil)).Elem(), iterMakerStringUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *uint16) bool)(nil)).Elem(), iterMakerStringUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *uint32) bool)(nil)).Elem(), iterMakerStringUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *uint64) bool)(nil)).Elem(), iterMakerStringUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *float32) bool)(nil)).Elem(), iterMakerStringFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *float64) bool)(nil)).Elem(), iterMakerStringFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.T) bool)(nil)).Elem(), iterMakerStringTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.U) bool)(nil)).Elem(), iterMakerStringTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.V) bool)(nil)).Elem(), iterMakerStringTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.W) bool)(nil)).Elem(), iterMakerStringTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.X) bool)(nil)).Elem(), iterMakerStringTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.Y) bool)(nil)).Elem(), iterMakerStringTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*string, *typex.Z) bool)(nil)).Elem(), iterMakerStringTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*int) bool)(nil)).Elem(), iterMakerInt)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *[]byte) bool)(nil)).Elem(), iterMakerIntByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *bool) bool)(nil)).Elem(), iterMakerIntBool)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *string) bool)(nil)).Elem(), iterMakerIntString)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *int) bool)(nil)).Elem(), iterMakerIntInt)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *int8) bool)(nil)).Elem(), iterMakerIntInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *int16) bool)(nil)).Elem(), iterMakerIntInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *int32) bool)(nil)).Elem(), iterMakerIntInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *int64) bool)(nil)).Elem(), iterMakerIntInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *uint) bool)(nil)).Elem(), iterMakerIntUint)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *uint8) bool)(nil)).Elem(), iterMakerIntUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *uint16) bool)(nil)).Elem(), iterMakerIntUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *uint32) bool)(nil)).Elem(), iterMakerIntUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *uint64) bool)(nil)).Elem(), iterMakerIntUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *float32) bool)(nil)).Elem(), iterMakerIntFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *float64) bool)(nil)).Elem(), iterMakerIntFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.T) bool)(nil)).Elem(), iterMakerIntTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.U) bool)(nil)).Elem(), iterMakerIntTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.V) bool)(nil)).Elem(), iterMakerIntTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.W) bool)(nil)).Elem(), iterMakerIntTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.X) bool)(nil)).Elem(), iterMakerIntTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.Y) bool)(nil)).Elem(), iterMakerIntTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*int, *typex.Z) bool)(nil)).Elem(), iterMakerIntTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*int8) bool)(nil)).Elem(), iterMakerInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *[]byte) bool)(nil)).Elem(), iterMakerInt8ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *bool) bool)(nil)).Elem(), iterMakerInt8Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *string) bool)(nil)).Elem(), iterMakerInt8String)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *int) bool)(nil)).Elem(), iterMakerInt8Int)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *int8) bool)(nil)).Elem(), iterMakerInt8Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *int16) bool)(nil)).Elem(), iterMakerInt8Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *int32) bool)(nil)).Elem(), iterMakerInt8Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *int64) bool)(nil)).Elem(), iterMakerInt8Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *uint) bool)(nil)).Elem(), iterMakerInt8Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *uint8) bool)(nil)).Elem(), iterMakerInt8Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *uint16) bool)(nil)).Elem(), iterMakerInt8Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *uint32) bool)(nil)).Elem(), iterMakerInt8Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *uint64) bool)(nil)).Elem(), iterMakerInt8Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *float32) bool)(nil)).Elem(), iterMakerInt8Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *float64) bool)(nil)).Elem(), iterMakerInt8Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.T) bool)(nil)).Elem(), iterMakerInt8Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.U) bool)(nil)).Elem(), iterMakerInt8Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.V) bool)(nil)).Elem(), iterMakerInt8Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.W) bool)(nil)).Elem(), iterMakerInt8Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.X) bool)(nil)).Elem(), iterMakerInt8Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.Y) bool)(nil)).Elem(), iterMakerInt8Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*int8, *typex.Z) bool)(nil)).Elem(), iterMakerInt8Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*int16) bool)(nil)).Elem(), iterMakerInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *[]byte) bool)(nil)).Elem(), iterMakerInt16ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *bool) bool)(nil)).Elem(), iterMakerInt16Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *string) bool)(nil)).Elem(), iterMakerInt16String)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *int) bool)(nil)).Elem(), iterMakerInt16Int)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *int8) bool)(nil)).Elem(), iterMakerInt16Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *int16) bool)(nil)).Elem(), iterMakerInt16Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *int32) bool)(nil)).Elem(), iterMakerInt16Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *int64) bool)(nil)).Elem(), iterMakerInt16Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *uint) bool)(nil)).Elem(), iterMakerInt16Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *uint8) bool)(nil)).Elem(), iterMakerInt16Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *uint16) bool)(nil)).Elem(), iterMakerInt16Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *uint32) bool)(nil)).Elem(), iterMakerInt16Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *uint64) bool)(nil)).Elem(), iterMakerInt16Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *float32) bool)(nil)).Elem(), iterMakerInt16Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *float64) bool)(nil)).Elem(), iterMakerInt16Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.T) bool)(nil)).Elem(), iterMakerInt16Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.U) bool)(nil)).Elem(), iterMakerInt16Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.V) bool)(nil)).Elem(), iterMakerInt16Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.W) bool)(nil)).Elem(), iterMakerInt16Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.X) bool)(nil)).Elem(), iterMakerInt16Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.Y) bool)(nil)).Elem(), iterMakerInt16Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*int16, *typex.Z) bool)(nil)).Elem(), iterMakerInt16Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*int32) bool)(nil)).Elem(), iterMakerInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *[]byte) bool)(nil)).Elem(), iterMakerInt32ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *bool) bool)(nil)).Elem(), iterMakerInt32Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *string) bool)(nil)).Elem(), iterMakerInt32String)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *int) bool)(nil)).Elem(), iterMakerInt32Int)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *int8) bool)(nil)).Elem(), iterMakerInt32Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *int16) bool)(nil)).Elem(), iterMakerInt32Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *int32) bool)(nil)).Elem(), iterMakerInt32Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *int64) bool)(nil)).Elem(), iterMakerInt32Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *uint) bool)(nil)).Elem(), iterMakerInt32Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *uint8) bool)(nil)).Elem(), iterMakerInt32Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *uint16) bool)(nil)).Elem(), iterMakerInt32Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *uint32) bool)(nil)).Elem(), iterMakerInt32Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *uint64) bool)(nil)).Elem(), iterMakerInt32Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *float32) bool)(nil)).Elem(), iterMakerInt32Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *float64) bool)(nil)).Elem(), iterMakerInt32Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.T) bool)(nil)).Elem(), iterMakerInt32Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.U) bool)(nil)).Elem(), iterMakerInt32Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.V) bool)(nil)).Elem(), iterMakerInt32Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.W) bool)(nil)).Elem(), iterMakerInt32Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.X) bool)(nil)).Elem(), iterMakerInt32Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.Y) bool)(nil)).Elem(), iterMakerInt32Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*int32, *typex.Z) bool)(nil)).Elem(), iterMakerInt32Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*int64) bool)(nil)).Elem(), iterMakerInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *[]byte) bool)(nil)).Elem(), iterMakerInt64ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *bool) bool)(nil)).Elem(), iterMakerInt64Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *string) bool)(nil)).Elem(), iterMakerInt64String)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *int) bool)(nil)).Elem(), iterMakerInt64Int)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *int8) bool)(nil)).Elem(), iterMakerInt64Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *int16) bool)(nil)).Elem(), iterMakerInt64Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *int32) bool)(nil)).Elem(), iterMakerInt64Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *int64) bool)(nil)).Elem(), iterMakerInt64Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *uint) bool)(nil)).Elem(), iterMakerInt64Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *uint8) bool)(nil)).Elem(), iterMakerInt64Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *uint16) bool)(nil)).Elem(), iterMakerInt64Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *uint32) bool)(nil)).Elem(), iterMakerInt64Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *uint64) bool)(nil)).Elem(), iterMakerInt64Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *float32) bool)(nil)).Elem(), iterMakerInt64Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *float64) bool)(nil)).Elem(), iterMakerInt64Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.T) bool)(nil)).Elem(), iterMakerInt64Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.U) bool)(nil)).Elem(), iterMakerInt64Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.V) bool)(nil)).Elem(), iterMakerInt64Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.W) bool)(nil)).Elem(), iterMakerInt64Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.X) bool)(nil)).Elem(), iterMakerInt64Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.Y) bool)(nil)).Elem(), iterMakerInt64Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*int64, *typex.Z) bool)(nil)).Elem(), iterMakerInt64Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*uint) bool)(nil)).Elem(), iterMakerUint)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *[]byte) bool)(nil)).Elem(), iterMakerUintByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *bool) bool)(nil)).Elem(), iterMakerUintBool)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *string) bool)(nil)).Elem(), iterMakerUintString)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *int) bool)(nil)).Elem(), iterMakerUintInt)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *int8) bool)(nil)).Elem(), iterMakerUintInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *int16) bool)(nil)).Elem(), iterMakerUintInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *int32) bool)(nil)).Elem(), iterMakerUintInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *int64) bool)(nil)).Elem(), iterMakerUintInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *uint) bool)(nil)).Elem(), iterMakerUintUint)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *uint8) bool)(nil)).Elem(), iterMakerUintUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *uint16) bool)(nil)).Elem(), iterMakerUintUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *uint32) bool)(nil)).Elem(), iterMakerUintUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *uint64) bool)(nil)).Elem(), iterMakerUintUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *float32) bool)(nil)).Elem(), iterMakerUintFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *float64) bool)(nil)).Elem(), iterMakerUintFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.T) bool)(nil)).Elem(), iterMakerUintTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.U) bool)(nil)).Elem(), iterMakerUintTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.V) bool)(nil)).Elem(), iterMakerUintTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.W) bool)(nil)).Elem(), iterMakerUintTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.X) bool)(nil)).Elem(), iterMakerUintTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.Y) bool)(nil)).Elem(), iterMakerUintTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*uint, *typex.Z) bool)(nil)).Elem(), iterMakerUintTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8) bool)(nil)).Elem(), iterMakerUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *[]byte) bool)(nil)).Elem(), iterMakerUint8ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *bool) bool)(nil)).Elem(), iterMakerUint8Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *string) bool)(nil)).Elem(), iterMakerUint8String)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *int) bool)(nil)).Elem(), iterMakerUint8Int)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *int8) bool)(nil)).Elem(), iterMakerUint8Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *int16) bool)(nil)).Elem(), iterMakerUint8Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *int32) bool)(nil)).Elem(), iterMakerUint8Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *int64) bool)(nil)).Elem(), iterMakerUint8Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *uint) bool)(nil)).Elem(), iterMakerUint8Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *uint8) bool)(nil)).Elem(), iterMakerUint8Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *uint16) bool)(nil)).Elem(), iterMakerUint8Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *uint32) bool)(nil)).Elem(), iterMakerUint8Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *uint64) bool)(nil)).Elem(), iterMakerUint8Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *float32) bool)(nil)).Elem(), iterMakerUint8Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *float64) bool)(nil)).Elem(), iterMakerUint8Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.T) bool)(nil)).Elem(), iterMakerUint8Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.U) bool)(nil)).Elem(), iterMakerUint8Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.V) bool)(nil)).Elem(), iterMakerUint8Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.W) bool)(nil)).Elem(), iterMakerUint8Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.X) bool)(nil)).Elem(), iterMakerUint8Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.Y) bool)(nil)).Elem(), iterMakerUint8Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*uint8, *typex.Z) bool)(nil)).Elem(), iterMakerUint8Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16) bool)(nil)).Elem(), iterMakerUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *[]byte) bool)(nil)).Elem(), iterMakerUint16ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *bool) bool)(nil)).Elem(), iterMakerUint16Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *string) bool)(nil)).Elem(), iterMakerUint16String)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *int) bool)(nil)).Elem(), iterMakerUint16Int)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *int8) bool)(nil)).Elem(), iterMakerUint16Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *int16) bool)(nil)).Elem(), iterMakerUint16Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *int32) bool)(nil)).Elem(), iterMakerUint16Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *int64) bool)(nil)).Elem(), iterMakerUint16Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *uint) bool)(nil)).Elem(), iterMakerUint16Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *uint8) bool)(nil)).Elem(), iterMakerUint16Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *uint16) bool)(nil)).Elem(), iterMakerUint16Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *uint32) bool)(nil)).Elem(), iterMakerUint16Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *uint64) bool)(nil)).Elem(), iterMakerUint16Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *float32) bool)(nil)).Elem(), iterMakerUint16Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *float64) bool)(nil)).Elem(), iterMakerUint16Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.T) bool)(nil)).Elem(), iterMakerUint16Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.U) bool)(nil)).Elem(), iterMakerUint16Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.V) bool)(nil)).Elem(), iterMakerUint16Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.W) bool)(nil)).Elem(), iterMakerUint16Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.X) bool)(nil)).Elem(), iterMakerUint16Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.Y) bool)(nil)).Elem(), iterMakerUint16Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*uint16, *typex.Z) bool)(nil)).Elem(), iterMakerUint16Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32) bool)(nil)).Elem(), iterMakerUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *[]byte) bool)(nil)).Elem(), iterMakerUint32ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *bool) bool)(nil)).Elem(), iterMakerUint32Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *string) bool)(nil)).Elem(), iterMakerUint32String)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *int) bool)(nil)).Elem(), iterMakerUint32Int)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *int8) bool)(nil)).Elem(), iterMakerUint32Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *int16) bool)(nil)).Elem(), iterMakerUint32Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *int32) bool)(nil)).Elem(), iterMakerUint32Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *int64) bool)(nil)).Elem(), iterMakerUint32Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *uint) bool)(nil)).Elem(), iterMakerUint32Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *uint8) bool)(nil)).Elem(), iterMakerUint32Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *uint16) bool)(nil)).Elem(), iterMakerUint32Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *uint32) bool)(nil)).Elem(), iterMakerUint32Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *uint64) bool)(nil)).Elem(), iterMakerUint32Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *float32) bool)(nil)).Elem(), iterMakerUint32Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *float64) bool)(nil)).Elem(), iterMakerUint32Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.T) bool)(nil)).Elem(), iterMakerUint32Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.U) bool)(nil)).Elem(), iterMakerUint32Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.V) bool)(nil)).Elem(), iterMakerUint32Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.W) bool)(nil)).Elem(), iterMakerUint32Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.X) bool)(nil)).Elem(), iterMakerUint32Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.Y) bool)(nil)).Elem(), iterMakerUint32Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*uint32, *typex.Z) bool)(nil)).Elem(), iterMakerUint32Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64) bool)(nil)).Elem(), iterMakerUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *[]byte) bool)(nil)).Elem(), iterMakerUint64ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *bool) bool)(nil)).Elem(), iterMakerUint64Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *string) bool)(nil)).Elem(), iterMakerUint64String)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *int) bool)(nil)).Elem(), iterMakerUint64Int)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *int8) bool)(nil)).Elem(), iterMakerUint64Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *int16) bool)(nil)).Elem(), iterMakerUint64Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *int32) bool)(nil)).Elem(), iterMakerUint64Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *int64) bool)(nil)).Elem(), iterMakerUint64Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *uint) bool)(nil)).Elem(), iterMakerUint64Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *uint8) bool)(nil)).Elem(), iterMakerUint64Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *uint16) bool)(nil)).Elem(), iterMakerUint64Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *uint32) bool)(nil)).Elem(), iterMakerUint64Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *uint64) bool)(nil)).Elem(), iterMakerUint64Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *float32) bool)(nil)).Elem(), iterMakerUint64Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *float64) bool)(nil)).Elem(), iterMakerUint64Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.T) bool)(nil)).Elem(), iterMakerUint64Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.U) bool)(nil)).Elem(), iterMakerUint64Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.V) bool)(nil)).Elem(), iterMakerUint64Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.W) bool)(nil)).Elem(), iterMakerUint64Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.X) bool)(nil)).Elem(), iterMakerUint64Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.Y) bool)(nil)).Elem(), iterMakerUint64Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*uint64, *typex.Z) bool)(nil)).Elem(), iterMakerUint64Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*float32) bool)(nil)).Elem(), iterMakerFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *[]byte) bool)(nil)).Elem(), iterMakerFloat32ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *bool) bool)(nil)).Elem(), iterMakerFloat32Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *string) bool)(nil)).Elem(), iterMakerFloat32String)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *int) bool)(nil)).Elem(), iterMakerFloat32Int)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *int8) bool)(nil)).Elem(), iterMakerFloat32Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *int16) bool)(nil)).Elem(), iterMakerFloat32Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *int32) bool)(nil)).Elem(), iterMakerFloat32Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *int64) bool)(nil)).Elem(), iterMakerFloat32Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *uint) bool)(nil)).Elem(), iterMakerFloat32Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *uint8) bool)(nil)).Elem(), iterMakerFloat32Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *uint16) bool)(nil)).Elem(), iterMakerFloat32Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *uint32) bool)(nil)).Elem(), iterMakerFloat32Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *uint64) bool)(nil)).Elem(), iterMakerFloat32Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *float32) bool)(nil)).Elem(), iterMakerFloat32Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *float64) bool)(nil)).Elem(), iterMakerFloat32Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.T) bool)(nil)).Elem(), iterMakerFloat32Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.U) bool)(nil)).Elem(), iterMakerFloat32Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.V) bool)(nil)).Elem(), iterMakerFloat32Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.W) bool)(nil)).Elem(), iterMakerFloat32Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.X) bool)(nil)).Elem(), iterMakerFloat32Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.Y) bool)(nil)).Elem(), iterMakerFloat32Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*float32, *typex.Z) bool)(nil)).Elem(), iterMakerFloat32Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*float64) bool)(nil)).Elem(), iterMakerFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *[]byte) bool)(nil)).Elem(), iterMakerFloat64ByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *bool) bool)(nil)).Elem(), iterMakerFloat64Bool)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *string) bool)(nil)).Elem(), iterMakerFloat64String)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *int) bool)(nil)).Elem(), iterMakerFloat64Int)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *int8) bool)(nil)).Elem(), iterMakerFloat64Int8)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *int16) bool)(nil)).Elem(), iterMakerFloat64Int16)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *int32) bool)(nil)).Elem(), iterMakerFloat64Int32)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *int64) bool)(nil)).Elem(), iterMakerFloat64Int64)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *uint) bool)(nil)).Elem(), iterMakerFloat64Uint)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *uint8) bool)(nil)).Elem(), iterMakerFloat64Uint8)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *uint16) bool)(nil)).Elem(), iterMakerFloat64Uint16)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *uint32) bool)(nil)).Elem(), iterMakerFloat64Uint32)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *uint64) bool)(nil)).Elem(), iterMakerFloat64Uint64)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *float32) bool)(nil)).Elem(), iterMakerFloat64Float32)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *float64) bool)(nil)).Elem(), iterMakerFloat64Float64)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.T) bool)(nil)).Elem(), iterMakerFloat64Typex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.U) bool)(nil)).Elem(), iterMakerFloat64Typex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.V) bool)(nil)).Elem(), iterMakerFloat64Typex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.W) bool)(nil)).Elem(), iterMakerFloat64Typex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.X) bool)(nil)).Elem(), iterMakerFloat64Typex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.Y) bool)(nil)).Elem(), iterMakerFloat64Typex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*float64, *typex.Z) bool)(nil)).Elem(), iterMakerFloat64Typex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T) bool)(nil)).Elem(), iterMakerTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *[]byte) bool)(nil)).Elem(), iterMakerTypex_TByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *bool) bool)(nil)).Elem(), iterMakerTypex_TBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *string) bool)(nil)).Elem(), iterMakerTypex_TString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *int) bool)(nil)).Elem(), iterMakerTypex_TInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *int8) bool)(nil)).Elem(), iterMakerTypex_TInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *int16) bool)(nil)).Elem(), iterMakerTypex_TInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *int32) bool)(nil)).Elem(), iterMakerTypex_TInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *int64) bool)(nil)).Elem(), iterMakerTypex_TInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *uint) bool)(nil)).Elem(), iterMakerTypex_TUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *uint8) bool)(nil)).Elem(), iterMakerTypex_TUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *uint16) bool)(nil)).Elem(), iterMakerTypex_TUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *uint32) bool)(nil)).Elem(), iterMakerTypex_TUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *uint64) bool)(nil)).Elem(), iterMakerTypex_TUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *float32) bool)(nil)).Elem(), iterMakerTypex_TFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *float64) bool)(nil)).Elem(), iterMakerTypex_TFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.T) bool)(nil)).Elem(), iterMakerTypex_TTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.U) bool)(nil)).Elem(), iterMakerTypex_TTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.V) bool)(nil)).Elem(), iterMakerTypex_TTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.W) bool)(nil)).Elem(), iterMakerTypex_TTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.X) bool)(nil)).Elem(), iterMakerTypex_TTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_TTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.T, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_TTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U) bool)(nil)).Elem(), iterMakerTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *[]byte) bool)(nil)).Elem(), iterMakerTypex_UByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *bool) bool)(nil)).Elem(), iterMakerTypex_UBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *string) bool)(nil)).Elem(), iterMakerTypex_UString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *int) bool)(nil)).Elem(), iterMakerTypex_UInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *int8) bool)(nil)).Elem(), iterMakerTypex_UInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *int16) bool)(nil)).Elem(), iterMakerTypex_UInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *int32) bool)(nil)).Elem(), iterMakerTypex_UInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *int64) bool)(nil)).Elem(), iterMakerTypex_UInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *uint) bool)(nil)).Elem(), iterMakerTypex_UUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *uint8) bool)(nil)).Elem(), iterMakerTypex_UUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *uint16) bool)(nil)).Elem(), iterMakerTypex_UUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *uint32) bool)(nil)).Elem(), iterMakerTypex_UUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *uint64) bool)(nil)).Elem(), iterMakerTypex_UUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *float32) bool)(nil)).Elem(), iterMakerTypex_UFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *float64) bool)(nil)).Elem(), iterMakerTypex_UFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.T) bool)(nil)).Elem(), iterMakerTypex_UTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.U) bool)(nil)).Elem(), iterMakerTypex_UTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.V) bool)(nil)).Elem(), iterMakerTypex_UTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.W) bool)(nil)).Elem(), iterMakerTypex_UTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.X) bool)(nil)).Elem(), iterMakerTypex_UTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_UTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.U, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_UTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V) bool)(nil)).Elem(), iterMakerTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *[]byte) bool)(nil)).Elem(), iterMakerTypex_VByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *bool) bool)(nil)).Elem(), iterMakerTypex_VBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *string) bool)(nil)).Elem(), iterMakerTypex_VString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *int) bool)(nil)).Elem(), iterMakerTypex_VInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *int8) bool)(nil)).Elem(), iterMakerTypex_VInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *int16) bool)(nil)).Elem(), iterMakerTypex_VInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *int32) bool)(nil)).Elem(), iterMakerTypex_VInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *int64) bool)(nil)).Elem(), iterMakerTypex_VInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *uint) bool)(nil)).Elem(), iterMakerTypex_VUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *uint8) bool)(nil)).Elem(), iterMakerTypex_VUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *uint16) bool)(nil)).Elem(), iterMakerTypex_VUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *uint32) bool)(nil)).Elem(), iterMakerTypex_VUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *uint64) bool)(nil)).Elem(), iterMakerTypex_VUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *float32) bool)(nil)).Elem(), iterMakerTypex_VFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *float64) bool)(nil)).Elem(), iterMakerTypex_VFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.T) bool)(nil)).Elem(), iterMakerTypex_VTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.U) bool)(nil)).Elem(), iterMakerTypex_VTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.V) bool)(nil)).Elem(), iterMakerTypex_VTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.W) bool)(nil)).Elem(), iterMakerTypex_VTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.X) bool)(nil)).Elem(), iterMakerTypex_VTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_VTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.V, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_VTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W) bool)(nil)).Elem(), iterMakerTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *[]byte) bool)(nil)).Elem(), iterMakerTypex_WByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *bool) bool)(nil)).Elem(), iterMakerTypex_WBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *string) bool)(nil)).Elem(), iterMakerTypex_WString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *int) bool)(nil)).Elem(), iterMakerTypex_WInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *int8) bool)(nil)).Elem(), iterMakerTypex_WInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *int16) bool)(nil)).Elem(), iterMakerTypex_WInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *int32) bool)(nil)).Elem(), iterMakerTypex_WInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *int64) bool)(nil)).Elem(), iterMakerTypex_WInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *uint) bool)(nil)).Elem(), iterMakerTypex_WUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *uint8) bool)(nil)).Elem(), iterMakerTypex_WUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *uint16) bool)(nil)).Elem(), iterMakerTypex_WUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *uint32) bool)(nil)).Elem(), iterMakerTypex_WUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *uint64) bool)(nil)).Elem(), iterMakerTypex_WUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *float32) bool)(nil)).Elem(), iterMakerTypex_WFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *float64) bool)(nil)).Elem(), iterMakerTypex_WFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.T) bool)(nil)).Elem(), iterMakerTypex_WTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.U) bool)(nil)).Elem(), iterMakerTypex_WTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.V) bool)(nil)).Elem(), iterMakerTypex_WTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.W) bool)(nil)).Elem(), iterMakerTypex_WTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.X) bool)(nil)).Elem(), iterMakerTypex_WTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_WTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.W, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_WTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X) bool)(nil)).Elem(), iterMakerTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *[]byte) bool)(nil)).Elem(), iterMakerTypex_XByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *bool) bool)(nil)).Elem(), iterMakerTypex_XBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *string) bool)(nil)).Elem(), iterMakerTypex_XString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *int) bool)(nil)).Elem(), iterMakerTypex_XInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *int8) bool)(nil)).Elem(), iterMakerTypex_XInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *int16) bool)(nil)).Elem(), iterMakerTypex_XInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *int32) bool)(nil)).Elem(), iterMakerTypex_XInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *int64) bool)(nil)).Elem(), iterMakerTypex_XInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *uint) bool)(nil)).Elem(), iterMakerTypex_XUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *uint8) bool)(nil)).Elem(), iterMakerTypex_XUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *uint16) bool)(nil)).Elem(), iterMakerTypex_XUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *uint32) bool)(nil)).Elem(), iterMakerTypex_XUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *uint64) bool)(nil)).Elem(), iterMakerTypex_XUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *float32) bool)(nil)).Elem(), iterMakerTypex_XFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *float64) bool)(nil)).Elem(), iterMakerTypex_XFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.T) bool)(nil)).Elem(), iterMakerTypex_XTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.U) bool)(nil)).Elem(), iterMakerTypex_XTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.V) bool)(nil)).Elem(), iterMakerTypex_XTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.W) bool)(nil)).Elem(), iterMakerTypex_XTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.X) bool)(nil)).Elem(), iterMakerTypex_XTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_XTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.X, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_XTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y) bool)(nil)).Elem(), iterMakerTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *[]byte) bool)(nil)).Elem(), iterMakerTypex_YByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *bool) bool)(nil)).Elem(), iterMakerTypex_YBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *string) bool)(nil)).Elem(), iterMakerTypex_YString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *int) bool)(nil)).Elem(), iterMakerTypex_YInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *int8) bool)(nil)).Elem(), iterMakerTypex_YInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *int16) bool)(nil)).Elem(), iterMakerTypex_YInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *int32) bool)(nil)).Elem(), iterMakerTypex_YInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *int64) bool)(nil)).Elem(), iterMakerTypex_YInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *uint) bool)(nil)).Elem(), iterMakerTypex_YUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *uint8) bool)(nil)).Elem(), iterMakerTypex_YUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *uint16) bool)(nil)).Elem(), iterMakerTypex_YUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *uint32) bool)(nil)).Elem(), iterMakerTypex_YUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *uint64) bool)(nil)).Elem(), iterMakerTypex_YUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *float32) bool)(nil)).Elem(), iterMakerTypex_YFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *float64) bool)(nil)).Elem(), iterMakerTypex_YFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.T) bool)(nil)).Elem(), iterMakerTypex_YTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.U) bool)(nil)).Elem(), iterMakerTypex_YTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.V) bool)(nil)).Elem(), iterMakerTypex_YTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.W) bool)(nil)).Elem(), iterMakerTypex_YTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.X) bool)(nil)).Elem(), iterMakerTypex_YTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_YTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Y, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_YTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z) bool)(nil)).Elem(), iterMakerTypex_Z)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *[]byte) bool)(nil)).Elem(), iterMakerTypex_ZByteSlice)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *bool) bool)(nil)).Elem(), iterMakerTypex_ZBool)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *string) bool)(nil)).Elem(), iterMakerTypex_ZString)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *int) bool)(nil)).Elem(), iterMakerTypex_ZInt)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *int8) bool)(nil)).Elem(), iterMakerTypex_ZInt8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *int16) bool)(nil)).Elem(), iterMakerTypex_ZInt16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *int32) bool)(nil)).Elem(), iterMakerTypex_ZInt32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *int64) bool)(nil)).Elem(), iterMakerTypex_ZInt64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *uint) bool)(nil)).Elem(), iterMakerTypex_ZUint)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *uint8) bool)(nil)).Elem(), iterMakerTypex_ZUint8)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *uint16) bool)(nil)).Elem(), iterMakerTypex_ZUint16)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *uint32) bool)(nil)).Elem(), iterMakerTypex_ZUint32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *uint64) bool)(nil)).Elem(), iterMakerTypex_ZUint64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *float32) bool)(nil)).Elem(), iterMakerTypex_ZFloat32)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *float64) bool)(nil)).Elem(), iterMakerTypex_ZFloat64)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.T) bool)(nil)).Elem(), iterMakerTypex_ZTypex_T)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.U) bool)(nil)).Elem(), iterMakerTypex_ZTypex_U)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.V) bool)(nil)).Elem(), iterMakerTypex_ZTypex_V)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.W) bool)(nil)).Elem(), iterMakerTypex_ZTypex_W)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.X) bool)(nil)).Elem(), iterMakerTypex_ZTypex_X)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.Y) bool)(nil)).Elem(), iterMakerTypex_ZTypex_Y)
	exec.RegisterInput(reflect.TypeOf((*func(*typex.Z, *typex.Z) bool)(nil)).Elem(), iterMakerTypex_ZTypex_Z)
}

type iterNative struct {
	s  exec.ReStream
	fn any

	// cur is the "current" stream, if any.
	cur exec.Stream
}

func (v *iterNative) Init() error {
	cur, err := v.s.Open()
	if err != nil {
		return err
	}
	v.cur = cur
	return nil
}

func (v *iterNative) Value() any {
	return v.fn
}

func (v *iterNative) Reset() error {
	if err := v.cur.Close(); err != nil {
		return err
	}
	v.cur = nil
	return nil
}

func (v *iterNative) readByteSlice(val *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.([]byte)
	return true
}

func iterMakerByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSlice
	return ret
}

func (v *iterNative) readByteSliceByteSlice(key *[]byte, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerByteSliceByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceByteSlice
	return ret
}

func (v *iterNative) readByteSliceBool(key *[]byte, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerByteSliceBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceBool
	return ret
}

func (v *iterNative) readByteSliceString(key *[]byte, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerByteSliceString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceString
	return ret
}

func (v *iterNative) readByteSliceInt(key *[]byte, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerByteSliceInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceInt
	return ret
}

func (v *iterNative) readByteSliceInt8(key *[]byte, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerByteSliceInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceInt8
	return ret
}

func (v *iterNative) readByteSliceInt16(key *[]byte, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerByteSliceInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceInt16
	return ret
}

func (v *iterNative) readByteSliceInt32(key *[]byte, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerByteSliceInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceInt32
	return ret
}

func (v *iterNative) readByteSliceInt64(key *[]byte, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerByteSliceInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceInt64
	return ret
}

func (v *iterNative) readByteSliceUint(key *[]byte, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerByteSliceUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceUint
	return ret
}

func (v *iterNative) readByteSliceUint8(key *[]byte, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerByteSliceUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceUint8
	return ret
}

func (v *iterNative) readByteSliceUint16(key *[]byte, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerByteSliceUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceUint16
	return ret
}

func (v *iterNative) readByteSliceUint32(key *[]byte, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerByteSliceUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceUint32
	return ret
}

func (v *iterNative) readByteSliceUint64(key *[]byte, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerByteSliceUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceUint64
	return ret
}

func (v *iterNative) readByteSliceFloat32(key *[]byte, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerByteSliceFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceFloat32
	return ret
}

func (v *iterNative) readByteSliceFloat64(key *[]byte, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerByteSliceFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceFloat64
	return ret
}

func (v *iterNative) readByteSliceTypex_T(key *[]byte, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerByteSliceTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_T
	return ret
}

func (v *iterNative) readByteSliceTypex_U(key *[]byte, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerByteSliceTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_U
	return ret
}

func (v *iterNative) readByteSliceTypex_V(key *[]byte, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerByteSliceTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_V
	return ret
}

func (v *iterNative) readByteSliceTypex_W(key *[]byte, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerByteSliceTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_W
	return ret
}

func (v *iterNative) readByteSliceTypex_X(key *[]byte, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerByteSliceTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_X
	return ret
}

func (v *iterNative) readByteSliceTypex_Y(key *[]byte, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerByteSliceTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_Y
	return ret
}

func (v *iterNative) readByteSliceTypex_Z(key *[]byte, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.([]byte)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerByteSliceTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readByteSliceTypex_Z
	return ret
}

func (v *iterNative) readBool(val *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(bool)
	return true
}

func iterMakerBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBool
	return ret
}

func (v *iterNative) readBoolByteSlice(key *bool, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerBoolByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolByteSlice
	return ret
}

func (v *iterNative) readBoolBool(key *bool, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerBoolBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolBool
	return ret
}

func (v *iterNative) readBoolString(key *bool, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerBoolString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolString
	return ret
}

func (v *iterNative) readBoolInt(key *bool, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerBoolInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolInt
	return ret
}

func (v *iterNative) readBoolInt8(key *bool, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerBoolInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolInt8
	return ret
}

func (v *iterNative) readBoolInt16(key *bool, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerBoolInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolInt16
	return ret
}

func (v *iterNative) readBoolInt32(key *bool, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerBoolInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolInt32
	return ret
}

func (v *iterNative) readBoolInt64(key *bool, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerBoolInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolInt64
	return ret
}

func (v *iterNative) readBoolUint(key *bool, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerBoolUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolUint
	return ret
}

func (v *iterNative) readBoolUint8(key *bool, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerBoolUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolUint8
	return ret
}

func (v *iterNative) readBoolUint16(key *bool, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerBoolUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolUint16
	return ret
}

func (v *iterNative) readBoolUint32(key *bool, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerBoolUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolUint32
	return ret
}

func (v *iterNative) readBoolUint64(key *bool, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerBoolUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolUint64
	return ret
}

func (v *iterNative) readBoolFloat32(key *bool, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerBoolFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolFloat32
	return ret
}

func (v *iterNative) readBoolFloat64(key *bool, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerBoolFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolFloat64
	return ret
}

func (v *iterNative) readBoolTypex_T(key *bool, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerBoolTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_T
	return ret
}

func (v *iterNative) readBoolTypex_U(key *bool, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerBoolTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_U
	return ret
}

func (v *iterNative) readBoolTypex_V(key *bool, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerBoolTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_V
	return ret
}

func (v *iterNative) readBoolTypex_W(key *bool, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerBoolTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_W
	return ret
}

func (v *iterNative) readBoolTypex_X(key *bool, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerBoolTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_X
	return ret
}

func (v *iterNative) readBoolTypex_Y(key *bool, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerBoolTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_Y
	return ret
}

func (v *iterNative) readBoolTypex_Z(key *bool, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(bool)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerBoolTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readBoolTypex_Z
	return ret
}

func (v *iterNative) readString(val *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(string)
	return true
}

func iterMakerString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readString
	return ret
}

func (v *iterNative) readStringByteSlice(key *string, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerStringByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringByteSlice
	return ret
}

func (v *iterNative) readStringBool(key *string, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerStringBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringBool
	return ret
}

func (v *iterNative) readStringString(key *string, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerStringString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringString
	return ret
}

func (v *iterNative) readStringInt(key *string, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerStringInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringInt
	return ret
}

func (v *iterNative) readStringInt8(key *string, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerStringInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringInt8
	return ret
}

func (v *iterNative) readStringInt16(key *string, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerStringInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringInt16
	return ret
}

func (v *iterNative) readStringInt32(key *string, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerStringInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringInt32
	return ret
}

func (v *iterNative) readStringInt64(key *string, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerStringInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringInt64
	return ret
}

func (v *iterNative) readStringUint(key *string, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerStringUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringUint
	return ret
}

func (v *iterNative) readStringUint8(key *string, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerStringUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringUint8
	return ret
}

func (v *iterNative) readStringUint16(key *string, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerStringUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringUint16
	return ret
}

func (v *iterNative) readStringUint32(key *string, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerStringUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringUint32
	return ret
}

func (v *iterNative) readStringUint64(key *string, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerStringUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringUint64
	return ret
}

func (v *iterNative) readStringFloat32(key *string, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerStringFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringFloat32
	return ret
}

func (v *iterNative) readStringFloat64(key *string, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerStringFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringFloat64
	return ret
}

func (v *iterNative) readStringTypex_T(key *string, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerStringTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_T
	return ret
}

func (v *iterNative) readStringTypex_U(key *string, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerStringTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_U
	return ret
}

func (v *iterNative) readStringTypex_V(key *string, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerStringTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_V
	return ret
}

func (v *iterNative) readStringTypex_W(key *string, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerStringTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_W
	return ret
}

func (v *iterNative) readStringTypex_X(key *string, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerStringTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_X
	return ret
}

func (v *iterNative) readStringTypex_Y(key *string, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerStringTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_Y
	return ret
}

func (v *iterNative) readStringTypex_Z(key *string, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(string)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerStringTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readStringTypex_Z
	return ret
}

func (v *iterNative) readInt(val *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(int)
	return true
}

func iterMakerInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt
	return ret
}

func (v *iterNative) readIntByteSlice(key *int, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerIntByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntByteSlice
	return ret
}

func (v *iterNative) readIntBool(key *int, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerIntBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntBool
	return ret
}

func (v *iterNative) readIntString(key *int, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerIntString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntString
	return ret
}

func (v *iterNative) readIntInt(key *int, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerIntInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntInt
	return ret
}

func (v *iterNative) readIntInt8(key *int, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerIntInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntInt8
	return ret
}

func (v *iterNative) readIntInt16(key *int, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerIntInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntInt16
	return ret
}

func (v *iterNative) readIntInt32(key *int, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerIntInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntInt32
	return ret
}

func (v *iterNative) readIntInt64(key *int, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerIntInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntInt64
	return ret
}

func (v *iterNative) readIntUint(key *int, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerIntUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntUint
	return ret
}

func (v *iterNative) readIntUint8(key *int, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerIntUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntUint8
	return ret
}

func (v *iterNative) readIntUint16(key *int, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerIntUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntUint16
	return ret
}

func (v *iterNative) readIntUint32(key *int, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerIntUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntUint32
	return ret
}

func (v *iterNative) readIntUint64(key *int, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerIntUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntUint64
	return ret
}

func (v *iterNative) readIntFloat32(key *int, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerIntFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntFloat32
	return ret
}

func (v *iterNative) readIntFloat64(key *int, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerIntFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntFloat64
	return ret
}

func (v *iterNative) readIntTypex_T(key *int, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerIntTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_T
	return ret
}

func (v *iterNative) readIntTypex_U(key *int, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerIntTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_U
	return ret
}

func (v *iterNative) readIntTypex_V(key *int, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerIntTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_V
	return ret
}

func (v *iterNative) readIntTypex_W(key *int, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerIntTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_W
	return ret
}

func (v *iterNative) readIntTypex_X(key *int, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerIntTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_X
	return ret
}

func (v *iterNative) readIntTypex_Y(key *int, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerIntTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_Y
	return ret
}

func (v *iterNative) readIntTypex_Z(key *int, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerIntTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readIntTypex_Z
	return ret
}

func (v *iterNative) readInt8(val *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(int8)
	return true
}

func iterMakerInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8
	return ret
}

func (v *iterNative) readInt8ByteSlice(key *int8, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerInt8ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8ByteSlice
	return ret
}

func (v *iterNative) readInt8Bool(key *int8, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerInt8Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Bool
	return ret
}

func (v *iterNative) readInt8String(key *int8, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerInt8String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8String
	return ret
}

func (v *iterNative) readInt8Int(key *int8, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerInt8Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Int
	return ret
}

func (v *iterNative) readInt8Int8(key *int8, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerInt8Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Int8
	return ret
}

func (v *iterNative) readInt8Int16(key *int8, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerInt8Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Int16
	return ret
}

func (v *iterNative) readInt8Int32(key *int8, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerInt8Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Int32
	return ret
}

func (v *iterNative) readInt8Int64(key *int8, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerInt8Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Int64
	return ret
}

func (v *iterNative) readInt8Uint(key *int8, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerInt8Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Uint
	return ret
}

func (v *iterNative) readInt8Uint8(key *int8, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerInt8Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Uint8
	return ret
}

func (v *iterNative) readInt8Uint16(key *int8, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerInt8Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Uint16
	return ret
}

func (v *iterNative) readInt8Uint32(key *int8, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerInt8Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Uint32
	return ret
}

func (v *iterNative) readInt8Uint64(key *int8, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerInt8Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Uint64
	return ret
}

func (v *iterNative) readInt8Float32(key *int8, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerInt8Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Float32
	return ret
}

func (v *iterNative) readInt8Float64(key *int8, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerInt8Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Float64
	return ret
}

func (v *iterNative) readInt8Typex_T(key *int8, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerInt8Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_T
	return ret
}

func (v *iterNative) readInt8Typex_U(key *int8, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerInt8Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_U
	return ret
}

func (v *iterNative) readInt8Typex_V(key *int8, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerInt8Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_V
	return ret
}

func (v *iterNative) readInt8Typex_W(key *int8, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerInt8Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_W
	return ret
}

func (v *iterNative) readInt8Typex_X(key *int8, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerInt8Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_X
	return ret
}

func (v *iterNative) readInt8Typex_Y(key *int8, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerInt8Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_Y
	return ret
}

func (v *iterNative) readInt8Typex_Z(key *int8, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int8)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerInt8Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt8Typex_Z
	return ret
}

func (v *iterNative) readInt16(val *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(int16)
	return true
}

func iterMakerInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16
	return ret
}

func (v *iterNative) readInt16ByteSlice(key *int16, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerInt16ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16ByteSlice
	return ret
}

func (v *iterNative) readInt16Bool(key *int16, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerInt16Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Bool
	return ret
}

func (v *iterNative) readInt16String(key *int16, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerInt16String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16String
	return ret
}

func (v *iterNative) readInt16Int(key *int16, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerInt16Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Int
	return ret
}

func (v *iterNative) readInt16Int8(key *int16, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerInt16Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Int8
	return ret
}

func (v *iterNative) readInt16Int16(key *int16, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerInt16Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Int16
	return ret
}

func (v *iterNative) readInt16Int32(key *int16, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerInt16Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Int32
	return ret
}

func (v *iterNative) readInt16Int64(key *int16, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerInt16Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Int64
	return ret
}

func (v *iterNative) readInt16Uint(key *int16, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerInt16Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Uint
	return ret
}

func (v *iterNative) readInt16Uint8(key *int16, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerInt16Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Uint8
	return ret
}

func (v *iterNative) readInt16Uint16(key *int16, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerInt16Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Uint16
	return ret
}

func (v *iterNative) readInt16Uint32(key *int16, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerInt16Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Uint32
	return ret
}

func (v *iterNative) readInt16Uint64(key *int16, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerInt16Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Uint64
	return ret
}

func (v *iterNative) readInt16Float32(key *int16, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerInt16Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Float32
	return ret
}

func (v *iterNative) readInt16Float64(key *int16, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerInt16Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Float64
	return ret
}

func (v *iterNative) readInt16Typex_T(key *int16, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerInt16Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_T
	return ret
}

func (v *iterNative) readInt16Typex_U(key *int16, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerInt16Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_U
	return ret
}

func (v *iterNative) readInt16Typex_V(key *int16, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerInt16Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_V
	return ret
}

func (v *iterNative) readInt16Typex_W(key *int16, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerInt16Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_W
	return ret
}

func (v *iterNative) readInt16Typex_X(key *int16, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerInt16Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_X
	return ret
}

func (v *iterNative) readInt16Typex_Y(key *int16, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerInt16Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_Y
	return ret
}

func (v *iterNative) readInt16Typex_Z(key *int16, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int16)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerInt16Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt16Typex_Z
	return ret
}

func (v *iterNative) readInt32(val *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(int32)
	return true
}

func iterMakerInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32
	return ret
}

func (v *iterNative) readInt32ByteSlice(key *int32, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerInt32ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32ByteSlice
	return ret
}

func (v *iterNative) readInt32Bool(key *int32, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerInt32Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Bool
	return ret
}

func (v *iterNative) readInt32String(key *int32, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerInt32String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32String
	return ret
}

func (v *iterNative) readInt32Int(key *int32, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerInt32Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Int
	return ret
}

func (v *iterNative) readInt32Int8(key *int32, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerInt32Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Int8
	return ret
}

func (v *iterNative) readInt32Int16(key *int32, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerInt32Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Int16
	return ret
}

func (v *iterNative) readInt32Int32(key *int32, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerInt32Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Int32
	return ret
}

func (v *iterNative) readInt32Int64(key *int32, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerInt32Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Int64
	return ret
}

func (v *iterNative) readInt32Uint(key *int32, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerInt32Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Uint
	return ret
}

func (v *iterNative) readInt32Uint8(key *int32, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerInt32Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Uint8
	return ret
}

func (v *iterNative) readInt32Uint16(key *int32, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerInt32Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Uint16
	return ret
}

func (v *iterNative) readInt32Uint32(key *int32, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerInt32Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Uint32
	return ret
}

func (v *iterNative) readInt32Uint64(key *int32, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerInt32Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Uint64
	return ret
}

func (v *iterNative) readInt32Float32(key *int32, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerInt32Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Float32
	return ret
}

func (v *iterNative) readInt32Float64(key *int32, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerInt32Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Float64
	return ret
}

func (v *iterNative) readInt32Typex_T(key *int32, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerInt32Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_T
	return ret
}

func (v *iterNative) readInt32Typex_U(key *int32, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerInt32Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_U
	return ret
}

func (v *iterNative) readInt32Typex_V(key *int32, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerInt32Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_V
	return ret
}

func (v *iterNative) readInt32Typex_W(key *int32, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerInt32Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_W
	return ret
}

func (v *iterNative) readInt32Typex_X(key *int32, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerInt32Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_X
	return ret
}

func (v *iterNative) readInt32Typex_Y(key *int32, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerInt32Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_Y
	return ret
}

func (v *iterNative) readInt32Typex_Z(key *int32, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int32)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerInt32Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt32Typex_Z
	return ret
}

func (v *iterNative) readInt64(val *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(int64)
	return true
}

func iterMakerInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64
	return ret
}

func (v *iterNative) readInt64ByteSlice(key *int64, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerInt64ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64ByteSlice
	return ret
}

func (v *iterNative) readInt64Bool(key *int64, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerInt64Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Bool
	return ret
}

func (v *iterNative) readInt64String(key *int64, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerInt64String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64String
	return ret
}

func (v *iterNative) readInt64Int(key *int64, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerInt64Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Int
	return ret
}

func (v *iterNative) readInt64Int8(key *int64, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerInt64Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Int8
	return ret
}

func (v *iterNative) readInt64Int16(key *int64, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerInt64Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Int16
	return ret
}

func (v *iterNative) readInt64Int32(key *int64, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerInt64Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Int32
	return ret
}

func (v *iterNative) readInt64Int64(key *int64, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerInt64Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Int64
	return ret
}

func (v *iterNative) readInt64Uint(key *int64, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerInt64Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Uint
	return ret
}

func (v *iterNative) readInt64Uint8(key *int64, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerInt64Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Uint8
	return ret
}

func (v *iterNative) readInt64Uint16(key *int64, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerInt64Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Uint16
	return ret
}

func (v *iterNative) readInt64Uint32(key *int64, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerInt64Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Uint32
	return ret
}

func (v *iterNative) readInt64Uint64(key *int64, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerInt64Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Uint64
	return ret
}

func (v *iterNative) readInt64Float32(key *int64, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerInt64Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Float32
	return ret
}

func (v *iterNative) readInt64Float64(key *int64, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerInt64Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Float64
	return ret
}

func (v *iterNative) readInt64Typex_T(key *int64, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerInt64Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_T
	return ret
}

func (v *iterNative) readInt64Typex_U(key *int64, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerInt64Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_U
	return ret
}

func (v *iterNative) readInt64Typex_V(key *int64, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerInt64Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_V
	return ret
}

func (v *iterNative) readInt64Typex_W(key *int64, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerInt64Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_W
	return ret
}

func (v *iterNative) readInt64Typex_X(key *int64, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerInt64Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_X
	return ret
}

func (v *iterNative) readInt64Typex_Y(key *int64, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerInt64Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_Y
	return ret
}

func (v *iterNative) readInt64Typex_Z(key *int64, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(int64)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerInt64Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readInt64Typex_Z
	return ret
}

func (v *iterNative) readUint(val *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(uint)
	return true
}

func iterMakerUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint
	return ret
}

func (v *iterNative) readUintByteSlice(key *uint, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerUintByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintByteSlice
	return ret
}

func (v *iterNative) readUintBool(key *uint, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerUintBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintBool
	return ret
}

func (v *iterNative) readUintString(key *uint, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerUintString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintString
	return ret
}

func (v *iterNative) readUintInt(key *uint, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerUintInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintInt
	return ret
}

func (v *iterNative) readUintInt8(key *uint, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerUintInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintInt8
	return ret
}

func (v *iterNative) readUintInt16(key *uint, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerUintInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintInt16
	return ret
}

func (v *iterNative) readUintInt32(key *uint, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerUintInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintInt32
	return ret
}

func (v *iterNative) readUintInt64(key *uint, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerUintInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintInt64
	return ret
}

func (v *iterNative) readUintUint(key *uint, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerUintUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintUint
	return ret
}

func (v *iterNative) readUintUint8(key *uint, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerUintUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintUint8
	return ret
}

func (v *iterNative) readUintUint16(key *uint, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerUintUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintUint16
	return ret
}

func (v *iterNative) readUintUint32(key *uint, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerUintUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintUint32
	return ret
}

func (v *iterNative) readUintUint64(key *uint, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerUintUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintUint64
	return ret
}

func (v *iterNative) readUintFloat32(key *uint, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerUintFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintFloat32
	return ret
}

func (v *iterNative) readUintFloat64(key *uint, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerUintFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintFloat64
	return ret
}

func (v *iterNative) readUintTypex_T(key *uint, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerUintTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_T
	return ret
}

func (v *iterNative) readUintTypex_U(key *uint, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerUintTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_U
	return ret
}

func (v *iterNative) readUintTypex_V(key *uint, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerUintTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_V
	return ret
}

func (v *iterNative) readUintTypex_W(key *uint, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerUintTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_W
	return ret
}

func (v *iterNative) readUintTypex_X(key *uint, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerUintTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_X
	return ret
}

func (v *iterNative) readUintTypex_Y(key *uint, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerUintTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_Y
	return ret
}

func (v *iterNative) readUintTypex_Z(key *uint, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerUintTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUintTypex_Z
	return ret
}

func (v *iterNative) readUint8(val *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(uint8)
	return true
}

func iterMakerUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8
	return ret
}

func (v *iterNative) readUint8ByteSlice(key *uint8, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerUint8ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8ByteSlice
	return ret
}

func (v *iterNative) readUint8Bool(key *uint8, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerUint8Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Bool
	return ret
}

func (v *iterNative) readUint8String(key *uint8, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerUint8String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8String
	return ret
}

func (v *iterNative) readUint8Int(key *uint8, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerUint8Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Int
	return ret
}

func (v *iterNative) readUint8Int8(key *uint8, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerUint8Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Int8
	return ret
}

func (v *iterNative) readUint8Int16(key *uint8, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerUint8Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Int16
	return ret
}

func (v *iterNative) readUint8Int32(key *uint8, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerUint8Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Int32
	return ret
}

func (v *iterNative) readUint8Int64(key *uint8, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerUint8Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Int64
	return ret
}

func (v *iterNative) readUint8Uint(key *uint8, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerUint8Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Uint
	return ret
}

func (v *iterNative) readUint8Uint8(key *uint8, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerUint8Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Uint8
	return ret
}

func (v *iterNative) readUint8Uint16(key *uint8, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerUint8Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Uint16
	return ret
}

func (v *iterNative) readUint8Uint32(key *uint8, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerUint8Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Uint32
	return ret
}

func (v *iterNative) readUint8Uint64(key *uint8, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerUint8Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Uint64
	return ret
}

func (v *iterNative) readUint8Float32(key *uint8, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerUint8Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Float32
	return ret
}

func (v *iterNative) readUint8Float64(key *uint8, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerUint8Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Float64
	return ret
}

func (v *iterNative) readUint8Typex_T(key *uint8, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerUint8Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_T
	return ret
}

func (v *iterNative) readUint8Typex_U(key *uint8, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerUint8Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_U
	return ret
}

func (v *iterNative) readUint8Typex_V(key *uint8, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerUint8Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_V
	return ret
}

func (v *iterNative) readUint8Typex_W(key *uint8, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerUint8Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_W
	return ret
}

func (v *iterNative) readUint8Typex_X(key *uint8, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerUint8Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_X
	return ret
}

func (v *iterNative) readUint8Typex_Y(key *uint8, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerUint8Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_Y
	return ret
}

func (v *iterNative) readUint8Typex_Z(key *uint8, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint8)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerUint8Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint8Typex_Z
	return ret
}

func (v *iterNative) readUint16(val *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(uint16)
	return true
}

func iterMakerUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16
	return ret
}

func (v *iterNative) readUint16ByteSlice(key *uint16, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerUint16ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16ByteSlice
	return ret
}

func (v *iterNative) readUint16Bool(key *uint16, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerUint16Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Bool
	return ret
}

func (v *iterNative) readUint16String(key *uint16, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerUint16String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16String
	return ret
}

func (v *iterNative) readUint16Int(key *uint16, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerUint16Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Int
	return ret
}

func (v *iterNative) readUint16Int8(key *uint16, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerUint16Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Int8
	return ret
}

func (v *iterNative) readUint16Int16(key *uint16, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerUint16Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Int16
	return ret
}

func (v *iterNative) readUint16Int32(key *uint16, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerUint16Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Int32
	return ret
}

func (v *iterNative) readUint16Int64(key *uint16, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerUint16Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Int64
	return ret
}

func (v *iterNative) readUint16Uint(key *uint16, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerUint16Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Uint
	return ret
}

func (v *iterNative) readUint16Uint8(key *uint16, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerUint16Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Uint8
	return ret
}

func (v *iterNative) readUint16Uint16(key *uint16, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerUint16Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Uint16
	return ret
}

func (v *iterNative) readUint16Uint32(key *uint16, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerUint16Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Uint32
	return ret
}

func (v *iterNative) readUint16Uint64(key *uint16, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerUint16Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Uint64
	return ret
}

func (v *iterNative) readUint16Float32(key *uint16, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerUint16Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Float32
	return ret
}

func (v *iterNative) readUint16Float64(key *uint16, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerUint16Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Float64
	return ret
}

func (v *iterNative) readUint16Typex_T(key *uint16, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerUint16Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_T
	return ret
}

func (v *iterNative) readUint16Typex_U(key *uint16, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerUint16Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_U
	return ret
}

func (v *iterNative) readUint16Typex_V(key *uint16, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerUint16Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_V
	return ret
}

func (v *iterNative) readUint16Typex_W(key *uint16, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerUint16Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_W
	return ret
}

func (v *iterNative) readUint16Typex_X(key *uint16, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerUint16Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_X
	return ret
}

func (v *iterNative) readUint16Typex_Y(key *uint16, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerUint16Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_Y
	return ret
}

func (v *iterNative) readUint16Typex_Z(key *uint16, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint16)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerUint16Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint16Typex_Z
	return ret
}

func (v *iterNative) readUint32(val *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(uint32)
	return true
}

func iterMakerUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32
	return ret
}

func (v *iterNative) readUint32ByteSlice(key *uint32, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerUint32ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32ByteSlice
	return ret
}

func (v *iterNative) readUint32Bool(key *uint32, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerUint32Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Bool
	return ret
}

func (v *iterNative) readUint32String(key *uint32, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerUint32String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32String
	return ret
}

func (v *iterNative) readUint32Int(key *uint32, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerUint32Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Int
	return ret
}

func (v *iterNative) readUint32Int8(key *uint32, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerUint32Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Int8
	return ret
}

func (v *iterNative) readUint32Int16(key *uint32, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerUint32Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Int16
	return ret
}

func (v *iterNative) readUint32Int32(key *uint32, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerUint32Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Int32
	return ret
}

func (v *iterNative) readUint32Int64(key *uint32, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerUint32Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Int64
	return ret
}

func (v *iterNative) readUint32Uint(key *uint32, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerUint32Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Uint
	return ret
}

func (v *iterNative) readUint32Uint8(key *uint32, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerUint32Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Uint8
	return ret
}

func (v *iterNative) readUint32Uint16(key *uint32, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerUint32Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Uint16
	return ret
}

func (v *iterNative) readUint32Uint32(key *uint32, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerUint32Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Uint32
	return ret
}

func (v *iterNative) readUint32Uint64(key *uint32, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerUint32Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Uint64
	return ret
}

func (v *iterNative) readUint32Float32(key *uint32, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerUint32Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Float32
	return ret
}

func (v *iterNative) readUint32Float64(key *uint32, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerUint32Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Float64
	return ret
}

func (v *iterNative) readUint32Typex_T(key *uint32, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerUint32Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_T
	return ret
}

func (v *iterNative) readUint32Typex_U(key *uint32, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerUint32Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_U
	return ret
}

func (v *iterNative) readUint32Typex_V(key *uint32, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerUint32Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_V
	return ret
}

func (v *iterNative) readUint32Typex_W(key *uint32, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerUint32Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_W
	return ret
}

func (v *iterNative) readUint32Typex_X(key *uint32, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerUint32Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_X
	return ret
}

func (v *iterNative) readUint32Typex_Y(key *uint32, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerUint32Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_Y
	return ret
}

func (v *iterNative) readUint32Typex_Z(key *uint32, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint32)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerUint32Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint32Typex_Z
	return ret
}

func (v *iterNative) readUint64(val *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(uint64)
	return true
}

func iterMakerUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64
	return ret
}

func (v *iterNative) readUint64ByteSlice(key *uint64, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerUint64ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64ByteSlice
	return ret
}

func (v *iterNative) readUint64Bool(key *uint64, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerUint64Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Bool
	return ret
}

func (v *iterNative) readUint64String(key *uint64, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerUint64String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64String
	return ret
}

func (v *iterNative) readUint64Int(key *uint64, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerUint64Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Int
	return ret
}

func (v *iterNative) readUint64Int8(key *uint64, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerUint64Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Int8
	return ret
}

func (v *iterNative) readUint64Int16(key *uint64, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerUint64Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Int16
	return ret
}

func (v *iterNative) readUint64Int32(key *uint64, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerUint64Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Int32
	return ret
}

func (v *iterNative) readUint64Int64(key *uint64, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerUint64Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Int64
	return ret
}

func (v *iterNative) readUint64Uint(key *uint64, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerUint64Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Uint
	return ret
}

func (v *iterNative) readUint64Uint8(key *uint64, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerUint64Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Uint8
	return ret
}

func (v *iterNative) readUint64Uint16(key *uint64, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerUint64Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Uint16
	return ret
}

func (v *iterNative) readUint64Uint32(key *uint64, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerUint64Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Uint32
	return ret
}

func (v *iterNative) readUint64Uint64(key *uint64, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerUint64Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Uint64
	return ret
}

func (v *iterNative) readUint64Float32(key *uint64, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerUint64Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Float32
	return ret
}

func (v *iterNative) readUint64Float64(key *uint64, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerUint64Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Float64
	return ret
}

func (v *iterNative) readUint64Typex_T(key *uint64, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerUint64Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_T
	return ret
}

func (v *iterNative) readUint64Typex_U(key *uint64, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerUint64Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_U
	return ret
}

func (v *iterNative) readUint64Typex_V(key *uint64, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerUint64Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_V
	return ret
}

func (v *iterNative) readUint64Typex_W(key *uint64, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerUint64Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_W
	return ret
}

func (v *iterNative) readUint64Typex_X(key *uint64, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerUint64Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_X
	return ret
}

func (v *iterNative) readUint64Typex_Y(key *uint64, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerUint64Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_Y
	return ret
}

func (v *iterNative) readUint64Typex_Z(key *uint64, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(uint64)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerUint64Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readUint64Typex_Z
	return ret
}

func (v *iterNative) readFloat32(val *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(float32)
	return true
}

func iterMakerFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32
	return ret
}

func (v *iterNative) readFloat32ByteSlice(key *float32, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerFloat32ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32ByteSlice
	return ret
}

func (v *iterNative) readFloat32Bool(key *float32, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerFloat32Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Bool
	return ret
}

func (v *iterNative) readFloat32String(key *float32, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerFloat32String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32String
	return ret
}

func (v *iterNative) readFloat32Int(key *float32, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerFloat32Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Int
	return ret
}

func (v *iterNative) readFloat32Int8(key *float32, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerFloat32Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Int8
	return ret
}

func (v *iterNative) readFloat32Int16(key *float32, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerFloat32Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Int16
	return ret
}

func (v *iterNative) readFloat32Int32(key *float32, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerFloat32Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Int32
	return ret
}

func (v *iterNative) readFloat32Int64(key *float32, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerFloat32Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Int64
	return ret
}

func (v *iterNative) readFloat32Uint(key *float32, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerFloat32Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Uint
	return ret
}

func (v *iterNative) readFloat32Uint8(key *float32, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerFloat32Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Uint8
	return ret
}

func (v *iterNative) readFloat32Uint16(key *float32, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerFloat32Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Uint16
	return ret
}

func (v *iterNative) readFloat32Uint32(key *float32, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerFloat32Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Uint32
	return ret
}

func (v *iterNative) readFloat32Uint64(key *float32, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerFloat32Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Uint64
	return ret
}

func (v *iterNative) readFloat32Float32(key *float32, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerFloat32Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Float32
	return ret
}

func (v *iterNative) readFloat32Float64(key *float32, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerFloat32Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Float64
	return ret
}

func (v *iterNative) readFloat32Typex_T(key *float32, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerFloat32Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_T
	return ret
}

func (v *iterNative) readFloat32Typex_U(key *float32, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerFloat32Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_U
	return ret
}

func (v *iterNative) readFloat32Typex_V(key *float32, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerFloat32Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_V
	return ret
}

func (v *iterNative) readFloat32Typex_W(key *float32, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerFloat32Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_W
	return ret
}

func (v *iterNative) readFloat32Typex_X(key *float32, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerFloat32Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_X
	return ret
}

func (v *iterNative) readFloat32Typex_Y(key *float32, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerFloat32Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_Y
	return ret
}

func (v *iterNative) readFloat32Typex_Z(key *float32, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float32)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerFloat32Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat32Typex_Z
	return ret
}

func (v *iterNative) readFloat64(val *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(float64)
	return true
}

func iterMakerFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64
	return ret
}

func (v *iterNative) readFloat64ByteSlice(key *float64, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerFloat64ByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64ByteSlice
	return ret
}

func (v *iterNative) readFloat64Bool(key *float64, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerFloat64Bool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Bool
	return ret
}

func (v *iterNative) readFloat64String(key *float64, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerFloat64String(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64String
	return ret
}

func (v *iterNative) readFloat64Int(key *float64, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerFloat64Int(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Int
	return ret
}

func (v *iterNative) readFloat64Int8(key *float64, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerFloat64Int8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Int8
	return ret
}

func (v *iterNative) readFloat64Int16(key *float64, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerFloat64Int16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Int16
	return ret
}

func (v *iterNative) readFloat64Int32(key *float64, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerFloat64Int32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Int32
	return ret
}

func (v *iterNative) readFloat64Int64(key *float64, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerFloat64Int64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Int64
	return ret
}

func (v *iterNative) readFloat64Uint(key *float64, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerFloat64Uint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Uint
	return ret
}

func (v *iterNative) readFloat64Uint8(key *float64, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerFloat64Uint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Uint8
	return ret
}

func (v *iterNative) readFloat64Uint16(key *float64, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerFloat64Uint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Uint16
	return ret
}

func (v *iterNative) readFloat64Uint32(key *float64, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerFloat64Uint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Uint32
	return ret
}

func (v *iterNative) readFloat64Uint64(key *float64, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerFloat64Uint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Uint64
	return ret
}

func (v *iterNative) readFloat64Float32(key *float64, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerFloat64Float32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Float32
	return ret
}

func (v *iterNative) readFloat64Float64(key *float64, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerFloat64Float64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Float64
	return ret
}

func (v *iterNative) readFloat64Typex_T(key *float64, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerFloat64Typex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_T
	return ret
}

func (v *iterNative) readFloat64Typex_U(key *float64, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerFloat64Typex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_U
	return ret
}

func (v *iterNative) readFloat64Typex_V(key *float64, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerFloat64Typex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_V
	return ret
}

func (v *iterNative) readFloat64Typex_W(key *float64, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerFloat64Typex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_W
	return ret
}

func (v *iterNative) readFloat64Typex_X(key *float64, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerFloat64Typex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_X
	return ret
}

func (v *iterNative) readFloat64Typex_Y(key *float64, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerFloat64Typex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_Y
	return ret
}

func (v *iterNative) readFloat64Typex_Z(key *float64, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(float64)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerFloat64Typex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readFloat64Typex_Z
	return ret
}

func (v *iterNative) readTypex_T(val *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.T)
	return true
}

func iterMakerTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_T
	return ret
}

func (v *iterNative) readTypex_TByteSlice(key *typex.T, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_TByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TByteSlice
	return ret
}

func (v *iterNative) readTypex_TBool(key *typex.T, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_TBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TBool
	return ret
}

func (v *iterNative) readTypex_TString(key *typex.T, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerTypex_TString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TString
	return ret
}

func (v *iterNative) readTypex_TInt(key *typex.T, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_TInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TInt
	return ret
}

func (v *iterNative) readTypex_TInt8(key *typex.T, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_TInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TInt8
	return ret
}

func (v *iterNative) readTypex_TInt16(key *typex.T, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_TInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TInt16
	return ret
}

func (v *iterNative) readTypex_TInt32(key *typex.T, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_TInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TInt32
	return ret
}

func (v *iterNative) readTypex_TInt64(key *typex.T, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_TInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TInt64
	return ret
}

func (v *iterNative) readTypex_TUint(key *typex.T, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_TUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TUint
	return ret
}

func (v *iterNative) readTypex_TUint8(key *typex.T, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_TUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TUint8
	return ret
}

func (v *iterNative) readTypex_TUint16(key *typex.T, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_TUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TUint16
	return ret
}

func (v *iterNative) readTypex_TUint32(key *typex.T, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_TUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TUint32
	return ret
}

func (v *iterNative) readTypex_TUint64(key *typex.T, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_TUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TUint64
	return ret
}

func (v *iterNative) readTypex_TFloat32(key *typex.T, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_TFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TFloat32
	return ret
}

func (v *iterNative) readTypex_TFloat64(key *typex.T, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_TFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TFloat64
	return ret
}

func (v *iterNative) readTypex_TTypex_T(key *typex.T, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_TTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_T
	return ret
}

func (v *iterNative) readTypex_TTypex_U(key *typex.T, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_TTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_U
	return ret
}

func (v *iterNative) readTypex_TTypex_V(key *typex.T, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_TTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_V
	return ret
}

func (v *iterNative) readTypex_TTypex_W(key *typex.T, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_TTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_W
	return ret
}

func (v *iterNative) readTypex_TTypex_X(key *typex.T, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_TTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_X
	return ret
}

func (v *iterNative) readTypex_TTypex_Y(key *typex.T, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_TTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_Y
	return ret
}

func (v *iterNative) readTypex_TTypex_Z(key *typex.T, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.T)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_TTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_TTypex_Z
	return ret
}

func (v *iterNative) readTypex_U(val *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.U)
	return true
}

func iterMakerTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_U
	return ret
}

func (v *iterNative) readTypex_UByteSlice(key *typex.U, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_UByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UByteSlice
	return ret
}

func (v *iterNative) readTypex_UBool(key *typex.U, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_UBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UBool
	return ret
}

func (v *iterNative) readTypex_UString(key *typex.U, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerTypex_UString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UString
	return ret
}

func (v *iterNative) readTypex_UInt(key *typex.U, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_UInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UInt
	return ret
}

func (v *iterNative) readTypex_UInt8(key *typex.U, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_UInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UInt8
	return ret
}

func (v *iterNative) readTypex_UInt16(key *typex.U, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_UInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UInt16
	return ret
}

func (v *iterNative) readTypex_UInt32(key *typex.U, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_UInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UInt32
	return ret
}

func (v *iterNative) readTypex_UInt64(key *typex.U, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_UInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UInt64
	return ret
}

func (v *iterNative) readTypex_UUint(key *typex.U, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_UUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UUint
	return ret
}

func (v *iterNative) readTypex_UUint8(key *typex.U, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_UUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UUint8
	return ret
}

func (v *iterNative) readTypex_UUint16(key *typex.U, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_UUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UUint16
	return ret
}

func (v *iterNative) readTypex_UUint32(key *typex.U, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_UUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UUint32
	return ret
}

func (v *iterNative) readTypex_UUint64(key *typex.U, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_UUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UUint64
	return ret
}

func (v *iterNative) readTypex_UFloat32(key *typex.U, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_UFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UFloat32
	return ret
}

func (v *iterNative) readTypex_UFloat64(key *typex.U, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_UFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UFloat64
	return ret
}

func (v *iterNative) readTypex_UTypex_T(key *typex.U, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_UTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_T
	return ret
}

func (v *iterNative) readTypex_UTypex_U(key *typex.U, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_UTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_U
	return ret
}

func (v *iterNative) readTypex_UTypex_V(key *typex.U, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_UTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_V
	return ret
}

func (v *iterNative) readTypex_UTypex_W(key *typex.U, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_UTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_W
	return ret
}

func (v *iterNative) readTypex_UTypex_X(key *typex.U, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_UTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_X
	return ret
}

func (v *iterNative) readTypex_UTypex_Y(key *typex.U, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_UTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_Y
	return ret
}

func (v *iterNative) readTypex_UTypex_Z(key *typex.U, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.U)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_UTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_UTypex_Z
	return ret
}

func (v *iterNative) readTypex_V(val *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.V)
	return true
}

func iterMakerTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_V
	return ret
}

func (v *iterNative) readTypex_VByteSlice(key *typex.V, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_VByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VByteSlice
	return ret
}

func (v *iterNative) readTypex_VBool(key *typex.V, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_VBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VBool
	return ret
}

func (v *iterNative) readTypex_VString(key *typex.V, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerTypex_VString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VString
	return ret
}

func (v *iterNative) readTypex_VInt(key *typex.V, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_VInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VInt
	return ret
}

func (v *iterNative) readTypex_VInt8(key *typex.V, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_VInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VInt8
	return ret
}

func (v *iterNative) readTypex_VInt16(key *typex.V, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_VInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VInt16
	return ret
}

func (v *iterNative) readTypex_VInt32(key *typex.V, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_VInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VInt32
	return ret
}

func (v *iterNative) readTypex_VInt64(key *typex.V, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_VInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VInt64
	return ret
}

func (v *iterNative) readTypex_VUint(key *typex.V, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_VUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VUint
	return ret
}

func (v *iterNative) readTypex_VUint8(key *typex.V, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_VUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VUint8
	return ret
}

func (v *iterNative) readTypex_VUint16(key *typex.V, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_VUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VUint16
	return ret
}

func (v *iterNative) readTypex_VUint32(key *typex.V, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_VUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VUint32
	return ret
}

func (v *iterNative) readTypex_VUint64(key *typex.V, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_VUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VUint64
	return ret
}

func (v *iterNative) readTypex_VFloat32(key *typex.V, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_VFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VFloat32
	return ret
}

func (v *iterNative) readTypex_VFloat64(key *typex.V, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_VFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VFloat64
	return ret
}

func (v *iterNative) readTypex_VTypex_T(key *typex.V, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_VTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_T
	return ret
}

func (v *iterNative) readTypex_VTypex_U(key *typex.V, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_VTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_U
	return ret
}

func (v *iterNative) readTypex_VTypex_V(key *typex.V, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_VTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_V
	return ret
}

func (v *iterNative) readTypex_VTypex_W(key *typex.V, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_VTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_W
	return ret
}

func (v *iterNative) readTypex_VTypex_X(key *typex.V, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_VTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_X
	return ret
}

func (v *iterNative) readTypex_VTypex_Y(key *typex.V, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_VTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_Y
	return ret
}

func (v *iterNative) readTypex_VTypex_Z(key *typex.V, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.V)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_VTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_VTypex_Z
	return ret
}

func (v *iterNative) readTypex_W(val *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.W)
	return true
}

func iterMakerTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_W
	return ret
}

func (v *iterNative) readTypex_WByteSlice(key *typex.W, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_WByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WByteSlice
	return ret
}

func (v *iterNative) readTypex_WBool(key *typex.W, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_WBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WBool
	return ret
}

func (v *iterNative) readTypex_WString(key *typex.W, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerTypex_WString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WString
	return ret
}

func (v *iterNative) readTypex_WInt(key *typex.W, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_WInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WInt
	return ret
}

func (v *iterNative) readTypex_WInt8(key *typex.W, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_WInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WInt8
	return ret
}

func (v *iterNative) readTypex_WInt16(key *typex.W, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_WInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WInt16
	return ret
}

func (v *iterNative) readTypex_WInt32(key *typex.W, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_WInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WInt32
	return ret
}

func (v *iterNative) readTypex_WInt64(key *typex.W, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_WInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WInt64
	return ret
}

func (v *iterNative) readTypex_WUint(key *typex.W, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_WUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WUint
	return ret
}

func (v *iterNative) readTypex_WUint8(key *typex.W, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_WUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WUint8
	return ret
}

func (v *iterNative) readTypex_WUint16(key *typex.W, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_WUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WUint16
	return ret
}

func (v *iterNative) readTypex_WUint32(key *typex.W, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_WUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WUint32
	return ret
}

func (v *iterNative) readTypex_WUint64(key *typex.W, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_WUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WUint64
	return ret
}

func (v *iterNative) readTypex_WFloat32(key *typex.W, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_WFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WFloat32
	return ret
}

func (v *iterNative) readTypex_WFloat64(key *typex.W, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_WFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WFloat64
	return ret
}

func (v *iterNative) readTypex_WTypex_T(key *typex.W, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_WTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_T
	return ret
}

func (v *iterNative) readTypex_WTypex_U(key *typex.W, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_WTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_U
	return ret
}

func (v *iterNative) readTypex_WTypex_V(key *typex.W, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_WTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_V
	return ret
}

func (v *iterNative) readTypex_WTypex_W(key *typex.W, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_WTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_W
	return ret
}

func (v *iterNative) readTypex_WTypex_X(key *typex.W, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_WTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_X
	return ret
}

func (v *iterNative) readTypex_WTypex_Y(key *typex.W, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_WTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_Y
	return ret
}

func (v *iterNative) readTypex_WTypex_Z(key *typex.W, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.W)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_WTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_WTypex_Z
	return ret
}

func (v *iterNative) readTypex_X(val *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.X)
	return true
}

func iterMakerTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_X
	return ret
}

func (v *iterNative) readTypex_XByteSlice(key *typex.X, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_XByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XByteSlice
	return ret
}

func (v *iterNative) readTypex_XBool(key *typex.X, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_XBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XBool
	return ret
}

func (v *iterNative) readTypex_XString(key *typex.X, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerTypex_XString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XString
	return ret
}

func (v *iterNative) readTypex_XInt(key *typex.X, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_XInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XInt
	return ret
}

func (v *iterNative) readTypex_XInt8(key *typex.X, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_XInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XInt8
	return ret
}

func (v *iterNative) readTypex_XInt16(key *typex.X, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_XInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XInt16
	return ret
}

func (v *iterNative) readTypex_XInt32(key *typex.X, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_XInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XInt32
	return ret
}

func (v *iterNative) readTypex_XInt64(key *typex.X, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_XInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XInt64
	return ret
}

func (v *iterNative) readTypex_XUint(key *typex.X, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_XUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XUint
	return ret
}

func (v *iterNative) readTypex_XUint8(key *typex.X, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_XUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XUint8
	return ret
}

func (v *iterNative) readTypex_XUint16(key *typex.X, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_XUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XUint16
	return ret
}

func (v *iterNative) readTypex_XUint32(key *typex.X, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_XUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XUint32
	return ret
}

func (v *iterNative) readTypex_XUint64(key *typex.X, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_XUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XUint64
	return ret
}

func (v *iterNative) readTypex_XFloat32(key *typex.X, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_XFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XFloat32
	return ret
}

func (v *iterNative) readTypex_XFloat64(key *typex.X, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_XFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XFloat64
	return ret
}

func (v *iterNative) readTypex_XTypex_T(key *typex.X, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_XTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_T
	return ret
}

func (v *iterNative) readTypex_XTypex_U(key *typex.X, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_XTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_U
	return ret
}

func (v *iterNative) readTypex_XTypex_V(key *typex.X, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_XTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_V
	return ret
}

func (v *iterNative) readTypex_XTypex_W(key *typex.X, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_XTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_W
	return ret
}

func (v *iterNative) readTypex_XTypex_X(key *typex.X, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_XTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_X
	return ret
}

func (v *iterNative) readTypex_XTypex_Y(key *typex.X, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_XTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_Y
	return ret
}

func (v *iterNative) readTypex_XTypex_Z(key *typex.X, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.X)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_XTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_XTypex_Z
	return ret
}

func (v *iterNative) readTypex_Y(val *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.Y)
	return true
}

func iterMakerTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_Y
	return ret
}

func (v *iterNative) readTypex_YByteSlice(key *typex.Y, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_YByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YByteSlice
	return ret
}

func (v *iterNative) readTypex_YBool(key *typex.Y, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_YBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YBool
	return ret
}

func (v *iterNative) readTypex_YString(key *typex.Y, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerTypex_YString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YString
	return ret
}

func (v *iterNative) readTypex_YInt(key *typex.Y, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_YInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YInt
	return ret
}

func (v *iterNative) readTypex_YInt8(key *typex.Y, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_YInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YInt8
	return ret
}

func (v *iterNative) readTypex_YInt16(key *typex.Y, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_YInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YInt16
	return ret
}

func (v *iterNative) readTypex_YInt32(key *typex.Y, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_YInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YInt32
	return ret
}

func (v *iterNative) readTypex_YInt64(key *typex.Y, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_YInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YInt64
	return ret
}

func (v *iterNative) readTypex_YUint(key *typex.Y, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_YUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YUint
	return ret
}

func (v *iterNative) readTypex_YUint8(key *typex.Y, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_YUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YUint8
	return ret
}

func (v *iterNative) readTypex_YUint16(key *typex.Y, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_YUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YUint16
	return ret
}

func (v *iterNative) readTypex_YUint32(key *typex.Y, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_YUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YUint32
	return ret
}

func (v *iterNative) readTypex_YUint64(key *typex.Y, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_YUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YUint64
	return ret
}

func (v *iterNative) readTypex_YFloat32(key *typex.Y, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_YFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YFloat32
	return ret
}

func (v *iterNative) readTypex_YFloat64(key *typex.Y, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_YFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YFloat64
	return ret
}

func (v *iterNative) readTypex_YTypex_T(key *typex.Y, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_YTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_T
	return ret
}

func (v *iterNative) readTypex_YTypex_U(key *typex.Y, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_YTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_U
	return ret
}

func (v *iterNative) readTypex_YTypex_V(key *typex.Y, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_YTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_V
	return ret
}

func (v *iterNative) readTypex_YTypex_W(key *typex.Y, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_YTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_W
	return ret
}

func (v *iterNative) readTypex_YTypex_X(key *typex.Y, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_YTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_X
	return ret
}

func (v *iterNative) readTypex_YTypex_Y(key *typex.Y, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_YTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_Y
	return ret
}

func (v *iterNative) readTypex_YTypex_Z(key *typex.Y, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Y)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_YTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_YTypex_Z
	return ret
}

func (v *iterNative) readTypex_Z(val *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*val = elm.Elm.(typex.Z)
	return true
}

func iterMakerTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_Z
	return ret
}

func (v *iterNative) readTypex_ZByteSlice(key *typex.Z, value *[]byte) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.([]byte)
	return true
}

func iterMakerTypex_ZByteSlice(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZByteSlice
	return ret
}

func (v *iterNative) readTypex_ZBool(key *typex.Z, value *bool) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(bool)
	return true
}

func iterMakerTypex_ZBool(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZBool
	return ret
}

func (v *iterNative) readTypex_ZString(key *typex.Z, value *string) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(string)
	return true
}

func iterMakerTypex_ZString(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZString
	return ret
}

func (v *iterNative) readTypex_ZInt(key *typex.Z, value *int) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int)
	return true
}

func iterMakerTypex_ZInt(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZInt
	return ret
}

func (v *iterNative) readTypex_ZInt8(key *typex.Z, value *int8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int8)
	return true
}

func iterMakerTypex_ZInt8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZInt8
	return ret
}

func (v *iterNative) readTypex_ZInt16(key *typex.Z, value *int16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int16)
	return true
}

func iterMakerTypex_ZInt16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZInt16
	return ret
}

func (v *iterNative) readTypex_ZInt32(key *typex.Z, value *int32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int32)
	return true
}

func iterMakerTypex_ZInt32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZInt32
	return ret
}

func (v *iterNative) readTypex_ZInt64(key *typex.Z, value *int64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(int64)
	return true
}

func iterMakerTypex_ZInt64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZInt64
	return ret
}

func (v *iterNative) readTypex_ZUint(key *typex.Z, value *uint) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint)
	return true
}

func iterMakerTypex_ZUint(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZUint
	return ret
}

func (v *iterNative) readTypex_ZUint8(key *typex.Z, value *uint8) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint8)
	return true
}

func iterMakerTypex_ZUint8(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZUint8
	return ret
}

func (v *iterNative) readTypex_ZUint16(key *typex.Z, value *uint16) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint16)
	return true
}

func iterMakerTypex_ZUint16(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZUint16
	return ret
}

func (v *iterNative) readTypex_ZUint32(key *typex.Z, value *uint32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint32)
	return true
}

func iterMakerTypex_ZUint32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZUint32
	return ret
}

func (v *iterNative) readTypex_ZUint64(key *typex.Z, value *uint64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(uint64)
	return true
}

func iterMakerTypex_ZUint64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZUint64
	return ret
}

func (v *iterNative) readTypex_ZFloat32(key *typex.Z, value *float32) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(float32)
	return true
}

func iterMakerTypex_ZFloat32(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZFloat32
	return ret
}

func (v *iterNative) readTypex_ZFloat64(key *typex.Z, value *float64) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(float64)
	return true
}

func iterMakerTypex_ZFloat64(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZFloat64
	return ret
}

func (v *iterNative) readTypex_ZTypex_T(key *typex.Z, value *typex.T) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.T)
	return true
}

func iterMakerTypex_ZTypex_T(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_T
	return ret
}

func (v *iterNative) readTypex_ZTypex_U(key *typex.Z, value *typex.U) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.U)
	return true
}

func iterMakerTypex_ZTypex_U(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_U
	return ret
}

func (v *iterNative) readTypex_ZTypex_V(key *typex.Z, value *typex.V) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.V)
	return true
}

func iterMakerTypex_ZTypex_V(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_V
	return ret
}

func (v *iterNative) readTypex_ZTypex_W(key *typex.Z, value *typex.W) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.W)
	return true
}

func iterMakerTypex_ZTypex_W(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_W
	return ret
}

func (v *iterNative) readTypex_ZTypex_X(key *typex.Z, value *typex.X) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.X)
	return true
}

func iterMakerTypex_ZTypex_X(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_X
	return ret
}

func (v *iterNative) readTypex_ZTypex_Y(key *typex.Z, value *typex.Y) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.Y)
	return true
}

func iterMakerTypex_ZTypex_Y(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_Y
	return ret
}

func (v *iterNative) readTypex_ZTypex_Z(key *typex.Z, value *typex.Z) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*key = elm.Elm.(typex.Z)
	*value = elm.Elm2.(typex.Z)
	return true
}

func iterMakerTypex_ZTypex_Z(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readTypex_ZTypex_Z
	return ret
}
