// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by starcgen. DO NOT EDIT.
// File: coderx.shims.go

package coderx

import (
	"reflect"

	// Library imports
	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime"
	"github.com/apache/beam/sdks/go/pkg/beam/core/typex"
	"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx"
)

func init() {
	runtime.RegisterFunction(decFloat)
	runtime.RegisterFunction(decInt32)
	runtime.RegisterFunction(decInt64)
	runtime.RegisterFunction(decUint32)
	runtime.RegisterFunction(decUint64)
	runtime.RegisterFunction(decVarIntZ)
	runtime.RegisterFunction(decVarUintZ)
	runtime.RegisterFunction(encFloat)
	runtime.RegisterFunction(encInt32)
	runtime.RegisterFunction(encInt64)
	runtime.RegisterFunction(encUint32)
	runtime.RegisterFunction(encUint64)
	runtime.RegisterFunction(encVarIntZ)
	runtime.RegisterFunction(encVarUintZ)
	runtime.RegisterType(reflect.TypeOf((*reflect.Type)(nil)).Elem())
	runtime.RegisterType(reflect.TypeOf((*typex.T)(nil)).Elem())
	reflectx.RegisterFunc(reflect.TypeOf((*func(int32) ([]byte))(nil)).Elem(), funcMakerInt32ГSliceofByte)
	reflectx.RegisterFunc(reflect.TypeOf((*func(int64) ([]byte))(nil)).Elem(), funcMakerInt64ГSliceofByte)
	reflectx.RegisterFunc(reflect.TypeOf((*func(reflect.Type,[]byte) (typex.T,error))(nil)).Elem(), funcMakerReflect۰TypeSliceofByteГTypex۰TError)
	reflectx.RegisterFunc(reflect.TypeOf((*func([]byte) (int32))(nil)).Elem(), funcMakerSliceofByteГInt32)
	reflectx.RegisterFunc(reflect.TypeOf((*func([]byte) (int64))(nil)).Elem(), funcMakerSliceofByteГInt64)
	reflectx.RegisterFunc(reflect.TypeOf((*func([]byte) (uint32))(nil)).Elem(), funcMakerSliceofByteГUint32)
	reflectx.RegisterFunc(reflect.TypeOf((*func([]byte) (uint64))(nil)).Elem(), funcMakerSliceofByteГUint64)
	reflectx.RegisterFunc(reflect.TypeOf((*func(typex.T) ([]byte))(nil)).Elem(), funcMakerTypex۰TГSliceofByte)
	reflectx.RegisterFunc(reflect.TypeOf((*func(uint32) ([]byte))(nil)).Elem(), funcMakerUint32ГSliceofByte)
	reflectx.RegisterFunc(reflect.TypeOf((*func(uint64) ([]byte))(nil)).Elem(), funcMakerUint64ГSliceofByte)
}

type callerInt32ГSliceofByte struct {
	fn func(int32) ([]byte)
}

func funcMakerInt32ГSliceofByte(fn interface{}) reflectx.Func {
	f := fn.(func(int32) ([]byte))
	return &callerInt32ГSliceofByte{fn: f}
}

func (c *callerInt32ГSliceofByte) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerInt32ГSliceofByte) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerInt32ГSliceofByte) Call(args []interface{}) []interface{} {
	out0 := c.fn(args[0].(int32))
	return []interface{}{out0}
}

func (c *callerInt32ГSliceofByte) Call1x1(arg0 interface{}) (interface{}) {
	return c.fn(arg0.(int32))
}

type callerInt64ГSliceofByte struct {
	fn func(int64) ([]byte)
}

func funcMakerInt64ГSliceofByte(fn interface{}) reflectx.Func {
	f := fn.(func(int64) ([]byte))
	return &callerInt64ГSliceofByte{fn: f}
}

func (c *callerInt64ГSliceofByte) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerInt64ГSliceofByte) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerInt64ГSliceofByte) Call(args []interface{}) []interface{} {
	out0 := c.fn(args[0].(int64))
	return []interface{}{out0}
}

func (c *callerInt64ГSliceofByte) Call1x1(arg0 interface{}) (interface{}) {
	return c.fn(arg0.(int64))
}

type callerReflect۰TypeSliceofByteГTypex۰TError struct {
	fn func(reflect.Type,[]byte) (typex.T,error)
}

func funcMakerReflect۰TypeSliceofByteГTypex۰TError(fn interface{}) reflectx.Func {
	f := fn.(func(reflect.Type,[]byte) (typex.T,error))
	return &callerReflect۰TypeSliceofByteГTypex۰TError{fn: f}
}

func (c *callerReflect۰TypeSliceofByteГTypex۰TError) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerReflect۰TypeSliceofByteГTypex۰TError) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerReflect۰TypeSliceofByteГTypex۰TError) Call(args []interface{}) []interface{} {
	out0, out1 := c.fn(args[0].(reflect.Type), args[1].([]byte))
	return []interface{}{out0, out1}
}

func (c *callerReflect۰TypeSliceofByteГTypex۰TError) Call2x2(arg0, arg1 interface{}) (interface{}, interface{}) {
	return c.fn(arg0.(reflect.Type), arg1.([]byte))
}

type callerSliceofByteГInt32 struct {
	fn func([]byte) (int32)
}

func funcMakerSliceofByteГInt32(fn interface{}) reflectx.Func {
	f := fn.(func([]byte) (int32))
	return &callerSliceofByteГInt32{fn: f}
}

func (c *callerSliceofByteГInt32) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerSliceofByteГInt32) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerSliceofByteГInt32) Call(args []interface{}) []interface{} {
	out0 := c.fn(args[0].([]byte))
	return []interface{}{out0}
}

func (c *callerSliceofByteГInt32) Call1x1(arg0 interface{}) (interface{}) {
	return c.fn(arg0.([]byte))
}

type callerSliceofByteГInt64 struct {
	fn func([]byte) (int64)
}

func funcMakerSliceofByteГInt64(fn interface{}) reflectx.Func {
	f := fn.(func([]byte) (int64))
	return &callerSliceofByteГInt64{fn: f}
}

func (c *callerSliceofByteГInt64) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerSliceofByteГInt64) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerSliceofByteГInt64) Call(args []interface{}) []interface{} {
	out0 := c.fn(args[0].([]byte))
	return []interface{}{out0}
}

func (c *callerSliceofByteГInt64) Call1x1(arg0 interface{}) (interface{}) {
	return c.fn(arg0.([]byte))
}

type callerSliceofByteГUint32 struct {
	fn func([]byte) (uint32)
}

func funcMakerSliceofByteГUint32(fn interface{}) reflectx.Func {
	f := fn.(func([]byte) (uint32))
	return &callerSliceofByteГUint32{fn: f}
}

func (c *callerSliceofByteГUint32) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerSliceofByteГUint32) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerSliceofByteГUint32) Call(args []interface{}) []interface{} {
	out0 := c.fn(args[0].([]byte))
	return []interface{}{out0}
}

func (c *callerSliceofByteГUint32) Call1x1(arg0 interface{}) (interface{}) {
	return c.fn(arg0.([]byte))
}

type callerSliceofByteГUint64 struct {
	fn func([]byte) (uint64)
}

func funcMakerSliceofByteГUint64(fn interface{}) reflectx.Func {
	f := fn.(func([]byte) (uint64))
	return &callerSliceofByteГUint64{fn: f}
}

func (c *callerSliceofByteГUint64) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerSliceofByteГUint64) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerSliceofByteГUint64) Call(args []interface{}) []interface{} {
	out0 := c.fn(args[0].([]byte))
	return []interface{}{out0}
}

func (c *callerSliceofByteГUint64) Call1x1(arg0 interface{}) (interface{}) {
	return c.fn(arg0.([]byte))
}

type callerTypex۰TГSliceofByte struct {
	fn func(typex.T) ([]byte)
}

func funcMakerTypex۰TГSliceofByte(fn interface{}) reflectx.Func {
	f := fn.(func(typex.T) ([]byte))
	return &callerTypex۰TГSliceofByte{fn: f}
}

func (c *callerTypex۰TГSliceofByte) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerTypex۰TГSliceofByte) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerTypex۰TГSliceofByte) Call(args []interface{}) []interface{} {
	out0 := c.fn(args[0].(typex.T))
	return []interface{}{out0}
}

func (c *callerTypex۰TГSliceofByte) Call1x1(arg0 interface{}) (interface{}) {
	return c.fn(arg0.(typex.T))
}

type callerUint32ГSliceofByte struct {
	fn func(uint32) ([]byte)
}

func funcMakerUint32ГSliceofByte(fn interface{}) reflectx.Func {
	f := fn.(func(uint32) ([]byte))
	return &callerUint32ГSliceofByte{fn: f}
}

func (c *callerUint32ГSliceofByte) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerUint32ГSliceofByte) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerUint32ГSliceofByte) Call(args []interface{}) []interface{} {
	out0 := c.fn(args[0].(uint32))
	return []interface{}{out0}
}

func (c *callerUint32ГSliceofByte) Call1x1(arg0 interface{}) (interface{}) {
	return c.fn(arg0.(uint32))
}

type callerUint64ГSliceofByte struct {
	fn func(uint64) ([]byte)
}

func funcMakerUint64ГSliceofByte(fn interface{}) reflectx.Func {
	f := fn.(func(uint64) ([]byte))
	return &callerUint64ГSliceofByte{fn: f}
}

func (c *callerUint64ГSliceofByte) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerUint64ГSliceofByte) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerUint64ГSliceofByte) Call(args []interface{}) []interface{} {
	out0 := c.fn(args[0].(uint64))
	return []interface{}{out0}
}

func (c *callerUint64ГSliceofByte) Call1x1(arg0 interface{}) (interface{}) {
	return c.fn(arg0.(uint64))
}


// DO NOT MODIFY: GENERATED CODE
