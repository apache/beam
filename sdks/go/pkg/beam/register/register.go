// File generated by specialize. Do not edit.

// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated from register.tmpl. DO NOT EDIT.

package register

import (
	"context"
	"fmt"
	"reflect"

	"github.com/apache/beam/sdks/v2/go/pkg/beam/core/runtime"
	"github.com/apache/beam/sdks/v2/go/pkg/beam/core/runtime/graphx/schema"
	"github.com/apache/beam/sdks/v2/go/pkg/beam/core/typex"
	"github.com/apache/beam/sdks/v2/go/pkg/beam/core/util/reflectx"
)

func registerStartBundle0x0FuncAndMakeStructWrapper() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func())(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller0x0{fn: fn.(func())}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func() {
			fn.(startBundle0x0).StartBundle()
		})
	}
}

func registerStartBundle0x1FuncAndMakeStructWrapper[R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func() R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller0x1[R0]{fn: fn.(func() R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func() R0 {
			return fn.(startBundle0x1[R0]).StartBundle()
		})
	}
}

func registerStartBundle1x0FuncAndMakeStructWrapper[I0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller1x0[I0]{fn: fn.(func(I0))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0) {
			fn.(startBundle1x0[I0]).StartBundle(a0)
		})
	}
}

func registerStartBundle1x1FuncAndMakeStructWrapper[I0, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller1x1[I0, R0]{fn: fn.(func(I0) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0) R0 {
			return fn.(startBundle1x1[I0, R0]).StartBundle(a0)
		})
	}
}

func registerStartBundle2x0FuncAndMakeStructWrapper[I0, I1 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller2x0[I0, I1]{fn: fn.(func(I0, I1))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1) {
			fn.(startBundle2x0[I0, I1]).StartBundle(a0, a1)
		})
	}
}

func registerStartBundle2x1FuncAndMakeStructWrapper[I0, I1, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller2x1[I0, I1, R0]{fn: fn.(func(I0, I1) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1) R0 {
			return fn.(startBundle2x1[I0, I1, R0]).StartBundle(a0, a1)
		})
	}
}

func registerStartBundle3x0FuncAndMakeStructWrapper[I0, I1, I2 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller3x0[I0, I1, I2]{fn: fn.(func(I0, I1, I2))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2) {
			fn.(startBundle3x0[I0, I1, I2]).StartBundle(a0, a1, a2)
		})
	}
}

func registerStartBundle3x1FuncAndMakeStructWrapper[I0, I1, I2, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller3x1[I0, I1, I2, R0]{fn: fn.(func(I0, I1, I2) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2) R0 {
			return fn.(startBundle3x1[I0, I1, I2, R0]).StartBundle(a0, a1, a2)
		})
	}
}

func registerStartBundle4x0FuncAndMakeStructWrapper[I0, I1, I2, I3 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller4x0[I0, I1, I2, I3]{fn: fn.(func(I0, I1, I2, I3))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3) {
			fn.(startBundle4x0[I0, I1, I2, I3]).StartBundle(a0, a1, a2, a3)
		})
	}
}

func registerStartBundle4x1FuncAndMakeStructWrapper[I0, I1, I2, I3, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller4x1[I0, I1, I2, I3, R0]{fn: fn.(func(I0, I1, I2, I3) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3) R0 {
			return fn.(startBundle4x1[I0, I1, I2, I3, R0]).StartBundle(a0, a1, a2, a3)
		})
	}
}

func registerStartBundle5x0FuncAndMakeStructWrapper[I0, I1, I2, I3, I4 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller5x0[I0, I1, I2, I3, I4]{fn: fn.(func(I0, I1, I2, I3, I4))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4) {
			fn.(startBundle5x0[I0, I1, I2, I3, I4]).StartBundle(a0, a1, a2, a3, a4)
		})
	}
}

func registerStartBundle5x1FuncAndMakeStructWrapper[I0, I1, I2, I3, I4, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller5x1[I0, I1, I2, I3, I4, R0]{fn: fn.(func(I0, I1, I2, I3, I4) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4) R0 {
			return fn.(startBundle5x1[I0, I1, I2, I3, I4, R0]).StartBundle(a0, a1, a2, a3, a4)
		})
	}
}

func registerStartBundle6x0FuncAndMakeStructWrapper[I0, I1, I2, I3, I4, I5 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller6x0[I0, I1, I2, I3, I4, I5]{fn: fn.(func(I0, I1, I2, I3, I4, I5))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5) {
			fn.(startBundle6x0[I0, I1, I2, I3, I4, I5]).StartBundle(a0, a1, a2, a3, a4, a5)
		})
	}
}

func registerStartBundle6x1FuncAndMakeStructWrapper[I0, I1, I2, I3, I4, I5, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller6x1[I0, I1, I2, I3, I4, I5, R0]{fn: fn.(func(I0, I1, I2, I3, I4, I5) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5) R0 {
			return fn.(startBundle6x1[I0, I1, I2, I3, I4, I5, R0]).StartBundle(a0, a1, a2, a3, a4, a5)
		})
	}
}

func registerStartBundle7x0FuncAndMakeStructWrapper[I0, I1, I2, I3, I4, I5, I6 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller7x0[I0, I1, I2, I3, I4, I5, I6]{fn: fn.(func(I0, I1, I2, I3, I4, I5, I6))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6) {
			fn.(startBundle7x0[I0, I1, I2, I3, I4, I5, I6]).StartBundle(a0, a1, a2, a3, a4, a5, a6)
		})
	}
}

func registerStartBundle7x1FuncAndMakeStructWrapper[I0, I1, I2, I3, I4, I5, I6, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller7x1[I0, I1, I2, I3, I4, I5, I6, R0]{fn: fn.(func(I0, I1, I2, I3, I4, I5, I6) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6) R0 {
			return fn.(startBundle7x1[I0, I1, I2, I3, I4, I5, I6, R0]).StartBundle(a0, a1, a2, a3, a4, a5, a6)
		})
	}
}

func buildStartBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9 any](doFn any) func(any) reflectx.Func {
	startBundleIn := -1
	startBundleOut := -1
	startBundleMethod := reflect.ValueOf(doFn).MethodByName("StartBundle")
	if !startBundleMethod.IsValid() {
		return nil
	}
	startBundleIn = startBundleMethod.Type().NumIn()
	startBundleOut = startBundleMethod.Type().NumOut()
	switch {

	case startBundleIn == 0:
		switch {
		case startBundleOut == 0:
			if _, ok := doFn.(startBundle0x0); ok {
				return registerStartBundle0x0FuncAndMakeStructWrapper()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		case startBundleOut == 1:
			if _, ok := doFn.(startBundle0x1[error]); ok {
				return registerStartBundle0x1FuncAndMakeStructWrapper[error]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		default:
			panic("Invalid signature for StartBundle")
		}

	case startBundleIn == 1:
		switch {
		case startBundleOut == 0:
			if _, ok := doFn.(startBundle1x0[I9]); ok {
				return registerStartBundle1x0FuncAndMakeStructWrapper[I9]()
			} else if _, ok := doFn.(startBundle1x0[context.Context]); ok {
				return registerStartBundle1x0FuncAndMakeStructWrapper[context.Context]()
			} else if _, ok := doFn.(startBundle1x0[typex.PaneInfo]); ok {
				return registerStartBundle1x0FuncAndMakeStructWrapper[typex.PaneInfo]()
			} else if _, ok := doFn.(startBundle1x0[[]typex.Window]); ok {
				return registerStartBundle1x0FuncAndMakeStructWrapper[[]typex.Window]()
			} else if _, ok := doFn.(startBundle1x0[typex.EventTime]); ok {
				return registerStartBundle1x0FuncAndMakeStructWrapper[typex.EventTime]()
			} else if _, ok := doFn.(startBundle1x0[typex.BundleFinalization]); ok {
				return registerStartBundle1x0FuncAndMakeStructWrapper[typex.BundleFinalization]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		case startBundleOut == 1:
			if _, ok := doFn.(startBundle1x1[I9, error]); ok {
				return registerStartBundle1x1FuncAndMakeStructWrapper[I9, error]()
			} else if _, ok := doFn.(startBundle1x1[context.Context, error]); ok {
				return registerStartBundle1x1FuncAndMakeStructWrapper[context.Context, error]()
			} else if _, ok := doFn.(startBundle1x1[typex.PaneInfo, error]); ok {
				return registerStartBundle1x1FuncAndMakeStructWrapper[typex.PaneInfo, error]()
			} else if _, ok := doFn.(startBundle1x1[[]typex.Window, error]); ok {
				return registerStartBundle1x1FuncAndMakeStructWrapper[[]typex.Window, error]()
			} else if _, ok := doFn.(startBundle1x1[typex.EventTime, error]); ok {
				return registerStartBundle1x1FuncAndMakeStructWrapper[typex.EventTime, error]()
			} else if _, ok := doFn.(startBundle1x1[typex.BundleFinalization, error]); ok {
				return registerStartBundle1x1FuncAndMakeStructWrapper[typex.BundleFinalization, error]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		default:
			panic("Invalid signature for StartBundle")
		}

	case startBundleIn == 2:
		switch {
		case startBundleOut == 0:
			if _, ok := doFn.(startBundle2x0[I8, I9]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[I8, I9]()
			} else if _, ok := doFn.(startBundle2x0[context.Context, I9]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[context.Context, I9]()
			} else if _, ok := doFn.(startBundle2x0[typex.PaneInfo, I9]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[typex.PaneInfo, I9]()
			} else if _, ok := doFn.(startBundle2x0[context.Context, typex.PaneInfo]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo]()
			} else if _, ok := doFn.(startBundle2x0[[]typex.Window, I9]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[[]typex.Window, I9]()
			} else if _, ok := doFn.(startBundle2x0[context.Context, []typex.Window]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[context.Context, []typex.Window]()
			} else if _, ok := doFn.(startBundle2x0[typex.PaneInfo, []typex.Window]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window]()
			} else if _, ok := doFn.(startBundle2x0[typex.EventTime, I9]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[typex.EventTime, I9]()
			} else if _, ok := doFn.(startBundle2x0[context.Context, typex.EventTime]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[context.Context, typex.EventTime]()
			} else if _, ok := doFn.(startBundle2x0[typex.PaneInfo, typex.EventTime]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime]()
			} else if _, ok := doFn.(startBundle2x0[[]typex.Window, typex.EventTime]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime]()
			} else if _, ok := doFn.(startBundle2x0[typex.BundleFinalization, I9]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle2x0[context.Context, typex.BundleFinalization]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization]()
			} else if _, ok := doFn.(startBundle2x0[typex.PaneInfo, typex.BundleFinalization]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization]()
			} else if _, ok := doFn.(startBundle2x0[[]typex.Window, typex.BundleFinalization]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization]()
			} else if _, ok := doFn.(startBundle2x0[typex.EventTime, typex.BundleFinalization]); ok {
				return registerStartBundle2x0FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		case startBundleOut == 1:
			if _, ok := doFn.(startBundle2x1[I8, I9, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[I8, I9, error]()
			} else if _, ok := doFn.(startBundle2x1[context.Context, I9, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[context.Context, I9, error]()
			} else if _, ok := doFn.(startBundle2x1[typex.PaneInfo, I9, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[typex.PaneInfo, I9, error]()
			} else if _, ok := doFn.(startBundle2x1[context.Context, typex.PaneInfo, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, error]()
			} else if _, ok := doFn.(startBundle2x1[[]typex.Window, I9, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[[]typex.Window, I9, error]()
			} else if _, ok := doFn.(startBundle2x1[context.Context, []typex.Window, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[context.Context, []typex.Window, error]()
			} else if _, ok := doFn.(startBundle2x1[typex.PaneInfo, []typex.Window, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, error]()
			} else if _, ok := doFn.(startBundle2x1[typex.EventTime, I9, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[typex.EventTime, I9, error]()
			} else if _, ok := doFn.(startBundle2x1[context.Context, typex.EventTime, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, error]()
			} else if _, ok := doFn.(startBundle2x1[typex.PaneInfo, typex.EventTime, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, error]()
			} else if _, ok := doFn.(startBundle2x1[[]typex.Window, typex.EventTime, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, error]()
			} else if _, ok := doFn.(startBundle2x1[typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle2x1[context.Context, typex.BundleFinalization, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(startBundle2x1[typex.PaneInfo, typex.BundleFinalization, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(startBundle2x1[[]typex.Window, typex.BundleFinalization, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(startBundle2x1[typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerStartBundle2x1FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, error]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		default:
			panic("Invalid signature for StartBundle")
		}

	case startBundleIn == 3:
		switch {
		case startBundleOut == 0:
			if _, ok := doFn.(startBundle3x0[I7, I8, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[I7, I8, I9]()
			} else if _, ok := doFn.(startBundle3x0[context.Context, I8, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[context.Context, I8, I9]()
			} else if _, ok := doFn.(startBundle3x0[typex.PaneInfo, I8, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, I8, I9]()
			} else if _, ok := doFn.(startBundle3x0[context.Context, typex.PaneInfo, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I9]()
			} else if _, ok := doFn.(startBundle3x0[[]typex.Window, I8, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[[]typex.Window, I8, I9]()
			} else if _, ok := doFn.(startBundle3x0[context.Context, []typex.Window, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[context.Context, []typex.Window, I9]()
			} else if _, ok := doFn.(startBundle3x0[typex.PaneInfo, []typex.Window, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I9]()
			} else if _, ok := doFn.(startBundle3x0[context.Context, typex.PaneInfo, []typex.Window]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window]()
			} else if _, ok := doFn.(startBundle3x0[typex.EventTime, I8, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(startBundle3x0[context.Context, typex.EventTime, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, I9]()
			} else if _, ok := doFn.(startBundle3x0[typex.PaneInfo, typex.EventTime, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I9]()
			} else if _, ok := doFn.(startBundle3x0[context.Context, typex.PaneInfo, typex.EventTime]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime]()
			} else if _, ok := doFn.(startBundle3x0[[]typex.Window, typex.EventTime, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I9]()
			} else if _, ok := doFn.(startBundle3x0[context.Context, []typex.Window, typex.EventTime]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime]()
			} else if _, ok := doFn.(startBundle3x0[typex.PaneInfo, []typex.Window, typex.EventTime]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime]()
			} else if _, ok := doFn.(startBundle3x0[typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle3x0[context.Context, typex.BundleFinalization, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle3x0[typex.PaneInfo, typex.BundleFinalization, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle3x0[context.Context, typex.PaneInfo, typex.BundleFinalization]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization]()
			} else if _, ok := doFn.(startBundle3x0[[]typex.Window, typex.BundleFinalization, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle3x0[context.Context, []typex.Window, typex.BundleFinalization]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization]()
			} else if _, ok := doFn.(startBundle3x0[typex.PaneInfo, []typex.Window, typex.BundleFinalization]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization]()
			} else if _, ok := doFn.(startBundle3x0[typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle3x0[context.Context, typex.EventTime, typex.BundleFinalization]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization]()
			} else if _, ok := doFn.(startBundle3x0[typex.PaneInfo, typex.EventTime, typex.BundleFinalization]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization]()
			} else if _, ok := doFn.(startBundle3x0[[]typex.Window, typex.EventTime, typex.BundleFinalization]); ok {
				return registerStartBundle3x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		case startBundleOut == 1:
			if _, ok := doFn.(startBundle3x1[I7, I8, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[context.Context, I8, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[context.Context, I8, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[typex.PaneInfo, I8, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, I8, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[context.Context, typex.PaneInfo, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[[]typex.Window, I8, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[[]typex.Window, I8, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[context.Context, []typex.Window, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[context.Context, []typex.Window, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[typex.PaneInfo, []typex.Window, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[context.Context, typex.PaneInfo, []typex.Window, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, error]()
			} else if _, ok := doFn.(startBundle3x1[typex.EventTime, I8, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[context.Context, typex.EventTime, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[typex.PaneInfo, typex.EventTime, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[context.Context, typex.PaneInfo, typex.EventTime, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, error]()
			} else if _, ok := doFn.(startBundle3x1[[]typex.Window, typex.EventTime, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[context.Context, []typex.Window, typex.EventTime, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, error]()
			} else if _, ok := doFn.(startBundle3x1[typex.PaneInfo, []typex.Window, typex.EventTime, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, error]()
			} else if _, ok := doFn.(startBundle3x1[typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[context.Context, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[typex.PaneInfo, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[context.Context, typex.PaneInfo, typex.BundleFinalization, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(startBundle3x1[[]typex.Window, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[context.Context, []typex.Window, typex.BundleFinalization, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(startBundle3x1[typex.PaneInfo, []typex.Window, typex.BundleFinalization, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(startBundle3x1[typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle3x1[context.Context, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(startBundle3x1[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(startBundle3x1[[]typex.Window, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerStartBundle3x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, error]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		default:
			panic("Invalid signature for StartBundle")
		}

	case startBundleIn == 4:
		switch {
		case startBundleOut == 0:
			if _, ok := doFn.(startBundle4x0[I6, I7, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, I7, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[typex.PaneInfo, I7, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, typex.PaneInfo, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[[]typex.Window, I7, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[[]typex.Window, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, []typex.Window, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, []typex.Window, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[typex.PaneInfo, []typex.Window, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, typex.PaneInfo, []typex.Window, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I9]()
			} else if _, ok := doFn.(startBundle4x0[typex.EventTime, I7, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, typex.EventTime, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[typex.PaneInfo, typex.EventTime, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, typex.PaneInfo, typex.EventTime, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I9]()
			} else if _, ok := doFn.(startBundle4x0[[]typex.Window, typex.EventTime, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, []typex.Window, typex.EventTime, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I9]()
			} else if _, ok := doFn.(startBundle4x0[typex.PaneInfo, []typex.Window, typex.EventTime, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime]()
			} else if _, ok := doFn.(startBundle4x0[typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[typex.PaneInfo, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, typex.PaneInfo, typex.BundleFinalization, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle4x0[[]typex.Window, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, []typex.Window, typex.BundleFinalization, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle4x0[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization]()
			} else if _, ok := doFn.(startBundle4x0[typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle4x0[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization]()
			} else if _, ok := doFn.(startBundle4x0[[]typex.Window, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle4x0[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization]()
			} else if _, ok := doFn.(startBundle4x0[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization]); ok {
				return registerStartBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		case startBundleOut == 1:
			if _, ok := doFn.(startBundle4x1[I6, I7, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, I7, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[typex.PaneInfo, I7, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, typex.PaneInfo, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[[]typex.Window, I7, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[[]typex.Window, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, []typex.Window, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, []typex.Window, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[typex.PaneInfo, []typex.Window, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, typex.PaneInfo, []typex.Window, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[typex.EventTime, I7, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, typex.EventTime, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[typex.PaneInfo, typex.EventTime, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, typex.PaneInfo, typex.EventTime, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[[]typex.Window, typex.EventTime, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, []typex.Window, typex.EventTime, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[typex.PaneInfo, []typex.Window, typex.EventTime, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, error]()
			} else if _, ok := doFn.(startBundle4x1[typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[typex.PaneInfo, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, typex.PaneInfo, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[[]typex.Window, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, []typex.Window, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(startBundle4x1[typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(startBundle4x1[[]typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle4x1[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(startBundle4x1[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerStartBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, error]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		default:
			panic("Invalid signature for StartBundle")
		}

	case startBundleIn == 5:
		switch {
		case startBundleOut == 0:
			if _, ok := doFn.(startBundle5x0[I5, I6, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, I6, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[typex.PaneInfo, I6, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, typex.PaneInfo, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[[]typex.Window, I6, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[[]typex.Window, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, []typex.Window, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, []typex.Window, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[typex.PaneInfo, []typex.Window, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, typex.PaneInfo, []typex.Window, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[typex.EventTime, I6, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, typex.EventTime, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[typex.PaneInfo, typex.EventTime, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, typex.PaneInfo, typex.EventTime, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[[]typex.Window, typex.EventTime, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, []typex.Window, typex.EventTime, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I9]()
			} else if _, ok := doFn.(startBundle5x0[typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[typex.PaneInfo, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, typex.PaneInfo, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[[]typex.Window, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, []typex.Window, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle5x0[typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle5x0[[]typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle5x0[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(startBundle5x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization]); ok {
				return registerStartBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		case startBundleOut == 1:
			if _, ok := doFn.(startBundle5x1[I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, I6, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[typex.PaneInfo, I6, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, typex.PaneInfo, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[[]typex.Window, I6, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[[]typex.Window, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, []typex.Window, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, []typex.Window, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[typex.PaneInfo, []typex.Window, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, typex.PaneInfo, []typex.Window, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, typex.EventTime, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[typex.PaneInfo, typex.EventTime, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, typex.PaneInfo, typex.EventTime, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[[]typex.Window, typex.EventTime, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, []typex.Window, typex.EventTime, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[typex.PaneInfo, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, typex.PaneInfo, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[[]typex.Window, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, []typex.Window, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[[]typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(startBundle5x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerStartBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, error]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		default:
			panic("Invalid signature for StartBundle")
		}

	case startBundleIn == 6:
		switch {
		case startBundleOut == 0:
			if _, ok := doFn.(startBundle6x0[I4, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[typex.PaneInfo, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, typex.PaneInfo, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[[]typex.Window, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[[]typex.Window, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, []typex.Window, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, []typex.Window, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[typex.PaneInfo, []typex.Window, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, typex.PaneInfo, []typex.Window, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[typex.EventTime, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[typex.EventTime, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, typex.EventTime, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[typex.PaneInfo, typex.EventTime, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, typex.PaneInfo, typex.EventTime, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[[]typex.Window, typex.EventTime, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, []typex.Window, typex.EventTime, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[typex.BundleFinalization, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[typex.BundleFinalization, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, typex.PaneInfo, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[[]typex.Window, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, []typex.Window, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[[]typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(startBundle6x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerStartBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		case startBundleOut == 1:
			if _, ok := doFn.(startBundle6x1[I4, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[typex.PaneInfo, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, typex.PaneInfo, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[[]typex.Window, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[[]typex.Window, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, []typex.Window, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, []typex.Window, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[typex.PaneInfo, []typex.Window, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, typex.PaneInfo, []typex.Window, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[typex.EventTime, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[typex.EventTime, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[typex.PaneInfo, typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, typex.PaneInfo, typex.EventTime, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[[]typex.Window, typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, []typex.Window, typex.EventTime, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[typex.BundleFinalization, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[typex.BundleFinalization, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, typex.PaneInfo, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[[]typex.Window, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, []typex.Window, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[[]typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(startBundle6x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerStartBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		default:
			panic("Invalid signature for StartBundle")
		}

	case startBundleIn == 7:
		switch {
		case startBundleOut == 0:
			if _, ok := doFn.(startBundle7x0[I3, I4, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[I3, I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, I4, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[typex.PaneInfo, I4, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, typex.PaneInfo, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[[]typex.Window, I4, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[[]typex.Window, I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, []typex.Window, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, []typex.Window, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[typex.PaneInfo, []typex.Window, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, typex.PaneInfo, []typex.Window, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[typex.EventTime, I4, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[typex.EventTime, I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, typex.EventTime, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[typex.PaneInfo, typex.EventTime, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, typex.PaneInfo, typex.EventTime, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[[]typex.Window, typex.EventTime, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, []typex.Window, typex.EventTime, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[typex.PaneInfo, []typex.Window, typex.EventTime, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[typex.BundleFinalization, I4, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[typex.BundleFinalization, I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, typex.BundleFinalization, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[typex.PaneInfo, typex.BundleFinalization, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[[]typex.Window, typex.BundleFinalization, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[typex.EventTime, typex.BundleFinalization, I5, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[[]typex.Window, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(startBundle7x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerStartBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		case startBundleOut == 1:
			if _, ok := doFn.(startBundle7x1[I3, I4, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[I3, I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, I4, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[typex.PaneInfo, I4, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, typex.PaneInfo, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[[]typex.Window, I4, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[[]typex.Window, I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, []typex.Window, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, []typex.Window, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[typex.PaneInfo, []typex.Window, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, typex.PaneInfo, []typex.Window, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[typex.EventTime, I4, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[typex.EventTime, I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, typex.EventTime, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[typex.PaneInfo, typex.EventTime, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, typex.PaneInfo, typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[[]typex.Window, typex.EventTime, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, []typex.Window, typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[typex.PaneInfo, []typex.Window, typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[typex.BundleFinalization, I4, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[typex.BundleFinalization, I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, typex.BundleFinalization, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[typex.PaneInfo, typex.BundleFinalization, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[[]typex.Window, typex.BundleFinalization, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[typex.EventTime, typex.BundleFinalization, I5, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[[]typex.Window, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(startBundle7x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerStartBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else {
				panic("Unable to infer the types of StartBundle")
			}
		default:
			panic("Invalid signature for StartBundle")
		}

	default:
		panic("Invalid signature for StartBundle")
	}
}

func registerFinishBundle0x0FuncAndMakeStructWrapper() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func())(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller0x0{fn: fn.(func())}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func() {
			fn.(finishBundle0x0).FinishBundle()
		})
	}
}

func registerFinishBundle0x1FuncAndMakeStructWrapper[R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func() R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller0x1[R0]{fn: fn.(func() R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func() R0 {
			return fn.(finishBundle0x1[R0]).FinishBundle()
		})
	}
}

func registerFinishBundle1x0FuncAndMakeStructWrapper[I0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller1x0[I0]{fn: fn.(func(I0))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0) {
			fn.(finishBundle1x0[I0]).FinishBundle(a0)
		})
	}
}

func registerFinishBundle1x1FuncAndMakeStructWrapper[I0, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller1x1[I0, R0]{fn: fn.(func(I0) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0) R0 {
			return fn.(finishBundle1x1[I0, R0]).FinishBundle(a0)
		})
	}
}

func registerFinishBundle2x0FuncAndMakeStructWrapper[I0, I1 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller2x0[I0, I1]{fn: fn.(func(I0, I1))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1) {
			fn.(finishBundle2x0[I0, I1]).FinishBundle(a0, a1)
		})
	}
}

func registerFinishBundle2x1FuncAndMakeStructWrapper[I0, I1, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller2x1[I0, I1, R0]{fn: fn.(func(I0, I1) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1) R0 {
			return fn.(finishBundle2x1[I0, I1, R0]).FinishBundle(a0, a1)
		})
	}
}

func registerFinishBundle3x0FuncAndMakeStructWrapper[I0, I1, I2 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller3x0[I0, I1, I2]{fn: fn.(func(I0, I1, I2))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2) {
			fn.(finishBundle3x0[I0, I1, I2]).FinishBundle(a0, a1, a2)
		})
	}
}

func registerFinishBundle3x1FuncAndMakeStructWrapper[I0, I1, I2, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller3x1[I0, I1, I2, R0]{fn: fn.(func(I0, I1, I2) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2) R0 {
			return fn.(finishBundle3x1[I0, I1, I2, R0]).FinishBundle(a0, a1, a2)
		})
	}
}

func registerFinishBundle4x0FuncAndMakeStructWrapper[I0, I1, I2, I3 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller4x0[I0, I1, I2, I3]{fn: fn.(func(I0, I1, I2, I3))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3) {
			fn.(finishBundle4x0[I0, I1, I2, I3]).FinishBundle(a0, a1, a2, a3)
		})
	}
}

func registerFinishBundle4x1FuncAndMakeStructWrapper[I0, I1, I2, I3, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller4x1[I0, I1, I2, I3, R0]{fn: fn.(func(I0, I1, I2, I3) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3) R0 {
			return fn.(finishBundle4x1[I0, I1, I2, I3, R0]).FinishBundle(a0, a1, a2, a3)
		})
	}
}

func registerFinishBundle5x0FuncAndMakeStructWrapper[I0, I1, I2, I3, I4 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller5x0[I0, I1, I2, I3, I4]{fn: fn.(func(I0, I1, I2, I3, I4))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4) {
			fn.(finishBundle5x0[I0, I1, I2, I3, I4]).FinishBundle(a0, a1, a2, a3, a4)
		})
	}
}

func registerFinishBundle5x1FuncAndMakeStructWrapper[I0, I1, I2, I3, I4, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller5x1[I0, I1, I2, I3, I4, R0]{fn: fn.(func(I0, I1, I2, I3, I4) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4) R0 {
			return fn.(finishBundle5x1[I0, I1, I2, I3, I4, R0]).FinishBundle(a0, a1, a2, a3, a4)
		})
	}
}

func registerFinishBundle6x0FuncAndMakeStructWrapper[I0, I1, I2, I3, I4, I5 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller6x0[I0, I1, I2, I3, I4, I5]{fn: fn.(func(I0, I1, I2, I3, I4, I5))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5) {
			fn.(finishBundle6x0[I0, I1, I2, I3, I4, I5]).FinishBundle(a0, a1, a2, a3, a4, a5)
		})
	}
}

func registerFinishBundle6x1FuncAndMakeStructWrapper[I0, I1, I2, I3, I4, I5, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller6x1[I0, I1, I2, I3, I4, I5, R0]{fn: fn.(func(I0, I1, I2, I3, I4, I5) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5) R0 {
			return fn.(finishBundle6x1[I0, I1, I2, I3, I4, I5, R0]).FinishBundle(a0, a1, a2, a3, a4, a5)
		})
	}
}

func registerFinishBundle7x0FuncAndMakeStructWrapper[I0, I1, I2, I3, I4, I5, I6 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6))(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller7x0[I0, I1, I2, I3, I4, I5, I6]{fn: fn.(func(I0, I1, I2, I3, I4, I5, I6))}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6) {
			fn.(finishBundle7x0[I0, I1, I2, I3, I4, I5, I6]).FinishBundle(a0, a1, a2, a3, a4, a5, a6)
		})
	}
}

func registerFinishBundle7x1FuncAndMakeStructWrapper[I0, I1, I2, I3, I4, I5, I6, R0 any]() func(any) reflectx.Func {
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6) R0)(nil)).Elem(), func(fn any) reflectx.Func {
		return &caller7x1[I0, I1, I2, I3, I4, I5, I6, R0]{fn: fn.(func(I0, I1, I2, I3, I4, I5, I6) R0)}
	})

	return func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6) R0 {
			return fn.(finishBundle7x1[I0, I1, I2, I3, I4, I5, I6, R0]).FinishBundle(a0, a1, a2, a3, a4, a5, a6)
		})
	}
}

func buildFinishBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9 any](doFn any) func(any) reflectx.Func {
	finishBundleIn := -1
	finishBundleOut := -1
	finishBundleMethod := reflect.ValueOf(doFn).MethodByName("FinishBundle")
	if !finishBundleMethod.IsValid() {
		return nil
	}
	finishBundleIn = finishBundleMethod.Type().NumIn()
	finishBundleOut = finishBundleMethod.Type().NumOut()
	switch {

	case finishBundleIn == 0:
		switch {
		case finishBundleOut == 0:
			if _, ok := doFn.(finishBundle0x0); ok {
				return registerFinishBundle0x0FuncAndMakeStructWrapper()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		case finishBundleOut == 1:
			if _, ok := doFn.(finishBundle0x1[error]); ok {
				return registerFinishBundle0x1FuncAndMakeStructWrapper[error]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		default:
			panic("Invalid signature for FinishBundle")
		}

	case finishBundleIn == 1:
		switch {
		case finishBundleOut == 0:
			if _, ok := doFn.(finishBundle1x0[I9]); ok {
				return registerFinishBundle1x0FuncAndMakeStructWrapper[I9]()
			} else if _, ok := doFn.(finishBundle1x0[context.Context]); ok {
				return registerFinishBundle1x0FuncAndMakeStructWrapper[context.Context]()
			} else if _, ok := doFn.(finishBundle1x0[typex.PaneInfo]); ok {
				return registerFinishBundle1x0FuncAndMakeStructWrapper[typex.PaneInfo]()
			} else if _, ok := doFn.(finishBundle1x0[[]typex.Window]); ok {
				return registerFinishBundle1x0FuncAndMakeStructWrapper[[]typex.Window]()
			} else if _, ok := doFn.(finishBundle1x0[typex.EventTime]); ok {
				return registerFinishBundle1x0FuncAndMakeStructWrapper[typex.EventTime]()
			} else if _, ok := doFn.(finishBundle1x0[typex.BundleFinalization]); ok {
				return registerFinishBundle1x0FuncAndMakeStructWrapper[typex.BundleFinalization]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		case finishBundleOut == 1:
			if _, ok := doFn.(finishBundle1x1[I9, error]); ok {
				return registerFinishBundle1x1FuncAndMakeStructWrapper[I9, error]()
			} else if _, ok := doFn.(finishBundle1x1[context.Context, error]); ok {
				return registerFinishBundle1x1FuncAndMakeStructWrapper[context.Context, error]()
			} else if _, ok := doFn.(finishBundle1x1[typex.PaneInfo, error]); ok {
				return registerFinishBundle1x1FuncAndMakeStructWrapper[typex.PaneInfo, error]()
			} else if _, ok := doFn.(finishBundle1x1[[]typex.Window, error]); ok {
				return registerFinishBundle1x1FuncAndMakeStructWrapper[[]typex.Window, error]()
			} else if _, ok := doFn.(finishBundle1x1[typex.EventTime, error]); ok {
				return registerFinishBundle1x1FuncAndMakeStructWrapper[typex.EventTime, error]()
			} else if _, ok := doFn.(finishBundle1x1[typex.BundleFinalization, error]); ok {
				return registerFinishBundle1x1FuncAndMakeStructWrapper[typex.BundleFinalization, error]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		default:
			panic("Invalid signature for FinishBundle")
		}

	case finishBundleIn == 2:
		switch {
		case finishBundleOut == 0:
			if _, ok := doFn.(finishBundle2x0[I8, I9]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[I8, I9]()
			} else if _, ok := doFn.(finishBundle2x0[context.Context, I9]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[context.Context, I9]()
			} else if _, ok := doFn.(finishBundle2x0[typex.PaneInfo, I9]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[typex.PaneInfo, I9]()
			} else if _, ok := doFn.(finishBundle2x0[context.Context, typex.PaneInfo]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo]()
			} else if _, ok := doFn.(finishBundle2x0[[]typex.Window, I9]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[[]typex.Window, I9]()
			} else if _, ok := doFn.(finishBundle2x0[context.Context, []typex.Window]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[context.Context, []typex.Window]()
			} else if _, ok := doFn.(finishBundle2x0[typex.PaneInfo, []typex.Window]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window]()
			} else if _, ok := doFn.(finishBundle2x0[typex.EventTime, I9]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[typex.EventTime, I9]()
			} else if _, ok := doFn.(finishBundle2x0[context.Context, typex.EventTime]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[context.Context, typex.EventTime]()
			} else if _, ok := doFn.(finishBundle2x0[typex.PaneInfo, typex.EventTime]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime]()
			} else if _, ok := doFn.(finishBundle2x0[[]typex.Window, typex.EventTime]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime]()
			} else if _, ok := doFn.(finishBundle2x0[typex.BundleFinalization, I9]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle2x0[context.Context, typex.BundleFinalization]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization]()
			} else if _, ok := doFn.(finishBundle2x0[typex.PaneInfo, typex.BundleFinalization]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization]()
			} else if _, ok := doFn.(finishBundle2x0[[]typex.Window, typex.BundleFinalization]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization]()
			} else if _, ok := doFn.(finishBundle2x0[typex.EventTime, typex.BundleFinalization]); ok {
				return registerFinishBundle2x0FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		case finishBundleOut == 1:
			if _, ok := doFn.(finishBundle2x1[I8, I9, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[I8, I9, error]()
			} else if _, ok := doFn.(finishBundle2x1[context.Context, I9, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[context.Context, I9, error]()
			} else if _, ok := doFn.(finishBundle2x1[typex.PaneInfo, I9, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[typex.PaneInfo, I9, error]()
			} else if _, ok := doFn.(finishBundle2x1[context.Context, typex.PaneInfo, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, error]()
			} else if _, ok := doFn.(finishBundle2x1[[]typex.Window, I9, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[[]typex.Window, I9, error]()
			} else if _, ok := doFn.(finishBundle2x1[context.Context, []typex.Window, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[context.Context, []typex.Window, error]()
			} else if _, ok := doFn.(finishBundle2x1[typex.PaneInfo, []typex.Window, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, error]()
			} else if _, ok := doFn.(finishBundle2x1[typex.EventTime, I9, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[typex.EventTime, I9, error]()
			} else if _, ok := doFn.(finishBundle2x1[context.Context, typex.EventTime, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, error]()
			} else if _, ok := doFn.(finishBundle2x1[typex.PaneInfo, typex.EventTime, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, error]()
			} else if _, ok := doFn.(finishBundle2x1[[]typex.Window, typex.EventTime, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, error]()
			} else if _, ok := doFn.(finishBundle2x1[typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle2x1[context.Context, typex.BundleFinalization, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(finishBundle2x1[typex.PaneInfo, typex.BundleFinalization, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(finishBundle2x1[[]typex.Window, typex.BundleFinalization, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(finishBundle2x1[typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerFinishBundle2x1FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, error]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		default:
			panic("Invalid signature for FinishBundle")
		}

	case finishBundleIn == 3:
		switch {
		case finishBundleOut == 0:
			if _, ok := doFn.(finishBundle3x0[I7, I8, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle3x0[context.Context, I8, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[context.Context, I8, I9]()
			} else if _, ok := doFn.(finishBundle3x0[typex.PaneInfo, I8, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, I8, I9]()
			} else if _, ok := doFn.(finishBundle3x0[context.Context, typex.PaneInfo, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I9]()
			} else if _, ok := doFn.(finishBundle3x0[[]typex.Window, I8, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[[]typex.Window, I8, I9]()
			} else if _, ok := doFn.(finishBundle3x0[context.Context, []typex.Window, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[context.Context, []typex.Window, I9]()
			} else if _, ok := doFn.(finishBundle3x0[typex.PaneInfo, []typex.Window, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I9]()
			} else if _, ok := doFn.(finishBundle3x0[context.Context, typex.PaneInfo, []typex.Window]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window]()
			} else if _, ok := doFn.(finishBundle3x0[typex.EventTime, I8, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(finishBundle3x0[context.Context, typex.EventTime, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, I9]()
			} else if _, ok := doFn.(finishBundle3x0[typex.PaneInfo, typex.EventTime, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I9]()
			} else if _, ok := doFn.(finishBundle3x0[context.Context, typex.PaneInfo, typex.EventTime]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime]()
			} else if _, ok := doFn.(finishBundle3x0[[]typex.Window, typex.EventTime, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I9]()
			} else if _, ok := doFn.(finishBundle3x0[context.Context, []typex.Window, typex.EventTime]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime]()
			} else if _, ok := doFn.(finishBundle3x0[typex.PaneInfo, []typex.Window, typex.EventTime]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime]()
			} else if _, ok := doFn.(finishBundle3x0[typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle3x0[context.Context, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle3x0[typex.PaneInfo, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle3x0[context.Context, typex.PaneInfo, typex.BundleFinalization]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization]()
			} else if _, ok := doFn.(finishBundle3x0[[]typex.Window, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle3x0[context.Context, []typex.Window, typex.BundleFinalization]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization]()
			} else if _, ok := doFn.(finishBundle3x0[typex.PaneInfo, []typex.Window, typex.BundleFinalization]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization]()
			} else if _, ok := doFn.(finishBundle3x0[typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle3x0[context.Context, typex.EventTime, typex.BundleFinalization]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization]()
			} else if _, ok := doFn.(finishBundle3x0[typex.PaneInfo, typex.EventTime, typex.BundleFinalization]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization]()
			} else if _, ok := doFn.(finishBundle3x0[[]typex.Window, typex.EventTime, typex.BundleFinalization]); ok {
				return registerFinishBundle3x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		case finishBundleOut == 1:
			if _, ok := doFn.(finishBundle3x1[I7, I8, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[context.Context, I8, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[context.Context, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[typex.PaneInfo, I8, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[context.Context, typex.PaneInfo, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[[]typex.Window, I8, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[[]typex.Window, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[context.Context, []typex.Window, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[context.Context, []typex.Window, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[typex.PaneInfo, []typex.Window, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[context.Context, typex.PaneInfo, []typex.Window, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, error]()
			} else if _, ok := doFn.(finishBundle3x1[typex.EventTime, I8, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[context.Context, typex.EventTime, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[typex.PaneInfo, typex.EventTime, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[context.Context, typex.PaneInfo, typex.EventTime, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, error]()
			} else if _, ok := doFn.(finishBundle3x1[[]typex.Window, typex.EventTime, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[context.Context, []typex.Window, typex.EventTime, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, error]()
			} else if _, ok := doFn.(finishBundle3x1[typex.PaneInfo, []typex.Window, typex.EventTime, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, error]()
			} else if _, ok := doFn.(finishBundle3x1[typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[context.Context, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[typex.PaneInfo, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[context.Context, typex.PaneInfo, typex.BundleFinalization, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(finishBundle3x1[[]typex.Window, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[context.Context, []typex.Window, typex.BundleFinalization, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(finishBundle3x1[typex.PaneInfo, []typex.Window, typex.BundleFinalization, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(finishBundle3x1[typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle3x1[context.Context, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(finishBundle3x1[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(finishBundle3x1[[]typex.Window, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerFinishBundle3x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, error]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		default:
			panic("Invalid signature for FinishBundle")
		}

	case finishBundleIn == 4:
		switch {
		case finishBundleOut == 0:
			if _, ok := doFn.(finishBundle4x0[I6, I7, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, I7, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[typex.PaneInfo, I7, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, typex.PaneInfo, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[[]typex.Window, I7, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[[]typex.Window, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, []typex.Window, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, []typex.Window, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[typex.PaneInfo, []typex.Window, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, typex.PaneInfo, []typex.Window, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I9]()
			} else if _, ok := doFn.(finishBundle4x0[typex.EventTime, I7, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, typex.EventTime, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[typex.PaneInfo, typex.EventTime, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, typex.PaneInfo, typex.EventTime, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I9]()
			} else if _, ok := doFn.(finishBundle4x0[[]typex.Window, typex.EventTime, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, []typex.Window, typex.EventTime, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I9]()
			} else if _, ok := doFn.(finishBundle4x0[typex.PaneInfo, []typex.Window, typex.EventTime, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime]()
			} else if _, ok := doFn.(finishBundle4x0[typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[typex.PaneInfo, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, typex.PaneInfo, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle4x0[[]typex.Window, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, []typex.Window, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle4x0[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization]()
			} else if _, ok := doFn.(finishBundle4x0[typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle4x0[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization]()
			} else if _, ok := doFn.(finishBundle4x0[[]typex.Window, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle4x0[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization]()
			} else if _, ok := doFn.(finishBundle4x0[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization]); ok {
				return registerFinishBundle4x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		case finishBundleOut == 1:
			if _, ok := doFn.(finishBundle4x1[I6, I7, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, I7, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[typex.PaneInfo, I7, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, typex.PaneInfo, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[[]typex.Window, I7, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[[]typex.Window, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, []typex.Window, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, []typex.Window, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[typex.PaneInfo, []typex.Window, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, typex.PaneInfo, []typex.Window, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[typex.EventTime, I7, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, typex.EventTime, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[typex.PaneInfo, typex.EventTime, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, typex.PaneInfo, typex.EventTime, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[[]typex.Window, typex.EventTime, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, []typex.Window, typex.EventTime, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[typex.PaneInfo, []typex.Window, typex.EventTime, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, error]()
			} else if _, ok := doFn.(finishBundle4x1[typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[typex.PaneInfo, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, typex.PaneInfo, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[[]typex.Window, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, []typex.Window, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(finishBundle4x1[typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(finishBundle4x1[[]typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle4x1[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, error]()
			} else if _, ok := doFn.(finishBundle4x1[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerFinishBundle4x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, error]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		default:
			panic("Invalid signature for FinishBundle")
		}

	case finishBundleIn == 5:
		switch {
		case finishBundleOut == 0:
			if _, ok := doFn.(finishBundle5x0[I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, I6, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[typex.PaneInfo, I6, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, typex.PaneInfo, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[[]typex.Window, I6, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[[]typex.Window, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, []typex.Window, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, []typex.Window, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[typex.PaneInfo, []typex.Window, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, typex.PaneInfo, []typex.Window, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[typex.EventTime, I6, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, typex.EventTime, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[typex.PaneInfo, typex.EventTime, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, typex.PaneInfo, typex.EventTime, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[[]typex.Window, typex.EventTime, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, []typex.Window, typex.EventTime, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I9]()
			} else if _, ok := doFn.(finishBundle5x0[typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[typex.PaneInfo, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, typex.PaneInfo, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[[]typex.Window, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, []typex.Window, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle5x0[typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle5x0[[]typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle5x0[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9]()
			} else if _, ok := doFn.(finishBundle5x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization]); ok {
				return registerFinishBundle5x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		case finishBundleOut == 1:
			if _, ok := doFn.(finishBundle5x1[I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[typex.PaneInfo, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, typex.PaneInfo, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[[]typex.Window, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[[]typex.Window, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, []typex.Window, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, []typex.Window, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[typex.PaneInfo, []typex.Window, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, typex.PaneInfo, []typex.Window, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, typex.EventTime, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[typex.PaneInfo, typex.EventTime, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, typex.PaneInfo, typex.EventTime, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[[]typex.Window, typex.EventTime, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, []typex.Window, typex.EventTime, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[typex.PaneInfo, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, typex.PaneInfo, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[[]typex.Window, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, []typex.Window, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[[]typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else if _, ok := doFn.(finishBundle5x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, error]); ok {
				return registerFinishBundle5x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, error]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		default:
			panic("Invalid signature for FinishBundle")
		}

	case finishBundleIn == 6:
		switch {
		case finishBundleOut == 0:
			if _, ok := doFn.(finishBundle6x0[I4, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[typex.PaneInfo, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, typex.PaneInfo, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[[]typex.Window, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[[]typex.Window, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, []typex.Window, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, []typex.Window, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[typex.PaneInfo, []typex.Window, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, typex.PaneInfo, []typex.Window, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[typex.EventTime, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[typex.EventTime, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, typex.EventTime, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[typex.PaneInfo, typex.EventTime, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, typex.PaneInfo, typex.EventTime, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[[]typex.Window, typex.EventTime, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, []typex.Window, typex.EventTime, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[typex.BundleFinalization, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[typex.BundleFinalization, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, typex.PaneInfo, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[[]typex.Window, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, []typex.Window, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[[]typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else if _, ok := doFn.(finishBundle6x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9]); ok {
				return registerFinishBundle6x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		case finishBundleOut == 1:
			if _, ok := doFn.(finishBundle6x1[I4, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[typex.PaneInfo, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, typex.PaneInfo, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[[]typex.Window, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[[]typex.Window, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, []typex.Window, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, []typex.Window, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[typex.PaneInfo, []typex.Window, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, typex.PaneInfo, []typex.Window, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[typex.EventTime, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[typex.EventTime, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[typex.PaneInfo, typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, typex.PaneInfo, typex.EventTime, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[[]typex.Window, typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, []typex.Window, typex.EventTime, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[typex.BundleFinalization, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[typex.BundleFinalization, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, typex.PaneInfo, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[[]typex.Window, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, []typex.Window, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[[]typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle6x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]); ok {
				return registerFinishBundle6x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I9, error]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		default:
			panic("Invalid signature for FinishBundle")
		}

	case finishBundleIn == 7:
		switch {
		case finishBundleOut == 0:
			if _, ok := doFn.(finishBundle7x0[I3, I4, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[I3, I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, I4, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[typex.PaneInfo, I4, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, typex.PaneInfo, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[[]typex.Window, I4, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[[]typex.Window, I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, []typex.Window, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, []typex.Window, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[typex.PaneInfo, []typex.Window, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, typex.PaneInfo, []typex.Window, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[typex.EventTime, I4, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[typex.EventTime, I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, typex.EventTime, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[typex.PaneInfo, typex.EventTime, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, typex.PaneInfo, typex.EventTime, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[[]typex.Window, typex.EventTime, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, []typex.Window, typex.EventTime, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[typex.PaneInfo, []typex.Window, typex.EventTime, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[typex.BundleFinalization, I4, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[typex.BundleFinalization, I4, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, typex.BundleFinalization, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[typex.PaneInfo, typex.BundleFinalization, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[[]typex.Window, typex.BundleFinalization, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[typex.EventTime, typex.BundleFinalization, I5, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I5, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[[]typex.Window, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9]()
			} else if _, ok := doFn.(finishBundle7x0[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]); ok {
				return registerFinishBundle7x0FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		case finishBundleOut == 1:
			if _, ok := doFn.(finishBundle7x1[I3, I4, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[I3, I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, I4, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[typex.PaneInfo, I4, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, typex.PaneInfo, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[[]typex.Window, I4, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[[]typex.Window, I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, []typex.Window, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, []typex.Window, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[typex.PaneInfo, []typex.Window, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, typex.PaneInfo, []typex.Window, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[typex.EventTime, I4, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[typex.EventTime, I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, typex.EventTime, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[typex.PaneInfo, typex.EventTime, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, typex.PaneInfo, typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[[]typex.Window, typex.EventTime, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, []typex.Window, typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[typex.PaneInfo, []typex.Window, typex.EventTime, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[typex.BundleFinalization, I4, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[typex.BundleFinalization, I4, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, typex.BundleFinalization, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, typex.BundleFinalization, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[typex.PaneInfo, typex.BundleFinalization, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.BundleFinalization, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[[]typex.Window, typex.BundleFinalization, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[[]typex.Window, typex.BundleFinalization, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[typex.EventTime, typex.BundleFinalization, I5, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[typex.EventTime, typex.BundleFinalization, I5, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[[]typex.Window, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[[]typex.Window, typex.EventTime, typex.BundleFinalization, I6, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I7, I8, I9, error]()
			} else if _, ok := doFn.(finishBundle7x1[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]); ok {
				return registerFinishBundle7x1FuncAndMakeStructWrapper[context.Context, typex.PaneInfo, []typex.Window, typex.EventTime, typex.BundleFinalization, I8, I9, error]()
			} else {
				panic("Unable to infer the types of FinishBundle")
			}
		default:
			panic("Invalid signature for FinishBundle")
		}

	default:
		panic("Invalid signature for FinishBundle")
	}
}

func buildSetupWrapper(doFn any) func(any) reflectx.Func {
	if _, ok := doFn.(setup0x0); ok {
		setupCaller := func(fn any) reflectx.Func {
			f := fn.(func())
			return &caller0x0{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func())(nil)).Elem(), setupCaller)

		return func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func() {
				fn.(setup0x0).Setup()
			})
		}
	} else if _, ok := doFn.(setup1x0); ok {
		setupCaller := func(fn any) reflectx.Func {
			f := fn.(func(context.Context))
			return &caller1x0[context.Context]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(context.Context))(nil)).Elem(), setupCaller)

		return func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 context.Context) {
				fn.(setup1x0).Setup(a0)
			})
		}
	} else if _, ok := doFn.(setup0x1); ok {
		setupCaller := func(fn any) reflectx.Func {
			f := fn.(func() error)
			return &caller0x1[error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func() error)(nil)).Elem(), setupCaller)

		return func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func() error {
				return fn.(setup0x1).Setup()
			})
		}
	} else if _, ok := doFn.(setup1x1); ok {
		setupCaller := func(fn any) reflectx.Func {
			f := fn.(func(context.Context) error)
			return &caller1x1[context.Context, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(context.Context) error)(nil)).Elem(), setupCaller)

		return func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 context.Context) error {
				return fn.(setup1x1).Setup(a0)
			})
		}
	}

	return nil
}

func buildTeardownWrapper(doFn any) func(any) reflectx.Func {
	if _, ok := doFn.(teardown0x0); ok {
		teardownCaller := func(fn any) reflectx.Func {
			f := fn.(func())
			return &caller0x0{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func())(nil)).Elem(), teardownCaller)

		return func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func() {
				fn.(teardown0x0).Teardown()
			})
		}
	} else if _, ok := doFn.(teardown1x0); ok {
		teardownCaller := func(fn any) reflectx.Func {
			f := fn.(func(context.Context))
			return &caller1x0[context.Context]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(context.Context))(nil)).Elem(), teardownCaller)

		return func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 context.Context) {
				fn.(teardown1x0).Teardown(a0)
			})
		}
	} else if _, ok := doFn.(teardown0x1); ok {
		teardownCaller := func(fn any) reflectx.Func {
			f := fn.(func() error)
			return &caller0x1[error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func() error)(nil)).Elem(), teardownCaller)

		return func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func() error {
				return fn.(teardown0x1).Teardown()
			})
		}
	} else if _, ok := doFn.(teardown1x1); ok {
		teardownCaller := func(fn any) reflectx.Func {
			f := fn.(func(context.Context) error)
			return &caller1x1[context.Context, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(context.Context) error)(nil)).Elem(), teardownCaller)

		return func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 context.Context) error {
				return fn.(teardown1x1).Teardown(a0)
			})
		}
	}

	return nil
}

type genericDoFn0x0 interface {
	ProcessElement()
}

type caller0x0 struct {
	fn func()
}

func (c *caller0x0) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller0x0) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller0x0) Call(args []any) []any {
	c.fn()
	return []any{}
}

func (c *caller0x0) Call0x0() {
	c.fn()
}

func registerDoFn0x0StructWrappersAndFuncs(doFn genericDoFn0x0) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func())
		return &caller0x0{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func())(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func() {
			fn.(genericDoFn0x0).ProcessElement()
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, int, int](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, int, int](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn0x0 registers your structural DoFn to optimize execution at runtime.
func DoFn0x0(doFn genericDoFn0x0) {
	registerDoFnTypes(doFn)
	registerDoFn0x0StructWrappersAndFuncs(doFn)
}

// Function0x0 registers your functional DoFn to optimize execution at runtime.
func Function0x0(doFn func()) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func())
		return &caller0x0{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func())(nil)).Elem(), caller)
}

type genericDoFn1x0[I0 any] interface {
	ProcessElement(i0 I0)
}

type caller1x0[I0 any] struct {
	fn func(I0)
}

func (c *caller1x0[I0]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller1x0[I0]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller1x0[I0]) Call(args []any) []any {
	c.fn(args[0].(I0))
	return []any{}
}

func (c *caller1x0[I0]) Call1x0(arg0 any) {
	c.fn(arg0.(I0))
}

func registerDoFn1x0StructWrappersAndFuncs[I0 any](doFn genericDoFn1x0[I0]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0))
		return &caller1x0[I0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0) {
			fn.(genericDoFn1x0[I0]).ProcessElement(a0)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, int, I0](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, int, I0](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn1x0[I0 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn1x0[I0 any](doFn genericDoFn1x0[I0]) {
	registerDoFnTypes(doFn)
	registerDoFn1x0StructWrappersAndFuncs[I0](doFn)
}

// Function1x0[I0 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function1x0[I0 any](doFn func(I0)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0))
		return &caller1x0[I0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0))(nil)).Elem(), caller)
}

type genericDoFn2x0[I0, I1 any] interface {
	ProcessElement(i0 I0, i1 I1)
}

type caller2x0[I0, I1 any] struct {
	fn func(I0, I1)
}

func (c *caller2x0[I0, I1]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller2x0[I0, I1]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller2x0[I0, I1]) Call(args []any) []any {
	c.fn(args[0].(I0), args[1].(I1))
	return []any{}
}

func (c *caller2x0[I0, I1]) Call2x0(arg0 any, arg1 any) {
	c.fn(arg0.(I0), arg1.(I1))
}

func registerDoFn2x0StructWrappersAndFuncs[I0, I1 any](doFn genericDoFn2x0[I0, I1]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1))
		return &caller2x0[I0, I1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1) {
			fn.(genericDoFn2x0[I0, I1]).ProcessElement(a0, a1)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, I0, I1](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, I0, I1](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn2x0[I0, I1 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn2x0[I0, I1 any](doFn genericDoFn2x0[I0, I1]) {
	registerDoFnTypes(doFn)
	registerDoFn2x0StructWrappersAndFuncs[I0, I1](doFn)
}

// Function2x0[I0, I1 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function2x0[I0, I1 any](doFn func(I0, I1)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1))
		return &caller2x0[I0, I1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1))(nil)).Elem(), caller)
}

type genericDoFn3x0[I0, I1, I2 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2)
}

type caller3x0[I0, I1, I2 any] struct {
	fn func(I0, I1, I2)
}

func (c *caller3x0[I0, I1, I2]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller3x0[I0, I1, I2]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller3x0[I0, I1, I2]) Call(args []any) []any {
	c.fn(args[0].(I0), args[1].(I1), args[2].(I2))
	return []any{}
}

func (c *caller3x0[I0, I1, I2]) Call3x0(arg0 any, arg1 any, arg2 any) {
	c.fn(arg0.(I0), arg1.(I1), arg2.(I2))
}

func registerDoFn3x0StructWrappersAndFuncs[I0, I1, I2 any](doFn genericDoFn3x0[I0, I1, I2]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2))
		return &caller3x0[I0, I1, I2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2) {
			fn.(genericDoFn3x0[I0, I1, I2]).ProcessElement(a0, a1, a2)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, I0, I1, I2](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, I0, I1, I2](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn3x0[I0, I1, I2 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn3x0[I0, I1, I2 any](doFn genericDoFn3x0[I0, I1, I2]) {
	registerDoFnTypes(doFn)
	registerDoFn3x0StructWrappersAndFuncs[I0, I1, I2](doFn)
}

// Function3x0[I0, I1, I2 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function3x0[I0, I1, I2 any](doFn func(I0, I1, I2)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2))
		return &caller3x0[I0, I1, I2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2))(nil)).Elem(), caller)
}

type genericDoFn4x0[I0, I1, I2, I3 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3)
}

type caller4x0[I0, I1, I2, I3 any] struct {
	fn func(I0, I1, I2, I3)
}

func (c *caller4x0[I0, I1, I2, I3]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller4x0[I0, I1, I2, I3]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller4x0[I0, I1, I2, I3]) Call(args []any) []any {
	c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3))
	return []any{}
}

func (c *caller4x0[I0, I1, I2, I3]) Call4x0(arg0 any, arg1 any, arg2 any, arg3 any) {
	c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3))
}

func registerDoFn4x0StructWrappersAndFuncs[I0, I1, I2, I3 any](doFn genericDoFn4x0[I0, I1, I2, I3]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3))
		return &caller4x0[I0, I1, I2, I3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3) {
			fn.(genericDoFn4x0[I0, I1, I2, I3]).ProcessElement(a0, a1, a2, a3)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, I0, I1, I2, I3](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, I0, I1, I2, I3](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn4x0[I0, I1, I2, I3 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn4x0[I0, I1, I2, I3 any](doFn genericDoFn4x0[I0, I1, I2, I3]) {
	registerDoFnTypes(doFn)
	registerDoFn4x0StructWrappersAndFuncs[I0, I1, I2, I3](doFn)
}

// Function4x0[I0, I1, I2, I3 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function4x0[I0, I1, I2, I3 any](doFn func(I0, I1, I2, I3)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3))
		return &caller4x0[I0, I1, I2, I3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3))(nil)).Elem(), caller)
}

type genericDoFn5x0[I0, I1, I2, I3, I4 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4)
}

type caller5x0[I0, I1, I2, I3, I4 any] struct {
	fn func(I0, I1, I2, I3, I4)
}

func (c *caller5x0[I0, I1, I2, I3, I4]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller5x0[I0, I1, I2, I3, I4]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller5x0[I0, I1, I2, I3, I4]) Call(args []any) []any {
	c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4))
	return []any{}
}

func (c *caller5x0[I0, I1, I2, I3, I4]) Call5x0(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any) {
	c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4))
}

func registerDoFn5x0StructWrappersAndFuncs[I0, I1, I2, I3, I4 any](doFn genericDoFn5x0[I0, I1, I2, I3, I4]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4))
		return &caller5x0[I0, I1, I2, I3, I4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4) {
			fn.(genericDoFn5x0[I0, I1, I2, I3, I4]).ProcessElement(a0, a1, a2, a3, a4)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, I0, I1, I2, I3, I4](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, I0, I1, I2, I3, I4](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn5x0[I0, I1, I2, I3, I4 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn5x0[I0, I1, I2, I3, I4 any](doFn genericDoFn5x0[I0, I1, I2, I3, I4]) {
	registerDoFnTypes(doFn)
	registerDoFn5x0StructWrappersAndFuncs[I0, I1, I2, I3, I4](doFn)
}

// Function5x0[I0, I1, I2, I3, I4 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function5x0[I0, I1, I2, I3, I4 any](doFn func(I0, I1, I2, I3, I4)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4))
		return &caller5x0[I0, I1, I2, I3, I4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4))(nil)).Elem(), caller)
}

type genericDoFn6x0[I0, I1, I2, I3, I4, I5 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5)
}

type caller6x0[I0, I1, I2, I3, I4, I5 any] struct {
	fn func(I0, I1, I2, I3, I4, I5)
}

func (c *caller6x0[I0, I1, I2, I3, I4, I5]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller6x0[I0, I1, I2, I3, I4, I5]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller6x0[I0, I1, I2, I3, I4, I5]) Call(args []any) []any {
	c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5))
	return []any{}
}

func (c *caller6x0[I0, I1, I2, I3, I4, I5]) Call6x0(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any) {
	c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5))
}

func registerDoFn6x0StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5 any](doFn genericDoFn6x0[I0, I1, I2, I3, I4, I5]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5))
		return &caller6x0[I0, I1, I2, I3, I4, I5]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5) {
			fn.(genericDoFn6x0[I0, I1, I2, I3, I4, I5]).ProcessElement(a0, a1, a2, a3, a4, a5)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, I0, I1, I2, I3, I4, I5](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, I0, I1, I2, I3, I4, I5](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn6x0[I0, I1, I2, I3, I4, I5 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn6x0[I0, I1, I2, I3, I4, I5 any](doFn genericDoFn6x0[I0, I1, I2, I3, I4, I5]) {
	registerDoFnTypes(doFn)
	registerDoFn6x0StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5](doFn)
}

// Function6x0[I0, I1, I2, I3, I4, I5 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function6x0[I0, I1, I2, I3, I4, I5 any](doFn func(I0, I1, I2, I3, I4, I5)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5))
		return &caller6x0[I0, I1, I2, I3, I4, I5]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5))(nil)).Elem(), caller)
}

type genericDoFn7x0[I0, I1, I2, I3, I4, I5, I6 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6)
}

type caller7x0[I0, I1, I2, I3, I4, I5, I6 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6)
}

func (c *caller7x0[I0, I1, I2, I3, I4, I5, I6]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller7x0[I0, I1, I2, I3, I4, I5, I6]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller7x0[I0, I1, I2, I3, I4, I5, I6]) Call(args []any) []any {
	c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6))
	return []any{}
}

func (c *caller7x0[I0, I1, I2, I3, I4, I5, I6]) Call7x0(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any) {
	c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6))
}

func registerDoFn7x0StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6 any](doFn genericDoFn7x0[I0, I1, I2, I3, I4, I5, I6]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6))
		return &caller7x0[I0, I1, I2, I3, I4, I5, I6]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6) {
			fn.(genericDoFn7x0[I0, I1, I2, I3, I4, I5, I6]).ProcessElement(a0, a1, a2, a3, a4, a5, a6)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, I0, I1, I2, I3, I4, I5, I6](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, I0, I1, I2, I3, I4, I5, I6](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn7x0[I0, I1, I2, I3, I4, I5, I6 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn7x0[I0, I1, I2, I3, I4, I5, I6 any](doFn genericDoFn7x0[I0, I1, I2, I3, I4, I5, I6]) {
	registerDoFnTypes(doFn)
	registerDoFn7x0StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6](doFn)
}

// Function7x0[I0, I1, I2, I3, I4, I5, I6 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function7x0[I0, I1, I2, I3, I4, I5, I6 any](doFn func(I0, I1, I2, I3, I4, I5, I6)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6))
		return &caller7x0[I0, I1, I2, I3, I4, I5, I6]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6))(nil)).Elem(), caller)
}

type genericDoFn8x0[I0, I1, I2, I3, I4, I5, I6, I7 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7)
}

type caller8x0[I0, I1, I2, I3, I4, I5, I6, I7 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7)
}

func (c *caller8x0[I0, I1, I2, I3, I4, I5, I6, I7]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller8x0[I0, I1, I2, I3, I4, I5, I6, I7]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller8x0[I0, I1, I2, I3, I4, I5, I6, I7]) Call(args []any) []any {
	c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7))
	return []any{}
}

func (c *caller8x0[I0, I1, I2, I3, I4, I5, I6, I7]) Call8x0(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any) {
	c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7))
}

func registerDoFn8x0StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7 any](doFn genericDoFn8x0[I0, I1, I2, I3, I4, I5, I6, I7]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7))
		return &caller8x0[I0, I1, I2, I3, I4, I5, I6, I7]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7) {
			fn.(genericDoFn8x0[I0, I1, I2, I3, I4, I5, I6, I7]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, I0, I1, I2, I3, I4, I5, I6, I7](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, I0, I1, I2, I3, I4, I5, I6, I7](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn8x0[I0, I1, I2, I3, I4, I5, I6, I7 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn8x0[I0, I1, I2, I3, I4, I5, I6, I7 any](doFn genericDoFn8x0[I0, I1, I2, I3, I4, I5, I6, I7]) {
	registerDoFnTypes(doFn)
	registerDoFn8x0StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7](doFn)
}

// Function8x0[I0, I1, I2, I3, I4, I5, I6, I7 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function8x0[I0, I1, I2, I3, I4, I5, I6, I7 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7))
		return &caller8x0[I0, I1, I2, I3, I4, I5, I6, I7]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7))(nil)).Elem(), caller)
}

type genericDoFn9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7, i8 I8)
}

type caller9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7, I8)
}

func (c *caller9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8]) Call(args []any) []any {
	c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7), args[8].(I8))
	return []any{}
}

func (c *caller9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8]) Call9x0(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any, arg8 any) {
	c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7), arg8.(I8))
}

func registerDoFn9x0StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8 any](doFn genericDoFn9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8))
		return &caller9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7, a8 I8) {
			fn.(genericDoFn9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7, a8)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8 any](doFn genericDoFn9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8]) {
	registerDoFnTypes(doFn)
	registerDoFn9x0StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
}

// Function9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7, I8)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8))
		return &caller9x0[I0, I1, I2, I3, I4, I5, I6, I7, I8]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8))(nil)).Elem(), caller)
}

type genericDoFn10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7, i8 I8, i9 I9)
}

type caller10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9)
}

func (c *caller10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9]) Call(args []any) []any {
	c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7), args[8].(I8), args[9].(I9))
	return []any{}
}

func (c *caller10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9]) Call10x0(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any, arg8 any, arg9 any) {
	c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7), arg8.(I8), arg9.(I9))
}

func registerDoFn10x0StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9 any](doFn genericDoFn10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9))
		return &caller10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7, a8 I8, a9 I9) {
			fn.(genericDoFn10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9 any](doFn genericDoFn10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9]) {
	registerDoFnTypes(doFn)
	registerDoFn10x0StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
}

// Function10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9))
		return &caller10x0[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9))(nil)).Elem(), caller)
}

type genericDoFn0x1[R0 any] interface {
	ProcessElement() R0
}

type caller0x1[R0 any] struct {
	fn func() R0
}

func (c *caller0x1[R0]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller0x1[R0]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller0x1[R0]) Call(args []any) []any {
	out0 := c.fn()
	return []any{out0}
}

func (c *caller0x1[R0]) Call0x1() any {
	return c.fn()
}

func registerDoFn0x1StructWrappersAndFuncs[R0 any](doFn genericDoFn0x1[R0]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func() R0)
		return &caller0x1[R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func() R0)(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func() R0 {
			return fn.(genericDoFn0x1[R0]).ProcessElement()
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, int, int](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, int, int](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn0x1[R0 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn0x1[R0 any](doFn genericDoFn0x1[R0]) {
	registerDoFnTypes(doFn)
	registerDoFn0x1StructWrappersAndFuncs[R0](doFn)
}

// Function0x1[R0 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function0x1[R0 any](doFn func() R0) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func() R0)
		return &caller0x1[R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func() R0)(nil)).Elem(), caller)
}

type genericDoFn1x1[I0, R0 any] interface {
	ProcessElement(i0 I0) R0
}

type caller1x1[I0, R0 any] struct {
	fn func(I0) R0
}

func (c *caller1x1[I0, R0]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller1x1[I0, R0]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller1x1[I0, R0]) Call(args []any) []any {
	out0 := c.fn(args[0].(I0))
	return []any{out0}
}

func (c *caller1x1[I0, R0]) Call1x1(arg0 any) any {
	return c.fn(arg0.(I0))
}

func registerDoFn1x1StructWrappersAndFuncs[I0, R0 any](doFn genericDoFn1x1[I0, R0]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0) R0)
		return &caller1x1[I0, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0) R0)(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0) R0 {
			return fn.(genericDoFn1x1[I0, R0]).ProcessElement(a0)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, int, I0](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, int, I0](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn1x1[I0, R0 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn1x1[I0, R0 any](doFn genericDoFn1x1[I0, R0]) {
	registerDoFnTypes(doFn)
	registerDoFn1x1StructWrappersAndFuncs[I0, R0](doFn)
}

// Function1x1[I0, R0 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function1x1[I0, R0 any](doFn func(I0) R0) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0) R0)
		return &caller1x1[I0, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0) R0)(nil)).Elem(), caller)
}

type genericDoFn2x1[I0, I1, R0 any] interface {
	ProcessElement(i0 I0, i1 I1) R0
}

type caller2x1[I0, I1, R0 any] struct {
	fn func(I0, I1) R0
}

func (c *caller2x1[I0, I1, R0]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller2x1[I0, I1, R0]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller2x1[I0, I1, R0]) Call(args []any) []any {
	out0 := c.fn(args[0].(I0), args[1].(I1))
	return []any{out0}
}

func (c *caller2x1[I0, I1, R0]) Call2x1(arg0 any, arg1 any) any {
	return c.fn(arg0.(I0), arg1.(I1))
}

func registerDoFn2x1StructWrappersAndFuncs[I0, I1, R0 any](doFn genericDoFn2x1[I0, I1, R0]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1) R0)
		return &caller2x1[I0, I1, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1) R0)(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1) R0 {
			return fn.(genericDoFn2x1[I0, I1, R0]).ProcessElement(a0, a1)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, I0, I1](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, I0, I1](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn2x1[I0, I1, R0 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn2x1[I0, I1, R0 any](doFn genericDoFn2x1[I0, I1, R0]) {
	registerDoFnTypes(doFn)
	registerDoFn2x1StructWrappersAndFuncs[I0, I1, R0](doFn)
}

// Function2x1[I0, I1, R0 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function2x1[I0, I1, R0 any](doFn func(I0, I1) R0) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1) R0)
		return &caller2x1[I0, I1, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1) R0)(nil)).Elem(), caller)
}

type genericDoFn3x1[I0, I1, I2, R0 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2) R0
}

type caller3x1[I0, I1, I2, R0 any] struct {
	fn func(I0, I1, I2) R0
}

func (c *caller3x1[I0, I1, I2, R0]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller3x1[I0, I1, I2, R0]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller3x1[I0, I1, I2, R0]) Call(args []any) []any {
	out0 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2))
	return []any{out0}
}

func (c *caller3x1[I0, I1, I2, R0]) Call3x1(arg0 any, arg1 any, arg2 any) any {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2))
}

func registerDoFn3x1StructWrappersAndFuncs[I0, I1, I2, R0 any](doFn genericDoFn3x1[I0, I1, I2, R0]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2) R0)
		return &caller3x1[I0, I1, I2, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2) R0)(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2) R0 {
			return fn.(genericDoFn3x1[I0, I1, I2, R0]).ProcessElement(a0, a1, a2)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, I0, I1, I2](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, I0, I1, I2](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn3x1[I0, I1, I2, R0 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn3x1[I0, I1, I2, R0 any](doFn genericDoFn3x1[I0, I1, I2, R0]) {
	registerDoFnTypes(doFn)
	registerDoFn3x1StructWrappersAndFuncs[I0, I1, I2, R0](doFn)
}

// Function3x1[I0, I1, I2, R0 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function3x1[I0, I1, I2, R0 any](doFn func(I0, I1, I2) R0) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2) R0)
		return &caller3x1[I0, I1, I2, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2) R0)(nil)).Elem(), caller)
}

type genericDoFn4x1[I0, I1, I2, I3, R0 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3) R0
}

type caller4x1[I0, I1, I2, I3, R0 any] struct {
	fn func(I0, I1, I2, I3) R0
}

func (c *caller4x1[I0, I1, I2, I3, R0]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller4x1[I0, I1, I2, I3, R0]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller4x1[I0, I1, I2, I3, R0]) Call(args []any) []any {
	out0 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3))
	return []any{out0}
}

func (c *caller4x1[I0, I1, I2, I3, R0]) Call4x1(arg0 any, arg1 any, arg2 any, arg3 any) any {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3))
}

func registerDoFn4x1StructWrappersAndFuncs[I0, I1, I2, I3, R0 any](doFn genericDoFn4x1[I0, I1, I2, I3, R0]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3) R0)
		return &caller4x1[I0, I1, I2, I3, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3) R0)(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3) R0 {
			return fn.(genericDoFn4x1[I0, I1, I2, I3, R0]).ProcessElement(a0, a1, a2, a3)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, I0, I1, I2, I3](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, I0, I1, I2, I3](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn4x1[I0, I1, I2, I3, R0 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn4x1[I0, I1, I2, I3, R0 any](doFn genericDoFn4x1[I0, I1, I2, I3, R0]) {
	registerDoFnTypes(doFn)
	registerDoFn4x1StructWrappersAndFuncs[I0, I1, I2, I3, R0](doFn)
}

// Function4x1[I0, I1, I2, I3, R0 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function4x1[I0, I1, I2, I3, R0 any](doFn func(I0, I1, I2, I3) R0) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3) R0)
		return &caller4x1[I0, I1, I2, I3, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3) R0)(nil)).Elem(), caller)
}

type genericDoFn5x1[I0, I1, I2, I3, I4, R0 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4) R0
}

type caller5x1[I0, I1, I2, I3, I4, R0 any] struct {
	fn func(I0, I1, I2, I3, I4) R0
}

func (c *caller5x1[I0, I1, I2, I3, I4, R0]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller5x1[I0, I1, I2, I3, I4, R0]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller5x1[I0, I1, I2, I3, I4, R0]) Call(args []any) []any {
	out0 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4))
	return []any{out0}
}

func (c *caller5x1[I0, I1, I2, I3, I4, R0]) Call5x1(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any) any {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4))
}

func registerDoFn5x1StructWrappersAndFuncs[I0, I1, I2, I3, I4, R0 any](doFn genericDoFn5x1[I0, I1, I2, I3, I4, R0]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4) R0)
		return &caller5x1[I0, I1, I2, I3, I4, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4) R0)(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4) R0 {
			return fn.(genericDoFn5x1[I0, I1, I2, I3, I4, R0]).ProcessElement(a0, a1, a2, a3, a4)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, I0, I1, I2, I3, I4](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, I0, I1, I2, I3, I4](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn5x1[I0, I1, I2, I3, I4, R0 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn5x1[I0, I1, I2, I3, I4, R0 any](doFn genericDoFn5x1[I0, I1, I2, I3, I4, R0]) {
	registerDoFnTypes(doFn)
	registerDoFn5x1StructWrappersAndFuncs[I0, I1, I2, I3, I4, R0](doFn)
}

// Function5x1[I0, I1, I2, I3, I4, R0 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function5x1[I0, I1, I2, I3, I4, R0 any](doFn func(I0, I1, I2, I3, I4) R0) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4) R0)
		return &caller5x1[I0, I1, I2, I3, I4, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4) R0)(nil)).Elem(), caller)
}

type genericDoFn6x1[I0, I1, I2, I3, I4, I5, R0 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5) R0
}

type caller6x1[I0, I1, I2, I3, I4, I5, R0 any] struct {
	fn func(I0, I1, I2, I3, I4, I5) R0
}

func (c *caller6x1[I0, I1, I2, I3, I4, I5, R0]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller6x1[I0, I1, I2, I3, I4, I5, R0]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller6x1[I0, I1, I2, I3, I4, I5, R0]) Call(args []any) []any {
	out0 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5))
	return []any{out0}
}

func (c *caller6x1[I0, I1, I2, I3, I4, I5, R0]) Call6x1(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any) any {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5))
}

func registerDoFn6x1StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, R0 any](doFn genericDoFn6x1[I0, I1, I2, I3, I4, I5, R0]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5) R0)
		return &caller6x1[I0, I1, I2, I3, I4, I5, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5) R0)(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5) R0 {
			return fn.(genericDoFn6x1[I0, I1, I2, I3, I4, I5, R0]).ProcessElement(a0, a1, a2, a3, a4, a5)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, I0, I1, I2, I3, I4, I5](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, I0, I1, I2, I3, I4, I5](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn6x1[I0, I1, I2, I3, I4, I5, R0 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn6x1[I0, I1, I2, I3, I4, I5, R0 any](doFn genericDoFn6x1[I0, I1, I2, I3, I4, I5, R0]) {
	registerDoFnTypes(doFn)
	registerDoFn6x1StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, R0](doFn)
}

// Function6x1[I0, I1, I2, I3, I4, I5, R0 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function6x1[I0, I1, I2, I3, I4, I5, R0 any](doFn func(I0, I1, I2, I3, I4, I5) R0) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5) R0)
		return &caller6x1[I0, I1, I2, I3, I4, I5, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5) R0)(nil)).Elem(), caller)
}

type genericDoFn7x1[I0, I1, I2, I3, I4, I5, I6, R0 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6) R0
}

type caller7x1[I0, I1, I2, I3, I4, I5, I6, R0 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6) R0
}

func (c *caller7x1[I0, I1, I2, I3, I4, I5, I6, R0]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller7x1[I0, I1, I2, I3, I4, I5, I6, R0]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller7x1[I0, I1, I2, I3, I4, I5, I6, R0]) Call(args []any) []any {
	out0 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6))
	return []any{out0}
}

func (c *caller7x1[I0, I1, I2, I3, I4, I5, I6, R0]) Call7x1(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any) any {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6))
}

func registerDoFn7x1StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, R0 any](doFn genericDoFn7x1[I0, I1, I2, I3, I4, I5, I6, R0]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6) R0)
		return &caller7x1[I0, I1, I2, I3, I4, I5, I6, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6) R0)(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6) R0 {
			return fn.(genericDoFn7x1[I0, I1, I2, I3, I4, I5, I6, R0]).ProcessElement(a0, a1, a2, a3, a4, a5, a6)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, I0, I1, I2, I3, I4, I5, I6](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, I0, I1, I2, I3, I4, I5, I6](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn7x1[I0, I1, I2, I3, I4, I5, I6, R0 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn7x1[I0, I1, I2, I3, I4, I5, I6, R0 any](doFn genericDoFn7x1[I0, I1, I2, I3, I4, I5, I6, R0]) {
	registerDoFnTypes(doFn)
	registerDoFn7x1StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, R0](doFn)
}

// Function7x1[I0, I1, I2, I3, I4, I5, I6, R0 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function7x1[I0, I1, I2, I3, I4, I5, I6, R0 any](doFn func(I0, I1, I2, I3, I4, I5, I6) R0) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6) R0)
		return &caller7x1[I0, I1, I2, I3, I4, I5, I6, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6) R0)(nil)).Elem(), caller)
}

type genericDoFn8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7) R0
}

type caller8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7) R0
}

func (c *caller8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0]) Call(args []any) []any {
	out0 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7))
	return []any{out0}
}

func (c *caller8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0]) Call8x1(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any) any {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7))
}

func registerDoFn8x1StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, R0 any](doFn genericDoFn8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7) R0)
		return &caller8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7) R0)(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7) R0 {
			return fn.(genericDoFn8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, I0, I1, I2, I3, I4, I5, I6, I7](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, I0, I1, I2, I3, I4, I5, I6, I7](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0 any](doFn genericDoFn8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0]) {
	registerDoFnTypes(doFn)
	registerDoFn8x1StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, R0](doFn)
}

// Function8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7) R0) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7) R0)
		return &caller8x1[I0, I1, I2, I3, I4, I5, I6, I7, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7) R0)(nil)).Elem(), caller)
}

type genericDoFn9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7, i8 I8) R0
}

type caller9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7, I8) R0
}

func (c *caller9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0]) Call(args []any) []any {
	out0 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7), args[8].(I8))
	return []any{out0}
}

func (c *caller9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0]) Call9x1(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any, arg8 any) any {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7), arg8.(I8))
}

func registerDoFn9x1StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0 any](doFn genericDoFn9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8) R0)
		return &caller9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8) R0)(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7, a8 I8) R0 {
			return fn.(genericDoFn9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7, a8)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0 any](doFn genericDoFn9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0]) {
	registerDoFnTypes(doFn)
	registerDoFn9x1StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0](doFn)
}

// Function9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7, I8) R0) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8) R0)
		return &caller9x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8) R0)(nil)).Elem(), caller)
}

type genericDoFn10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7, i8 I8, i9 I9) R0
}

type caller10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) R0
}

func (c *caller10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0]) Call(args []any) []any {
	out0 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7), args[8].(I8), args[9].(I9))
	return []any{out0}
}

func (c *caller10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0]) Call10x1(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any, arg8 any, arg9 any) any {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7), arg8.(I8), arg9.(I9))
}

func registerDoFn10x1StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0 any](doFn genericDoFn10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) R0)
		return &caller10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) R0)(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7, a8 I8, a9 I9) R0 {
			return fn.(genericDoFn10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0 any](doFn genericDoFn10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0]) {
	registerDoFnTypes(doFn)
	registerDoFn10x1StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0](doFn)
}

// Function10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) R0) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) R0)
		return &caller10x1[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) R0)(nil)).Elem(), caller)
}

type genericDoFn0x2[R0, R1 any] interface {
	ProcessElement() (R0, R1)
}

type caller0x2[R0, R1 any] struct {
	fn func() (R0, R1)
}

func (c *caller0x2[R0, R1]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller0x2[R0, R1]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller0x2[R0, R1]) Call(args []any) []any {
	out0, out1 := c.fn()
	return []any{out0, out1}
}

func (c *caller0x2[R0, R1]) Call0x2() (any, any) {
	return c.fn()
}

func registerDoFn0x2StructWrappersAndFuncs[R0, R1 any](doFn genericDoFn0x2[R0, R1]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func() (R0, R1))
		return &caller0x2[R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func() (R0, R1))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func() (R0, R1) {
			return fn.(genericDoFn0x2[R0, R1]).ProcessElement()
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, int, int](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, int, int](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn0x2[R0, R1 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn0x2[R0, R1 any](doFn genericDoFn0x2[R0, R1]) {
	registerDoFnTypes(doFn)
	registerDoFn0x2StructWrappersAndFuncs[R0, R1](doFn)
}

// Function0x2[R0, R1 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function0x2[R0, R1 any](doFn func() (R0, R1)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func() (R0, R1))
		return &caller0x2[R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func() (R0, R1))(nil)).Elem(), caller)
}

type genericDoFn1x2[I0, R0, R1 any] interface {
	ProcessElement(i0 I0) (R0, R1)
}

type caller1x2[I0, R0, R1 any] struct {
	fn func(I0) (R0, R1)
}

func (c *caller1x2[I0, R0, R1]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller1x2[I0, R0, R1]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller1x2[I0, R0, R1]) Call(args []any) []any {
	out0, out1 := c.fn(args[0].(I0))
	return []any{out0, out1}
}

func (c *caller1x2[I0, R0, R1]) Call1x2(arg0 any) (any, any) {
	return c.fn(arg0.(I0))
}

func registerDoFn1x2StructWrappersAndFuncs[I0, R0, R1 any](doFn genericDoFn1x2[I0, R0, R1]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0) (R0, R1))
		return &caller1x2[I0, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0) (R0, R1))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0) (R0, R1) {
			return fn.(genericDoFn1x2[I0, R0, R1]).ProcessElement(a0)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, int, I0](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, int, I0](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn1x2[I0, R0, R1 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn1x2[I0, R0, R1 any](doFn genericDoFn1x2[I0, R0, R1]) {
	registerDoFnTypes(doFn)
	registerDoFn1x2StructWrappersAndFuncs[I0, R0, R1](doFn)
}

// Function1x2[I0, R0, R1 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function1x2[I0, R0, R1 any](doFn func(I0) (R0, R1)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0) (R0, R1))
		return &caller1x2[I0, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0) (R0, R1))(nil)).Elem(), caller)
}

type genericDoFn2x2[I0, I1, R0, R1 any] interface {
	ProcessElement(i0 I0, i1 I1) (R0, R1)
}

type caller2x2[I0, I1, R0, R1 any] struct {
	fn func(I0, I1) (R0, R1)
}

func (c *caller2x2[I0, I1, R0, R1]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller2x2[I0, I1, R0, R1]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller2x2[I0, I1, R0, R1]) Call(args []any) []any {
	out0, out1 := c.fn(args[0].(I0), args[1].(I1))
	return []any{out0, out1}
}

func (c *caller2x2[I0, I1, R0, R1]) Call2x2(arg0 any, arg1 any) (any, any) {
	return c.fn(arg0.(I0), arg1.(I1))
}

func registerDoFn2x2StructWrappersAndFuncs[I0, I1, R0, R1 any](doFn genericDoFn2x2[I0, I1, R0, R1]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1) (R0, R1))
		return &caller2x2[I0, I1, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1) (R0, R1))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1) (R0, R1) {
			return fn.(genericDoFn2x2[I0, I1, R0, R1]).ProcessElement(a0, a1)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, I0, I1](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, I0, I1](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn2x2[I0, I1, R0, R1 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn2x2[I0, I1, R0, R1 any](doFn genericDoFn2x2[I0, I1, R0, R1]) {
	registerDoFnTypes(doFn)
	registerDoFn2x2StructWrappersAndFuncs[I0, I1, R0, R1](doFn)
}

// Function2x2[I0, I1, R0, R1 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function2x2[I0, I1, R0, R1 any](doFn func(I0, I1) (R0, R1)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1) (R0, R1))
		return &caller2x2[I0, I1, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1) (R0, R1))(nil)).Elem(), caller)
}

type genericDoFn3x2[I0, I1, I2, R0, R1 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2) (R0, R1)
}

type caller3x2[I0, I1, I2, R0, R1 any] struct {
	fn func(I0, I1, I2) (R0, R1)
}

func (c *caller3x2[I0, I1, I2, R0, R1]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller3x2[I0, I1, I2, R0, R1]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller3x2[I0, I1, I2, R0, R1]) Call(args []any) []any {
	out0, out1 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2))
	return []any{out0, out1}
}

func (c *caller3x2[I0, I1, I2, R0, R1]) Call3x2(arg0 any, arg1 any, arg2 any) (any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2))
}

func registerDoFn3x2StructWrappersAndFuncs[I0, I1, I2, R0, R1 any](doFn genericDoFn3x2[I0, I1, I2, R0, R1]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2) (R0, R1))
		return &caller3x2[I0, I1, I2, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2) (R0, R1))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2) (R0, R1) {
			return fn.(genericDoFn3x2[I0, I1, I2, R0, R1]).ProcessElement(a0, a1, a2)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, I0, I1, I2](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, I0, I1, I2](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn3x2[I0, I1, I2, R0, R1 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn3x2[I0, I1, I2, R0, R1 any](doFn genericDoFn3x2[I0, I1, I2, R0, R1]) {
	registerDoFnTypes(doFn)
	registerDoFn3x2StructWrappersAndFuncs[I0, I1, I2, R0, R1](doFn)
}

// Function3x2[I0, I1, I2, R0, R1 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function3x2[I0, I1, I2, R0, R1 any](doFn func(I0, I1, I2) (R0, R1)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2) (R0, R1))
		return &caller3x2[I0, I1, I2, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2) (R0, R1))(nil)).Elem(), caller)
}

type genericDoFn4x2[I0, I1, I2, I3, R0, R1 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3) (R0, R1)
}

type caller4x2[I0, I1, I2, I3, R0, R1 any] struct {
	fn func(I0, I1, I2, I3) (R0, R1)
}

func (c *caller4x2[I0, I1, I2, I3, R0, R1]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller4x2[I0, I1, I2, I3, R0, R1]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller4x2[I0, I1, I2, I3, R0, R1]) Call(args []any) []any {
	out0, out1 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3))
	return []any{out0, out1}
}

func (c *caller4x2[I0, I1, I2, I3, R0, R1]) Call4x2(arg0 any, arg1 any, arg2 any, arg3 any) (any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3))
}

func registerDoFn4x2StructWrappersAndFuncs[I0, I1, I2, I3, R0, R1 any](doFn genericDoFn4x2[I0, I1, I2, I3, R0, R1]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3) (R0, R1))
		return &caller4x2[I0, I1, I2, I3, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3) (R0, R1))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3) (R0, R1) {
			return fn.(genericDoFn4x2[I0, I1, I2, I3, R0, R1]).ProcessElement(a0, a1, a2, a3)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, I0, I1, I2, I3](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, I0, I1, I2, I3](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn4x2[I0, I1, I2, I3, R0, R1 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn4x2[I0, I1, I2, I3, R0, R1 any](doFn genericDoFn4x2[I0, I1, I2, I3, R0, R1]) {
	registerDoFnTypes(doFn)
	registerDoFn4x2StructWrappersAndFuncs[I0, I1, I2, I3, R0, R1](doFn)
}

// Function4x2[I0, I1, I2, I3, R0, R1 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function4x2[I0, I1, I2, I3, R0, R1 any](doFn func(I0, I1, I2, I3) (R0, R1)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3) (R0, R1))
		return &caller4x2[I0, I1, I2, I3, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3) (R0, R1))(nil)).Elem(), caller)
}

type genericDoFn5x2[I0, I1, I2, I3, I4, R0, R1 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4) (R0, R1)
}

type caller5x2[I0, I1, I2, I3, I4, R0, R1 any] struct {
	fn func(I0, I1, I2, I3, I4) (R0, R1)
}

func (c *caller5x2[I0, I1, I2, I3, I4, R0, R1]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller5x2[I0, I1, I2, I3, I4, R0, R1]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller5x2[I0, I1, I2, I3, I4, R0, R1]) Call(args []any) []any {
	out0, out1 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4))
	return []any{out0, out1}
}

func (c *caller5x2[I0, I1, I2, I3, I4, R0, R1]) Call5x2(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any) (any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4))
}

func registerDoFn5x2StructWrappersAndFuncs[I0, I1, I2, I3, I4, R0, R1 any](doFn genericDoFn5x2[I0, I1, I2, I3, I4, R0, R1]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4) (R0, R1))
		return &caller5x2[I0, I1, I2, I3, I4, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4) (R0, R1))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4) (R0, R1) {
			return fn.(genericDoFn5x2[I0, I1, I2, I3, I4, R0, R1]).ProcessElement(a0, a1, a2, a3, a4)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, I0, I1, I2, I3, I4](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, I0, I1, I2, I3, I4](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn5x2[I0, I1, I2, I3, I4, R0, R1 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn5x2[I0, I1, I2, I3, I4, R0, R1 any](doFn genericDoFn5x2[I0, I1, I2, I3, I4, R0, R1]) {
	registerDoFnTypes(doFn)
	registerDoFn5x2StructWrappersAndFuncs[I0, I1, I2, I3, I4, R0, R1](doFn)
}

// Function5x2[I0, I1, I2, I3, I4, R0, R1 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function5x2[I0, I1, I2, I3, I4, R0, R1 any](doFn func(I0, I1, I2, I3, I4) (R0, R1)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4) (R0, R1))
		return &caller5x2[I0, I1, I2, I3, I4, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4) (R0, R1))(nil)).Elem(), caller)
}

type genericDoFn6x2[I0, I1, I2, I3, I4, I5, R0, R1 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5) (R0, R1)
}

type caller6x2[I0, I1, I2, I3, I4, I5, R0, R1 any] struct {
	fn func(I0, I1, I2, I3, I4, I5) (R0, R1)
}

func (c *caller6x2[I0, I1, I2, I3, I4, I5, R0, R1]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller6x2[I0, I1, I2, I3, I4, I5, R0, R1]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller6x2[I0, I1, I2, I3, I4, I5, R0, R1]) Call(args []any) []any {
	out0, out1 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5))
	return []any{out0, out1}
}

func (c *caller6x2[I0, I1, I2, I3, I4, I5, R0, R1]) Call6x2(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any) (any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5))
}

func registerDoFn6x2StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, R0, R1 any](doFn genericDoFn6x2[I0, I1, I2, I3, I4, I5, R0, R1]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5) (R0, R1))
		return &caller6x2[I0, I1, I2, I3, I4, I5, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5) (R0, R1))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5) (R0, R1) {
			return fn.(genericDoFn6x2[I0, I1, I2, I3, I4, I5, R0, R1]).ProcessElement(a0, a1, a2, a3, a4, a5)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, I0, I1, I2, I3, I4, I5](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, I0, I1, I2, I3, I4, I5](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn6x2[I0, I1, I2, I3, I4, I5, R0, R1 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn6x2[I0, I1, I2, I3, I4, I5, R0, R1 any](doFn genericDoFn6x2[I0, I1, I2, I3, I4, I5, R0, R1]) {
	registerDoFnTypes(doFn)
	registerDoFn6x2StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, R0, R1](doFn)
}

// Function6x2[I0, I1, I2, I3, I4, I5, R0, R1 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function6x2[I0, I1, I2, I3, I4, I5, R0, R1 any](doFn func(I0, I1, I2, I3, I4, I5) (R0, R1)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5) (R0, R1))
		return &caller6x2[I0, I1, I2, I3, I4, I5, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5) (R0, R1))(nil)).Elem(), caller)
}

type genericDoFn7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6) (R0, R1)
}

type caller7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6) (R0, R1)
}

func (c *caller7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1]) Call(args []any) []any {
	out0, out1 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6))
	return []any{out0, out1}
}

func (c *caller7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1]) Call7x2(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any) (any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6))
}

func registerDoFn7x2StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, R0, R1 any](doFn genericDoFn7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6) (R0, R1))
		return &caller7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6) (R0, R1))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6) (R0, R1) {
			return fn.(genericDoFn7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1]).ProcessElement(a0, a1, a2, a3, a4, a5, a6)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, I0, I1, I2, I3, I4, I5, I6](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, I0, I1, I2, I3, I4, I5, I6](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1 any](doFn genericDoFn7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1]) {
	registerDoFnTypes(doFn)
	registerDoFn7x2StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, R0, R1](doFn)
}

// Function7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1 any](doFn func(I0, I1, I2, I3, I4, I5, I6) (R0, R1)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6) (R0, R1))
		return &caller7x2[I0, I1, I2, I3, I4, I5, I6, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6) (R0, R1))(nil)).Elem(), caller)
}

type genericDoFn8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7) (R0, R1)
}

type caller8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1)
}

func (c *caller8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1]) Call(args []any) []any {
	out0, out1 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7))
	return []any{out0, out1}
}

func (c *caller8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1]) Call8x2(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any) (any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7))
}

func registerDoFn8x2StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1 any](doFn genericDoFn8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1))
		return &caller8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7) (R0, R1) {
			return fn.(genericDoFn8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, I0, I1, I2, I3, I4, I5, I6, I7](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, I0, I1, I2, I3, I4, I5, I6, I7](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1 any](doFn genericDoFn8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1]) {
	registerDoFnTypes(doFn)
	registerDoFn8x2StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1](doFn)
}

// Function8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1))
		return &caller8x2[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1))(nil)).Elem(), caller)
}

type genericDoFn9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7, i8 I8) (R0, R1)
}

type caller9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1)
}

func (c *caller9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1]) Call(args []any) []any {
	out0, out1 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7), args[8].(I8))
	return []any{out0, out1}
}

func (c *caller9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1]) Call9x2(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any, arg8 any) (any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7), arg8.(I8))
}

func registerDoFn9x2StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1 any](doFn genericDoFn9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1))
		return &caller9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7, a8 I8) (R0, R1) {
			return fn.(genericDoFn9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7, a8)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1 any](doFn genericDoFn9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1]) {
	registerDoFnTypes(doFn)
	registerDoFn9x2StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1](doFn)
}

// Function9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1))
		return &caller9x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1))(nil)).Elem(), caller)
}

type genericDoFn10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7, i8 I8, i9 I9) (R0, R1)
}

type caller10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1)
}

func (c *caller10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1]) Call(args []any) []any {
	out0, out1 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7), args[8].(I8), args[9].(I9))
	return []any{out0, out1}
}

func (c *caller10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1]) Call10x2(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any, arg8 any, arg9 any) (any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7), arg8.(I8), arg9.(I9))
}

func registerDoFn10x2StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1 any](doFn genericDoFn10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1))
		return &caller10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7, a8 I8, a9 I9) (R0, R1) {
			return fn.(genericDoFn10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1 any](doFn genericDoFn10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1]) {
	registerDoFnTypes(doFn)
	registerDoFn10x2StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1](doFn)
}

// Function10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1))
		return &caller10x2[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1))(nil)).Elem(), caller)
}

type genericDoFn0x3[R0, R1, R2 any] interface {
	ProcessElement() (R0, R1, R2)
}

type caller0x3[R0, R1, R2 any] struct {
	fn func() (R0, R1, R2)
}

func (c *caller0x3[R0, R1, R2]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller0x3[R0, R1, R2]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller0x3[R0, R1, R2]) Call(args []any) []any {
	out0, out1, out2 := c.fn()
	return []any{out0, out1, out2}
}

func (c *caller0x3[R0, R1, R2]) Call0x3() (any, any, any) {
	return c.fn()
}

func registerDoFn0x3StructWrappersAndFuncs[R0, R1, R2 any](doFn genericDoFn0x3[R0, R1, R2]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func() (R0, R1, R2))
		return &caller0x3[R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func() (R0, R1, R2))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func() (R0, R1, R2) {
			return fn.(genericDoFn0x3[R0, R1, R2]).ProcessElement()
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, int, int](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, int, int](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn0x3[R0, R1, R2 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn0x3[R0, R1, R2 any](doFn genericDoFn0x3[R0, R1, R2]) {
	registerDoFnTypes(doFn)
	registerDoFn0x3StructWrappersAndFuncs[R0, R1, R2](doFn)
}

// Function0x3[R0, R1, R2 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function0x3[R0, R1, R2 any](doFn func() (R0, R1, R2)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func() (R0, R1, R2))
		return &caller0x3[R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func() (R0, R1, R2))(nil)).Elem(), caller)
}

type genericDoFn1x3[I0, R0, R1, R2 any] interface {
	ProcessElement(i0 I0) (R0, R1, R2)
}

type caller1x3[I0, R0, R1, R2 any] struct {
	fn func(I0) (R0, R1, R2)
}

func (c *caller1x3[I0, R0, R1, R2]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller1x3[I0, R0, R1, R2]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller1x3[I0, R0, R1, R2]) Call(args []any) []any {
	out0, out1, out2 := c.fn(args[0].(I0))
	return []any{out0, out1, out2}
}

func (c *caller1x3[I0, R0, R1, R2]) Call1x3(arg0 any) (any, any, any) {
	return c.fn(arg0.(I0))
}

func registerDoFn1x3StructWrappersAndFuncs[I0, R0, R1, R2 any](doFn genericDoFn1x3[I0, R0, R1, R2]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0) (R0, R1, R2))
		return &caller1x3[I0, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0) (R0, R1, R2))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0) (R0, R1, R2) {
			return fn.(genericDoFn1x3[I0, R0, R1, R2]).ProcessElement(a0)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, int, I0](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, int, I0](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn1x3[I0, R0, R1, R2 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn1x3[I0, R0, R1, R2 any](doFn genericDoFn1x3[I0, R0, R1, R2]) {
	registerDoFnTypes(doFn)
	registerDoFn1x3StructWrappersAndFuncs[I0, R0, R1, R2](doFn)
}

// Function1x3[I0, R0, R1, R2 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function1x3[I0, R0, R1, R2 any](doFn func(I0) (R0, R1, R2)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0) (R0, R1, R2))
		return &caller1x3[I0, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0) (R0, R1, R2))(nil)).Elem(), caller)
}

type genericDoFn2x3[I0, I1, R0, R1, R2 any] interface {
	ProcessElement(i0 I0, i1 I1) (R0, R1, R2)
}

type caller2x3[I0, I1, R0, R1, R2 any] struct {
	fn func(I0, I1) (R0, R1, R2)
}

func (c *caller2x3[I0, I1, R0, R1, R2]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller2x3[I0, I1, R0, R1, R2]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller2x3[I0, I1, R0, R1, R2]) Call(args []any) []any {
	out0, out1, out2 := c.fn(args[0].(I0), args[1].(I1))
	return []any{out0, out1, out2}
}

func (c *caller2x3[I0, I1, R0, R1, R2]) Call2x3(arg0 any, arg1 any) (any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1))
}

func registerDoFn2x3StructWrappersAndFuncs[I0, I1, R0, R1, R2 any](doFn genericDoFn2x3[I0, I1, R0, R1, R2]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1) (R0, R1, R2))
		return &caller2x3[I0, I1, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1) (R0, R1, R2))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1) (R0, R1, R2) {
			return fn.(genericDoFn2x3[I0, I1, R0, R1, R2]).ProcessElement(a0, a1)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, I0, I1](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, I0, I1](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn2x3[I0, I1, R0, R1, R2 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn2x3[I0, I1, R0, R1, R2 any](doFn genericDoFn2x3[I0, I1, R0, R1, R2]) {
	registerDoFnTypes(doFn)
	registerDoFn2x3StructWrappersAndFuncs[I0, I1, R0, R1, R2](doFn)
}

// Function2x3[I0, I1, R0, R1, R2 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function2x3[I0, I1, R0, R1, R2 any](doFn func(I0, I1) (R0, R1, R2)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1) (R0, R1, R2))
		return &caller2x3[I0, I1, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1) (R0, R1, R2))(nil)).Elem(), caller)
}

type genericDoFn3x3[I0, I1, I2, R0, R1, R2 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2) (R0, R1, R2)
}

type caller3x3[I0, I1, I2, R0, R1, R2 any] struct {
	fn func(I0, I1, I2) (R0, R1, R2)
}

func (c *caller3x3[I0, I1, I2, R0, R1, R2]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller3x3[I0, I1, I2, R0, R1, R2]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller3x3[I0, I1, I2, R0, R1, R2]) Call(args []any) []any {
	out0, out1, out2 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2))
	return []any{out0, out1, out2}
}

func (c *caller3x3[I0, I1, I2, R0, R1, R2]) Call3x3(arg0 any, arg1 any, arg2 any) (any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2))
}

func registerDoFn3x3StructWrappersAndFuncs[I0, I1, I2, R0, R1, R2 any](doFn genericDoFn3x3[I0, I1, I2, R0, R1, R2]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2) (R0, R1, R2))
		return &caller3x3[I0, I1, I2, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2) (R0, R1, R2))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2) (R0, R1, R2) {
			return fn.(genericDoFn3x3[I0, I1, I2, R0, R1, R2]).ProcessElement(a0, a1, a2)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, I0, I1, I2](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, I0, I1, I2](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn3x3[I0, I1, I2, R0, R1, R2 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn3x3[I0, I1, I2, R0, R1, R2 any](doFn genericDoFn3x3[I0, I1, I2, R0, R1, R2]) {
	registerDoFnTypes(doFn)
	registerDoFn3x3StructWrappersAndFuncs[I0, I1, I2, R0, R1, R2](doFn)
}

// Function3x3[I0, I1, I2, R0, R1, R2 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function3x3[I0, I1, I2, R0, R1, R2 any](doFn func(I0, I1, I2) (R0, R1, R2)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2) (R0, R1, R2))
		return &caller3x3[I0, I1, I2, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2) (R0, R1, R2))(nil)).Elem(), caller)
}

type genericDoFn4x3[I0, I1, I2, I3, R0, R1, R2 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3) (R0, R1, R2)
}

type caller4x3[I0, I1, I2, I3, R0, R1, R2 any] struct {
	fn func(I0, I1, I2, I3) (R0, R1, R2)
}

func (c *caller4x3[I0, I1, I2, I3, R0, R1, R2]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller4x3[I0, I1, I2, I3, R0, R1, R2]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller4x3[I0, I1, I2, I3, R0, R1, R2]) Call(args []any) []any {
	out0, out1, out2 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3))
	return []any{out0, out1, out2}
}

func (c *caller4x3[I0, I1, I2, I3, R0, R1, R2]) Call4x3(arg0 any, arg1 any, arg2 any, arg3 any) (any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3))
}

func registerDoFn4x3StructWrappersAndFuncs[I0, I1, I2, I3, R0, R1, R2 any](doFn genericDoFn4x3[I0, I1, I2, I3, R0, R1, R2]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3) (R0, R1, R2))
		return &caller4x3[I0, I1, I2, I3, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3) (R0, R1, R2))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3) (R0, R1, R2) {
			return fn.(genericDoFn4x3[I0, I1, I2, I3, R0, R1, R2]).ProcessElement(a0, a1, a2, a3)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, I0, I1, I2, I3](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, I0, I1, I2, I3](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn4x3[I0, I1, I2, I3, R0, R1, R2 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn4x3[I0, I1, I2, I3, R0, R1, R2 any](doFn genericDoFn4x3[I0, I1, I2, I3, R0, R1, R2]) {
	registerDoFnTypes(doFn)
	registerDoFn4x3StructWrappersAndFuncs[I0, I1, I2, I3, R0, R1, R2](doFn)
}

// Function4x3[I0, I1, I2, I3, R0, R1, R2 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function4x3[I0, I1, I2, I3, R0, R1, R2 any](doFn func(I0, I1, I2, I3) (R0, R1, R2)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3) (R0, R1, R2))
		return &caller4x3[I0, I1, I2, I3, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3) (R0, R1, R2))(nil)).Elem(), caller)
}

type genericDoFn5x3[I0, I1, I2, I3, I4, R0, R1, R2 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4) (R0, R1, R2)
}

type caller5x3[I0, I1, I2, I3, I4, R0, R1, R2 any] struct {
	fn func(I0, I1, I2, I3, I4) (R0, R1, R2)
}

func (c *caller5x3[I0, I1, I2, I3, I4, R0, R1, R2]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller5x3[I0, I1, I2, I3, I4, R0, R1, R2]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller5x3[I0, I1, I2, I3, I4, R0, R1, R2]) Call(args []any) []any {
	out0, out1, out2 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4))
	return []any{out0, out1, out2}
}

func (c *caller5x3[I0, I1, I2, I3, I4, R0, R1, R2]) Call5x3(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any) (any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4))
}

func registerDoFn5x3StructWrappersAndFuncs[I0, I1, I2, I3, I4, R0, R1, R2 any](doFn genericDoFn5x3[I0, I1, I2, I3, I4, R0, R1, R2]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4) (R0, R1, R2))
		return &caller5x3[I0, I1, I2, I3, I4, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4) (R0, R1, R2))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4) (R0, R1, R2) {
			return fn.(genericDoFn5x3[I0, I1, I2, I3, I4, R0, R1, R2]).ProcessElement(a0, a1, a2, a3, a4)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, I0, I1, I2, I3, I4](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, I0, I1, I2, I3, I4](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn5x3[I0, I1, I2, I3, I4, R0, R1, R2 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn5x3[I0, I1, I2, I3, I4, R0, R1, R2 any](doFn genericDoFn5x3[I0, I1, I2, I3, I4, R0, R1, R2]) {
	registerDoFnTypes(doFn)
	registerDoFn5x3StructWrappersAndFuncs[I0, I1, I2, I3, I4, R0, R1, R2](doFn)
}

// Function5x3[I0, I1, I2, I3, I4, R0, R1, R2 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function5x3[I0, I1, I2, I3, I4, R0, R1, R2 any](doFn func(I0, I1, I2, I3, I4) (R0, R1, R2)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4) (R0, R1, R2))
		return &caller5x3[I0, I1, I2, I3, I4, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4) (R0, R1, R2))(nil)).Elem(), caller)
}

type genericDoFn6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5) (R0, R1, R2)
}

type caller6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2 any] struct {
	fn func(I0, I1, I2, I3, I4, I5) (R0, R1, R2)
}

func (c *caller6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2]) Call(args []any) []any {
	out0, out1, out2 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5))
	return []any{out0, out1, out2}
}

func (c *caller6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2]) Call6x3(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any) (any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5))
}

func registerDoFn6x3StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, R0, R1, R2 any](doFn genericDoFn6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5) (R0, R1, R2))
		return &caller6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5) (R0, R1, R2))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5) (R0, R1, R2) {
			return fn.(genericDoFn6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2]).ProcessElement(a0, a1, a2, a3, a4, a5)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, I0, I1, I2, I3, I4, I5](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, I0, I1, I2, I3, I4, I5](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2 any](doFn genericDoFn6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2]) {
	registerDoFnTypes(doFn)
	registerDoFn6x3StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, R0, R1, R2](doFn)
}

// Function6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2 any](doFn func(I0, I1, I2, I3, I4, I5) (R0, R1, R2)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5) (R0, R1, R2))
		return &caller6x3[I0, I1, I2, I3, I4, I5, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5) (R0, R1, R2))(nil)).Elem(), caller)
}

type genericDoFn7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6) (R0, R1, R2)
}

type caller7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2)
}

func (c *caller7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2]) Call(args []any) []any {
	out0, out1, out2 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6))
	return []any{out0, out1, out2}
}

func (c *caller7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2]) Call7x3(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any) (any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6))
}

func registerDoFn7x3StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2 any](doFn genericDoFn7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2))
		return &caller7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6) (R0, R1, R2) {
			return fn.(genericDoFn7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2]).ProcessElement(a0, a1, a2, a3, a4, a5, a6)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, I0, I1, I2, I3, I4, I5, I6](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, I0, I1, I2, I3, I4, I5, I6](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2 any](doFn genericDoFn7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2]) {
	registerDoFnTypes(doFn)
	registerDoFn7x3StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2](doFn)
}

// Function7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2 any](doFn func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2))
		return &caller7x3[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2))(nil)).Elem(), caller)
}

type genericDoFn8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7) (R0, R1, R2)
}

type caller8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2)
}

func (c *caller8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2]) Call(args []any) []any {
	out0, out1, out2 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7))
	return []any{out0, out1, out2}
}

func (c *caller8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2]) Call8x3(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any) (any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7))
}

func registerDoFn8x3StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2 any](doFn genericDoFn8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2))
		return &caller8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7) (R0, R1, R2) {
			return fn.(genericDoFn8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, I0, I1, I2, I3, I4, I5, I6, I7](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, I0, I1, I2, I3, I4, I5, I6, I7](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2 any](doFn genericDoFn8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2]) {
	registerDoFnTypes(doFn)
	registerDoFn8x3StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2](doFn)
}

// Function8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2))
		return &caller8x3[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2))(nil)).Elem(), caller)
}

type genericDoFn9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7, i8 I8) (R0, R1, R2)
}

type caller9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2)
}

func (c *caller9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2]) Call(args []any) []any {
	out0, out1, out2 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7), args[8].(I8))
	return []any{out0, out1, out2}
}

func (c *caller9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2]) Call9x3(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any, arg8 any) (any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7), arg8.(I8))
}

func registerDoFn9x3StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2 any](doFn genericDoFn9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2))
		return &caller9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7, a8 I8) (R0, R1, R2) {
			return fn.(genericDoFn9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7, a8)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2 any](doFn genericDoFn9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2]) {
	registerDoFnTypes(doFn)
	registerDoFn9x3StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2](doFn)
}

// Function9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2))
		return &caller9x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2))(nil)).Elem(), caller)
}

type genericDoFn10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7, i8 I8, i9 I9) (R0, R1, R2)
}

type caller10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2)
}

func (c *caller10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2]) Call(args []any) []any {
	out0, out1, out2 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7), args[8].(I8), args[9].(I9))
	return []any{out0, out1, out2}
}

func (c *caller10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2]) Call10x3(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any, arg8 any, arg9 any) (any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7), arg8.(I8), arg9.(I9))
}

func registerDoFn10x3StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2 any](doFn genericDoFn10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2))
		return &caller10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7, a8 I8, a9 I9) (R0, R1, R2) {
			return fn.(genericDoFn10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2 any](doFn genericDoFn10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2]) {
	registerDoFnTypes(doFn)
	registerDoFn10x3StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2](doFn)
}

// Function10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2))
		return &caller10x3[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2))(nil)).Elem(), caller)
}

type genericDoFn0x4[R0, R1, R2, R3 any] interface {
	ProcessElement() (R0, R1, R2, R3)
}

type caller0x4[R0, R1, R2, R3 any] struct {
	fn func() (R0, R1, R2, R3)
}

func (c *caller0x4[R0, R1, R2, R3]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller0x4[R0, R1, R2, R3]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller0x4[R0, R1, R2, R3]) Call(args []any) []any {
	out0, out1, out2, out3 := c.fn()
	return []any{out0, out1, out2, out3}
}

func (c *caller0x4[R0, R1, R2, R3]) Call0x4() (any, any, any, any) {
	return c.fn()
}

func registerDoFn0x4StructWrappersAndFuncs[R0, R1, R2, R3 any](doFn genericDoFn0x4[R0, R1, R2, R3]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func() (R0, R1, R2, R3))
		return &caller0x4[R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func() (R0, R1, R2, R3))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func() (R0, R1, R2, R3) {
			return fn.(genericDoFn0x4[R0, R1, R2, R3]).ProcessElement()
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, int, int](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, int, int](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn0x4[R0, R1, R2, R3 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn0x4[R0, R1, R2, R3 any](doFn genericDoFn0x4[R0, R1, R2, R3]) {
	registerDoFnTypes(doFn)
	registerDoFn0x4StructWrappersAndFuncs[R0, R1, R2, R3](doFn)
}

// Function0x4[R0, R1, R2, R3 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function0x4[R0, R1, R2, R3 any](doFn func() (R0, R1, R2, R3)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func() (R0, R1, R2, R3))
		return &caller0x4[R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func() (R0, R1, R2, R3))(nil)).Elem(), caller)
}

type genericDoFn1x4[I0, R0, R1, R2, R3 any] interface {
	ProcessElement(i0 I0) (R0, R1, R2, R3)
}

type caller1x4[I0, R0, R1, R2, R3 any] struct {
	fn func(I0) (R0, R1, R2, R3)
}

func (c *caller1x4[I0, R0, R1, R2, R3]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller1x4[I0, R0, R1, R2, R3]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller1x4[I0, R0, R1, R2, R3]) Call(args []any) []any {
	out0, out1, out2, out3 := c.fn(args[0].(I0))
	return []any{out0, out1, out2, out3}
}

func (c *caller1x4[I0, R0, R1, R2, R3]) Call1x4(arg0 any) (any, any, any, any) {
	return c.fn(arg0.(I0))
}

func registerDoFn1x4StructWrappersAndFuncs[I0, R0, R1, R2, R3 any](doFn genericDoFn1x4[I0, R0, R1, R2, R3]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0) (R0, R1, R2, R3))
		return &caller1x4[I0, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0) (R0, R1, R2, R3))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0) (R0, R1, R2, R3) {
			return fn.(genericDoFn1x4[I0, R0, R1, R2, R3]).ProcessElement(a0)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, int, I0](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, int, I0](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn1x4[I0, R0, R1, R2, R3 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn1x4[I0, R0, R1, R2, R3 any](doFn genericDoFn1x4[I0, R0, R1, R2, R3]) {
	registerDoFnTypes(doFn)
	registerDoFn1x4StructWrappersAndFuncs[I0, R0, R1, R2, R3](doFn)
}

// Function1x4[I0, R0, R1, R2, R3 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function1x4[I0, R0, R1, R2, R3 any](doFn func(I0) (R0, R1, R2, R3)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0) (R0, R1, R2, R3))
		return &caller1x4[I0, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0) (R0, R1, R2, R3))(nil)).Elem(), caller)
}

type genericDoFn2x4[I0, I1, R0, R1, R2, R3 any] interface {
	ProcessElement(i0 I0, i1 I1) (R0, R1, R2, R3)
}

type caller2x4[I0, I1, R0, R1, R2, R3 any] struct {
	fn func(I0, I1) (R0, R1, R2, R3)
}

func (c *caller2x4[I0, I1, R0, R1, R2, R3]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller2x4[I0, I1, R0, R1, R2, R3]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller2x4[I0, I1, R0, R1, R2, R3]) Call(args []any) []any {
	out0, out1, out2, out3 := c.fn(args[0].(I0), args[1].(I1))
	return []any{out0, out1, out2, out3}
}

func (c *caller2x4[I0, I1, R0, R1, R2, R3]) Call2x4(arg0 any, arg1 any) (any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1))
}

func registerDoFn2x4StructWrappersAndFuncs[I0, I1, R0, R1, R2, R3 any](doFn genericDoFn2x4[I0, I1, R0, R1, R2, R3]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1) (R0, R1, R2, R3))
		return &caller2x4[I0, I1, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1) (R0, R1, R2, R3))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1) (R0, R1, R2, R3) {
			return fn.(genericDoFn2x4[I0, I1, R0, R1, R2, R3]).ProcessElement(a0, a1)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, I0, I1](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, I0, I1](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn2x4[I0, I1, R0, R1, R2, R3 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn2x4[I0, I1, R0, R1, R2, R3 any](doFn genericDoFn2x4[I0, I1, R0, R1, R2, R3]) {
	registerDoFnTypes(doFn)
	registerDoFn2x4StructWrappersAndFuncs[I0, I1, R0, R1, R2, R3](doFn)
}

// Function2x4[I0, I1, R0, R1, R2, R3 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function2x4[I0, I1, R0, R1, R2, R3 any](doFn func(I0, I1) (R0, R1, R2, R3)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1) (R0, R1, R2, R3))
		return &caller2x4[I0, I1, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1) (R0, R1, R2, R3))(nil)).Elem(), caller)
}

type genericDoFn3x4[I0, I1, I2, R0, R1, R2, R3 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2) (R0, R1, R2, R3)
}

type caller3x4[I0, I1, I2, R0, R1, R2, R3 any] struct {
	fn func(I0, I1, I2) (R0, R1, R2, R3)
}

func (c *caller3x4[I0, I1, I2, R0, R1, R2, R3]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller3x4[I0, I1, I2, R0, R1, R2, R3]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller3x4[I0, I1, I2, R0, R1, R2, R3]) Call(args []any) []any {
	out0, out1, out2, out3 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2))
	return []any{out0, out1, out2, out3}
}

func (c *caller3x4[I0, I1, I2, R0, R1, R2, R3]) Call3x4(arg0 any, arg1 any, arg2 any) (any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2))
}

func registerDoFn3x4StructWrappersAndFuncs[I0, I1, I2, R0, R1, R2, R3 any](doFn genericDoFn3x4[I0, I1, I2, R0, R1, R2, R3]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2) (R0, R1, R2, R3))
		return &caller3x4[I0, I1, I2, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2) (R0, R1, R2, R3))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2) (R0, R1, R2, R3) {
			return fn.(genericDoFn3x4[I0, I1, I2, R0, R1, R2, R3]).ProcessElement(a0, a1, a2)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, I0, I1, I2](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, I0, I1, I2](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn3x4[I0, I1, I2, R0, R1, R2, R3 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn3x4[I0, I1, I2, R0, R1, R2, R3 any](doFn genericDoFn3x4[I0, I1, I2, R0, R1, R2, R3]) {
	registerDoFnTypes(doFn)
	registerDoFn3x4StructWrappersAndFuncs[I0, I1, I2, R0, R1, R2, R3](doFn)
}

// Function3x4[I0, I1, I2, R0, R1, R2, R3 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function3x4[I0, I1, I2, R0, R1, R2, R3 any](doFn func(I0, I1, I2) (R0, R1, R2, R3)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2) (R0, R1, R2, R3))
		return &caller3x4[I0, I1, I2, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2) (R0, R1, R2, R3))(nil)).Elem(), caller)
}

type genericDoFn4x4[I0, I1, I2, I3, R0, R1, R2, R3 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3) (R0, R1, R2, R3)
}

type caller4x4[I0, I1, I2, I3, R0, R1, R2, R3 any] struct {
	fn func(I0, I1, I2, I3) (R0, R1, R2, R3)
}

func (c *caller4x4[I0, I1, I2, I3, R0, R1, R2, R3]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller4x4[I0, I1, I2, I3, R0, R1, R2, R3]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller4x4[I0, I1, I2, I3, R0, R1, R2, R3]) Call(args []any) []any {
	out0, out1, out2, out3 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3))
	return []any{out0, out1, out2, out3}
}

func (c *caller4x4[I0, I1, I2, I3, R0, R1, R2, R3]) Call4x4(arg0 any, arg1 any, arg2 any, arg3 any) (any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3))
}

func registerDoFn4x4StructWrappersAndFuncs[I0, I1, I2, I3, R0, R1, R2, R3 any](doFn genericDoFn4x4[I0, I1, I2, I3, R0, R1, R2, R3]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3) (R0, R1, R2, R3))
		return &caller4x4[I0, I1, I2, I3, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3) (R0, R1, R2, R3))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3) (R0, R1, R2, R3) {
			return fn.(genericDoFn4x4[I0, I1, I2, I3, R0, R1, R2, R3]).ProcessElement(a0, a1, a2, a3)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, I0, I1, I2, I3](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, I0, I1, I2, I3](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn4x4[I0, I1, I2, I3, R0, R1, R2, R3 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn4x4[I0, I1, I2, I3, R0, R1, R2, R3 any](doFn genericDoFn4x4[I0, I1, I2, I3, R0, R1, R2, R3]) {
	registerDoFnTypes(doFn)
	registerDoFn4x4StructWrappersAndFuncs[I0, I1, I2, I3, R0, R1, R2, R3](doFn)
}

// Function4x4[I0, I1, I2, I3, R0, R1, R2, R3 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function4x4[I0, I1, I2, I3, R0, R1, R2, R3 any](doFn func(I0, I1, I2, I3) (R0, R1, R2, R3)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3) (R0, R1, R2, R3))
		return &caller4x4[I0, I1, I2, I3, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3) (R0, R1, R2, R3))(nil)).Elem(), caller)
}

type genericDoFn5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4) (R0, R1, R2, R3)
}

type caller5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3 any] struct {
	fn func(I0, I1, I2, I3, I4) (R0, R1, R2, R3)
}

func (c *caller5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3]) Call(args []any) []any {
	out0, out1, out2, out3 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4))
	return []any{out0, out1, out2, out3}
}

func (c *caller5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3]) Call5x4(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any) (any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4))
}

func registerDoFn5x4StructWrappersAndFuncs[I0, I1, I2, I3, I4, R0, R1, R2, R3 any](doFn genericDoFn5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4) (R0, R1, R2, R3))
		return &caller5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4) (R0, R1, R2, R3))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4) (R0, R1, R2, R3) {
			return fn.(genericDoFn5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3]).ProcessElement(a0, a1, a2, a3, a4)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, I0, I1, I2, I3, I4](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, I0, I1, I2, I3, I4](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3 any](doFn genericDoFn5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3]) {
	registerDoFnTypes(doFn)
	registerDoFn5x4StructWrappersAndFuncs[I0, I1, I2, I3, I4, R0, R1, R2, R3](doFn)
}

// Function5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3 any](doFn func(I0, I1, I2, I3, I4) (R0, R1, R2, R3)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4) (R0, R1, R2, R3))
		return &caller5x4[I0, I1, I2, I3, I4, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4) (R0, R1, R2, R3))(nil)).Elem(), caller)
}

type genericDoFn6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5) (R0, R1, R2, R3)
}

type caller6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3 any] struct {
	fn func(I0, I1, I2, I3, I4, I5) (R0, R1, R2, R3)
}

func (c *caller6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3]) Call(args []any) []any {
	out0, out1, out2, out3 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5))
	return []any{out0, out1, out2, out3}
}

func (c *caller6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3]) Call6x4(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any) (any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5))
}

func registerDoFn6x4StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3 any](doFn genericDoFn6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5) (R0, R1, R2, R3))
		return &caller6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5) (R0, R1, R2, R3))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5) (R0, R1, R2, R3) {
			return fn.(genericDoFn6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3]).ProcessElement(a0, a1, a2, a3, a4, a5)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, I0, I1, I2, I3, I4, I5](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, I0, I1, I2, I3, I4, I5](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3 any](doFn genericDoFn6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3]) {
	registerDoFnTypes(doFn)
	registerDoFn6x4StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3](doFn)
}

// Function6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3 any](doFn func(I0, I1, I2, I3, I4, I5) (R0, R1, R2, R3)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5) (R0, R1, R2, R3))
		return &caller6x4[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5) (R0, R1, R2, R3))(nil)).Elem(), caller)
}

type genericDoFn7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6) (R0, R1, R2, R3)
}

type caller7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2, R3)
}

func (c *caller7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3]) Call(args []any) []any {
	out0, out1, out2, out3 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6))
	return []any{out0, out1, out2, out3}
}

func (c *caller7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3]) Call7x4(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any) (any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6))
}

func registerDoFn7x4StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3 any](doFn genericDoFn7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2, R3))
		return &caller7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2, R3))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6) (R0, R1, R2, R3) {
			return fn.(genericDoFn7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3]).ProcessElement(a0, a1, a2, a3, a4, a5, a6)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, I0, I1, I2, I3, I4, I5, I6](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, I0, I1, I2, I3, I4, I5, I6](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3 any](doFn genericDoFn7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3]) {
	registerDoFnTypes(doFn)
	registerDoFn7x4StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3](doFn)
}

// Function7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3 any](doFn func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2, R3)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2, R3))
		return &caller7x4[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2, R3))(nil)).Elem(), caller)
}

type genericDoFn8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7) (R0, R1, R2, R3)
}

type caller8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2, R3)
}

func (c *caller8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3]) Call(args []any) []any {
	out0, out1, out2, out3 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7))
	return []any{out0, out1, out2, out3}
}

func (c *caller8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3]) Call8x4(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any) (any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7))
}

func registerDoFn8x4StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3 any](doFn genericDoFn8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2, R3))
		return &caller8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2, R3))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7) (R0, R1, R2, R3) {
			return fn.(genericDoFn8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, I0, I1, I2, I3, I4, I5, I6, I7](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, I0, I1, I2, I3, I4, I5, I6, I7](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3 any](doFn genericDoFn8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3]) {
	registerDoFnTypes(doFn)
	registerDoFn8x4StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3](doFn)
}

// Function8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2, R3)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2, R3))
		return &caller8x4[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2, R3))(nil)).Elem(), caller)
}

type genericDoFn9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7, i8 I8) (R0, R1, R2, R3)
}

type caller9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2, R3)
}

func (c *caller9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3]) Call(args []any) []any {
	out0, out1, out2, out3 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7), args[8].(I8))
	return []any{out0, out1, out2, out3}
}

func (c *caller9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3]) Call9x4(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any, arg8 any) (any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7), arg8.(I8))
}

func registerDoFn9x4StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3 any](doFn genericDoFn9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2, R3))
		return &caller9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2, R3))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7, a8 I8) (R0, R1, R2, R3) {
			return fn.(genericDoFn9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7, a8)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3 any](doFn genericDoFn9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3]) {
	registerDoFnTypes(doFn)
	registerDoFn9x4StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3](doFn)
}

// Function9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2, R3)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2, R3))
		return &caller9x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2, R3))(nil)).Elem(), caller)
}

type genericDoFn10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7, i8 I8, i9 I9) (R0, R1, R2, R3)
}

type caller10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2, R3)
}

func (c *caller10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3]) Call(args []any) []any {
	out0, out1, out2, out3 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7), args[8].(I8), args[9].(I9))
	return []any{out0, out1, out2, out3}
}

func (c *caller10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3]) Call10x4(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any, arg8 any, arg9 any) (any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7), arg8.(I8), arg9.(I9))
}

func registerDoFn10x4StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3 any](doFn genericDoFn10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2, R3))
		return &caller10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2, R3))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7, a8 I8, a9 I9) (R0, R1, R2, R3) {
			return fn.(genericDoFn10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3 any](doFn genericDoFn10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3]) {
	registerDoFnTypes(doFn)
	registerDoFn10x4StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3](doFn)
}

// Function10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2, R3)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2, R3))
		return &caller10x4[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2, R3))(nil)).Elem(), caller)
}

type genericDoFn0x5[R0, R1, R2, R3, R4 any] interface {
	ProcessElement() (R0, R1, R2, R3, R4)
}

type caller0x5[R0, R1, R2, R3, R4 any] struct {
	fn func() (R0, R1, R2, R3, R4)
}

func (c *caller0x5[R0, R1, R2, R3, R4]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller0x5[R0, R1, R2, R3, R4]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller0x5[R0, R1, R2, R3, R4]) Call(args []any) []any {
	out0, out1, out2, out3, out4 := c.fn()
	return []any{out0, out1, out2, out3, out4}
}

func (c *caller0x5[R0, R1, R2, R3, R4]) Call0x5() (any, any, any, any, any) {
	return c.fn()
}

func registerDoFn0x5StructWrappersAndFuncs[R0, R1, R2, R3, R4 any](doFn genericDoFn0x5[R0, R1, R2, R3, R4]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func() (R0, R1, R2, R3, R4))
		return &caller0x5[R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func() (R0, R1, R2, R3, R4))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func() (R0, R1, R2, R3, R4) {
			return fn.(genericDoFn0x5[R0, R1, R2, R3, R4]).ProcessElement()
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, int, int](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, int, int](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn0x5[R0, R1, R2, R3, R4 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn0x5[R0, R1, R2, R3, R4 any](doFn genericDoFn0x5[R0, R1, R2, R3, R4]) {
	registerDoFnTypes(doFn)
	registerDoFn0x5StructWrappersAndFuncs[R0, R1, R2, R3, R4](doFn)
}

// Function0x5[R0, R1, R2, R3, R4 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function0x5[R0, R1, R2, R3, R4 any](doFn func() (R0, R1, R2, R3, R4)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func() (R0, R1, R2, R3, R4))
		return &caller0x5[R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func() (R0, R1, R2, R3, R4))(nil)).Elem(), caller)
}

type genericDoFn1x5[I0, R0, R1, R2, R3, R4 any] interface {
	ProcessElement(i0 I0) (R0, R1, R2, R3, R4)
}

type caller1x5[I0, R0, R1, R2, R3, R4 any] struct {
	fn func(I0) (R0, R1, R2, R3, R4)
}

func (c *caller1x5[I0, R0, R1, R2, R3, R4]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller1x5[I0, R0, R1, R2, R3, R4]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller1x5[I0, R0, R1, R2, R3, R4]) Call(args []any) []any {
	out0, out1, out2, out3, out4 := c.fn(args[0].(I0))
	return []any{out0, out1, out2, out3, out4}
}

func (c *caller1x5[I0, R0, R1, R2, R3, R4]) Call1x5(arg0 any) (any, any, any, any, any) {
	return c.fn(arg0.(I0))
}

func registerDoFn1x5StructWrappersAndFuncs[I0, R0, R1, R2, R3, R4 any](doFn genericDoFn1x5[I0, R0, R1, R2, R3, R4]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0) (R0, R1, R2, R3, R4))
		return &caller1x5[I0, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0) (R0, R1, R2, R3, R4))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0) (R0, R1, R2, R3, R4) {
			return fn.(genericDoFn1x5[I0, R0, R1, R2, R3, R4]).ProcessElement(a0)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, int, I0](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, int, I0](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn1x5[I0, R0, R1, R2, R3, R4 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn1x5[I0, R0, R1, R2, R3, R4 any](doFn genericDoFn1x5[I0, R0, R1, R2, R3, R4]) {
	registerDoFnTypes(doFn)
	registerDoFn1x5StructWrappersAndFuncs[I0, R0, R1, R2, R3, R4](doFn)
}

// Function1x5[I0, R0, R1, R2, R3, R4 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function1x5[I0, R0, R1, R2, R3, R4 any](doFn func(I0) (R0, R1, R2, R3, R4)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0) (R0, R1, R2, R3, R4))
		return &caller1x5[I0, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0) (R0, R1, R2, R3, R4))(nil)).Elem(), caller)
}

type genericDoFn2x5[I0, I1, R0, R1, R2, R3, R4 any] interface {
	ProcessElement(i0 I0, i1 I1) (R0, R1, R2, R3, R4)
}

type caller2x5[I0, I1, R0, R1, R2, R3, R4 any] struct {
	fn func(I0, I1) (R0, R1, R2, R3, R4)
}

func (c *caller2x5[I0, I1, R0, R1, R2, R3, R4]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller2x5[I0, I1, R0, R1, R2, R3, R4]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller2x5[I0, I1, R0, R1, R2, R3, R4]) Call(args []any) []any {
	out0, out1, out2, out3, out4 := c.fn(args[0].(I0), args[1].(I1))
	return []any{out0, out1, out2, out3, out4}
}

func (c *caller2x5[I0, I1, R0, R1, R2, R3, R4]) Call2x5(arg0 any, arg1 any) (any, any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1))
}

func registerDoFn2x5StructWrappersAndFuncs[I0, I1, R0, R1, R2, R3, R4 any](doFn genericDoFn2x5[I0, I1, R0, R1, R2, R3, R4]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1) (R0, R1, R2, R3, R4))
		return &caller2x5[I0, I1, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1) (R0, R1, R2, R3, R4))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1) (R0, R1, R2, R3, R4) {
			return fn.(genericDoFn2x5[I0, I1, R0, R1, R2, R3, R4]).ProcessElement(a0, a1)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, int, I0, I1](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, int, I0, I1](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn2x5[I0, I1, R0, R1, R2, R3, R4 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn2x5[I0, I1, R0, R1, R2, R3, R4 any](doFn genericDoFn2x5[I0, I1, R0, R1, R2, R3, R4]) {
	registerDoFnTypes(doFn)
	registerDoFn2x5StructWrappersAndFuncs[I0, I1, R0, R1, R2, R3, R4](doFn)
}

// Function2x5[I0, I1, R0, R1, R2, R3, R4 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function2x5[I0, I1, R0, R1, R2, R3, R4 any](doFn func(I0, I1) (R0, R1, R2, R3, R4)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1) (R0, R1, R2, R3, R4))
		return &caller2x5[I0, I1, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1) (R0, R1, R2, R3, R4))(nil)).Elem(), caller)
}

type genericDoFn3x5[I0, I1, I2, R0, R1, R2, R3, R4 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2) (R0, R1, R2, R3, R4)
}

type caller3x5[I0, I1, I2, R0, R1, R2, R3, R4 any] struct {
	fn func(I0, I1, I2) (R0, R1, R2, R3, R4)
}

func (c *caller3x5[I0, I1, I2, R0, R1, R2, R3, R4]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller3x5[I0, I1, I2, R0, R1, R2, R3, R4]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller3x5[I0, I1, I2, R0, R1, R2, R3, R4]) Call(args []any) []any {
	out0, out1, out2, out3, out4 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2))
	return []any{out0, out1, out2, out3, out4}
}

func (c *caller3x5[I0, I1, I2, R0, R1, R2, R3, R4]) Call3x5(arg0 any, arg1 any, arg2 any) (any, any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2))
}

func registerDoFn3x5StructWrappersAndFuncs[I0, I1, I2, R0, R1, R2, R3, R4 any](doFn genericDoFn3x5[I0, I1, I2, R0, R1, R2, R3, R4]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2) (R0, R1, R2, R3, R4))
		return &caller3x5[I0, I1, I2, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2) (R0, R1, R2, R3, R4))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2) (R0, R1, R2, R3, R4) {
			return fn.(genericDoFn3x5[I0, I1, I2, R0, R1, R2, R3, R4]).ProcessElement(a0, a1, a2)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, int, I0, I1, I2](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, int, I0, I1, I2](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn3x5[I0, I1, I2, R0, R1, R2, R3, R4 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn3x5[I0, I1, I2, R0, R1, R2, R3, R4 any](doFn genericDoFn3x5[I0, I1, I2, R0, R1, R2, R3, R4]) {
	registerDoFnTypes(doFn)
	registerDoFn3x5StructWrappersAndFuncs[I0, I1, I2, R0, R1, R2, R3, R4](doFn)
}

// Function3x5[I0, I1, I2, R0, R1, R2, R3, R4 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function3x5[I0, I1, I2, R0, R1, R2, R3, R4 any](doFn func(I0, I1, I2) (R0, R1, R2, R3, R4)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2) (R0, R1, R2, R3, R4))
		return &caller3x5[I0, I1, I2, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2) (R0, R1, R2, R3, R4))(nil)).Elem(), caller)
}

type genericDoFn4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3) (R0, R1, R2, R3, R4)
}

type caller4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4 any] struct {
	fn func(I0, I1, I2, I3) (R0, R1, R2, R3, R4)
}

func (c *caller4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4]) Call(args []any) []any {
	out0, out1, out2, out3, out4 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3))
	return []any{out0, out1, out2, out3, out4}
}

func (c *caller4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4]) Call4x5(arg0 any, arg1 any, arg2 any, arg3 any) (any, any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3))
}

func registerDoFn4x5StructWrappersAndFuncs[I0, I1, I2, I3, R0, R1, R2, R3, R4 any](doFn genericDoFn4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3) (R0, R1, R2, R3, R4))
		return &caller4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3) (R0, R1, R2, R3, R4))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3) (R0, R1, R2, R3, R4) {
			return fn.(genericDoFn4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4]).ProcessElement(a0, a1, a2, a3)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, int, I0, I1, I2, I3](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, int, I0, I1, I2, I3](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4 any](doFn genericDoFn4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4]) {
	registerDoFnTypes(doFn)
	registerDoFn4x5StructWrappersAndFuncs[I0, I1, I2, I3, R0, R1, R2, R3, R4](doFn)
}

// Function4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4 any](doFn func(I0, I1, I2, I3) (R0, R1, R2, R3, R4)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3) (R0, R1, R2, R3, R4))
		return &caller4x5[I0, I1, I2, I3, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3) (R0, R1, R2, R3, R4))(nil)).Elem(), caller)
}

type genericDoFn5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4) (R0, R1, R2, R3, R4)
}

type caller5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4 any] struct {
	fn func(I0, I1, I2, I3, I4) (R0, R1, R2, R3, R4)
}

func (c *caller5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4]) Call(args []any) []any {
	out0, out1, out2, out3, out4 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4))
	return []any{out0, out1, out2, out3, out4}
}

func (c *caller5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4]) Call5x5(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any) (any, any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4))
}

func registerDoFn5x5StructWrappersAndFuncs[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4 any](doFn genericDoFn5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4) (R0, R1, R2, R3, R4))
		return &caller5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4) (R0, R1, R2, R3, R4))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4) (R0, R1, R2, R3, R4) {
			return fn.(genericDoFn5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4]).ProcessElement(a0, a1, a2, a3, a4)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, int, I0, I1, I2, I3, I4](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, int, I0, I1, I2, I3, I4](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4 any](doFn genericDoFn5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4]) {
	registerDoFnTypes(doFn)
	registerDoFn5x5StructWrappersAndFuncs[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4](doFn)
}

// Function5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4 any](doFn func(I0, I1, I2, I3, I4) (R0, R1, R2, R3, R4)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4) (R0, R1, R2, R3, R4))
		return &caller5x5[I0, I1, I2, I3, I4, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4) (R0, R1, R2, R3, R4))(nil)).Elem(), caller)
}

type genericDoFn6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5) (R0, R1, R2, R3, R4)
}

type caller6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4 any] struct {
	fn func(I0, I1, I2, I3, I4, I5) (R0, R1, R2, R3, R4)
}

func (c *caller6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4]) Call(args []any) []any {
	out0, out1, out2, out3, out4 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5))
	return []any{out0, out1, out2, out3, out4}
}

func (c *caller6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4]) Call6x5(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any) (any, any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5))
}

func registerDoFn6x5StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4 any](doFn genericDoFn6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5) (R0, R1, R2, R3, R4))
		return &caller6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5) (R0, R1, R2, R3, R4))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5) (R0, R1, R2, R3, R4) {
			return fn.(genericDoFn6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4]).ProcessElement(a0, a1, a2, a3, a4, a5)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, int, I0, I1, I2, I3, I4, I5](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, int, I0, I1, I2, I3, I4, I5](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4 any](doFn genericDoFn6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4]) {
	registerDoFnTypes(doFn)
	registerDoFn6x5StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4](doFn)
}

// Function6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4 any](doFn func(I0, I1, I2, I3, I4, I5) (R0, R1, R2, R3, R4)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5) (R0, R1, R2, R3, R4))
		return &caller6x5[I0, I1, I2, I3, I4, I5, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5) (R0, R1, R2, R3, R4))(nil)).Elem(), caller)
}

type genericDoFn7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6) (R0, R1, R2, R3, R4)
}

type caller7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2, R3, R4)
}

func (c *caller7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4]) Call(args []any) []any {
	out0, out1, out2, out3, out4 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6))
	return []any{out0, out1, out2, out3, out4}
}

func (c *caller7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4]) Call7x5(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any) (any, any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6))
}

func registerDoFn7x5StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4 any](doFn genericDoFn7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2, R3, R4))
		return &caller7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2, R3, R4))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6) (R0, R1, R2, R3, R4) {
			return fn.(genericDoFn7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4]).ProcessElement(a0, a1, a2, a3, a4, a5, a6)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, int, I0, I1, I2, I3, I4, I5, I6](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, int, I0, I1, I2, I3, I4, I5, I6](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4 any](doFn genericDoFn7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4]) {
	registerDoFnTypes(doFn)
	registerDoFn7x5StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4](doFn)
}

// Function7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4 any](doFn func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2, R3, R4)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2, R3, R4))
		return &caller7x5[I0, I1, I2, I3, I4, I5, I6, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6) (R0, R1, R2, R3, R4))(nil)).Elem(), caller)
}

type genericDoFn8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7) (R0, R1, R2, R3, R4)
}

type caller8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2, R3, R4)
}

func (c *caller8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4]) Call(args []any) []any {
	out0, out1, out2, out3, out4 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7))
	return []any{out0, out1, out2, out3, out4}
}

func (c *caller8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4]) Call8x5(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any) (any, any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7))
}

func registerDoFn8x5StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4 any](doFn genericDoFn8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2, R3, R4))
		return &caller8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2, R3, R4))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7) (R0, R1, R2, R3, R4) {
			return fn.(genericDoFn8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, int, I0, I1, I2, I3, I4, I5, I6, I7](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, int, I0, I1, I2, I3, I4, I5, I6, I7](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4 any](doFn genericDoFn8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4]) {
	registerDoFnTypes(doFn)
	registerDoFn8x5StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4](doFn)
}

// Function8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2, R3, R4)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2, R3, R4))
		return &caller8x5[I0, I1, I2, I3, I4, I5, I6, I7, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7) (R0, R1, R2, R3, R4))(nil)).Elem(), caller)
}

type genericDoFn9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7, i8 I8) (R0, R1, R2, R3, R4)
}

type caller9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2, R3, R4)
}

func (c *caller9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4]) Call(args []any) []any {
	out0, out1, out2, out3, out4 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7), args[8].(I8))
	return []any{out0, out1, out2, out3, out4}
}

func (c *caller9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4]) Call9x5(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any, arg8 any) (any, any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7), arg8.(I8))
}

func registerDoFn9x5StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4 any](doFn genericDoFn9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2, R3, R4))
		return &caller9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2, R3, R4))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7, a8 I8) (R0, R1, R2, R3, R4) {
			return fn.(genericDoFn9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7, a8)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[int, I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[int, I0, I1, I2, I3, I4, I5, I6, I7, I8](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4 any](doFn genericDoFn9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4]) {
	registerDoFnTypes(doFn)
	registerDoFn9x5StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4](doFn)
}

// Function9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2, R3, R4)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2, R3, R4))
		return &caller9x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8) (R0, R1, R2, R3, R4))(nil)).Elem(), caller)
}

type genericDoFn10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4 any] interface {
	ProcessElement(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6, i7 I7, i8 I8, i9 I9) (R0, R1, R2, R3, R4)
}

type caller10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4 any] struct {
	fn func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2, R3, R4)
}

func (c *caller10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4]) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *caller10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4]) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *caller10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4]) Call(args []any) []any {
	out0, out1, out2, out3, out4 := c.fn(args[0].(I0), args[1].(I1), args[2].(I2), args[3].(I3), args[4].(I4), args[5].(I5), args[6].(I6), args[7].(I7), args[8].(I8), args[9].(I9))
	return []any{out0, out1, out2, out3, out4}
}

func (c *caller10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4]) Call10x5(arg0 any, arg1 any, arg2 any, arg3 any, arg4 any, arg5 any, arg6 any, arg7 any, arg8 any, arg9 any) (any, any, any, any, any) {
	return c.fn(arg0.(I0), arg1.(I1), arg2.(I2), arg3.(I3), arg4.(I4), arg5.(I5), arg6.(I6), arg7.(I7), arg8.(I8), arg9.(I9))
}

func registerDoFn10x5StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4 any](doFn genericDoFn10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4]) {
	processElementCaller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2, R3, R4))
		return &caller10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2, R3, R4))(nil)).Elem(), processElementCaller)
	processElementWrapper := func(fn any) reflectx.Func {
		return reflectx.MakeFunc(func(a0 I0, a1 I1, a2 I2, a3 I3, a4 I4, a5 I5, a6 I6, a7 I7, a8 I8, a9 I9) (R0, R1, R2, R3, R4) {
			return fn.(genericDoFn10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4]).ProcessElement(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
		})
	}
	startBundleWrapper := buildStartBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
	finishBundleWrapper := buildFinishBundleWrapper[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9](doFn)
	setupWrapper := buildSetupWrapper(doFn)
	teardownWrapper := buildTeardownWrapper(doFn)

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if processElementWrapper != nil {
			m["ProcessElement"] = processElementWrapper(fn)
		}
		if startBundleWrapper != nil {
			m["StartBundle"] = startBundleWrapper(fn)
		}
		if finishBundleWrapper != nil {
			m["FinishBundle"] = finishBundleWrapper(fn)
		}
		if setupWrapper != nil {
			m["Setup"] = setupWrapper(fn)
		}
		if teardownWrapper != nil {
			m["Teardown"] = teardownWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(doFn).Elem(), wrapperFn)
}

// DoFn10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4 any] registers your structural DoFn to optimize execution at runtime.
// DoFn input and output parameter types should be provided in order as the generic constraints.
func DoFn10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4 any](doFn genericDoFn10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4]) {
	registerDoFnTypes(doFn)
	registerDoFn10x5StructWrappersAndFuncs[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4](doFn)
}

// Function10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4 any] registers your functional DoFn to optimize execution at runtime.
// Function input and output parameter types should be provided in order as the generic constraints.
func Function10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4 any](doFn func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2, R3, R4)) {
	runtime.RegisterFunction(doFn)
	registerMethodTypes(reflect.TypeOf(doFn))
	caller := func(fn any) reflectx.Func {
		f := fn.(func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2, R3, R4))
		return &caller10x5[I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, R0, R1, R2, R3, R4]{fn: f}
	}
	reflectx.RegisterFunc(reflect.TypeOf((*func(I0, I1, I2, I3, I4, I5, I6, I7, I8, I9) (R0, R1, R2, R3, R4))(nil)).Elem(), caller)
}

type startBundle0x0 interface {
	StartBundle()
}

type finishBundle0x0 interface {
	FinishBundle()
}

type startBundle1x0[I0 any] interface {
	StartBundle(i0 I0)
}

type finishBundle1x0[I0 any] interface {
	FinishBundle(i0 I0)
}

type startBundle2x0[I0, I1 any] interface {
	StartBundle(i0 I0, i1 I1)
}

type finishBundle2x0[I0, I1 any] interface {
	FinishBundle(i0 I0, i1 I1)
}

type startBundle3x0[I0, I1, I2 any] interface {
	StartBundle(i0 I0, i1 I1, i2 I2)
}

type finishBundle3x0[I0, I1, I2 any] interface {
	FinishBundle(i0 I0, i1 I1, i2 I2)
}

type startBundle4x0[I0, I1, I2, I3 any] interface {
	StartBundle(i0 I0, i1 I1, i2 I2, i3 I3)
}

type finishBundle4x0[I0, I1, I2, I3 any] interface {
	FinishBundle(i0 I0, i1 I1, i2 I2, i3 I3)
}

type startBundle5x0[I0, I1, I2, I3, I4 any] interface {
	StartBundle(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4)
}

type finishBundle5x0[I0, I1, I2, I3, I4 any] interface {
	FinishBundle(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4)
}

type startBundle6x0[I0, I1, I2, I3, I4, I5 any] interface {
	StartBundle(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5)
}

type finishBundle6x0[I0, I1, I2, I3, I4, I5 any] interface {
	FinishBundle(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5)
}

type startBundle7x0[I0, I1, I2, I3, I4, I5, I6 any] interface {
	StartBundle(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6)
}

type finishBundle7x0[I0, I1, I2, I3, I4, I5, I6 any] interface {
	FinishBundle(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6)
}

type startBundle0x1[R0 any] interface {
	StartBundle() R0
}

type finishBundle0x1[R0 any] interface {
	FinishBundle() R0
}

type startBundle1x1[I0, R0 any] interface {
	StartBundle(i0 I0) R0
}

type finishBundle1x1[I0, R0 any] interface {
	FinishBundle(i0 I0) R0
}

type startBundle2x1[I0, I1, R0 any] interface {
	StartBundle(i0 I0, i1 I1) R0
}

type finishBundle2x1[I0, I1, R0 any] interface {
	FinishBundle(i0 I0, i1 I1) R0
}

type startBundle3x1[I0, I1, I2, R0 any] interface {
	StartBundle(i0 I0, i1 I1, i2 I2) R0
}

type finishBundle3x1[I0, I1, I2, R0 any] interface {
	FinishBundle(i0 I0, i1 I1, i2 I2) R0
}

type startBundle4x1[I0, I1, I2, I3, R0 any] interface {
	StartBundle(i0 I0, i1 I1, i2 I2, i3 I3) R0
}

type finishBundle4x1[I0, I1, I2, I3, R0 any] interface {
	FinishBundle(i0 I0, i1 I1, i2 I2, i3 I3) R0
}

type startBundle5x1[I0, I1, I2, I3, I4, R0 any] interface {
	StartBundle(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4) R0
}

type finishBundle5x1[I0, I1, I2, I3, I4, R0 any] interface {
	FinishBundle(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4) R0
}

type startBundle6x1[I0, I1, I2, I3, I4, I5, R0 any] interface {
	StartBundle(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5) R0
}

type finishBundle6x1[I0, I1, I2, I3, I4, I5, R0 any] interface {
	FinishBundle(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5) R0
}

type startBundle7x1[I0, I1, I2, I3, I4, I5, I6, R0 any] interface {
	StartBundle(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6) R0
}

type finishBundle7x1[I0, I1, I2, I3, I4, I5, I6, R0 any] interface {
	FinishBundle(i0 I0, i1 I1, i2 I2, i3 I3, i4 I4, i5 I5, i6 I6) R0
}

type setup0x0 interface {
	Setup()
}

type setup1x0 interface {
	Setup(ctx context.Context)
}

type setup0x1 interface {
	Setup() error
}

type setup1x1 interface {
	Setup(ctx context.Context) error
}

type teardown0x0 interface {
	Teardown()
}

type teardown1x0 interface {
	Teardown(ctx context.Context)
}

type teardown0x1 interface {
	Teardown() error
}

type teardown1x1 interface {
	Teardown(ctx context.Context) error
}

type createAccumulator0x1[T any] interface {
	CreateAccumulator() T
}

type createAccumulator0x2[T any] interface {
	CreateAccumulator() (T, error)
}

type addInput2x1[T1, T2 any] interface {
	AddInput(a T1, i T2) T1
}

type addInput2x2[T1, T2 any] interface {
	AddInput(a T1, i T2) (T1, error)
}

type mergeAccumulators2x1[T any] interface {
	MergeAccumulators(a0 T, a1 T) T
}

type mergeAccumulators2x2[T any] interface {
	MergeAccumulators(a0 T, a1 T) (T, error)
}

type extractOutput1x1[T1, T2 any] interface {
	ExtractOutput(a T1) T2
}

type extractOutput1x2[T1, T2 any] interface {
	ExtractOutput(a T1) (T2, error)
}

// Combiner1 registers a CombineFn's structural functions
// and types and optimizes their runtime execution. There are 3 different Combiner
// functions, each of which should be used for a different situation.
// Combiner1 should be used when your accumulator, input, and output are all of the same type.
// It can be called with register.Combiner1[T](&CustomCombiner{})
// where T is the type of the input/accumulator/output.
func Combiner1[T0 any](accum any) {
	registerCombinerTypes(accum)
	accumVal := reflect.ValueOf(accum)
	var mergeAccumulatorsWrapper func(fn any) reflectx.Func
	if _, ok := accum.(mergeAccumulators2x2[T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T0) (T0, error))
			return &caller2x2[T0, T0, T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T0) (T0, error))(nil)).Elem(), caller)

		mergeAccumulatorsWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T0) (T0, error) {
				return fn.(mergeAccumulators2x2[T0]).MergeAccumulators(a0, a1)
			})
		}
	} else if _, ok := accum.(mergeAccumulators2x1[T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T0) T0)
			return &caller2x1[T0, T0, T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T0) T0)(nil)).Elem(), caller)

		mergeAccumulatorsWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T0) T0 {
				return fn.(mergeAccumulators2x1[T0]).MergeAccumulators(a0, a1)
			})
		}
	}

	if mergeAccumulatorsWrapper == nil {
		panic(fmt.Sprintf("Failed to optimize MergeAccumulators for combiner %v. Failed to infer types", accum))
	}

	var createAccumulatorWrapper func(fn any) reflectx.Func
	if _, ok := accum.(createAccumulator0x2[T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func() (T0, error))
			return &caller0x2[T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func() (T0, error))(nil)).Elem(), caller)

		createAccumulatorWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func() (T0, error) {
				return fn.(createAccumulator0x2[T0]).CreateAccumulator()
			})
		}
	} else if _, ok := accum.(createAccumulator0x1[T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func() T0)
			return &caller0x1[T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func() T0)(nil)).Elem(), caller)

		createAccumulatorWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func() T0 {
				return fn.(createAccumulator0x1[T0]).CreateAccumulator()
			})
		}
	}
	if m := accumVal.MethodByName("CreateAccumulator"); m.IsValid() && createAccumulatorWrapper == nil {
		panic(fmt.Sprintf("Failed to optimize CreateAccumulator for combiner %v. Failed to infer types", accum))
	}

	var addInputWrapper func(fn any) reflectx.Func
	if _, ok := accum.(addInput2x2[T0, T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T0) (T0, error))
			return &caller2x2[T0, T0, T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T0) (T0, error))(nil)).Elem(), caller)

		addInputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T0) (T0, error) {
				return fn.(addInput2x2[T0, T0]).AddInput(a0, a1)
			})
		}
	} else if _, ok := accum.(addInput2x1[T0, T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T0) T0)
			return &caller2x1[T0, T0, T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T0) T0)(nil)).Elem(), caller)

		addInputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T0) T0 {
				return fn.(addInput2x1[T0, T0]).AddInput(a0, a1)
			})
		}
	}

	if m := accumVal.MethodByName("AddInput"); m.IsValid() && addInputWrapper == nil {
		panic(fmt.Sprintf("Failed to optimize AddInput for combiner %v. Failed to infer types", accum))
	}

	var extractOutputWrapper func(fn any) reflectx.Func
	if _, ok := accum.(extractOutput1x2[T0, T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0) (T0, error))
			return &caller1x2[T0, T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0) (T0, error))(nil)).Elem(), caller)

		extractOutputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0) (T0, error) {
				return fn.(extractOutput1x2[T0, T0]).ExtractOutput(a0)
			})
		}
	} else if _, ok := accum.(extractOutput1x1[T0, T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0) T0)
			return &caller1x1[T0, T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0) T0)(nil)).Elem(), caller)

		extractOutputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0) T0 {
				return fn.(extractOutput1x1[T0, T0]).ExtractOutput(a0)
			})
		}
	}

	if m := accumVal.MethodByName("ExtractOutput"); m.IsValid() && extractOutputWrapper == nil {
		panic(fmt.Sprintf("Failed to optimize ExtractOutput for combiner %v. Failed to infer types", accum))
	}

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if mergeAccumulatorsWrapper != nil {
			m["MergeAccumulators"] = mergeAccumulatorsWrapper(fn)
		}
		if createAccumulatorWrapper != nil {
			m["CreateAccumulator"] = createAccumulatorWrapper(fn)
		}
		if addInputWrapper != nil {
			m["AddInput"] = addInputWrapper(fn)
		}
		if extractOutputWrapper != nil {
			m["ExtractOutput"] = extractOutputWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(accum).Elem(), wrapperFn)
}

// Combiner2 registers a CombineFn's structural functions
// and types and optimizes their runtime execution. There are 3 different Combiner
// functions, each of which should be used for a different situation.
// Combiner2 should be used when your accumulator, input, and output are 2 distinct types.
// It can be called with register.Combiner2[T1, T2](&CustomCombiner{})
// where T1 is the type of the accumulator and T2 is the other type.
func Combiner2[T0, T1 any](accum any) {
	registerCombinerTypes(accum)
	accumVal := reflect.ValueOf(accum)
	var mergeAccumulatorsWrapper func(fn any) reflectx.Func
	if _, ok := accum.(mergeAccumulators2x2[T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T0) (T0, error))
			return &caller2x2[T0, T0, T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T0) (T0, error))(nil)).Elem(), caller)

		mergeAccumulatorsWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T0) (T0, error) {
				return fn.(mergeAccumulators2x2[T0]).MergeAccumulators(a0, a1)
			})
		}
	} else if _, ok := accum.(mergeAccumulators2x1[T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T0) T0)
			return &caller2x1[T0, T0, T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T0) T0)(nil)).Elem(), caller)

		mergeAccumulatorsWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T0) T0 {
				return fn.(mergeAccumulators2x1[T0]).MergeAccumulators(a0, a1)
			})
		}
	}

	if mergeAccumulatorsWrapper == nil {
		panic(fmt.Sprintf("Failed to optimize MergeAccumulators for combiner %v. Failed to infer types", accum))
	}

	var createAccumulatorWrapper func(fn any) reflectx.Func
	if _, ok := accum.(createAccumulator0x2[T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func() (T0, error))
			return &caller0x2[T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func() (T0, error))(nil)).Elem(), caller)

		createAccumulatorWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func() (T0, error) {
				return fn.(createAccumulator0x2[T0]).CreateAccumulator()
			})
		}
	} else if _, ok := accum.(createAccumulator0x1[T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func() T0)
			return &caller0x1[T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func() T0)(nil)).Elem(), caller)

		createAccumulatorWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func() T0 {
				return fn.(createAccumulator0x1[T0]).CreateAccumulator()
			})
		}
	}
	if m := accumVal.MethodByName("CreateAccumulator"); m.IsValid() && createAccumulatorWrapper == nil {
		panic(fmt.Sprintf("Failed to optimize CreateAccumulator for combiner %v. Failed to infer types", accum))
	}

	var addInputWrapper func(fn any) reflectx.Func
	if _, ok := accum.(addInput2x2[T0, T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T0) (T0, error))
			return &caller2x2[T0, T0, T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T0) (T0, error))(nil)).Elem(), caller)

		addInputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T0) (T0, error) {
				return fn.(addInput2x2[T0, T0]).AddInput(a0, a1)
			})
		}
	} else if _, ok := accum.(addInput2x1[T0, T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T0) T0)
			return &caller2x1[T0, T0, T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T0) T0)(nil)).Elem(), caller)

		addInputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T0) T0 {
				return fn.(addInput2x1[T0, T0]).AddInput(a0, a1)
			})
		}
	} else if _, ok := accum.(addInput2x2[T0, T1]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T1) (T0, error))
			return &caller2x2[T0, T1, T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T1) (T0, error))(nil)).Elem(), caller)

		addInputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T1) (T0, error) {
				return fn.(addInput2x2[T0, T1]).AddInput(a0, a1)
			})
		}
	} else if _, ok := accum.(addInput2x1[T0, T1]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T1) T0)
			return &caller2x1[T0, T1, T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T1) T0)(nil)).Elem(), caller)

		addInputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T1) T0 {
				return fn.(addInput2x1[T0, T1]).AddInput(a0, a1)
			})
		}
	}

	if m := accumVal.MethodByName("AddInput"); m.IsValid() && addInputWrapper == nil {
		panic(fmt.Sprintf("Failed to optimize AddInput for combiner %v. Failed to infer types", accum))
	}

	var extractOutputWrapper func(fn any) reflectx.Func
	if _, ok := accum.(extractOutput1x2[T0, T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0) (T0, error))
			return &caller1x2[T0, T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0) (T0, error))(nil)).Elem(), caller)

		extractOutputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0) (T0, error) {
				return fn.(extractOutput1x2[T0, T0]).ExtractOutput(a0)
			})
		}
	} else if _, ok := accum.(extractOutput1x1[T0, T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0) T0)
			return &caller1x1[T0, T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0) T0)(nil)).Elem(), caller)

		extractOutputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0) T0 {
				return fn.(extractOutput1x1[T0, T0]).ExtractOutput(a0)
			})
		}
	} else if _, ok := accum.(extractOutput1x2[T0, T1]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0) (T1, error))
			return &caller1x2[T0, T1, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0) (T1, error))(nil)).Elem(), caller)

		extractOutputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0) (T1, error) {
				return fn.(extractOutput1x2[T0, T1]).ExtractOutput(a0)
			})
		}
	} else if _, ok := accum.(extractOutput1x1[T0, T1]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0) T1)
			return &caller1x1[T0, T1]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0) T1)(nil)).Elem(), caller)

		extractOutputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0) T1 {
				return fn.(extractOutput1x1[T0, T1]).ExtractOutput(a0)
			})
		}
	}

	if m := accumVal.MethodByName("ExtractOutput"); m.IsValid() && extractOutputWrapper == nil {
		panic(fmt.Sprintf("Failed to optimize ExtractOutput for combiner %v. Failed to infer types", accum))
	}

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if mergeAccumulatorsWrapper != nil {
			m["MergeAccumulators"] = mergeAccumulatorsWrapper(fn)
		}
		if createAccumulatorWrapper != nil {
			m["CreateAccumulator"] = createAccumulatorWrapper(fn)
		}
		if addInputWrapper != nil {
			m["AddInput"] = addInputWrapper(fn)
		}
		if extractOutputWrapper != nil {
			m["ExtractOutput"] = extractOutputWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(accum).Elem(), wrapperFn)
}

// Combiner3 registers a CombineFn's structural functions
// and types and optimizes their runtime execution. There are 3 different Combiner
// functions, each of which should be used for a different situation.
// Combiner3 should be used when your accumulator, input, and output are 3 distinct types.
// It can be called with register.Combiner3[T1, T2, T3](&CustomCombiner{})
// where T1 is the type of the accumulator, T2 is the type of the input, and T3 is the type of the output.
func Combiner3[T0, T1, T2 any](accum any) {
	registerCombinerTypes(accum)
	accumVal := reflect.ValueOf(accum)
	var mergeAccumulatorsWrapper func(fn any) reflectx.Func
	if _, ok := accum.(mergeAccumulators2x2[T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T0) (T0, error))
			return &caller2x2[T0, T0, T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T0) (T0, error))(nil)).Elem(), caller)

		mergeAccumulatorsWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T0) (T0, error) {
				return fn.(mergeAccumulators2x2[T0]).MergeAccumulators(a0, a1)
			})
		}
	} else if _, ok := accum.(mergeAccumulators2x1[T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T0) T0)
			return &caller2x1[T0, T0, T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T0) T0)(nil)).Elem(), caller)

		mergeAccumulatorsWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T0) T0 {
				return fn.(mergeAccumulators2x1[T0]).MergeAccumulators(a0, a1)
			})
		}
	}

	if mergeAccumulatorsWrapper == nil {
		panic(fmt.Sprintf("Failed to optimize MergeAccumulators for combiner %v. Failed to infer types", accum))
	}

	var createAccumulatorWrapper func(fn any) reflectx.Func
	if _, ok := accum.(createAccumulator0x2[T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func() (T0, error))
			return &caller0x2[T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func() (T0, error))(nil)).Elem(), caller)

		createAccumulatorWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func() (T0, error) {
				return fn.(createAccumulator0x2[T0]).CreateAccumulator()
			})
		}
	} else if _, ok := accum.(createAccumulator0x1[T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func() T0)
			return &caller0x1[T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func() T0)(nil)).Elem(), caller)

		createAccumulatorWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func() T0 {
				return fn.(createAccumulator0x1[T0]).CreateAccumulator()
			})
		}
	}
	if m := accumVal.MethodByName("CreateAccumulator"); m.IsValid() && createAccumulatorWrapper == nil {
		panic(fmt.Sprintf("Failed to optimize CreateAccumulator for combiner %v. Failed to infer types", accum))
	}

	var addInputWrapper func(fn any) reflectx.Func
	if _, ok := accum.(addInput2x2[T0, T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T0) (T0, error))
			return &caller2x2[T0, T0, T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T0) (T0, error))(nil)).Elem(), caller)

		addInputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T0) (T0, error) {
				return fn.(addInput2x2[T0, T0]).AddInput(a0, a1)
			})
		}
	} else if _, ok := accum.(addInput2x1[T0, T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T0) T0)
			return &caller2x1[T0, T0, T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T0) T0)(nil)).Elem(), caller)

		addInputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T0) T0 {
				return fn.(addInput2x1[T0, T0]).AddInput(a0, a1)
			})
		}
	} else if _, ok := accum.(addInput2x2[T0, T1]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T1) (T0, error))
			return &caller2x2[T0, T1, T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T1) (T0, error))(nil)).Elem(), caller)

		addInputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T1) (T0, error) {
				return fn.(addInput2x2[T0, T1]).AddInput(a0, a1)
			})
		}
	} else if _, ok := accum.(addInput2x1[T0, T1]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T1) T0)
			return &caller2x1[T0, T1, T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T1) T0)(nil)).Elem(), caller)

		addInputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T1) T0 {
				return fn.(addInput2x1[T0, T1]).AddInput(a0, a1)
			})
		}
	} else if _, ok := accum.(addInput2x2[T0, T2]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T2) (T0, error))
			return &caller2x2[T0, T2, T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T2) (T0, error))(nil)).Elem(), caller)

		addInputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T2) (T0, error) {
				return fn.(addInput2x2[T0, T2]).AddInput(a0, a1)
			})
		}
	} else if _, ok := accum.(addInput2x1[T0, T2]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0, T2) T0)
			return &caller2x1[T0, T2, T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0, T2) T0)(nil)).Elem(), caller)

		addInputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0, a1 T2) T0 {
				return fn.(addInput2x1[T0, T2]).AddInput(a0, a1)
			})
		}
	}

	if m := accumVal.MethodByName("AddInput"); m.IsValid() && addInputWrapper == nil {
		panic(fmt.Sprintf("Failed to optimize AddInput for combiner %v. Failed to infer types", accum))
	}

	var extractOutputWrapper func(fn any) reflectx.Func
	if _, ok := accum.(extractOutput1x2[T0, T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0) (T0, error))
			return &caller1x2[T0, T0, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0) (T0, error))(nil)).Elem(), caller)

		extractOutputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0) (T0, error) {
				return fn.(extractOutput1x2[T0, T0]).ExtractOutput(a0)
			})
		}
	} else if _, ok := accum.(extractOutput1x1[T0, T0]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0) T0)
			return &caller1x1[T0, T0]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0) T0)(nil)).Elem(), caller)

		extractOutputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0) T0 {
				return fn.(extractOutput1x1[T0, T0]).ExtractOutput(a0)
			})
		}
	} else if _, ok := accum.(extractOutput1x2[T0, T1]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0) (T1, error))
			return &caller1x2[T0, T1, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0) (T1, error))(nil)).Elem(), caller)

		extractOutputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0) (T1, error) {
				return fn.(extractOutput1x2[T0, T1]).ExtractOutput(a0)
			})
		}
	} else if _, ok := accum.(extractOutput1x1[T0, T1]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0) T1)
			return &caller1x1[T0, T1]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0) T1)(nil)).Elem(), caller)

		extractOutputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0) T1 {
				return fn.(extractOutput1x1[T0, T1]).ExtractOutput(a0)
			})
		}
	} else if _, ok := accum.(extractOutput1x2[T0, T2]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0) (T2, error))
			return &caller1x2[T0, T2, error]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0) (T2, error))(nil)).Elem(), caller)

		extractOutputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0) (T2, error) {
				return fn.(extractOutput1x2[T0, T2]).ExtractOutput(a0)
			})
		}
	} else if _, ok := accum.(extractOutput1x1[T0, T2]); ok {
		caller := func(fn any) reflectx.Func {
			f := fn.(func(T0) T2)
			return &caller1x1[T0, T2]{fn: f}
		}
		reflectx.RegisterFunc(reflect.TypeOf((*func(T0) T2)(nil)).Elem(), caller)

		extractOutputWrapper = func(fn any) reflectx.Func {
			return reflectx.MakeFunc(func(a0 T0) T2 {
				return fn.(extractOutput1x1[T0, T2]).ExtractOutput(a0)
			})
		}
	}

	if m := accumVal.MethodByName("ExtractOutput"); m.IsValid() && extractOutputWrapper == nil {
		panic(fmt.Sprintf("Failed to optimize ExtractOutput for combiner %v. Failed to infer types", accum))
	}

	wrapperFn := func(fn any) map[string]reflectx.Func {
		m := map[string]reflectx.Func{}
		if mergeAccumulatorsWrapper != nil {
			m["MergeAccumulators"] = mergeAccumulatorsWrapper(fn)
		}
		if createAccumulatorWrapper != nil {
			m["CreateAccumulator"] = createAccumulatorWrapper(fn)
		}
		if addInputWrapper != nil {
			m["AddInput"] = addInputWrapper(fn)
		}
		if extractOutputWrapper != nil {
			m["ExtractOutput"] = extractOutputWrapper(fn)
		}

		return m
	}
	reflectx.RegisterStructWrapper(reflect.TypeOf(accum).Elem(), wrapperFn)
}

func registerCombinerTypes(accum any) {
	// Register the combiner
	runtime.RegisterType(reflect.TypeOf(accum).Elem())
	schema.RegisterType(reflect.TypeOf(accum).Elem())

	// Register all types in the Combiner.
	// There may be different types across MergeAccumulators, AddInput, and ExtractOutput.
	accumVal := reflect.ValueOf(accum)
	registerMethodTypes(accumVal.MethodByName("MergeAccumulators").Type())
	if m := accumVal.MethodByName("AddInput"); m.IsValid() {
		registerMethodTypes(m.Type())
	}
	if m := accumVal.MethodByName("ExtractOutput"); m.IsValid() {
		registerMethodTypes(m.Type())
	}
}

func registerDoFnTypes(doFn any) {
	// Register the doFn
	runtime.RegisterType(reflect.TypeOf(doFn).Elem())
	schema.RegisterType(reflect.TypeOf(doFn).Elem())

	// Register all types in the DoFn
	registerMethodTypes(reflect.ValueOf(doFn).MethodByName("ProcessElement").Type())
}

func registerMethodTypes(fn reflect.Type) {
	for i := 0; i < fn.NumIn(); i++ {
		in := reflectx.SkipPtr(fn.In(i))
		if in.Kind() == reflect.Struct {
			runtime.RegisterType(in)
			schema.RegisterType(in)
		}
	}
	for i := 0; i < fn.NumOut(); i++ {
		out := reflectx.SkipPtr(fn.Out(i))
		if out.Kind() == reflect.Struct {
			runtime.RegisterType(out)
			schema.RegisterType(out)
		}
	}
}
