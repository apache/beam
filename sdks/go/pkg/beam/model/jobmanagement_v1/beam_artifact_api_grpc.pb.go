//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// Protocol Buffers describing the Artifact API, for communicating with a runner
// for artifact staging and retrieval over GRPC.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.27.3
// source: org/apache/beam/model/job_management/v1/beam_artifact_api.proto

package jobmanagement_v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ArtifactRetrievalService_ResolveArtifacts_FullMethodName = "/org.apache.beam.model.job_management.v1.ArtifactRetrievalService/ResolveArtifacts"
	ArtifactRetrievalService_GetArtifact_FullMethodName      = "/org.apache.beam.model.job_management.v1.ArtifactRetrievalService/GetArtifact"
)

// ArtifactRetrievalServiceClient is the client API for ArtifactRetrievalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// A service to retrieve artifacts for use in a Job.
type ArtifactRetrievalServiceClient interface {
	// Resolves the given artifact references into one or more replacement
	// artifact references (e.g. a Maven dependency into a (transitive) set
	// of jars.
	ResolveArtifacts(ctx context.Context, in *ResolveArtifactsRequest, opts ...grpc.CallOption) (*ResolveArtifactsResponse, error)
	// Retrieves the given artifact as a stream of bytes.
	GetArtifact(ctx context.Context, in *GetArtifactRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetArtifactResponse], error)
}

type artifactRetrievalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewArtifactRetrievalServiceClient(cc grpc.ClientConnInterface) ArtifactRetrievalServiceClient {
	return &artifactRetrievalServiceClient{cc}
}

func (c *artifactRetrievalServiceClient) ResolveArtifacts(ctx context.Context, in *ResolveArtifactsRequest, opts ...grpc.CallOption) (*ResolveArtifactsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveArtifactsResponse)
	err := c.cc.Invoke(ctx, ArtifactRetrievalService_ResolveArtifacts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artifactRetrievalServiceClient) GetArtifact(ctx context.Context, in *GetArtifactRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetArtifactResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ArtifactRetrievalService_ServiceDesc.Streams[0], ArtifactRetrievalService_GetArtifact_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetArtifactRequest, GetArtifactResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ArtifactRetrievalService_GetArtifactClient = grpc.ServerStreamingClient[GetArtifactResponse]

// ArtifactRetrievalServiceServer is the server API for ArtifactRetrievalService service.
// All implementations must embed UnimplementedArtifactRetrievalServiceServer
// for forward compatibility.
//
// A service to retrieve artifacts for use in a Job.
type ArtifactRetrievalServiceServer interface {
	// Resolves the given artifact references into one or more replacement
	// artifact references (e.g. a Maven dependency into a (transitive) set
	// of jars.
	ResolveArtifacts(context.Context, *ResolveArtifactsRequest) (*ResolveArtifactsResponse, error)
	// Retrieves the given artifact as a stream of bytes.
	GetArtifact(*GetArtifactRequest, grpc.ServerStreamingServer[GetArtifactResponse]) error
	mustEmbedUnimplementedArtifactRetrievalServiceServer()
}

// UnimplementedArtifactRetrievalServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedArtifactRetrievalServiceServer struct{}

func (UnimplementedArtifactRetrievalServiceServer) ResolveArtifacts(context.Context, *ResolveArtifactsRequest) (*ResolveArtifactsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveArtifacts not implemented")
}
func (UnimplementedArtifactRetrievalServiceServer) GetArtifact(*GetArtifactRequest, grpc.ServerStreamingServer[GetArtifactResponse]) error {
	return status.Errorf(codes.Unimplemented, "method GetArtifact not implemented")
}
func (UnimplementedArtifactRetrievalServiceServer) mustEmbedUnimplementedArtifactRetrievalServiceServer() {
}
func (UnimplementedArtifactRetrievalServiceServer) testEmbeddedByValue() {}

// UnsafeArtifactRetrievalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ArtifactRetrievalServiceServer will
// result in compilation errors.
type UnsafeArtifactRetrievalServiceServer interface {
	mustEmbedUnimplementedArtifactRetrievalServiceServer()
}

func RegisterArtifactRetrievalServiceServer(s grpc.ServiceRegistrar, srv ArtifactRetrievalServiceServer) {
	// If the following call pancis, it indicates UnimplementedArtifactRetrievalServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ArtifactRetrievalService_ServiceDesc, srv)
}

func _ArtifactRetrievalService_ResolveArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveArtifactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtifactRetrievalServiceServer).ResolveArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ArtifactRetrievalService_ResolveArtifacts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtifactRetrievalServiceServer).ResolveArtifacts(ctx, req.(*ResolveArtifactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtifactRetrievalService_GetArtifact_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetArtifactRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ArtifactRetrievalServiceServer).GetArtifact(m, &grpc.GenericServerStream[GetArtifactRequest, GetArtifactResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ArtifactRetrievalService_GetArtifactServer = grpc.ServerStreamingServer[GetArtifactResponse]

// ArtifactRetrievalService_ServiceDesc is the grpc.ServiceDesc for ArtifactRetrievalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ArtifactRetrievalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "org.apache.beam.model.job_management.v1.ArtifactRetrievalService",
	HandlerType: (*ArtifactRetrievalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResolveArtifacts",
			Handler:    _ArtifactRetrievalService_ResolveArtifacts_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetArtifact",
			Handler:       _ArtifactRetrievalService_GetArtifact_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "org/apache/beam/model/job_management/v1/beam_artifact_api.proto",
}

const (
	ArtifactStagingService_ReverseArtifactRetrievalService_FullMethodName = "/org.apache.beam.model.job_management.v1.ArtifactStagingService/ReverseArtifactRetrievalService"
)

// ArtifactStagingServiceClient is the client API for ArtifactStagingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// A service that allows the client to act as an ArtifactRetrievalService,
// for a particular job with the server initiating requests and receiving
// responses.
//
// A client calls the service with an ArtifactResponseWrapper that has the
// staging token set, and thereafter responds to the server's requests.
type ArtifactStagingServiceClient interface {
	ReverseArtifactRetrievalService(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ArtifactResponseWrapper, ArtifactRequestWrapper], error)
}

type artifactStagingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewArtifactStagingServiceClient(cc grpc.ClientConnInterface) ArtifactStagingServiceClient {
	return &artifactStagingServiceClient{cc}
}

func (c *artifactStagingServiceClient) ReverseArtifactRetrievalService(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ArtifactResponseWrapper, ArtifactRequestWrapper], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ArtifactStagingService_ServiceDesc.Streams[0], ArtifactStagingService_ReverseArtifactRetrievalService_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ArtifactResponseWrapper, ArtifactRequestWrapper]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ArtifactStagingService_ReverseArtifactRetrievalServiceClient = grpc.BidiStreamingClient[ArtifactResponseWrapper, ArtifactRequestWrapper]

// ArtifactStagingServiceServer is the server API for ArtifactStagingService service.
// All implementations must embed UnimplementedArtifactStagingServiceServer
// for forward compatibility.
//
// A service that allows the client to act as an ArtifactRetrievalService,
// for a particular job with the server initiating requests and receiving
// responses.
//
// A client calls the service with an ArtifactResponseWrapper that has the
// staging token set, and thereafter responds to the server's requests.
type ArtifactStagingServiceServer interface {
	ReverseArtifactRetrievalService(grpc.BidiStreamingServer[ArtifactResponseWrapper, ArtifactRequestWrapper]) error
	mustEmbedUnimplementedArtifactStagingServiceServer()
}

// UnimplementedArtifactStagingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedArtifactStagingServiceServer struct{}

func (UnimplementedArtifactStagingServiceServer) ReverseArtifactRetrievalService(grpc.BidiStreamingServer[ArtifactResponseWrapper, ArtifactRequestWrapper]) error {
	return status.Errorf(codes.Unimplemented, "method ReverseArtifactRetrievalService not implemented")
}
func (UnimplementedArtifactStagingServiceServer) mustEmbedUnimplementedArtifactStagingServiceServer() {
}
func (UnimplementedArtifactStagingServiceServer) testEmbeddedByValue() {}

// UnsafeArtifactStagingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ArtifactStagingServiceServer will
// result in compilation errors.
type UnsafeArtifactStagingServiceServer interface {
	mustEmbedUnimplementedArtifactStagingServiceServer()
}

func RegisterArtifactStagingServiceServer(s grpc.ServiceRegistrar, srv ArtifactStagingServiceServer) {
	// If the following call pancis, it indicates UnimplementedArtifactStagingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ArtifactStagingService_ServiceDesc, srv)
}

func _ArtifactStagingService_ReverseArtifactRetrievalService_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ArtifactStagingServiceServer).ReverseArtifactRetrievalService(&grpc.GenericServerStream[ArtifactResponseWrapper, ArtifactRequestWrapper]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ArtifactStagingService_ReverseArtifactRetrievalServiceServer = grpc.BidiStreamingServer[ArtifactResponseWrapper, ArtifactRequestWrapper]

// ArtifactStagingService_ServiceDesc is the grpc.ServiceDesc for ArtifactStagingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ArtifactStagingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "org.apache.beam.model.job_management.v1.ArtifactStagingService",
	HandlerType: (*ArtifactStagingServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReverseArtifactRetrievalService",
			Handler:       _ArtifactStagingService_ReverseArtifactRetrievalService_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "org/apache/beam/model/job_management/v1/beam_artifact_api.proto",
}

const (
	LegacyArtifactStagingService_PutArtifact_FullMethodName    = "/org.apache.beam.model.job_management.v1.LegacyArtifactStagingService/PutArtifact"
	LegacyArtifactStagingService_CommitManifest_FullMethodName = "/org.apache.beam.model.job_management.v1.LegacyArtifactStagingService/CommitManifest"
)

// LegacyArtifactStagingServiceClient is the client API for LegacyArtifactStagingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// A service to stage artifacts for use in a Job.
type LegacyArtifactStagingServiceClient interface {
	// Stage an artifact to be available during job execution. The first request must contain the
	// name of the artifact. All future requests must contain sequential chunks of the content of
	// the artifact.
	PutArtifact(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[PutArtifactRequest, PutArtifactResponse], error)
	// Commit the manifest for a Job. All artifacts must have been successfully uploaded
	// before this call is made.
	//
	// Throws error INVALID_ARGUMENT if not all of the members of the manifest are present
	CommitManifest(ctx context.Context, in *CommitManifestRequest, opts ...grpc.CallOption) (*CommitManifestResponse, error)
}

type legacyArtifactStagingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLegacyArtifactStagingServiceClient(cc grpc.ClientConnInterface) LegacyArtifactStagingServiceClient {
	return &legacyArtifactStagingServiceClient{cc}
}

func (c *legacyArtifactStagingServiceClient) PutArtifact(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[PutArtifactRequest, PutArtifactResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LegacyArtifactStagingService_ServiceDesc.Streams[0], LegacyArtifactStagingService_PutArtifact_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[PutArtifactRequest, PutArtifactResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LegacyArtifactStagingService_PutArtifactClient = grpc.ClientStreamingClient[PutArtifactRequest, PutArtifactResponse]

func (c *legacyArtifactStagingServiceClient) CommitManifest(ctx context.Context, in *CommitManifestRequest, opts ...grpc.CallOption) (*CommitManifestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommitManifestResponse)
	err := c.cc.Invoke(ctx, LegacyArtifactStagingService_CommitManifest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LegacyArtifactStagingServiceServer is the server API for LegacyArtifactStagingService service.
// All implementations must embed UnimplementedLegacyArtifactStagingServiceServer
// for forward compatibility.
//
// A service to stage artifacts for use in a Job.
type LegacyArtifactStagingServiceServer interface {
	// Stage an artifact to be available during job execution. The first request must contain the
	// name of the artifact. All future requests must contain sequential chunks of the content of
	// the artifact.
	PutArtifact(grpc.ClientStreamingServer[PutArtifactRequest, PutArtifactResponse]) error
	// Commit the manifest for a Job. All artifacts must have been successfully uploaded
	// before this call is made.
	//
	// Throws error INVALID_ARGUMENT if not all of the members of the manifest are present
	CommitManifest(context.Context, *CommitManifestRequest) (*CommitManifestResponse, error)
	mustEmbedUnimplementedLegacyArtifactStagingServiceServer()
}

// UnimplementedLegacyArtifactStagingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLegacyArtifactStagingServiceServer struct{}

func (UnimplementedLegacyArtifactStagingServiceServer) PutArtifact(grpc.ClientStreamingServer[PutArtifactRequest, PutArtifactResponse]) error {
	return status.Errorf(codes.Unimplemented, "method PutArtifact not implemented")
}
func (UnimplementedLegacyArtifactStagingServiceServer) CommitManifest(context.Context, *CommitManifestRequest) (*CommitManifestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitManifest not implemented")
}
func (UnimplementedLegacyArtifactStagingServiceServer) mustEmbedUnimplementedLegacyArtifactStagingServiceServer() {
}
func (UnimplementedLegacyArtifactStagingServiceServer) testEmbeddedByValue() {}

// UnsafeLegacyArtifactStagingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LegacyArtifactStagingServiceServer will
// result in compilation errors.
type UnsafeLegacyArtifactStagingServiceServer interface {
	mustEmbedUnimplementedLegacyArtifactStagingServiceServer()
}

func RegisterLegacyArtifactStagingServiceServer(s grpc.ServiceRegistrar, srv LegacyArtifactStagingServiceServer) {
	// If the following call pancis, it indicates UnimplementedLegacyArtifactStagingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LegacyArtifactStagingService_ServiceDesc, srv)
}

func _LegacyArtifactStagingService_PutArtifact_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LegacyArtifactStagingServiceServer).PutArtifact(&grpc.GenericServerStream[PutArtifactRequest, PutArtifactResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LegacyArtifactStagingService_PutArtifactServer = grpc.ClientStreamingServer[PutArtifactRequest, PutArtifactResponse]

func _LegacyArtifactStagingService_CommitManifest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitManifestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LegacyArtifactStagingServiceServer).CommitManifest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LegacyArtifactStagingService_CommitManifest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LegacyArtifactStagingServiceServer).CommitManifest(ctx, req.(*CommitManifestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LegacyArtifactStagingService_ServiceDesc is the grpc.ServiceDesc for LegacyArtifactStagingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LegacyArtifactStagingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "org.apache.beam.model.job_management.v1.LegacyArtifactStagingService",
	HandlerType: (*LegacyArtifactStagingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CommitManifest",
			Handler:    _LegacyArtifactStagingService_CommitManifest_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutArtifact",
			Handler:       _LegacyArtifactStagingService_PutArtifact_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "org/apache/beam/model/job_management/v1/beam_artifact_api.proto",
}

const (
	LegacyArtifactRetrievalService_GetManifest_FullMethodName = "/org.apache.beam.model.job_management.v1.LegacyArtifactRetrievalService/GetManifest"
	LegacyArtifactRetrievalService_GetArtifact_FullMethodName = "/org.apache.beam.model.job_management.v1.LegacyArtifactRetrievalService/GetArtifact"
)

// LegacyArtifactRetrievalServiceClient is the client API for LegacyArtifactRetrievalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// A service to retrieve artifacts for use in a Job.
type LegacyArtifactRetrievalServiceClient interface {
	// Get the manifest for the job
	GetManifest(ctx context.Context, in *GetManifestRequest, opts ...grpc.CallOption) (*GetManifestResponse, error)
	// Get an artifact staged for the job. The requested artifact must be within the manifest
	GetArtifact(ctx context.Context, in *LegacyGetArtifactRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ArtifactChunk], error)
}

type legacyArtifactRetrievalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLegacyArtifactRetrievalServiceClient(cc grpc.ClientConnInterface) LegacyArtifactRetrievalServiceClient {
	return &legacyArtifactRetrievalServiceClient{cc}
}

func (c *legacyArtifactRetrievalServiceClient) GetManifest(ctx context.Context, in *GetManifestRequest, opts ...grpc.CallOption) (*GetManifestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetManifestResponse)
	err := c.cc.Invoke(ctx, LegacyArtifactRetrievalService_GetManifest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *legacyArtifactRetrievalServiceClient) GetArtifact(ctx context.Context, in *LegacyGetArtifactRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ArtifactChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LegacyArtifactRetrievalService_ServiceDesc.Streams[0], LegacyArtifactRetrievalService_GetArtifact_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LegacyGetArtifactRequest, ArtifactChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LegacyArtifactRetrievalService_GetArtifactClient = grpc.ServerStreamingClient[ArtifactChunk]

// LegacyArtifactRetrievalServiceServer is the server API for LegacyArtifactRetrievalService service.
// All implementations must embed UnimplementedLegacyArtifactRetrievalServiceServer
// for forward compatibility.
//
// A service to retrieve artifacts for use in a Job.
type LegacyArtifactRetrievalServiceServer interface {
	// Get the manifest for the job
	GetManifest(context.Context, *GetManifestRequest) (*GetManifestResponse, error)
	// Get an artifact staged for the job. The requested artifact must be within the manifest
	GetArtifact(*LegacyGetArtifactRequest, grpc.ServerStreamingServer[ArtifactChunk]) error
	mustEmbedUnimplementedLegacyArtifactRetrievalServiceServer()
}

// UnimplementedLegacyArtifactRetrievalServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLegacyArtifactRetrievalServiceServer struct{}

func (UnimplementedLegacyArtifactRetrievalServiceServer) GetManifest(context.Context, *GetManifestRequest) (*GetManifestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetManifest not implemented")
}
func (UnimplementedLegacyArtifactRetrievalServiceServer) GetArtifact(*LegacyGetArtifactRequest, grpc.ServerStreamingServer[ArtifactChunk]) error {
	return status.Errorf(codes.Unimplemented, "method GetArtifact not implemented")
}
func (UnimplementedLegacyArtifactRetrievalServiceServer) mustEmbedUnimplementedLegacyArtifactRetrievalServiceServer() {
}
func (UnimplementedLegacyArtifactRetrievalServiceServer) testEmbeddedByValue() {}

// UnsafeLegacyArtifactRetrievalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LegacyArtifactRetrievalServiceServer will
// result in compilation errors.
type UnsafeLegacyArtifactRetrievalServiceServer interface {
	mustEmbedUnimplementedLegacyArtifactRetrievalServiceServer()
}

func RegisterLegacyArtifactRetrievalServiceServer(s grpc.ServiceRegistrar, srv LegacyArtifactRetrievalServiceServer) {
	// If the following call pancis, it indicates UnimplementedLegacyArtifactRetrievalServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LegacyArtifactRetrievalService_ServiceDesc, srv)
}

func _LegacyArtifactRetrievalService_GetManifest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetManifestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LegacyArtifactRetrievalServiceServer).GetManifest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LegacyArtifactRetrievalService_GetManifest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LegacyArtifactRetrievalServiceServer).GetManifest(ctx, req.(*GetManifestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LegacyArtifactRetrievalService_GetArtifact_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LegacyGetArtifactRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LegacyArtifactRetrievalServiceServer).GetArtifact(m, &grpc.GenericServerStream[LegacyGetArtifactRequest, ArtifactChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LegacyArtifactRetrievalService_GetArtifactServer = grpc.ServerStreamingServer[ArtifactChunk]

// LegacyArtifactRetrievalService_ServiceDesc is the grpc.ServiceDesc for LegacyArtifactRetrievalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LegacyArtifactRetrievalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "org.apache.beam.model.job_management.v1.LegacyArtifactRetrievalService",
	HandlerType: (*LegacyArtifactRetrievalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetManifest",
			Handler:    _LegacyArtifactRetrievalService_GetManifest_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetArtifact",
			Handler:       _LegacyArtifactRetrievalService_GetArtifact_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "org/apache/beam/model/job_management/v1/beam_artifact_api.proto",
}
