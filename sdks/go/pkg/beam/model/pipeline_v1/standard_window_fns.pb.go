// Code generated by protoc-gen-go. DO NOT EDIT.
// source: standard_window_fns.proto

package pipeline_v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GlobalWindowsPayload_Enum int32

const (
	GlobalWindowsPayload_PROPERTIES GlobalWindowsPayload_Enum = 0
)

var GlobalWindowsPayload_Enum_name = map[int32]string{
	0: "PROPERTIES",
}

var GlobalWindowsPayload_Enum_value = map[string]int32{
	"PROPERTIES": 0,
}

func (x GlobalWindowsPayload_Enum) String() string {
	return proto.EnumName(GlobalWindowsPayload_Enum_name, int32(x))
}

func (GlobalWindowsPayload_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fab9dd76b0d0d680, []int{0, 0}
}

type FixedWindowsPayload_Enum int32

const (
	FixedWindowsPayload_PROPERTIES FixedWindowsPayload_Enum = 0
)

var FixedWindowsPayload_Enum_name = map[int32]string{
	0: "PROPERTIES",
}

var FixedWindowsPayload_Enum_value = map[string]int32{
	"PROPERTIES": 0,
}

func (x FixedWindowsPayload_Enum) String() string {
	return proto.EnumName(FixedWindowsPayload_Enum_name, int32(x))
}

func (FixedWindowsPayload_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fab9dd76b0d0d680, []int{1, 0}
}

type SlidingWindowsPayload_Enum int32

const (
	SlidingWindowsPayload_PROPERTIES SlidingWindowsPayload_Enum = 0
)

var SlidingWindowsPayload_Enum_name = map[int32]string{
	0: "PROPERTIES",
}

var SlidingWindowsPayload_Enum_value = map[string]int32{
	"PROPERTIES": 0,
}

func (x SlidingWindowsPayload_Enum) String() string {
	return proto.EnumName(SlidingWindowsPayload_Enum_name, int32(x))
}

func (SlidingWindowsPayload_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fab9dd76b0d0d680, []int{2, 0}
}

type SessionWindowsPayload_Enum int32

const (
	SessionWindowsPayload_PROPERTIES SessionWindowsPayload_Enum = 0
)

var SessionWindowsPayload_Enum_name = map[int32]string{
	0: "PROPERTIES",
}

var SessionWindowsPayload_Enum_value = map[string]int32{
	"PROPERTIES": 0,
}

func (x SessionWindowsPayload_Enum) String() string {
	return proto.EnumName(SessionWindowsPayload_Enum_name, int32(x))
}

func (SessionWindowsPayload_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fab9dd76b0d0d680, []int{3, 0}
}

// By default, all data in a PCollection is assigned to the single global
// window. See BeamConstants for the time span this window encompasses.
//
// See https://beam.apache.org/documentation/programming-guide/#single-global-window
// for additional details.
type GlobalWindowsPayload struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GlobalWindowsPayload) Reset()         { *m = GlobalWindowsPayload{} }
func (m *GlobalWindowsPayload) String() string { return proto.CompactTextString(m) }
func (*GlobalWindowsPayload) ProtoMessage()    {}
func (*GlobalWindowsPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_fab9dd76b0d0d680, []int{0}
}

func (m *GlobalWindowsPayload) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GlobalWindowsPayload.Unmarshal(m, b)
}
func (m *GlobalWindowsPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GlobalWindowsPayload.Marshal(b, m, deterministic)
}
func (m *GlobalWindowsPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalWindowsPayload.Merge(m, src)
}
func (m *GlobalWindowsPayload) XXX_Size() int {
	return xxx_messageInfo_GlobalWindowsPayload.Size(m)
}
func (m *GlobalWindowsPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalWindowsPayload.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalWindowsPayload proto.InternalMessageInfo

// A fixed time window represents a consistent duration size, non overlapping
// time interval in the data stream.
//
// See https://beam.apache.org/documentation/programming-guide/#fixed-time-windows
// for additional details.
type FixedWindowsPayload struct {
	// (Required) Represents the size of the window.
	Size *duration.Duration `protobuf:"bytes,1,opt,name=size,proto3" json:"size,omitempty"`
	// (Required) Represents the timestamp of when the first window begins.
	// Window N will start at offset + N * size.
	Offset               *timestamp.Timestamp `protobuf:"bytes,2,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *FixedWindowsPayload) Reset()         { *m = FixedWindowsPayload{} }
func (m *FixedWindowsPayload) String() string { return proto.CompactTextString(m) }
func (*FixedWindowsPayload) ProtoMessage()    {}
func (*FixedWindowsPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_fab9dd76b0d0d680, []int{1}
}

func (m *FixedWindowsPayload) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FixedWindowsPayload.Unmarshal(m, b)
}
func (m *FixedWindowsPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FixedWindowsPayload.Marshal(b, m, deterministic)
}
func (m *FixedWindowsPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FixedWindowsPayload.Merge(m, src)
}
func (m *FixedWindowsPayload) XXX_Size() int {
	return xxx_messageInfo_FixedWindowsPayload.Size(m)
}
func (m *FixedWindowsPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_FixedWindowsPayload.DiscardUnknown(m)
}

var xxx_messageInfo_FixedWindowsPayload proto.InternalMessageInfo

func (m *FixedWindowsPayload) GetSize() *duration.Duration {
	if m != nil {
		return m.Size
	}
	return nil
}

func (m *FixedWindowsPayload) GetOffset() *timestamp.Timestamp {
	if m != nil {
		return m.Offset
	}
	return nil
}

// A sliding time window represents time intervals in the data stream that can
// overlap. For example, each window might capture 60 seconds worth of data, but
// a new window starts every 30 seconds. The frequency with which sliding
// windows begin is called the period. Therefore, our example would have a
// window size of 60 seconds and a period of 30 seconds.
//
// Because multiple windows overlap, most elements in a data set will belong to
// more than one window. This kind of windowing is useful for taking running
// averages of data; using sliding time windows, you can compute a running
// average of the past 60 secondsâ€™ worth of data, updated every 30 seconds, in
// our example.
//
// See https://beam.apache.org/documentation/programming-guide/#sliding-time-windows
// for additional details.
type SlidingWindowsPayload struct {
	// (Required) Represents the size of the window.
	Size *duration.Duration `protobuf:"bytes,1,opt,name=size,proto3" json:"size,omitempty"`
	// (Required) Represents the timestamp of when the first window begins.
	// Window N will start at offset + N * period.
	Offset *timestamp.Timestamp `protobuf:"bytes,2,opt,name=offset,proto3" json:"offset,omitempty"`
	// (Required) Represents the amount of time between each start of a window.
	Period               *duration.Duration `protobuf:"bytes,3,opt,name=period,proto3" json:"period,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SlidingWindowsPayload) Reset()         { *m = SlidingWindowsPayload{} }
func (m *SlidingWindowsPayload) String() string { return proto.CompactTextString(m) }
func (*SlidingWindowsPayload) ProtoMessage()    {}
func (*SlidingWindowsPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_fab9dd76b0d0d680, []int{2}
}

func (m *SlidingWindowsPayload) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SlidingWindowsPayload.Unmarshal(m, b)
}
func (m *SlidingWindowsPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SlidingWindowsPayload.Marshal(b, m, deterministic)
}
func (m *SlidingWindowsPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlidingWindowsPayload.Merge(m, src)
}
func (m *SlidingWindowsPayload) XXX_Size() int {
	return xxx_messageInfo_SlidingWindowsPayload.Size(m)
}
func (m *SlidingWindowsPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SlidingWindowsPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SlidingWindowsPayload proto.InternalMessageInfo

func (m *SlidingWindowsPayload) GetSize() *duration.Duration {
	if m != nil {
		return m.Size
	}
	return nil
}

func (m *SlidingWindowsPayload) GetOffset() *timestamp.Timestamp {
	if m != nil {
		return m.Offset
	}
	return nil
}

func (m *SlidingWindowsPayload) GetPeriod() *duration.Duration {
	if m != nil {
		return m.Period
	}
	return nil
}

// A session window function defines windows that contain elements that are
// within a certain gap size of another element. Session windowing applies
// on a per-key basis and is useful for data that is irregularly distributed
// with respect to time. For example, a data stream representing user mouse
// activity may have long periods of idle time interspersed with high
// concentrations of clicks. If data arrives after the minimum specified gap
// size duration, this initiates the start of a new window.
//
// See https://beam.apache.org/documentation/programming-guide/#session-windows
// for additional details.
type SessionWindowsPayload struct {
	// (Required) Minimum duration of gaps between sessions.
	GapSize              *duration.Duration `protobuf:"bytes,1,opt,name=gap_size,json=gapSize,proto3" json:"gap_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SessionWindowsPayload) Reset()         { *m = SessionWindowsPayload{} }
func (m *SessionWindowsPayload) String() string { return proto.CompactTextString(m) }
func (*SessionWindowsPayload) ProtoMessage()    {}
func (*SessionWindowsPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_fab9dd76b0d0d680, []int{3}
}

func (m *SessionWindowsPayload) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SessionWindowsPayload.Unmarshal(m, b)
}
func (m *SessionWindowsPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SessionWindowsPayload.Marshal(b, m, deterministic)
}
func (m *SessionWindowsPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionWindowsPayload.Merge(m, src)
}
func (m *SessionWindowsPayload) XXX_Size() int {
	return xxx_messageInfo_SessionWindowsPayload.Size(m)
}
func (m *SessionWindowsPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionWindowsPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SessionWindowsPayload proto.InternalMessageInfo

func (m *SessionWindowsPayload) GetGapSize() *duration.Duration {
	if m != nil {
		return m.GapSize
	}
	return nil
}

func init() {
	proto.RegisterEnum("org.apache.beam.model.pipeline.v1.GlobalWindowsPayload_Enum", GlobalWindowsPayload_Enum_name, GlobalWindowsPayload_Enum_value)
	proto.RegisterEnum("org.apache.beam.model.pipeline.v1.FixedWindowsPayload_Enum", FixedWindowsPayload_Enum_name, FixedWindowsPayload_Enum_value)
	proto.RegisterEnum("org.apache.beam.model.pipeline.v1.SlidingWindowsPayload_Enum", SlidingWindowsPayload_Enum_name, SlidingWindowsPayload_Enum_value)
	proto.RegisterEnum("org.apache.beam.model.pipeline.v1.SessionWindowsPayload_Enum", SessionWindowsPayload_Enum_name, SessionWindowsPayload_Enum_value)
	proto.RegisterType((*GlobalWindowsPayload)(nil), "org.apache.beam.model.pipeline.v1.GlobalWindowsPayload")
	proto.RegisterType((*FixedWindowsPayload)(nil), "org.apache.beam.model.pipeline.v1.FixedWindowsPayload")
	proto.RegisterType((*SlidingWindowsPayload)(nil), "org.apache.beam.model.pipeline.v1.SlidingWindowsPayload")
	proto.RegisterType((*SessionWindowsPayload)(nil), "org.apache.beam.model.pipeline.v1.SessionWindowsPayload")
}

func init() { proto.RegisterFile("standard_window_fns.proto", fileDescriptor_fab9dd76b0d0d680) }

var fileDescriptor_fab9dd76b0d0d680 = []byte{
	// 404 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x93, 0x4d, 0x4e, 0xdb, 0x40,
	0x14, 0xc7, 0xeb, 0x36, 0x4d, 0xab, 0xc9, 0xa6, 0x75, 0x1b, 0x29, 0xf1, 0xa2, 0x49, 0x2c, 0xf5,
	0x63, 0xd3, 0x89, 0x9c, 0x7e, 0x49, 0x91, 0xda, 0x4a, 0x81, 0x04, 0xb1, 0x22, 0xb2, 0x23, 0x90,
	0xd8, 0x58, 0x63, 0x66, 0x6c, 0x46, 0xb2, 0x67, 0x46, 0x1e, 0x3b, 0x81, 0x1c, 0x82, 0x43, 0x70,
	0x06, 0x24, 0xf6, 0x1c, 0x88, 0x03, 0xb0, 0x42, 0x1e, 0x4f, 0x50, 0x30, 0x8b, 0xc0, 0x86, 0xe5,
	0xcc, 0xfb, 0xbf, 0xf7, 0x7e, 0xbf, 0xc5, 0x03, 0x6d, 0x99, 0x21, 0x86, 0x51, 0x8a, 0xfd, 0x05,
	0x65, 0x98, 0x2f, 0xfc, 0x90, 0x49, 0x28, 0x52, 0x9e, 0x71, 0xb3, 0xc7, 0xd3, 0x08, 0x22, 0x81,
	0x8e, 0x8e, 0x09, 0x0c, 0x08, 0x4a, 0x60, 0xc2, 0x31, 0x89, 0xa1, 0xa0, 0x82, 0xc4, 0x94, 0x11,
	0x38, 0x77, 0xac, 0x66, 0xf1, 0xef, 0xa7, 0x39, 0x63, 0x24, 0xf5, 0x91, 0xa0, 0x65, 0xa7, 0xf5,
	0x29, 0xe2, 0x3c, 0x8a, 0x49, 0x5f, 0xbd, 0x82, 0x3c, 0xec, 0xe3, 0x3c, 0x45, 0x19, 0xe5, 0x4c,
	0xd7, 0x3b, 0xd5, 0x7a, 0x46, 0x13, 0x22, 0x33, 0x94, 0x88, 0x32, 0x60, 0xef, 0x83, 0x8f, 0x3b,
	0x31, 0x0f, 0x50, 0x7c, 0xa0, 0xa0, 0xe4, 0x14, 0x9d, 0xc6, 0x1c, 0x61, 0xfb, 0x1f, 0xa8, 0x8d,
	0x59, 0x9e, 0x98, 0xbf, 0x01, 0x98, 0xba, 0x7b, 0xd3, 0xb1, 0x3b, 0xdb, 0x1d, 0x7b, 0xef, 0x5e,
	0x58, 0x5f, 0xce, 0x2f, 0x6e, 0xae, 0x5e, 0x77, 0x0b, 0x9a, 0xe1, 0x9d, 0xc7, 0x30, 0x52, 0x23,
	0xb4, 0x98, 0x1c, 0xce, 0x1d, 0xfb, 0xd2, 0x00, 0x1f, 0x26, 0xf4, 0x84, 0xe0, 0xfb, 0x73, 0xcd,
	0xef, 0xa0, 0x26, 0xe9, 0x92, 0xb4, 0x8c, 0xae, 0xf1, 0xad, 0x31, 0x68, 0xc3, 0x92, 0x0f, 0xae,
	0xf8, 0xe0, 0xb6, 0xe6, 0x77, 0x55, 0xcc, 0x1c, 0x80, 0x3a, 0x0f, 0x43, 0x49, 0xb2, 0xd6, 0x4b,
	0xd5, 0x60, 0x3d, 0x68, 0x98, 0xad, 0x84, 0x5c, 0x9d, 0xb4, 0xff, 0x6a, 0xf4, 0x5f, 0x15, 0xf4,
	0xcf, 0x0a, 0xbd, 0x53, 0x41, 0x0f, 0x0b, 0xc8, 0x75, 0xf2, 0x6b, 0x03, 0x34, 0xbd, 0x98, 0x62,
	0xca, 0xa2, 0x67, 0x67, 0x37, 0x1d, 0x50, 0x17, 0x24, 0xa5, 0x1c, 0xb7, 0x5e, 0x6d, 0x5a, 0xa2,
	0x83, 0xf6, 0x7f, 0xad, 0xfb, 0xa7, 0xa2, 0xfb, 0x55, 0xe9, 0xf6, 0x2a, 0xba, 0xb2, 0x34, 0x5b,
	0x17, 0x3e, 0x2b, 0x84, 0x89, 0x94, 0x94, 0xb3, 0x8a, 0xf0, 0x4f, 0xf0, 0x36, 0x42, 0xc2, 0x7f,
	0x9c, 0xf4, 0x9b, 0x08, 0x09, 0x8f, 0x2e, 0xc9, 0x53, 0x81, 0xca, 0xcd, 0x6b, 0x40, 0xa3, 0x2d,
	0xb0, 0xf9, 0x20, 0x46, 0xef, 0x3d, 0x7d, 0x4e, 0x25, 0xf3, 0x84, 0xc9, 0xc3, 0xc6, 0xaa, 0xee,
	0xcf, 0x9d, 0xa0, 0xae, 0x08, 0x7f, 0xdc, 0x06, 0x00, 0x00, 0xff, 0xff, 0xb9, 0x67, 0xf3, 0xc1,
	0x77, 0x03, 0x00, 0x00,
}
